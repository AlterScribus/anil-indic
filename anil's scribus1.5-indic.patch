diff -Naur Scribus_1.5_120815/BUILDING Scribus_1.5_indic/BUILDING
--- Scribus_1.5_120815/BUILDING	2012-08-15 11:03:21.516827758 +0530
+++ Scribus_1.5_indic/BUILDING	2012-08-15 11:17:04.539850935 +0530
@@ -35,6 +35,7 @@
 	libjpeg (depending on how Qt is packaged)
 	libpng
 	Qtwebkit
+	ICU
 
 Recommended:
 	CUPS
@@ -260,6 +261,7 @@
         boost-devel
         libGraphicsMagick++-devel
         libOpenSceneGraph-devel  *Optional- but available from the Packman repo
+        libicu-devel
 
 You can install these packages using YaST. You may find it difficult to compile
 Scribus 1.3.5+ on anything older than Suse 11.1. 
diff -Naur Scribus_1.5_120815/cmake/modules/FindICU.cmake Scribus_1.5_indic/cmake/modules/FindICU.cmake
--- Scribus_1.5_120815/cmake/modules/FindICU.cmake	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/cmake/modules/FindICU.cmake	2012-08-15 11:17:42.286851769 +0530
@@ -0,0 +1,69 @@
+# Finds the International Components for Unicode (ICU) Library
+#
+#  ICU_FOUND          - True if ICU found.
+#  ICU_INCLUDE_DIRS   - Directory to include to get ICU headers
+#                       Note: always include ICU headers as, e.g., 
+#                       unicode/utypes.h
+#  ICU_LIBRARIES      - Libraries to link against for ICU (at large)
+
+# Look for the main header file.
+ find_path(
+   ICU_INCLUDE_DIR
+   NAMES unicode/utypes.h
+   DOC "Include directory for the ICU library")
+ mark_as_advanced(ICU_INCLUDE_DIR)
+
+# Look for ICU Layout header
+FIND_PATH(
+ICULE_INCLUDE_DIR
+NAMES layout/LayoutEngine.h
+DOC "Include directory for the ICU Layout library"
+)
+mark_as_advanced(ICULE_INCLUDE_DIR)
+
+# Look for the ICU internationalization libraries
+find_library(
+    ICU_I18N_LIBRARY
+    NAMES icuin icui18n
+    DOC "Libraries to link against for ICU internationalization")
+mark_as_advanced(ICU_I18N_LIBRARY)
+
+# Look for the layout engine library.
+find_library(
+  ICULE_LIBRARY
+  NAMES icule
+  DOC "Libraries to link against for ICU LE")
+mark_as_advanced(ICULE_LIBRARY)
+
+# Look for ICU X library.
+find_library(
+  ICUX_LIBRARY
+  NAMES iculx
+  DOC "Libraries to link against for the common parts of ICU X")
+mark_as_advanced(ICUX_LIBRARY)
+
+# Look for ICU UC library.
+find_library(
+  ICUUC_LIBRARY
+  NAMES icuuc
+  DOC "Libraries to link against for the common parts of ICU UC")
+mark_as_advanced(ICUUC_LIBRARY)
+
+# Copy the results to the output variables.
+if(ICU_INCLUDE_DIR AND ICULE_INCLUDE_DIR AND ICU_I18N_LIBRARY AND ICULE_LIBRARY AND ICUX_LIBRARY AND ICUUC_LIBRARY)
+  set(ICU_FOUND 1)
+  set(ICU_LIBRARIES ${ICU_I18N_LIBRARY} ${ICULE_LIBRARY} ${ICUX_LIBRARY} ${ICUUC_LIBRARY})
+  set(ICU_INCLUDE_DIRS ${ICU_INCLUDE_DIR} ${ICULE_INCLUDE_DIR})
+else(ICU_INCLUDE_DIR AND ICULE_INCLUDE_DIR AND ICU_I18N_LIBRARY AND ICULE_LIBRARY AND ICUX_LIBRARY AND ICUUC_LIBRARY)
+MESSAGE(STATUS)
+MESSAGE(STATUS "ICU_INCLUDE_DIR ${ICU_INCLUDE_DIR}")
+MESSAGE(STATUS "ICULE_INCLUDE_DIR ${ICULE_INCLUDE_DIR}")
+MESSAGE(STATUS "ICU_I18N_LIBRARY ${ICU_I18N_LIBRARY}")
+MESSAGE(STATUS "ICULE_LIBRARY ${ICULE_LIBRARY}")
+MESSAGE(STATUS "ICUX_LIBRARY ${ICUX_LIBRARY}")
+MESSAGE(STATUS "ICUUC_LIBRARY ${ICUUC_LIBRARY}")
+  set(ICU_FOUND 0)
+  set(ICU_LIBRARIES)
+  set(ICU_INCLUDE_DIRS)
+endif(ICU_INCLUDE_DIR AND ICULE_INCLUDE_DIR AND ICU_I18N_LIBRARY AND ICULE_LIBRARY AND ICUX_LIBRARY AND ICUUC_LIBRARY)
+
diff -Naur Scribus_1.5_120815/CMakeLists.txt Scribus_1.5_indic/CMakeLists.txt
--- Scribus_1.5_120815/CMakeLists.txt	2012-08-15 11:03:21.507827758 +0530
+++ Scribus_1.5_indic/CMakeLists.txt	2012-08-15 11:21:43.180858508 +0530
@@ -437,6 +437,11 @@
                   -DCOMPILE_PLUGIN_AS_DLL
   )
   SET(BUILD_WINDOWS_VERSION 1)
+  SET(SC_USE_GDI 1)
+  IF(NOT SC_SHOULD_NOT_USE_GDIPLUS)
+    SET(SC_USE_GDIPLUS 1)
+  ENDIF(NOT SC_SHOULD_NOT_USE_GDIPLUS)
+
   SET(DLL_USE_NATIVE_API 1)
 ENDIF(WIN32)
 
@@ -782,6 +787,15 @@
 ENDIF (POPPLER_FOUND)
 #>>Poppler for PDF import
 
+#<<ICU for text shaping (required)
+FIND_PACKAGE(ICU)
+IF(ICU_FOUND)
+  MESSAGE(STATUS "ICU Found OK")
+ELSE(ICU_FOUND)
+  MESSAGE(FATAL_ERROR "ICU NOT Found!")
+ENDIF(ICU_FOUND)
+#>>ICU for text shaping
+
 
 ##############################################################################################################
 ########## Include Setup                                                                            ##########
diff -Naur Scribus_1.5_120815/scribus/CMakeLists.txt Scribus_1.5_indic/scribus/CMakeLists.txt
--- Scribus_1.5_120815/scribus/CMakeLists.txt	2012-08-15 11:02:06.656825670 +0530
+++ Scribus_1.5_indic/scribus/CMakeLists.txt	2012-08-15 14:12:48.788144825 +0530
@@ -981,6 +981,8 @@
   SET(SCRIBUS_2GEOM_LIB "scribus_2geom_lib")
 ENDIF (HAVE_BOOST)
 SET(SCRIBUS_WPG_LIB "scribus_wpg_lib")
+SET(SCRIBUS_HARFBUZZ_LIB "scribus_harfbuzz_lib")
+SET(SCRIBUS_FRIBIDI_LIB "scribus_fribidi_lib")
 
 SET(SCRIBUS_PGF_LIB "scribus_pgf_lib")
 
@@ -988,6 +990,7 @@
   ${CMAKE_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${FREETYPE_INCLUDE_DIRS}
+  ${ICU_INCLUDE_DIRS}
 )
 
 IF (GMAGICK_FOUND)
@@ -1118,6 +1121,7 @@
   ${ZLIB_LIBRARIES}
   ${WIN32_ONLY_LIBS}
   ${GMAGICK_LIBRARIES}
+  ${ICU_LIBRARIES}
 )
 
 # required to resolve symbols from libdl when ld is called with --no-add-needed
@@ -1149,6 +1153,8 @@
   ${SCRIBUS_FONTS_LIB}
   ${SCRIBUS_WPG_LIB}
   ${SCRIBUS_PGF_LIB}
+  ${SCRIBUS_HARFBUZZ_LIB}
+  ${SCRIBUS_FRIBIDI_LIB}
   ${LCMS_LIBRARIES}
 )
 
diff -Naur Scribus_1.5_120815/scribus/fonts/CMakeLists.txt Scribus_1.5_indic/scribus/fonts/CMakeLists.txt
--- Scribus_1.5_120815/scribus/fonts/CMakeLists.txt	2012-08-15 11:01:50.063825207 +0530
+++ Scribus_1.5_indic/scribus/fonts/CMakeLists.txt	2012-08-15 11:27:32.652868920 +0530
@@ -2,6 +2,7 @@
 ${CMAKE_SOURCE_DIR}
 ${CMAKE_SOURCE_DIR}/scribus
 ${FREETYPE_INCLUDE_DIRS}
+${ICU_INCLUDE_DIRS}
 )
 
 
@@ -11,6 +12,9 @@
   scface_ps.cpp
   scface_ttf.cpp
   scfontmetrics.cpp
+  schbfunctions.cpp
+  fontfeatureset.cpp
+  scicufont.cpp
 )
 SET(SCRIBUS_FONTS_LIB "scribus_fonts_lib")
 ADD_LIBRARY(${SCRIBUS_FONTS_LIB} STATIC ${SCRIBUS_FONTS_LIB_SOURCES})
diff -Naur Scribus_1.5_120815/scribus/fonts/fontfeatureset.cpp Scribus_1.5_indic/scribus/fonts/fontfeatureset.cpp
--- Scribus_1.5_120815/scribus/fonts/fontfeatureset.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/fontfeatureset.cpp	2012-08-15 11:28:08.964869248 +0530
@@ -0,0 +1,25 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "fontfeatureset.h"
+
+FontFeatureSet::FontFeatureSet()
+{
+}
diff -Naur Scribus_1.5_120815/scribus/fonts/fontfeatureset.h Scribus_1.5_indic/scribus/fonts/fontfeatureset.h
--- Scribus_1.5_120815/scribus/fonts/fontfeatureset.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/fontfeatureset.h	2012-08-15 11:28:24.572869682 +0530
@@ -0,0 +1,73 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef FONTFEATURESET_H
+#define FONTFEATURESET_H
+
+#include <QList>
+#include <QString>
+#include <QStringList>
+
+#include "scribusapi.h"
+
+/*! \brief Base Class FontFeatureSet is an interface to expose
+	features, at large, that a font would provide.
+
+	note: At this stage, the service provided is as minimal as a listing.
+	note2a: If in first intention we want to focus on exposing OpenType
+		features, we can also imagine how an scface_ps for example would declare
+		ligatures found into the font as a feature.
+	note2b: We can imagine this interface to provide informations on
+		script or language ability as well.
+*/
+
+class SCRIBUS_API FontFeatureSet
+{
+public:
+	enum FeatureType
+	{
+		Pos,
+		Sub,
+		Any
+	};
+
+	struct Feature
+	{
+		QString name;
+		FeatureType type;
+		QString script;
+		QString lang;
+		Feature(){}
+		Feature& operator=(const Feature& other)
+		{
+			name = other.name;
+			type = other.type;
+			script = other.script;
+			lang = other.lang;
+			return *this;
+		}
+	};
+
+	FontFeatureSet();
+
+	QList<Feature> features(FeatureType type) const {return QList<Feature>();}
+};
+
+#endif // FONTFEATURESET_H
diff -Naur Scribus_1.5_120815/scribus/fonts/scface.h Scribus_1.5_indic/scribus/fonts/scface.h
--- Scribus_1.5_120815/scribus/fonts/scface.h	2012-08-15 11:01:50.062825207 +0530
+++ Scribus_1.5_indic/scribus/fonts/scface.h	2012-08-15 11:34:35.007879774 +0530
@@ -26,6 +26,7 @@
 #include <utility>
 
 #include "fpointarray.h"
+#include "fonts/fontfeatureset.h"
 
 
 
@@ -180,6 +181,8 @@
 		virtual bool EmbedFont(QString &/*str*/)       const { return false; }
 		virtual void RawData(QByteArray & /*bb*/)      const {}
 		virtual bool glyphNames(QMap<uint, std::pair<QChar, QString> >& gList) const;
+		virtual FontFeatureSet * features() const { return 0; }
+		virtual int shapeText(void* /*gs*/, unsigned int /*item*/) const {return 0;}
 
 		// these use the cache:
 		virtual qreal      glyphWidth(uint gl, qreal sz)   const;
@@ -373,6 +376,12 @@
 	/// deprecated, see glyphBBox()
 	qreal realCharDescent(QChar ch, qreal sz=1.0) const { return glyphBBox(char2CMap(ch),sz).descent; }
 	
+        /// Return a features Object provided by the font
+        FontFeatureSet * features() { return m->features();}
+       
+        /// Process a string
+        int shapeText(void* gs, unsigned int item) const{return m->shapeText(gs, item);}
+        
 private:
 		
 	friend class SCFonts;
diff -Naur Scribus_1.5_120815/scribus/fonts/scface_ttf.cpp Scribus_1.5_indic/scribus/fonts/scface_ttf.cpp
--- Scribus_1.5_120815/scribus/fonts/scface_ttf.cpp	2012-08-15 11:01:50.058825207 +0530
+++ Scribus_1.5_indic/scribus/fonts/scface_ttf.cpp	2012-08-15 13:31:41.158076108 +0530
@@ -3,586 +3,277 @@
 to the COPYING file provided with the program. Following this notice may exist
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
 */
 
 #include <QFile>
 #include <QString>
 #include <QObject>
+#include <QByteArray>
 #include <QDebug>
+// #include <QTime>
 
 #include <sys/types.h>
 
 #include "fonts/scface_ttf.h"
 #include "fonts/scfontmetrics.h"
+#include "fonts/fontfeatureset.h"
+#include "fonts/schbfunctions.h"
 #include "util.h"
 #include "scconfig.h"
+#include "sctextstruct.h"
+#include "langmgr.h"
+#include "fonts/scicufont.h"
 
-KernFeature::KernFeature ( FT_Face face )
-		:m_valid ( true )
-{
-	FontName = QString ( face->family_name ) + " " + QString ( face->style_name )   ;
-// 	qDebug() <<"KF"<<FontName;
-// 	QTime t;
-// 	t.start();
-	FT_ULong length = 0;
-	if ( !FT_Load_Sfnt_Table ( face, TTAG_GPOS , 0, NULL, &length ) )
-	{
-// 		qDebug() <<"\t"<<"GPOS table len"<<length;
-		if ( length > 32 )
-		{
-			GPOSTableRaw.resize ( length );
-			FT_Load_Sfnt_Table ( face, TTAG_GPOS, 0, reinterpret_cast<FT_Byte*> ( GPOSTableRaw.data() ), &length );
-
-			makeCoverage();
-		}
-		else
-			m_valid = false;
-
-		GPOSTableRaw.clear();
-//		coverages.clear();
-	}
-	else
-		m_valid = false;
+#include <layout/LETypes.h>
+#include <layout/LEFontInstance.h>
+#include <layout/LEScripts.h>
 
-	if ( !m_valid )
-		pairs.clear();
-// 	qDebug() <<"\t"<<m_valid;
-// 	qDebug() <<"\t"<<t.elapsed();
-}
+#include "third_party/harfbuzz/src/hb.h"
+#include "third_party/harfbuzz/src/hb-ot.h"
+#include "third_party/harfbuzz/src/hb-ft.h"
 
-KernFeature::KernFeature ( const KernFeature & kf )
+// Missing feature in Harfbuzz
+QString tagToString(hb_tag_t tag)
 {
-	m_valid = kf.m_valid;
-	if ( m_valid )
-		pairs = kf.pairs;
-
+    QString name;
+    name[0] = ( char ) ( tag >> 24 );
+    name[1] = ( char ) ( ( tag >> 16 ) & 0xFF );
+    name[2] = ( char ) ( ( tag >> 8 ) & 0xFF );
+    name[3] = ( char ) ( tag & 0xFF );
+qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " << QString("OTF_tag_name (%1) -> %2").arg(tag).arg(name);
+    return name;
 }
 
-
-KernFeature::~ KernFeature()
+hb_tag_t stringToTag(const QString& tag)
 {
+    return HB_TAG(tag.at(0).toAscii(),tag.at(1).toAscii(),tag.at(2).toAscii(),tag.at(3).toAscii());
 }
 
-double KernFeature::getPairValue ( unsigned int glyph1, unsigned int glyph2 ) const
-{
-	if ( m_valid )
+	uint word ( QByteArray const & bb, uint pos )
 	{
-
-		if ( pairs.contains( glyph1 )
-				&& pairs[glyph1].contains(glyph2))
-		{
-			return pairs[glyph1][glyph2];
-		}
-		else
-		{
-			//qDebug()<<"Search in classes";
-			foreach (const quint16& coverageId, coverages.keys())
-			{
-				// for each pairpos table, coverage lists covered _first_ (left) glyph
-				if(coverages[coverageId].contains(glyph1))
-				{
-					foreach(const quint16& classDefOffset, classGlyphFirst[coverageId].keys())
-					{
-						const ClassDefTable& cdt(classGlyphFirst[coverageId][classDefOffset]);
-						foreach(const quint16& classIndex, cdt.keys())
-						{
-							const QList<quint16>& gl(cdt[classIndex]);
-							if(gl.contains(glyph1))
-							{
-								//qDebug()<<"Found G1"<<glyph1<<"in Class"<<classIndex<<"at pos"<<gl.indexOf(glyph1);
-								// Now we got the index of the first glyph class, see if glyph2 is in one of the left glyphs classes attached to this subtable.
-								foreach(const quint16& classDefOffset2, classGlyphSecond[coverageId].keys())
-								{
-									const ClassDefTable& cdt2(classGlyphSecond[coverageId][classDefOffset2]);
-									foreach(const quint16& classIndex2, cdt2.keys())
-									{
-										const QList<quint16>& gl2(cdt2[classIndex2]);
-										if(gl2.contains(glyph2))
-										{
-											//qDebug()<<"Found G2"<<glyph2<<"in Class"<<classIndex2<<"at pos"<<gl2.indexOf(glyph2);
-
-											double v(classValue[coverageId][classIndex][classIndex2]);
-											// Cache this pair into "pairs" map.
-											pairs[glyph1][glyph2] = v;
-											return v;
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-		}
+		const unsigned char * pp = reinterpret_cast<const unsigned char*> ( bb.data() ) + pos;
+		return pp[0] << 24 | pp[1] << 16 | pp[2] << 8 | pp[3];
 	}
-	return 0.0;
-}
-
-void KernFeature::makeCoverage()
-{
-	if ( GPOSTableRaw.isEmpty() )
-		return;
-
-	quint16 FeatureList_Offset= toUint16 ( 6 );
-	quint16 LookupList_Offset = toUint16 ( 8 );
-
-	// Find the offsets of the kern feature tables
-	quint16 FeatureCount = toUint16 ( FeatureList_Offset );;
-	QList<quint16> FeatureKern_Offset;
-	for ( quint16 FeatureRecord ( 0 ); FeatureRecord < FeatureCount; ++ FeatureRecord )
+	uint word16 ( QByteArray const & bb, uint pos )
 	{
-		int rawIdx ( FeatureList_Offset + 2 + ( 6 * FeatureRecord ) );
-		quint32 tag ( FT_MAKE_TAG ( GPOSTableRaw.at ( rawIdx ),
-					    GPOSTableRaw.at ( rawIdx + 1 ),
-					    GPOSTableRaw.at ( rawIdx + 2 ),
-					    GPOSTableRaw.at ( rawIdx + 3 ) ) );
-		if ( tag == TTAG_kern )
-		{
-			FeatureKern_Offset << ( toUint16 ( rawIdx + 4 ) + FeatureList_Offset );
-
-		}
+		const unsigned char * pp = reinterpret_cast<const unsigned char*> ( bb.data() ) + pos;
+		return pp[0] << 8 | pp[1];
 	}
-
-	// Extract indices of lookups for feture kern
-	QList<quint16> LookupListIndex;
-	foreach ( quint16 kern, FeatureKern_Offset )
+	QString tag ( QByteArray const & bb, uint pos )
 	{
-		quint16 LookupCount ( toUint16 ( kern + 2 ) );
-		for ( int llio ( 0 ) ; llio < LookupCount; ++llio )
-		{
-			quint16 Idx ( toUint16 ( kern + 4 + ( llio * 2 ) ) );
-			if ( !LookupListIndex.contains ( Idx ) )
-			{
-				LookupListIndex <<Idx ;
-			}
-		}
-	}
-
-
-	// Extract offsets of lookup tables for feature kern
-	QList<quint16> LookupTables;
-	QList<quint16> PairAdjustmentSubTables;
-	for ( int i ( 0 ); i < LookupListIndex.count(); ++i )
-	{
-		int rawIdx ( LookupList_Offset + 2 + ( LookupListIndex[i] * 2 ) );
-		quint16 Lookup ( toUint16 ( rawIdx )  + LookupList_Offset );
-		quint16 SubTableCount ( toUint16 ( Lookup + 4 ) );
-		for ( int stIdx ( 0 ); stIdx < SubTableCount; ++ stIdx )
-		{
-			quint16 SubTable ( toUint16 ( Lookup + 6 + ( 2 * stIdx ) ) + Lookup );
-
-// 			quint16 PosFormat ( toUint16 ( SubTable ) );
-			quint16 Coverage_Offset ( toUint16 ( SubTable + 2 ) + SubTable );
-			quint16 CoverageFormat ( toUint16 ( Coverage_Offset ) );
-
-			if ( 1 == CoverageFormat ) // glyph indices based
-			{
-				quint16 GlyphCount ( toUint16 ( Coverage_Offset + 2 ) );
-				quint16 GlyphID ( Coverage_Offset + 4 );
-				if (GlyphCount == 0) continue;
-
-				for ( unsigned int gl ( 0 ); gl < GlyphCount; ++gl )
-				{
-					coverages[SubTable] << toUint16 ( GlyphID + ( gl * 2 ) );
-				}
-			}
-			else if ( 2 == CoverageFormat ) // Coverage Format2 => ranges based
-			{
-				quint16 RangeCount ( toUint16 ( Coverage_Offset + 2 ) );
-				if (RangeCount == 0) continue;
-
-// 				int gl_base ( 0 );
-				for ( int r ( 0 ); r < RangeCount; ++r )
-				{
-					quint16 rBase ( Coverage_Offset + 4 + ( r * 6 ) );
-					quint16 Start ( toUint16 ( rBase ) );
-					quint16 End ( toUint16 ( rBase + 2 ) );
-// 					quint16 StartCoverageIndex ( toUint16 ( rBase + 4 ) );
-					// #9842 : for some font such as Gabriola Regular
-					// the range maybe be specified in reverse order
-					if (Start <= End)
-					{
-						for ( unsigned int gl ( Start ); gl <= End; ++gl )
-							coverages[SubTable]  << gl;
-					}
-					else
-					{
-						for ( int gl ( Start ); gl >= (int) End; --gl )
-							coverages[SubTable]  << gl;
-					}
-				}
-			}
-			else
-			{
-//				qDebug() <<"Unknow Coverage Format:"<<CoverageFormat;
-				continue;
-			}
-
-			makePairs ( SubTable );
-		}
-
+		char buf[5] = "1234";
+		buf[0] = bb.data() [pos];
+		buf[1] = bb.data() [pos+1];
+		buf[2] = bb.data() [pos+2];
+		buf[3] = bb.data() [pos+3];
+		return buf;
 	}
-
-
-}
-
-
-void KernFeature::makePairs ( quint16 subtableOffset )
-{
-	/*
-	Lookup Type 2:
-	Pair Adjustment Positioning Subtable
-	*/
-
-	quint16 PosFormat ( toUint16 ( subtableOffset ) );
-
-	if ( PosFormat == 1 )
+	bool copy ( QByteArray & dst, uint to, QByteArray & src, uint from, uint len )
 	{
-		quint16 ValueFormat1 ( toUint16 ( subtableOffset +4 ) );
-		quint16 ValueFormat2 ( toUint16 ( subtableOffset +6 ) );
-		quint16 PairSetCount ( toUint16 ( subtableOffset +8 ) );
-		if ( ValueFormat1 && ValueFormat2 )
-		{
-			for ( int psIdx ( 0 ); psIdx < PairSetCount; ++ psIdx )
-			{
-				unsigned int FirstGlyph ( coverages[subtableOffset][psIdx] );
-				quint16 PairSetOffset ( toUint16 ( subtableOffset +10 + ( 2 * psIdx ) ) +  subtableOffset );
-				quint16 PairValueCount ( toUint16 ( PairSetOffset ) );
-				quint16 PairValueRecord ( PairSetOffset + 2 );
-				for ( int pvIdx ( 0 );pvIdx < PairValueCount; ++pvIdx )
-				{
-					quint16 recordBase ( PairValueRecord + ( ( 2 + 2 + 2 ) * pvIdx ) );
-					quint16 SecondGlyph ( toUint16 ( recordBase ) );
-					qint16 Value1 ( toInt16 ( recordBase + 2 ) );
-					pairs[FirstGlyph][SecondGlyph] = double ( Value1 );
-				}
-
-			}
-		}
-		else if ( ValueFormat1 && ( !ValueFormat2 ) )
-		{
-			for ( int psIdx ( 0 ); psIdx < PairSetCount; ++ psIdx )
-			{
-				unsigned int FirstGlyph ( coverages[subtableOffset][psIdx] );
-				quint16 PairSetOffset ( toUint16 ( subtableOffset +10 + ( 2 * psIdx ) ) +  subtableOffset );
-				quint16 PairValueCount ( toUint16 ( PairSetOffset ) );
-				quint16 PairValueRecord ( PairSetOffset + 2 );
-				for ( int pvIdx ( 0 );pvIdx < PairValueCount; ++pvIdx )
-				{
-					quint16 recordBase ( PairValueRecord + ( ( 2 + 2 ) * pvIdx ) );
-					quint16 SecondGlyph ( toUint16 ( recordBase ) );
-					qint16 Value1 ( toInt16 ( recordBase + 2 ) );
-					pairs[FirstGlyph][SecondGlyph] = double ( Value1 );
-
-				}
-
-			}
-		}
-		else
-		{
-//			qDebug() <<"ValueFormat1 is null or both ValueFormat1 and ValueFormat2 are null";
-		}
+		if ( !dst.data() )
+			return false;
+		if ( !src.data() )
+			return false;
+		if ( to + len > static_cast<uint> ( dst.size() ) )
+			return false;
+		if ( from + len > static_cast<uint> ( src.size() ) )
+			return false;
 
+		memcpy ( dst.data() + to, src.data() + from, len );
+		return true;
 	}
-	else if ( PosFormat == 2 ) // class kerning
-	{
-		quint16 ValueFormat1 ( toUint16 ( subtableOffset +4 ) );
-		quint16 ValueFormat2 ( toUint16 ( subtableOffset +6 ) );
-		quint16 ClassDef1 ( toUint16 ( subtableOffset +8 )  + subtableOffset );
-		quint16 ClassDef2 ( toUint16 ( subtableOffset +10 ) + subtableOffset );
-		quint16 Class1Count ( toUint16 ( subtableOffset +12 ) );
-		quint16 Class2Count ( toUint16 ( subtableOffset +14 ) );
-		quint16 Class1Record ( subtableOffset +16 );
 
-		// first extract classses
-		getClass(true, ClassDef1 , subtableOffset );
-		getClass(false, ClassDef2 , subtableOffset );
 
-		if ( ValueFormat1 && ValueFormat2 )
-		{
-			for ( quint16 C1 ( 0 );C1 < Class1Count; ++C1 )
-			{
-				quint16 Class2Record ( Class1Record + ( C1 * ( 2 * 2 * Class2Count ) ) );
-				for ( quint16 C2 ( 0 );C2 < Class2Count; ++C2 )
-				{
-					qint16 Value1 ( toInt16 ( Class2Record + ( C2 * ( 2 * 2 ) ) ) );
-					if(Value1 != 0)
-					{
-						classValue[subtableOffset][C1][C2] = double ( Value1 );
-					}
-				}
-			}
-		}
-		else if ( ValueFormat1 && ( !ValueFormat2 ) )
-		{
-			for ( quint16 C1 ( 1 );C1 < Class1Count; ++C1 )
-			{
-				quint16 Class2Record ( Class1Record + ( C1 * ( 2 * Class2Count ) ) );
-				for ( quint16 C2 ( 1 );C2 < Class2Count; ++C2 )
-				{
-					qint16 Value1 ( toInt16 ( Class2Record + ( C2 * 2 ) ) );
-					if(Value1 != 0)
-					{
-						classValue[subtableOffset][C1][C2] = double ( Value1 );
-					}
-				}
-			}
-		}
-		else
-		{
-//			qDebug() <<"ValueFormat1 is null or both ValueFormat1 and ValueFormat2 are null";
-		}
-
-	}
-	else
-		qDebug() <<"unknown PosFormat"<<PosFormat;
-}
+void releaseFaceForHB(void *){} // HB hassle
 
-KernFeature::ClassDefTable KernFeature::getClass ( bool leftGlyph, quint16 classDefOffset, quint16 coverageId )
+TTFFeatureSet::TTFFeatureSet(FT_Face ftface)
+	:FontFeatureSet()
 {
-	if(leftGlyph)
-	{
-		if(classGlyphFirst.contains(coverageId) && classGlyphFirst[coverageId].contains(classDefOffset))
-			return classGlyphFirst[coverageId][classDefOffset];
-	}
-	else
-	{
-		if(classGlyphSecond.contains(coverageId) && classGlyphSecond[coverageId].contains(classDefOffset))
-			return classGlyphSecond[coverageId][classDefOffset];
-	}
-
-	ClassDefTable ret;
-
-	QList<quint16> excludeList;
-	quint16 ClassFormat ( toUint16 ( classDefOffset ) );
-	if ( ClassFormat == 1 )
-	{
-		quint16 StartGlyph ( toUint16 ( classDefOffset +2 ) );
-		quint16 GlyphCount ( toUint16 ( classDefOffset +4 ) );
-		quint16 ClassValueArray ( classDefOffset + 6 );
-
-		for ( quint16 CV ( 0 );CV < GlyphCount; ++CV )
-		{
-			excludeList<<StartGlyph + CV;
-			ret[ toUint16 ( ClassValueArray + ( CV * 2 ) ) ] << StartGlyph + CV;
-		}
-	}
-	else if ( ClassFormat == 2 )
-	{
-		quint16 ClassRangeCount ( toUint16 ( classDefOffset + 2 ) );
-		quint16 ClassRangeRecord ( classDefOffset + 4 );
-		for ( int CRR ( 0 ); CRR < ClassRangeCount; ++CRR )
-		{
-			quint16 Start ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) ) );
-			quint16 End ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) + 2 ) );
-			quint16 Class ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) + 4 ) );
-
-			if (Start <= End)
-			{
-				for ( int gl ( Start ); gl <= (int) End; ++gl )
-				{
-					excludeList<< (quint16) gl;
-					ret[Class] << gl;
-				}
-			}
+	// on prend son souffle :)
+	hb_face_t * face = hb_ft_face_create(ftface, releaseFaceForHB );
+	QList<hb_tag_t> tables;
+	tables << HB_TAG('G','P','O','S') << HB_TAG('G','S','U','B');
+	unsigned int script_index = 0;
+	unsigned int language_index = 0;
+	foreach(hb_tag_t table, tables)
+	{
+		unsigned int script_count = hb_ot_layout_table_get_script_count(face, table);
+		// unsigned int script_count ;
+		bool hastDFLTScript(hb_ot_layout_table_find_script(face,table,HB_OT_TAG_DEFAULT_SCRIPT, &script_index));
+		hb_tag_t     * script_tags = new hb_tag_t[(hastDFLTScript ? script_count + 1 : script_count)];
+		if(hastDFLTScript)
+			script_tags[0] = HB_OT_TAG_DEFAULT_SCRIPT;
+		else
+//			qDebug()<< "(" << __FILE__ << ")(" << __LINE__  <<") No default script for "<< tagToString(table) <<ftface->family_name<<ftface->style_name ;
+		hb_ot_layout_table_get_script_tags (face, table, 0, &script_count, (hastDFLTScript ? script_tags + 1 :  script_tags));
+//		qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"Table:"<<tagToString(table)<<"ScriptCount:"<<script_count;
+
+		for(unsigned int scIdx(0); scIdx < script_count; ++scIdx)
+		{
+			script_index = 0;
+			hb_ot_layout_table_find_script (face, table, script_tags[scIdx], &script_index);
+			unsigned int language_count = hb_ot_layout_script_get_language_count(face, table, script_index);
+			// unsigned int language_count ;
+			bool hasDFLTLang(hb_ot_layout_script_find_language(face, table, script_index, HB_OT_TAG_DEFAULT_LANGUAGE, &language_index));
+			hb_tag_t * language_tags =  new hb_tag_t[(hasDFLTLang ? language_count + 1: language_count)];
+			if(hasDFLTLang)
+				language_tags[0] =  HB_OT_TAG_DEFAULT_LANGUAGE;
 			else
-			{
-				for ( int gl ( Start ); gl >= (int) End; --gl )
+//				qDebug()<< "(" << __FILE__ << ")(" << __LINE__  <<") No default lang for"<< tagToString(table) <<tagToString(script_tags[scIdx]) <<ftface->family_name<<ftface->style_name ;
+			hb_ot_layout_script_get_language_tags(face, table, script_index, 0, &language_count , (hasDFLTLang ? language_tags + 1 : language_tags) );
+//			qDebug()<< "(" << __FILE__ << ")(" << __LINE__  <<") \tScript:"<<tagToString(script_tags[scIdx])<<"LanguageCount:"<<language_count;
+
+			for(unsigned int laIdx(0); laIdx < language_count; ++laIdx)
+			{
+				language_index = 0;
+				hb_ot_layout_script_find_language (face, table,  script_index, language_tags[laIdx], &language_index);
+				unsigned int feature_count = hb_ot_layout_language_get_feature_count(face, table, script_index, language_index);
+				// unsigned int feature_count = 0;
+				hb_tag_t * feature_tags = new hb_tag_t[feature_count];
+				hb_ot_layout_language_get_feature_tags (face, table, script_index, language_index , 0, &feature_count, feature_tags );
+				qDebug()<<"\t\tLanguage:"<<tagToString(language_tags[laIdx])<<"FeatureCount:"<<feature_count;
+
+				for(unsigned int feIdx(0); feIdx < feature_count; ++feIdx)
 				{
-					excludeList<< (quint16) gl;
-					ret[Class] << gl;
+					QString feName(tagToString(feature_tags[feIdx]));
+					qDebug()<<"\t\t\tFeature:"<<feName;
+					FontFeatureSet::Feature f;
+
+					f.name = feName;
+					f.type = (table == HB_TAG('G','P','O','S')) ? FontFeatureSet::Pos :  FontFeatureSet::Sub;
+					f.lang = tagToString(language_tags[laIdx]);
+					f.script = tagToString(script_tags[scIdx]);
+					featuresList << f;
 				}
+				delete[] feature_tags;
 			}
+			delete[] language_tags;
 		}
+		delete[] script_tags;
 	}
-	else
-		qDebug() <<"Unknown Class Table type";
-
-	// if possible (all glyphs are "classed"), avoid to pass through this slow piece of code.
-	if(excludeList.count() != coverages[coverageId].count())
-	{
-		foreach(const quint16& gidx, coverages[coverageId])
-		{
-			if(!excludeList.contains(gidx))
-				ret[0] << gidx;
-		}
-	}
-	if(leftGlyph)
-		classGlyphFirst[coverageId][classDefOffset] = ret;
-	else
-		classGlyphSecond[coverageId][classDefOffset] = ret;
-
-	return ret;
-}
 
-quint16 KernFeature::toUint16 ( quint16 index )
-{
-	if ( ( index + 2 ) > GPOSTableRaw.count() )
-	{
-//                qDebug() << "HORROR!" << index << GPOSTableRaw.count() << FontName ;
-		// Rather no kerning at all than random kerning
-// 		m_valid = false;
-		return 0;
-	}
-	// FIXME I just do not know how it has to be done *properly*
-	quint16 c1 ( GPOSTableRaw.at ( index ) );
-	quint16 c2 ( GPOSTableRaw.at ( index + 1 ) );
-	c1 &= 0xFF;
-	c2 &= 0xFF;
-	quint16 ret ( ( c1 << 8 ) | c2 );
-	return ret;
 }
 
-qint16 KernFeature::toInt16 ( quint16 index )
+QList<FontFeatureSet::Feature> TTFFeatureSet::features(FeatureType type) const
 {
-	if ( ( index + 2 ) > GPOSTableRaw.count() )
+	QList<FontFeatureSet::Feature> ret;
+	foreach(FontFeatureSet::Feature f, featuresList)
 	{
-		return 0;
+		if(f.type == type)
+			ret << f;
 	}
-	// FIXME I just do not know how it has to be done *properly*
-	quint16 c1 ( GPOSTableRaw.at ( index ) );
-	quint16 c2 ( GPOSTableRaw.at ( index + 1 ) );
-	c1 &= 0xFF;
-	c2 &= 0xFF;
-	qint16 ret ( ( c1 << 8 ) | c2 );
 	return ret;
 }
 
-
-namespace {
-uint word(QByteArray const & bb, uint pos) 
-{
-	const unsigned char * pp = reinterpret_cast<const unsigned char*>(bb.data()) + pos;
-	return pp[0] << 24 | pp[1] << 16 | pp[2] << 8 | pp[3];
-}
-uint word16(QByteArray const & bb, uint pos) 
-{
-	const unsigned char * pp = reinterpret_cast<const unsigned char*>(bb.data()) + pos;
-	return pp[0] << 8 | pp[1];
-}
-QString tag(QByteArray const & bb, uint pos)
-{
-	char buf[5] = "1234";
-	buf[0] = bb.data()[pos];
-	buf[1] = bb.data()[pos+1];
-	buf[2] = bb.data()[pos+2];
-	buf[3] = bb.data()[pos+3];
-	return buf;
-}
-bool copy(QByteArray & dst, uint to, QByteArray & src, uint from, uint len) 
-{
-	if (!dst.data())
-		return false;
-	if (!src.data())
-		return false;
-	if (to + len > static_cast<uint>(dst.size()))
-		return false;
-	if (from + len > static_cast<uint>(src.size()))
-		return false;
-	
-	memcpy(dst.data() + to, src.data() + from, len);
-	return true;
-}
-} //namespace
+QMap<QString, LanguageCodes> ScFace_ttf::icuLangList;
+QMap<QString, ScriptCodes> ScFace_ttf::scriptTagToICUCode;
+QMap<QString, hb_tag_t > ScFace_ttf::scLangToTags ;
 
 ScFace_ttf::ScFace_ttf ( QString fam, QString sty, QString alt, QString scname, QString psname, QString path, int face )
-		: FtFace ( fam, sty, alt, scname, psname, path, face )
+	: FtFace ( fam, sty, alt, scname, psname, path, face )
 {
 	formatCode = ScFace::SFNT;
-	kernFeature = 0;
+	featureSet = 0;
+	icuFont = 0;
+	fillLangToTag();
 }
 
 ScFace_ttf::~ ScFace_ttf()
 {
-	if ( kernFeature )
-		delete kernFeature;
 }
 
 
 void ScFace_ttf::load() const
 {
-	if ( !kernFeature )
-		kernFeature = new KernFeature ( ftFace() );
 	FtFace::load();
+	if(!featureSet)
+		featureSet = new TTFFeatureSet( ftFace() );
+	if(!icuFont)
+		icuFont = new ScICUFont(ftFace());
 }
 
 void ScFace_ttf::unload() const
 {
-	if ( kernFeature )
-		delete kernFeature;
-	kernFeature = 0;
+	if(featureSet)
+		delete featureSet;
+	if(icuFont)
+		delete icuFont;
+	icuFont = 0;
+	featureSet = 0;
 	FtFace::unload();
 }
 
-qreal ScFace_ttf::glyphKerning ( uint gl1, uint gl2, qreal sz ) const
-{
-	if ( kernFeature->isValid() )
-		return kernFeature->getPairValue ( gl1,gl2 ) / m_uniEM * sz;
-	return FtFace::glyphKerning ( gl1, gl2, sz );
-}
 
-void ScFace_ttf::RawData(QByteArray & bb) const {
-	if (formatCode == ScFace::TTCF) {
+void ScFace_ttf::RawData ( QByteArray & bb ) const
+{
+	if ( formatCode == ScFace::TTCF )
+	{
 		QByteArray coll;
-		FtFace::RawData(coll);
+		FtFace::RawData ( coll );
 		// access table for faceIndex
-		if (faceIndex >= static_cast<int>(word(coll, 8)))
+		if ( faceIndex >= static_cast<int> ( word ( coll, 8 ) ) )
 		{
-			bb.resize(0);
+			bb.resize ( 0 );
 			return;
 		}
 		static const uint OFFSET_TABLE_LEN = 12;
 		static const uint   TDIR_ENTRY_LEN = 16;
-		uint faceOffset = word(coll, 12 + 4 * faceIndex);
-		uint nTables    = word16(coll, faceOffset + 4);
-		sDebug(QObject::tr("extracting face %1 from font %2 (offset=%3, nTables=%4)").arg(faceIndex).arg(fontFile).arg(faceOffset).arg(nTables));
+		uint faceOffset = word ( coll, 12 + 4 * faceIndex );
+		uint nTables    = word16 ( coll, faceOffset + 4 );
+		sDebug ( QObject::tr ( "extracting face %1 from font %2 (offset=%3, nTables=%4)" ).arg ( faceIndex ).arg ( fontFile ).arg ( faceOffset ).arg ( nTables ) );
 		uint headerLength = OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * nTables;
 		uint tableLengths = 0;
 		// sum table lengths incl padding
-		for (uint i=0; i < nTables; ++i)
+		for ( uint i=0; i < nTables; ++i )
 		{
-			tableLengths += word(coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 12);
-			tableLengths = (tableLengths+3) & ~3;
+			tableLengths += word ( coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 12 );
+			tableLengths = ( tableLengths+3 ) & ~3;
 		}
-		bb.resize(headerLength + tableLengths);
-		if (! bb.data())
+		bb.resize ( headerLength + tableLengths );
+		if ( ! bb.data() )
 			return;
 		// write header
-		sDebug(QObject::tr("memcpy header: %1 %2 %3").arg(0).arg(faceOffset).arg(headerLength));
-		if (!copy(bb, 0, coll, faceOffset, headerLength))
+		sDebug ( QObject::tr ( "memcpy header: %1 %2 %3" ).arg ( 0 ).arg ( faceOffset ).arg ( headerLength ) );
+		if ( !copy ( bb, 0, coll, faceOffset, headerLength ) )
 			return;
 
 		uint pos = headerLength;
-		for (uint i=0; i < nTables; ++i)
+		for ( uint i=0; i < nTables; ++i )
 		{
-			uint tableSize  = word(coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 12);
-			uint tableStart = word(coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 8);
-			sDebug(QObject::tr("table '%1'").arg(tag(coll, tableStart)));
-			sDebug(QObject::tr("memcpy table: %1 %2 %3").arg(pos).arg(tableStart).arg(tableSize));
-			if (!copy(bb, pos, coll, tableStart, tableSize)) break;
+			uint tableSize  = word ( coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 12 );
+			uint tableStart = word ( coll, faceOffset + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 8 );
+			sDebug ( QObject::tr ( "table '%1'" ).arg ( tag ( coll, tableStart ) ) );
+			sDebug ( QObject::tr ( "memcpy table: %1 %2 %3" ).arg ( pos ).arg ( tableStart ).arg ( tableSize ) );
+			if ( !copy ( bb, pos, coll, tableStart, tableSize ) ) break;
 			// write new offset to table entry
-			sDebug(QObject::tr("memcpy offset: %1 %2 %3").arg(OFFSET_TABLE_LEN + TDIR_ENTRY_LEN*i + 8).arg(pos).arg(4));
-			memcpy(bb.data() + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 8, &pos, 4);
+			sDebug ( QObject::tr ( "memcpy offset: %1 %2 %3" ).arg ( OFFSET_TABLE_LEN + TDIR_ENTRY_LEN*i + 8 ).arg ( pos ).arg ( 4 ) );
+			memcpy ( bb.data() + OFFSET_TABLE_LEN + TDIR_ENTRY_LEN * i + 8, &pos, 4 );
 			pos += tableSize;
 			// pad
-			while ((pos & 3) != 0)
-				bb.data()[pos++] = '\0';
+			while ( ( pos & 3 ) != 0 )
+				bb.data() [pos++] = '\0';
 		}
-	}	
-	else if (formatCode == ScFace::TYPE42) {
-		FtFace::RawData(bb);
 	}
-	else {
-		FtFace::RawData(bb);
+	else if ( formatCode == ScFace::TYPE42 )
+	{
+		FtFace::RawData ( bb );
+	}
+	else
+	{
+		FtFace::RawData ( bb );
 	}
 }
 
-bool ScFace_ttf::EmbedFont(QString &str) const
+bool ScFace_ttf::EmbedFont ( QString &str ) const
 {
-	if (formatCode == ScFace::TYPE42) {
+	if ( formatCode == ScFace::TYPE42 )
+	{
 		//easy:
 		QByteArray bb;
-		FtFace::RawData(bb);
+		FtFace::RawData ( bb );
 		str += bb;
 		return true;
 	}
@@ -594,12 +285,14 @@
 	FT_ULong  charcode;
 	FT_UInt   gindex;
 	FT_Face face = ftFace();
-	if (!face) {
+	if ( !face )
+	{
 		return false;
 	}
 	const FT_Stream fts = face->stream;
-	if (ftIOFunc(fts, 0L, NULL, 0)) {
-		return(false);
+	if ( ftIOFunc ( fts, 0L, NULL, 0 ) )
+	{
+		return ( false );
 	}
 	str+="%!PS-TrueTypeFont\n";
 	str+="11 dict begin\n";
@@ -616,26 +309,28 @@
 	char linebuf[80];
 	str += "/sfnts [";
 	int poso=0;
-	do {
+	do
+	{
 		int posi=0;
 		length= fts->size - fts->pos;
-		if (length > 65534) {
+		if ( length > 65534 )
+		{
 			length = 65534;
 		}
-		if (!ftIOFunc(fts, 0L, tmp, length))
+		if ( !ftIOFunc ( fts, 0L, tmp, length ) )
 		{
 			str+="\n<\n";
-			for (int j = 0; j < length; j++)
+			for ( int j = 0; j < length; j++ )
 			{
 				unsigned char u=tmp[posi];
-				linebuf[poso]=((u >> 4) & 15) + '0';
-				if(u>0x9f) linebuf[poso]+='a'-':';
+				linebuf[poso]= ( ( u >> 4 ) & 15 ) + '0';
+				if ( u>0x9f ) linebuf[poso]+='a'-':';
 				++poso;
 				u&=15; linebuf[poso]=u + '0';
-				if(u>0x9) linebuf[poso]+='a'-':';
+				if ( u>0x9 ) linebuf[poso]+='a'-':';
 				++posi;
 				++poso;
-				if (poso > 70)
+				if ( poso > 70 )
 				{
 					linebuf[poso++]='\n';
 					linebuf[poso++]=0;
@@ -648,29 +343,286 @@
 			poso = 0;
 			str += "00\n>";
 		}
-		else {
-			sDebug(QObject::tr("Font %1 is broken (read stream), no embedding").arg(fontFile));
+		else
+		{
+			sDebug ( QObject::tr ( "Font %1 is broken (read stream), no embedding" ).arg ( fontFile ) );
 			str += "\n] def\n";
-			status = qMax(status,ScFace::BROKENGLYPHS);
+			status = qMax ( status,ScFace::BROKENGLYPHS );
 			return false;
 		}
-	} while (length==65534);
-	
+	}
+	while ( length==65534 );
+
 	str += "\n] def\n";
 	delete[] tmp;
 	gindex = 0;
-	charcode = FT_Get_First_Char(face, &gindex );
-	while (gindex != 0)
+	charcode = FT_Get_First_Char ( face, &gindex );
+	while ( gindex != 0 )
 	{
-		FT_Get_Glyph_Name(face, gindex, buf, 50);
-		tmp2 += "/"+QString(reinterpret_cast<char*>(buf))+" "+tmp3.setNum(gindex)+" def\n";
-		 charcode = FT_Get_Next_Char(face, charcode, &gindex );
+		FT_Get_Glyph_Name ( face, gindex, buf, 50 );
+		tmp2 += "/"+QString ( reinterpret_cast<char*> ( buf ) ) +" "+tmp3.setNum ( gindex ) +" def\n";
+		charcode = FT_Get_Next_Char ( face, charcode, &gindex );
 		counter++;
 	}
-	tmp4.setNum(counter);
+	tmp4.setNum ( counter );
 	str += "/CharStrings " + tmp4 + " dict dup begin\n"+tmp2;
 	str += "end readonly def\n";
 	str += "FontName currentdict end definefont pop\n";
-	return(true);
+	return ( true );
 }
 
+qreal ScFace_ttf::glyphKerning ( uint gl1, uint gl2, qreal sz ) const
+{
+	return FtFace::glyphKerning ( gl1, gl2, sz );
+}
+
+int ScFace_ttf::shapeText(void* stry, unsigned int item) const
+{
+        StoryText* st = (StoryText*) stry ;
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"Shaping:";
+	if(status != ScFace::LOADED)
+		load();
+	unsigned int itemCount(st->itemCount());
+	if(item >= itemCount)
+		return -1;
+	LanguageManager * lm(LanguageManager::instance());
+	QString language(lm->getAbbrevFromLang(st->itemStyle(st->startOfItem(item)).language(), false, false));
+	double fSize(st->itemStyle(st->startOfItem(item)).fontSize() /10.0);
+	hb_font_t * font = hb_ft_font_create (ftFace(), releaseFaceForHB);
+	hb_buffer_t * buf = hb_buffer_create();
+	ScHBFunctions::setBufferFunctions(buf);
+	hb_font_set_scale(font, fSize * 1000, fSize * 1000);
+	 st->nOfGlyphs = st->itemTextPosition(item) ;
+	unsigned int end(st->itemTextPosition(item) + st->itemCharCount(item));
+	unsigned int counterP(0);
+//printf ( "(%s) (%d) (%s) from  (%d) to (%d) item (%d) \n", __FILE__, __LINE__, __func__, st->itemTextPosition(item), end, item ) ;
+	for(unsigned int ci(st->itemTextPosition(item)); ci < end; ++ci)
+	{
+	unsigned short gIndex(st->text(ci,1).at(0).unicode());
+		hb_buffer_add(buf, gIndex, 0x1, ci);
+		hb_glyph_position_t * pos = hb_buffer_get_glyph_positions(buf ,NULL) + counterP;
+		pos->x_advance = 0;
+		pos->x_offset = 0;
+		pos->y_advance = 0;
+		pos->y_offset = 0;
+		++counterP;
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " << counterP << " ( #" << ci <<  "|" << hex << gIndex << ")" ;
+	}
+	
+	hb_shape (font, buf, NULL, 0);
+	unsigned int bLen(hb_buffer_get_length(buf));
+	hb_glyph_info_t * gInfos = hb_buffer_get_glyph_infos (buf, NULL);
+	hb_glyph_position_t * gPositions = hb_buffer_get_glyph_positions (buf, &bLen);
+	
+	int clstr = -1 ;
+	GlyphLayout* curGlyph = &st->item_p(st->nOfGlyphs)->glyph ;
+	ScText* sct = st->item_p(st->nOfGlyphs) ;
+	sct->gch = sct->ch.unicode() ;
+	int glCnt = 0 ;
+	for(unsigned int bIdx(0); bIdx < bLen; ++bIdx)
+	{
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ")  " << st->nOfGlyphs ;
+		hb_glyph_info_t  gi = gInfos[bIdx];
+		hb_glyph_position_t  gp = gPositions[bIdx];
+		if ( clstr == gi.cluster ) {
+			curGlyph->grow() ;
+			curGlyph = curGlyph->more ;
+			glCnt++ ;
+		} else {
+	        	curGlyph = &st->item_p(st->nOfGlyphs)->glyph ;
+			clstr = gi.cluster ;
+			sct = st->item_p(st->nOfGlyphs) ;
+			sct->gIdx = st->nOfGlyphs ;
+			glCnt = 0 ;
+		}
+		st->nOfGlyphs++ ;
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") (" << bIdx << ")(" << bLen << ") text len (" << st->length() << ")(" << st->nOfGlyphs << ")" ;
+if ((int)curGlyph < 0x1000 ){
+qDebug()<< "FIXME (" << __FILE__ << ")(" << __LINE__ << __func__ << ") (" << bIdx << ")(" << bLen << ") text len (" << st->length() << ") glyph len(" << st->nOfGlyphs << ") adr Glyph(" << curGlyph << ")" ;
+   continue ;
+}
+		gp.x_advance = 0 ;
+		curGlyph->xadvance = glyphWidth(gi.codepoint, fSize) ; // + (double(gp.x_advance) / 1000.0);
+		curGlyph->xoffset = gp.x_offset;
+		curGlyph->yadvance = gp.y_advance;
+		curGlyph->yoffset = gp.y_offset;
+		curGlyph->glyph = gi.codepoint;
+	}
+	st->item_p(end-1)->gch = st->item_p(end-1)->ch ;
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"Shaping: nonAuto";
+
+	hb_buffer_destroy(buf);
+//qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"Shaping: nonAuto";
+
+	// FIXME_OIF return proper value
+	return 0;
+}
+
+void ScFace_ttf::icuShape(StoryText* st, unsigned int item, LayoutEngine *le, const QString &text, QList<GlyphLayout> &glList, QList<le_int32> &charList, QList<le_int32> &baseCharList) const
+{
+	//bool isRTL(st->charAttributes(st->startOfItem(item)).testFlag(TextFlag_RightToLeft));
+	bool isRTL = 0 ;
+	double fSize(st->charStyle(st->startOfItem(item)).fontSize() /10.0);
+        unsigned int strt = st->startOfItem(item) ;
+        unsigned int end = st->endOfItem(item) ;
+	const QString text2(text.isEmpty() ? st->text(strt, end - strt ) : text);
+	// const bool textBased(!text.isEmpty());
+	const int sCount (text2.length());
+	LEUnicode16 *ts = new LEUnicode[sCount];
+	LEErrorCode err(LE_NO_ERROR);
+	qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"Shaping:"<<text2;
+	unsigned int ci(0);
+	foreach(const QChar& c, text2)
+	{
+		ts[ci] = c.unicode();
+		++ci;
+	}
+	le->reset();
+	/*int glAllocated = */le->layoutChars( ts, 0, sCount , sCount, isRTL, 0, 0, err );
+
+	le_int32 gCount(le->getGlyphCount());
+	LEGlyphID *glyphs    = new LEGlyphID[gCount];
+	le_int32 *indices   = new le_int32[gCount];
+	le->getGlyphs ( glyphs, err );
+	le->getCharIndices ( indices, err );
+	float xShift(0.0);
+
+	double sFactor(fSize / m_uniEM);
+	float icuX(0);
+	float icuY(0);
+	float icuFwdX(0);
+	float icuFwdY(0);
+	for ( le_int32 gIdx ( 0 ); gIdx < gCount ; ++gIdx )
+	{
+		if((glyphs[gIdx] != 0xFFFF)
+			&& (glyphs[gIdx] != 0xFFFE))
+		{
+			le->getGlyphPosition(gIdx, icuX, icuY, err);
+			le_int32 nextIdx(gIdx + 1);
+			while((glyphs[nextIdx] == 0xFFFF) && (nextIdx < gCount))
+				++nextIdx;
+			le->getGlyphPosition(nextIdx, icuFwdX, icuFwdY, err);
+			icuX *= sFactor;
+			icuY *= sFactor;
+			icuFwdX *= sFactor;
+			icuFwdY *= sFactor;
+			if(err != LE_NO_ERROR)
+				continue;
+			bool isCombining(text2.at(indices[gIdx]).isMark());
+			GlyphLayout curGlyph;
+			curGlyph.glyph = glyphs[gIdx];
+			curGlyph.xadvance = glyphWidth(curGlyph.glyph, fSize);
+			curGlyph.xoffset = isRTL ? (icuFwdX - icuX) - curGlyph.xadvance : xShift;
+			curGlyph.yoffset = icuY;
+			curGlyph.yadvance = 0;
+			xShift =  (icuFwdX - icuX) - curGlyph.xadvance;
+			if(isRTL)
+			{
+				glList.prepend( curGlyph );
+				charList.prepend(indices[gIdx]);
+				if(!isCombining)
+					baseCharList.prepend(indices[gIdx]);
+			}
+			else
+			{
+				glList << curGlyph;
+				charList << indices[gIdx];
+				if(!isCombining)
+					baseCharList << indices[gIdx];
+			}
+//			qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") " <<"icu"<<indices[gIdx] << curGlyph.glyph << sHeight << icuY << icuFwdY;
+		}
+	}
+	le->reset();
+
+	delete[]  ts;
+	delete[]  glyphs;
+	delete[]  indices;
+}
+
+QList<unsigned int> ScFace_ttf::getlookupIndex(const QString &table, const QString &language, const QString &feature) const
+{
+qDebug()<< "(" << __FILE__ << ")(" << __LINE__ << __func__ << ") Table (" << table  << ") Lang (" << language << " ) Featu ( " << feature ;
+	hb_tag_t t = (table == QString("GSUB")) ? HB_OT_TAG_GSUB : HB_OT_TAG_GPOS;
+	LanguageManager * lm(LanguageManager::instance());
+//	if(scLangToTags.contains(language))
+	{
+		hb_tag_t scriptTag = stringToTag(lm->getScriptTag( language ));
+		hb_tag_t langTag = stringToTag(lm->getLangTag( language ));
+		if(feature.isEmpty())
+		{
+			// If no specific feature has been asked for, we return required feature for this language.
+			hb_face_t * face = hb_ft_face_create(ftFace(), releaseFaceForHB );
+			unsigned int scriptIndex(0);
+			unsigned int languageIndex(0);
+			unsigned int featureIndex(0);
+			hb_ot_layout_table_find_script(face, t,scriptTag, &scriptIndex);
+			if(!hb_ot_layout_script_find_language(face, t, scriptIndex, langTag, &languageIndex))
+				hb_ot_layout_script_find_language(face, t, scriptIndex, HB_OT_TAG_DEFAULT_LANGUAGE, &languageIndex);
+			hb_ot_layout_language_get_required_feature_index(face, t, scriptIndex, languageIndex, &featureIndex);
+			unsigned int lookupCount(hb_ot_layout_feature_get_lookup_indexes (face,t,  featureIndex,0, 0 ,0));
+			unsigned int * lookup_indexes = new unsigned int[lookupCount];
+			hb_ot_layout_feature_get_lookup_indexes (face,t,  featureIndex,0, &lookupCount, lookup_indexes);
+
+			QList<unsigned int> ret;
+			for(unsigned int ui(0); ui < lookupCount; ++ui)
+				ret << lookup_indexes[ui];
+			delete lookup_indexes;
+			return ret;
+		}
+		else
+		{
+			hb_tag_t featureTag = stringToTag(feature);
+			bool haveIt(false);
+			QList<FontFeatureSet::Feature> ff = featureSet->features(t == HB_OT_TAG_GSUB ? FontFeatureSet::Sub :FontFeatureSet::Pos );
+			foreach(const FontFeatureSet::Feature& f, ff)
+			{
+				if((f.name == feature)
+					/* FIXME_OIF && (f.lang.contains( tagToString(langTag) ))*/ )
+					{
+					haveIt = true;
+					break;
+				}
+			}
+			if(haveIt)
+			{
+				hb_face_t * face = hb_ft_face_create(ftFace(), releaseFaceForHB );
+				unsigned int scriptIndex(0);
+				unsigned int languageIndex(0);
+				unsigned int featureIndex(0);
+				hb_ot_layout_table_find_script(face, t,scriptTag, &scriptIndex);
+				if(!hb_ot_layout_script_find_language(face, t, scriptIndex, langTag, &languageIndex))
+					hb_ot_layout_script_find_language(face, t, scriptIndex, HB_OT_TAG_DEFAULT_LANGUAGE, &languageIndex);
+				hb_ot_layout_language_find_feature(face, t,scriptIndex, languageIndex, featureTag, &featureIndex);
+				unsigned int lookupCount(hb_ot_layout_feature_get_lookup_indexes (face,t,  featureIndex,0, 0 ,0));
+				unsigned int * lookup_indexes = new unsigned int[lookupCount];
+				hb_ot_layout_feature_get_lookup_indexes (face,t,  featureIndex,0, &lookupCount, lookup_indexes);
+				QList<unsigned int> ret;
+				for(unsigned int ui(0); ui < lookupCount; ++ui)
+					ret << lookup_indexes[ui];
+				delete lookup_indexes;
+				return ret;
+			}
+		}
+	}
+	return QList<unsigned int>();
+}
+
+void ScFace_ttf::fillLangToTag()
+{
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << __func__ << ")" ;
+//	if(!icuLangList.isEmpty())
+//		return;
+
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << __func__ << ")" ;
+	LanguageManager *lm(LanguageManager::instance());
+	QStringList langs;
+	lm->fillInstalledStringList(&langs, false);
+	// Latin scripts
+	foreach(const QString& lang, langs)
+	{
+		QString abbr(lm->getAbbrevFromLang(lang));
+//		scLangToTags[lm->getLangFromTransLang(lang)] = qMakePair(HB_TAG('l','a','t','n'), hb_ot_tag_from_language(hb_language_from_string(abbr.toAscii().data(), -1)));
+		scLangToTags[lm->getLangFromTransLang(lang)] = hb_ot_tag_from_language(hb_language_from_string(abbr.toAscii().data(), -1));
+	}
+}
diff -Naur Scribus_1.5_120815/scribus/fonts/scface_ttf.h Scribus_1.5_indic/scribus/fonts/scface_ttf.h
--- Scribus_1.5_120815/scribus/fonts/scface_ttf.h	2012-08-15 11:01:50.060825207 +0530
+++ Scribus_1.5_indic/scribus/fonts/scface_ttf.h	2012-08-15 13:32:16.073076970 +0530
@@ -3,80 +3,47 @@
 to the COPYING file provided with the program. Following this notice may exist
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
 */
 #ifndef SCFACE_TTF_H
 #define SCFACE_TTF_H
 
 #include "scribusapi.h"
 #include "fonts/ftface.h"
+#include "fonts/fontfeatureset.h"
+#include "text/storytext.h"
 
+#include "third_party/harfbuzz/src/hb.h"
+#include "layout/LELanguages.h"
+#include "layout/LEScripts.h"
+#include "layout/LayoutEngine.h"
 
-#include FT_TRUETYPE_TABLES_H
-#include FT_TRUETYPE_TAGS_H
+#include <QMap>
+#include <QPair>
 
+class ScICUFont;
 
-/**
-	An object holding a table of kerning pairs extracted from
-	a kern feature such as found in a GPOS table
- */
-class SCRIBUS_API KernFeature
-{
-	typedef QMap<quint16, QList<quint16> > ClassDefTable; // <Class index (0 to N) , list of glyphs >
+//#include FT_TRUETYPE_TABLES_H
+//#include FT_TRUETYPE_TAGS_H
 
-	public:
-		/**
-		* Build a ready-to-use kerning pairs table
-		* @param face a valid FT_Face, It wont be store by KernFeature
-		 */
-		KernFeature ( FT_Face face );
-		KernFeature ( const KernFeature& kf );
-		~KernFeature();
-
-		/**
-		 * Get the kerning value for a pair of glyph indexes.
-		 * @param glyph1 Index of the left glyph in logical order
-		 * @param glyph2 Index of the right glyph in logical order
-		 * @return the unscaled delta to apply to xadvance of the first glyph
-		 */
-		double getPairValue ( unsigned int glyph1, unsigned int glyph2 ) const;
-
-		/**
-		 * The table can have been invalidated if something went wrong at any moment.
-		 * @return True if valid, False otherwise.
-		 */
-		bool isValid() const {return m_valid;}
 
-	private:
-		bool m_valid;
-		QByteArray GPOSTableRaw;
-		QMap<quint16,QList<quint16> > coverages;
-		mutable QMap<quint16, QMap<quint16, double> > pairs;
-		QMap< quint16, QMap<quint16, ClassDefTable> > classGlyphFirst; // < subtable offset, map<offset, class definition table> > for first glyph
-		QMap< quint16, QMap<quint16, ClassDefTable> > classGlyphSecond; // < subtable offset, map<offset, class definition table> > for second glyph
-		QMap< quint16, QMap<int, QMap<int, double> > > classValue; // < subtable offset, map<class1, map<class2, value> > >
-
-		void makeCoverage();
-		void makePairs ( quint16 subtableOffset );
-
-		ClassDefTable getClass (bool leftGlyph, quint16 classDefOffset, quint16 coverageId );
-		inline quint16 toUint16 ( quint16 index );
-		inline qint16 toInt16 ( quint16 index );
-
-		enum ValueFormat
-		{
-			XPlacement = 0x0001,
-			YPlacement = 0x0002,
-			XAdvance = 0x0004,
-			YAdvance = 0x0008,
-			XPlaDevice =0x0010,
-			YPlaDevice =0x0020,
-			XAdvDevice =0x0040,
-			YAdvDevice =0x0080
-		};
-		QString FontName;// for debugging purpose
-};
+///** Deprecated, will do regular OpenType processing
+//	An object holding a table of kerning pairs extracted from
+//	a kern feature such as found in a GPOS table
+// */
 
+class SCRIBUS_API TTFFeatureSet : public FontFeatureSet
+{
+	QList<Feature> featuresList;
 
+public:
+	TTFFeatureSet( FT_Face ftface );
+	QList<Feature> features(FeatureType type) const;
+	bool hasFeature(const QString& f);
+	Feature getFeature(const QString& f);
+};
 
 /*
 	Class ScFace_ttf
@@ -84,22 +51,34 @@
 	Implements: RealName() and EmbedFont().
 */
 
-class SCRIBUS_API ScFace_ttf : public FtFace
-{
-public:
-	ScFace_ttf ( QString fam, QString sty, QString alt, QString scname, QString psname, QString path, int face );
-	~ScFace_ttf();
 
-	void load () const;
-	void unload () const;
 
-	bool EmbedFont(QString &str) const;
-	void RawData(QByteArray & bb) const;
+class SCRIBUS_API ScFace_ttf : public FtFace
+{
+	public:
+		ScFace_ttf ( QString fam, QString sty, QString alt, QString scname, QString psname, QString path, int face );
+		~ScFace_ttf();
+		
+		void load () const;
+		void unload () const;
+		
+		bool EmbedFont ( QString &str ) const;
+		void RawData ( QByteArray & bb ) const;
+		
+		qreal glyphKerning ( uint gl1, uint gl2, qreal sz ) const;
 
-	qreal glyphKerning ( uint gl1, uint gl2, qreal sz ) const;
+		TTFFeatureSet * features(FontFeatureSet::FeatureType type) const {return featureSet;}
+		int shapeText( void* stry, unsigned int item) const;
 
-private:
-	mutable KernFeature * kernFeature;
+	private:
+		void icuShape(StoryText* st, unsigned int item, LayoutEngine * le, const QString& text, QList<GlyphLayout>& glList, QList<le_int32>& charList, QList<le_int32>& baseCharList) const;
+		static QMap<QString, LanguageCodes> icuLangList;
+		static QMap<QString, ScriptCodes> scriptTagToICUCode;
+                static QMap<QString, hb_tag_t> scLangToTags ;
+		void fillLangToTag();
+		QList<unsigned int> getlookupIndex(const QString& table, const QString& language, const QString& feature = QString()) const;
+		mutable TTFFeatureSet * featureSet;
+		mutable ScICUFont * icuFont;
 };
 
 #endif
diff -Naur Scribus_1.5_120815/scribus/fonts/schbfunctions.cpp Scribus_1.5_indic/scribus/fonts/schbfunctions.cpp
--- Scribus_1.5_120815/scribus/fonts/schbfunctions.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/schbfunctions.cpp	2012-08-15 11:58:52.959920681 +0530
@@ -0,0 +1,287 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#include "schbfunctions.h"
+#include <QDebug>
+#include <unicode/uversion.h>
+#include <unicode/uchar.h>
+#include <unicode/uscript.h>
+
+
+QMap<QChar, hb_unicode_general_category_t> ScHBFunctions::UniCatMap;
+ScHBFunctions * ScHBFunctions::instance = 0;
+hb_unicode_funcs_t * ScHBFunctions::funcs = 0;
+
+ScHBFunctions::ScHBFunctions()
+{
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	UniCatMap[QChar::Mark_NonSpacing] = HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ;
+//	UniCatMap[QChar::Mark_SpacingCombining] = HB_UNICODE_GENERAL_CATEGORY_COMBINING_MARK ;
+	UniCatMap[QChar::Mark_Enclosing] = HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK ;
+	UniCatMap[QChar::Number_DecimalDigit] = HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER ;
+	UniCatMap[QChar::Number_Letter] = HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER ;
+	UniCatMap[QChar::Number_Other] = HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER ;
+	UniCatMap[QChar::Separator_Space] = HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR ;
+	UniCatMap[QChar::Separator_Line] = HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR ;
+	UniCatMap[QChar::Separator_Paragraph] = HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR ;
+	UniCatMap[QChar::Other_Control] = HB_UNICODE_GENERAL_CATEGORY_CONTROL ;
+	UniCatMap[QChar::Other_Format] = HB_UNICODE_GENERAL_CATEGORY_FORMAT ;
+	UniCatMap[QChar::Other_Surrogate] = HB_UNICODE_GENERAL_CATEGORY_SURROGATE ;
+	UniCatMap[QChar::Other_PrivateUse] = HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE ;
+	UniCatMap[QChar::Other_NotAssigned] = HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED ;
+	UniCatMap[QChar::Letter_Uppercase] = HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER ;
+	UniCatMap[QChar::Letter_Lowercase] = HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER ;
+	UniCatMap[QChar::Letter_Titlecase] = HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER ;
+	UniCatMap[QChar::Letter_Modifier] = HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER ;
+	UniCatMap[QChar::Letter_Other] = HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER ;
+	UniCatMap[QChar::Punctuation_Connector] = HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_Dash] = HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_Open] = HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_Close] = HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_InitialQuote] = HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_FinalQuote] = HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION ;
+	UniCatMap[QChar::Punctuation_Other] = HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION ;
+	UniCatMap[QChar::Symbol_Math] = HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL ;
+	UniCatMap[QChar::Symbol_Currency] = HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL ;
+	UniCatMap[QChar::Symbol_Modifier] = HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL ;
+	UniCatMap[QChar::Symbol_Other] = HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL ;
+
+
+	// funcs = hb_unicode_funcs_create();
+	funcs = hb_unicode_funcs_create(NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	hb_unicode_funcs_set_mirroring_func(funcs, (hb_unicode_mirroring_func_t)ScHBFunctions::getMirroring, NULL, NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	hb_unicode_funcs_set_general_category_func(funcs, (hb_unicode_general_category_func_t)ScHBFunctions::getCategory,   NULL,NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	hb_unicode_funcs_set_script_func(funcs, (hb_unicode_script_func_t)ScHBFunctions::getScript, NULL, NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	hb_unicode_funcs_set_combining_class_func(funcs, (hb_unicode_combining_class_func_t)ScHBFunctions::getCombiningClass, NULL,NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+	hb_unicode_funcs_set_eastasian_width_func(funcs, (hb_unicode_eastasian_width_func_t)ScHBFunctions::getEastasianWidth, NULL,NULL);
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" ;
+}
+
+
+hb_codepoint_t ScHBFunctions::getMirroring(hb_codepoint_t unicode)
+{
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" << unicode ;
+	return hb_codepoint_t(QChar::mirroredChar(unicode));
+}
+
+hb_unicode_general_category_t ScHBFunctions::getCategory(hb_codepoint_t unicode)
+{
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" << unicode ;
+//	return UniCatMap[QChar::category(unicode)];
+  switch (u_getIntPropertyValue(unicode, UCHAR_GENERAL_CATEGORY))
+  {
+  case U_UNASSIGNED:			return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;
+
+  case U_UPPERCASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER;
+  case U_LOWERCASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER;
+  case U_TITLECASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER;
+  case U_MODIFIER_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER;
+  case U_OTHER_LETTER:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER;
+
+  case U_NON_SPACING_MARK:		return HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK;
+  case U_ENCLOSING_MARK:		return HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK;
+  case U_COMBINING_SPACING_MARK:	return HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK;
+
+  case U_DECIMAL_DIGIT_NUMBER:		return HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER;
+  case U_LETTER_NUMBER:			return HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER;
+  case U_OTHER_NUMBER:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER;
+
+  case U_SPACE_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR;
+  case U_LINE_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR;
+  case U_PARAGRAPH_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR;
+
+  case U_CONTROL_CHAR:			return HB_UNICODE_GENERAL_CATEGORY_CONTROL;
+  case U_FORMAT_CHAR:			return HB_UNICODE_GENERAL_CATEGORY_FORMAT;
+  case U_PRIVATE_USE_CHAR:		return HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE;
+  case U_SURROGATE:			return HB_UNICODE_GENERAL_CATEGORY_SURROGATE;
+
+
+  case U_DASH_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION;
+  case U_START_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION;
+  case U_END_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION;
+  case U_CONNECTOR_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION;
+  case U_OTHER_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION;
+
+  case U_MATH_SYMBOL:			return HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL;
+  case U_CURRENCY_SYMBOL:		return HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL;
+  case U_MODIFIER_SYMBOL:		return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL;
+  case U_OTHER_SYMBOL:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL;
+
+  case U_INITIAL_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION;
+  case U_FINAL_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION;
+  }
+
+  return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;
+}
+
+hb_script_t ScHBFunctions::getScript(hb_codepoint_t unicode, hb_codepoint_t codepoint)
+{
+//printf ( "(%s)(%d)(%s) -(%X)(%X)  \n", __FILE__, __LINE__, __func__, unicode, codepoint ) ;
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" << unicode ;
+	// FIXME_OIF
+  UErrorCode status = U_ZERO_ERROR;
+  UScriptCode scriptCode = uscript_getScript(codepoint, &status);
+  switch ((int) scriptCode)
+  {
+#define MATCH_SCRIPT(C) case USCRIPT_##C: return HB_SCRIPT_##C
+#define MATCH_SCRIPT2(C1, C2) case USCRIPT_##C1: return HB_SCRIPT_##C2
+  MATCH_SCRIPT (COMMON);             /* Zyyy */
+  MATCH_SCRIPT (INHERITED);          /* Qaai */
+  MATCH_SCRIPT (ARABIC);             /* Arab */
+  MATCH_SCRIPT (ARMENIAN);           /* Armn */
+  MATCH_SCRIPT (BENGALI);            /* Beng */
+  MATCH_SCRIPT (BOPOMOFO);           /* Bopo */
+  MATCH_SCRIPT (CHEROKEE);           /* Cher */
+  MATCH_SCRIPT (COPTIC);             /* Qaac */
+  MATCH_SCRIPT (CYRILLIC);           /* Cyrl (Cyrs) */
+  MATCH_SCRIPT (DESERET);            /* Dsrt */
+  MATCH_SCRIPT (DEVANAGARI);         /* Deva */
+  MATCH_SCRIPT (ETHIOPIC);           /* Ethi */
+  MATCH_SCRIPT (GEORGIAN);           /* Geor (Geon); Geoa) */
+  MATCH_SCRIPT (GOTHIC);             /* Goth */
+  MATCH_SCRIPT (GREEK);              /* Grek */
+  MATCH_SCRIPT (GUJARATI);           /* Gujr */
+  MATCH_SCRIPT (GURMUKHI);           /* Guru */
+  MATCH_SCRIPT (HAN);                /* Hani */
+  MATCH_SCRIPT (HANGUL);             /* Hang */
+  MATCH_SCRIPT (HEBREW);             /* Hebr */
+  MATCH_SCRIPT (HIRAGANA);           /* Hira */
+  MATCH_SCRIPT (KANNADA);            /* Knda */
+  MATCH_SCRIPT (KATAKANA);           /* Kana */
+  MATCH_SCRIPT (KHMER);              /* Khmr */
+  MATCH_SCRIPT (LAO);                /* Laoo */
+  MATCH_SCRIPT (LATIN);              /* Latn (Latf); Latg) */
+  MATCH_SCRIPT (MALAYALAM);          /* Mlym */
+  MATCH_SCRIPT (MONGOLIAN);          /* Mong */
+  MATCH_SCRIPT (MYANMAR);            /* Mymr */
+  MATCH_SCRIPT (OGHAM);              /* Ogam */
+  MATCH_SCRIPT (OLD_ITALIC);         /* Ital */
+  MATCH_SCRIPT (ORIYA);              /* Orya */
+  MATCH_SCRIPT (RUNIC);              /* Runr */
+  MATCH_SCRIPT (SINHALA);            /* Sinh */
+  MATCH_SCRIPT (SYRIAC);             /* Syrc (Syrj, Syrn); Syre) */
+  MATCH_SCRIPT (TAMIL);              /* Taml */
+  MATCH_SCRIPT (TELUGU);             /* Telu */
+  MATCH_SCRIPT (THAANA);             /* Thaa */
+  MATCH_SCRIPT (THAI);               /* Thai */
+  MATCH_SCRIPT (TIBETAN);            /* Tibt */
+  MATCH_SCRIPT (CANADIAN_ABORIGINAL);/* Cans */
+  MATCH_SCRIPT (YI);                 /* Yiii */
+  MATCH_SCRIPT (TAGALOG);            /* Tglg */
+  MATCH_SCRIPT (HANUNOO);            /* Hano */
+  MATCH_SCRIPT (BUHID);              /* Buhd */
+  MATCH_SCRIPT (TAGBANWA);           /* Tagb */
+
+  /* Unicode-4.0 additions */
+  MATCH_SCRIPT (BRAILLE);            /* Brai */
+  MATCH_SCRIPT (CYPRIOT);            /* Cprt */
+  MATCH_SCRIPT (LIMBU);              /* Limb */
+  MATCH_SCRIPT (OSMANYA);            /* Osma */
+  MATCH_SCRIPT (SHAVIAN);            /* Shaw */
+  MATCH_SCRIPT (LINEAR_B);           /* Linb */
+  MATCH_SCRIPT (TAI_LE);             /* Tale */
+  MATCH_SCRIPT (UGARITIC);           /* Ugar */
+
+  /* Unicode-4.1 additions */
+  MATCH_SCRIPT (NEW_TAI_LUE);        /* Talu */
+  MATCH_SCRIPT (BUGINESE);           /* Bugi */
+  MATCH_SCRIPT (GLAGOLITIC);         /* Glag */
+  MATCH_SCRIPT (TIFINAGH);           /* Tfng */
+  MATCH_SCRIPT (SYLOTI_NAGRI);       /* Sylo */
+  MATCH_SCRIPT (OLD_PERSIAN);        /* Xpeo */
+  MATCH_SCRIPT (KHAROSHTHI);         /* Khar */
+
+  /* Unicode-5.0 additions */
+  MATCH_SCRIPT (UNKNOWN);            /* Zzzz */
+  MATCH_SCRIPT (BALINESE);           /* Bali */
+  MATCH_SCRIPT (CUNEIFORM);          /* Xsux */
+  MATCH_SCRIPT (PHOENICIAN);         /* Phnx */
+  MATCH_SCRIPT (PHAGS_PA);           /* Phag */
+  MATCH_SCRIPT (NKO);                /* Nkoo */
+
+  /* Unicode-5.1 additions */
+  MATCH_SCRIPT (KAYAH_LI);           /* Kali */
+  MATCH_SCRIPT (LEPCHA);             /* Lepc */
+  MATCH_SCRIPT (REJANG);             /* Rjng */
+  MATCH_SCRIPT (SUNDANESE);          /* Sund */
+  MATCH_SCRIPT (SAURASHTRA);         /* Saur */
+  MATCH_SCRIPT (CHAM);               /* Cham */
+  MATCH_SCRIPT (OL_CHIKI);           /* Olck */
+  MATCH_SCRIPT (VAI);                /* Vaii */
+  MATCH_SCRIPT (CARIAN);             /* Cari */
+  MATCH_SCRIPT (LYCIAN);             /* Lyci */
+  MATCH_SCRIPT (LYDIAN);             /* Lydi */
+
+  /* Unicode-5.2 additions */
+  MATCH_SCRIPT (AVESTAN);                /* Avst */
+  MATCH_SCRIPT (BAMUM);                  /* Bamu */
+  MATCH_SCRIPT (EGYPTIAN_HIEROGLYPHS);   /* Egyp */
+  MATCH_SCRIPT (IMPERIAL_ARAMAIC);       /* Armi */
+  MATCH_SCRIPT (INSCRIPTIONAL_PAHLAVI);  /* Phli */
+  MATCH_SCRIPT (INSCRIPTIONAL_PARTHIAN); /* Prti */
+  MATCH_SCRIPT (JAVANESE);               /* Java */
+  MATCH_SCRIPT (KAITHI);                 /* Kthi */
+  MATCH_SCRIPT2(LANNA, TAI_THAM);        /* Lana */
+  MATCH_SCRIPT (LISU);                   /* Lisu */
+  MATCH_SCRIPT (OLD_SOUTH_ARABIAN);      /* Sarb */
+  MATCH_SCRIPT2(ORKHON, OLD_TURKIC);     /* Orkh */
+  MATCH_SCRIPT (SAMARITAN);              /* Samr */
+  MATCH_SCRIPT (TAI_VIET);               /* Tavt */
+  }
+  return HB_SCRIPT_UNKNOWN;
+}
+
+unsigned int ScHBFunctions::getCombiningClass(hb_codepoint_t unicode)
+{
+//qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")" << unicode ;
+	return (unsigned int)QChar::combiningClass ( unicode );
+}
+
+unsigned int ScHBFunctions::getEastasianWidth(hb_codepoint_t unicode)
+{
+qDebug() << "(" << __FILE__ << ")(" << __LINE__ << ")"  ;
+  switch (u_getIntPropertyValue(unicode, UCHAR_EAST_ASIAN_WIDTH))
+  {
+  case U_EA_WIDE:
+  case U_EA_FULLWIDTH:
+    return 2;
+  case U_EA_NEUTRAL:
+  case U_EA_AMBIGUOUS:
+  case U_EA_HALFWIDTH:
+  case U_EA_NARROW:
+    return 1;
+  }
+  return 1;
+}
+
+
+void ScHBFunctions::setBufferFunctions(hb_buffer_t *buf)
+{
+	if(0 == instance)
+		instance = new ScHBFunctions;
+	hb_buffer_set_unicode_funcs(buf, funcs);
+}
+
diff -Naur Scribus_1.5_120815/scribus/fonts/schbfunctions.h Scribus_1.5_indic/scribus/fonts/schbfunctions.h
--- Scribus_1.5_120815/scribus/fonts/schbfunctions.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/schbfunctions.h	2012-08-15 11:58:57.962920894 +0530
@@ -0,0 +1,59 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#ifndef SCHBFUNCTIONS_H
+#define SCHBFUNCTIONS_H
+
+#include <QMap>
+#include <QChar>
+
+#include "third_party/harfbuzz/src/hb.h"
+//#include "third_party/harfbuzz/src/hb-unicode.h"
+//#include "third_party/harfbuzz/src/hb-buffer.h"
+
+class ScFace_ttf;
+
+/**
+  Harfbuzz library expects the client to provide a bunch of functions
+  in order to perform some of its operations. While it now provides
+  some of them as optional packages, it's at the price of GLib dependency.
+  */
+
+class ScHBFunctions
+{
+	static ScHBFunctions * instance;
+
+	ScHBFunctions();
+
+	static hb_unicode_funcs_t * funcs;
+	static QMap<QChar, hb_unicode_general_category_t> UniCatMap;
+
+	static hb_codepoint_t getMirroring (hb_codepoint_t unicode);
+	static hb_unicode_general_category_t getCategory (hb_codepoint_t unicode);
+	static unsigned int getCombiningClass (hb_codepoint_t unicode);
+	static unsigned int getEastasianWidth (hb_codepoint_t unicode);
+	static hb_script_t getScript (hb_codepoint_t unicode, hb_codepoint_t codepoint);
+
+public:
+	static void setBufferFunctions(hb_buffer_t * buf);
+};
+
+#endif // SCHBFUNCTIONS_H
diff -Naur Scribus_1.5_120815/scribus/fonts/scicufont.cpp Scribus_1.5_indic/scribus/fonts/scicufont.cpp
--- Scribus_1.5_120815/scribus/fonts/scicufont.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/scicufont.cpp	2012-08-15 11:59:56.661922462 +0530
@@ -0,0 +1,128 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "scicufont.h"
+
+ScICUFont *ScICUFont::instance = 0;
+
+ScICUFont::ScICUFont ( FT_Face ftface)
+		:face ( ftface )
+{
+	instance = this;
+}
+
+ScICUFont::~ ScICUFont()
+{
+	foreach(unsigned char* p, tables)
+	{
+		delete p;
+	}
+
+}
+
+const void * ScICUFont::getFontTable ( LETag tableTag ) const
+{
+	FT_ULong length(0);
+	if ( !FT_Load_Sfnt_Table ( face, tableTag, 0, NULL, &length ) )
+	{
+		if ( length > 0 )
+		{
+// 			qDebug()<<"Table len"<< length;
+			FT_Byte * bA = new FT_Byte[length];
+
+			FT_Load_Sfnt_Table ( face, tableTag, 0, bA, &length );
+
+			regTables( tableTag,  bA );
+			return  (const void*) tables.value(tableTag);
+		}
+
+	}
+	return 0;
+}
+
+le_int32 ScICUFont::getUnitsPerEM() const
+{
+	return face->units_per_EM;
+}
+
+LEGlyphID ScICUFont::mapCharToGlyph ( LEUnicode32 ch ) const
+{
+	int gi(FT_Get_Char_Index ( face, ch ));
+// 	cerr << "ScICUFont::mapCharToGlyph("<< ch <<") = "<<gi<<std::endl;
+	return gi;
+}
+
+void ScICUFont::getGlyphAdvance ( LEGlyphID glyph, LEPoint & advance ) const
+{
+	if ( !FT_Load_Glyph ( face, glyph , FT_LOAD_NO_SCALE ) )
+	{
+		advance.fX = face->glyph->metrics.horiAdvance;
+//		Would be relevant only for fonts with vertical metrics
+//		advance.fY = face->glyph->metrics.vertAdvance;
+		advance.fY = 0;
+	}
+	else
+	{
+		advance.fX = 0;
+		advance.fY = 0;
+	}
+}
+
+le_bool ScICUFont::getGlyphPoint ( LEGlyphID glyph, le_int32 pointNumber, LEPoint & point ) const
+{
+// 	cerr<< "ScICUFont::getGlyphPoint" <<std::endl;
+	return false;
+}
+
+float ScICUFont::getXPixelsPerEm() const
+{
+	return getUnitsPerEM();
+}
+
+float ScICUFont::getYPixelsPerEm() const
+{
+	return getUnitsPerEM();
+}
+
+float ScICUFont::getScaleFactorX() const
+{
+	return 1.0;
+}
+
+float ScICUFont::getScaleFactorY() const
+{
+	return 1.0;
+}
+
+le_int32 ScICUFont::getAscent() const
+{
+	return face->ascender;
+}
+
+le_int32 ScICUFont::getDescent() const
+{
+	return face->descender;
+}
+
+le_int32 ScICUFont::getLeading() const
+{
+	return 0;
+}
+
diff -Naur Scribus_1.5_120815/scribus/fonts/scicufont.h Scribus_1.5_indic/scribus/fonts/scicufont.h
--- Scribus_1.5_120815/scribus/fonts/scicufont.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/fonts/scicufont.h	2012-08-15 11:59:56.669922459 +0530
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef SCICUFONT_H
+#define SCICUFONT_H
+
+#include <ft2build.h>
+#include FT_TRUETYPE_TABLES_H
+#include FT_TRUETYPE_TAGS_H
+
+#include "layout/LEFontInstance.h"
+
+#include <QMap>
+
+class ScICUFont : public LEFontInstance
+{
+public:
+	ScICUFont ( FT_Face ftface );
+	~ScICUFont();
+	// implements pure virtual methods of LEFontInstance
+
+	const void* getFontTable(LETag   tableTag ) const;
+	le_bool 	canDisplay (LEUnicode32 ch) const {return true;}
+	le_int32 	getUnitsPerEM () const;
+	LEGlyphID 	mapCharToGlyph (LEUnicode32 ch) const ;
+	void 	getGlyphAdvance (LEGlyphID glyph, LEPoint &advance) const;
+	le_bool 	getGlyphPoint (LEGlyphID glyph, le_int32 pointNumber, LEPoint &point) const;
+	float 	getXPixelsPerEm () const ;
+	float 	getYPixelsPerEm () const ;
+	float 	getScaleFactorX () const ;
+	float 	getScaleFactorY () const ;
+	le_int32 	getAscent () const ;
+	le_int32 	getDescent () const;
+	le_int32 	getLeading () const;
+
+	static void regTables(LETag   tableTag, unsigned char *t){instance->tables[tableTag] = t;}
+
+private:
+	FT_Face face;
+	static ScICUFont *instance;
+	QMap<LETag, unsigned char*> tables;
+
+};
+
+#endif // SCICUFONT_H
diff -Naur Scribus_1.5_120815/scribus/fpointarray.cpp Scribus_1.5_indic/scribus/fpointarray.cpp
--- Scribus_1.5_120815/scribus/fpointarray.cpp	2012-08-15 11:02:06.429825663 +0530
+++ Scribus_1.5_indic/scribus/fpointarray.cpp	2012-08-15 12:03:43.134928776 +0530
@@ -266,6 +266,11 @@
 	}
 }
 
+void FPointArray::map(QMatrix m)
+{
+       map(QTransform(m));
+}
+
 void FPointArray::setMarker()
 {
 	addQuadPoint(999999.0, 999999.0,
diff -Naur Scribus_1.5_120815/scribus/fpointarray.h Scribus_1.5_indic/scribus/fpointarray.h
--- Scribus_1.5_120815/scribus/fpointarray.h	2012-08-15 11:02:06.336825661 +0530
+++ Scribus_1.5_indic/scribus/fpointarray.h	2012-08-15 12:05:19.290931445 +0530
@@ -25,6 +25,7 @@
 #define FPOINTARRAY_H
 
 #include <QTransform>
+#include <QMatrix>
 #include <QPainterPath>
 #include <QPoint>
 #include <QPointF>
@@ -61,6 +62,7 @@
 	void scale( double sx, double sy );
 	FPoint WidthHeight() const;
 	void map(QTransform m);
+	void map(QMatrix m);
 	FPointArray &operator=( const FPointArray &a );
 	FPointArray copy() const;
 	void setMarker();
diff -Naur Scribus_1.5_120815/scribus/langmgr.cpp Scribus_1.5_indic/scribus/langmgr.cpp
--- Scribus_1.5_120815/scribus/langmgr.cpp	2012-08-15 11:02:06.639825670 +0530
+++ Scribus_1.5_indic/scribus/langmgr.cpp	2012-08-15 12:07:44.044935495 +0530
@@ -20,7 +20,7 @@
  ***************************************************************************/
  
 #include <iostream>
-#include <QDebug>
+
 #include <QDir>
 #include <QFileInfo>
 #include <QMap>
@@ -56,64 +56,55 @@
 	// TODO get rid of the redundant key, the english name.
 	// So internally language would always be manipulated as a code and otherwise presented translated.
 	langList.insert("af",       langPair("Afrikaans",           QObject::tr( "Afrikaans" )) );
-	langList.insert("af_ZA",    langPair("Afrikaans",           QObject::tr( "Afrikaans" )) );
-	langList.insert("an_ES",    langPair("Aragonese",           QObject::tr( "Aragonese" )) );
 	langList.insert("ar",       langPair("Arabic",              QObject::tr( "Arabic" )) );
-	langList.insert("be_BY",    langPair("Belarusian",          QObject::tr( "Belarusian" )) );
-	langList.insert("bg",       langPair("Bulgarian",           QObject::tr( "Bulgarian" )) );
-	langList.insert("bg_BG",    langPair("Bulgarian",           QObject::tr( "Bulgarian" )) );
+	langList.insert("sq",       langPair("Albanian",            QObject::tr( "Albanian" )) );
+	langList.insert("eu",       langPair("Basque",              QObject::tr( "Basque" )) );
 	langList.insert("bn",       langPair("Bengali",             QObject::tr( "Bengali" )) );
 	langList.insert("br",       langPair("Breton",              QObject::tr( "Breton" )) );
+	langList.insert("bg",       langPair("Bulgarian",           QObject::tr( "Bulgarian" )) );
 	langList.insert("ca",       langPair("Catalan",             QObject::tr( "Catalan" )) );
+	langList.insert("zh",       langPair("Chinese",             QObject::tr( "Chinese" )) );
+	langList.insert("zh_TW",    langPair("Chinese (Trad.)",     QObject::tr( "Chinese (Trad.)" )) );
+	langList.insert("hr",       langPair("Croatian",            QObject::tr( "Croatian" )) );
 	langList.insert("cs",       langPair("Czech",               QObject::tr( "Czech" )) );
 	langList.insert("cs_CZ",    langPair("Czech",               QObject::tr( "Czech" )) );
-	langList.insert("cy",       langPair("Welsh",               QObject::tr( "Welsh" )) );
 	langList.insert("da",       langPair("Danish",              QObject::tr( "Danish" )) );
 	langList.insert("da_DK",    langPair("Danish",              QObject::tr( "Danish" )) );
-	langList.insert("de",       langPair("German",              QObject::tr( "German" )) );
-	langList.insert("de_1901",  langPair("German (Trad.)",      QObject::tr( "German (Trad.)" )) );
-	langList.insert("de_CH",    langPair("German (Swiss)",      QObject::tr( "German (Swiss)" )) );
-	langList.insert("de_DE",    langPair("German",              QObject::tr( "German" )) );
 	langList.insert("dz",       langPair("Dzongkha",            QObject::tr( "Dzongkha" )) );
-	langList.insert("el",       langPair("Greek",               QObject::tr( "Greek" )) );
+	langList.insert("nl",       langPair("Dutch",               QObject::tr( "Dutch" )) );
 	langList.insert("en",       langPair("English",             QObject::tr( "English" )) );
-	langList.insert("en_AU",    langPair("English (Australia)", QObject::tr( "English (Australia)" )) );
-	langList.insert("en_CA",    langPair("English (Canada)",    QObject::tr( "English (Canada)" )) );
-	langList.insert("en_GB",    langPair("English (UK)",        QObject::tr( "English (UK)" )) );
-	langList.insert("en_NZ",    langPair("English (New Zealand)", QObject::tr( "English (New Zealand)" )) );
-	langList.insert("en_US",    langPair("English (USA)",       QObject::tr( "English (USA)" )) );
-	langList.insert("en_ZA",    langPair("English (South Africa)", QObject::tr( "English (South Africa)" )) );
+	langList.insert("en_AU",    langPair("English (Australian)",QObject::tr( "English (Australian)" )) );
+	langList.insert("en_GB",    langPair("English (British)",   QObject::tr( "English (British)" )) );
+	langList.insert("en_US",    langPair("English (American)",  QObject::tr( "English (American)" )) );
 	langList.insert("eo",       langPair("Esperanto",           QObject::tr( "Esperanto" )) );
-	langList.insert("es",       langPair("Spanish",             QObject::tr( "Spanish" )) );
-	langList.insert("es_AR",    langPair("Spanish (Argentina)", QObject::tr( "Spanish (Argentina)" )) );
-	langList.insert("es_ES",    langPair("Spanish",             QObject::tr( "Spanish" )) );
-	langList.insert("es_LA",    langPair("Spanish (Latin)",     QObject::tr( "Spanish (Latin)" )) );
 	langList.insert("et",       langPair("Estonian",            QObject::tr( "Estonian" )) );
-	langList.insert("eu",       langPair("Basque",              QObject::tr( "Basque" )) );
+	langList.insert("de",       langPair("German",              QObject::tr( "German" )) );
+	langList.insert("de_CH",    langPair("German (Swiss)",      QObject::tr( "German (Swiss)" )) );
+	langList.insert("de_1901",  langPair("German (Trad.)",      QObject::tr( "German (Trad.)" )) );
 	langList.insert("fi",       langPair("Finnish",             QObject::tr( "Finnish" )) );
 	langList.insert("fr",       langPair("French",              QObject::tr( "French" )) );
 	langList.insert("fr_FR",    langPair("French",              QObject::tr( "French" )) );
 	langList.insert("gl",       langPair("Galician",            QObject::tr( "Galician" )) );
+	langList.insert("el",       langPair("Greek",               QObject::tr( "Greek" )) );
 	langList.insert("he",       langPair("Hebrew",              QObject::tr( "Hebrew" )) );
-	langList.insert("hr",       langPair("Croatian",            QObject::tr( "Croatian" )) );
+	langList.insert("hi",       langPair("Hindi",              QObject::tr( "Hindi" )) );
 	langList.insert("hu",       langPair("Hungarian",           QObject::tr( "Hungarian" )) );
 	langList.insert("ia",       langPair("Latin",               QObject::tr( "Latin" )) );
-	langList.insert("id",       langPair("Indonesian",          QObject::tr( "Indonesian" )) );
 	langList.insert("is",       langPair("Icelandic",           QObject::tr( "Icelandic" )) );
+	langList.insert("id",       langPair("Indonesian",          QObject::tr( "Indonesian" )) );
 	langList.insert("it",       langPair("Italian",             QObject::tr( "Italian" )) );
-	langList.insert("it_IT",    langPair("Italian",             QObject::tr( "Italian" )) );
 	langList.insert("ja",       langPair("Japanese",            QObject::tr( "Japanese" )) );
 	langList.insert("km",       langPair("Khmer",               QObject::tr( "Khmer" )) );
 	langList.insert("ko",       langPair("Korean",              QObject::tr( "Korean" )) );
 	langList.insert("ku",       langPair("Kurdish",             QObject::tr( "Kurdish" )) );
-	langList.insert("la",       langPair("Latin",               QObject::tr( "Latin" )) );
-	langList.insert("lb",       langPair("Luxembourgish",       QObject::tr( "Luxembourgish" )) );
 	langList.insert("lo",       langPair("Lao",                 QObject::tr( "Lao" )) );
+	langList.insert("la",       langPair("Latin",               QObject::tr( "Latin" )) );
 	langList.insert("lt",       langPair("Lithuanian",          QObject::tr( "Lithuanian" )) );
 	langList.insert("lt_LT",    langPair("Lithuanian",          QObject::tr( "Lithuanian" )) );
+	langList.insert("lu",       langPair("Luxembourgish",       QObject::tr( "Luxembourgish" )) );
+	//We might need &#00E5; for this accented a
 	langList.insert("nb",       langPair("Norwegian (Bokml)",  QObject::trUtf8( "Norwegian (Bokm\303\245l)" )) );
 	langList.insert("nb_NO",    langPair("Norwegian (Bokml)",  QObject::trUtf8( "Norwegian (Bokm\303\245l)" )) );
-	langList.insert("nl",       langPair("Dutch",               QObject::tr( "Dutch" )) );
 	langList.insert("nn",       langPair("Norwegian (Nnyorsk)", QObject::tr( "Norwegian (Nnyorsk)" )) );
 	langList.insert("nn_NO",    langPair("Norwegian (Nnyorsk)", QObject::tr( "Norwegian (Nnyorsk)" )) );
 	langList.insert("no",       langPair("Norwegian",           QObject::tr( "Norwegian" )) );
@@ -125,10 +116,12 @@
 	langList.insert("ro",       langPair("Romanian",            QObject::tr( "Romanian" )) );
 	langList.insert("ru",       langPair("Russian",             QObject::tr( "Russian" )) );
 	langList.insert("sa",       langPair("Sanskrit",            QObject::tr( "Sanskrit" )) );
+	langList.insert("es",       langPair("Spanish",             QObject::tr( "Spanish" )) );
+	langList.insert("es_ES",    langPair("Spanish",             QObject::tr( "Spanish" )) );
+	langList.insert("es_LA",    langPair("Spanish (Latin)",     QObject::tr( "Spanish (Latin)" )) );
 	langList.insert("sk",       langPair("Slovak",              QObject::tr( "Slovak" )) );
 	langList.insert("sk_SK",    langPair("Slovak",              QObject::tr( "Slovak" )) );
 	langList.insert("sl",       langPair("Slovenian",           QObject::tr( "Slovenian" )) );
-	langList.insert("sq",       langPair("Albanian",            QObject::tr( "Albanian" )) );
 	langList.insert("sr",       langPair("Serbian",             QObject::tr( "Serbian" )) );
 	langList.insert("sv",       langPair("Swedish",             QObject::tr( "Swedish" )) );
 	langList.insert("th",       langPair("Thai",                QObject::tr( "Thai" )) );
@@ -136,10 +129,214 @@
 	langList.insert("tr",       langPair("Turkish",             QObject::tr( "Turkish" )) );
 	langList.insert("tr_TR",    langPair("Turkish",             QObject::tr( "Turkish" )) );
 	langList.insert("uk",       langPair("Ukranian",            QObject::tr( "Ukranian" )) );
-	langList.insert("uk_UA",    langPair("Ukranian",            QObject::tr( "Ukranian" )) );
 	langList.insert("vi",       langPair("Vietnamese",          QObject::tr( "Vietnamese" )) );
-	langList.insert("zh",       langPair("Chinese",             QObject::tr( "Chinese" )) );
-	langList.insert("zh_TW",    langPair("Chinese (Trad.)",     QObject::tr( "Chinese (Trad.)" )) );
+	langList.insert("cy",       langPair("Welsh",               QObject::tr( "Welsh" )) );
+
+
+	isoLang.insert(QString("aa"), QString("aar"));
+	isoLang.insert(QString("ab"), QString("abk"));
+	isoLang.insert(QString("af"), QString("afr"));
+	isoLang.insert(QString("ak"), QString("aka"));
+	isoLang.insert(QString("sq"), QString("alb"));
+	isoLang.insert(QString("am"), QString("amh"));
+	isoLang.insert(QString("ar"), QString("ara"));
+	isoLang.insert(QString("an"), QString("arg"));
+	isoLang.insert(QString("hy"), QString("arm"));
+	isoLang.insert(QString("as"), QString("asm"));
+	isoLang.insert(QString("av"), QString("ava"));
+	isoLang.insert(QString("ae"), QString("ave"));
+	isoLang.insert(QString("ay"), QString("aym"));
+	isoLang.insert(QString("az"), QString("aze"));
+	isoLang.insert(QString("ba"), QString("bak"));
+	isoLang.insert(QString("bm"), QString("bam"));
+	isoLang.insert(QString("eu"), QString("baq"));
+	isoLang.insert(QString("be"), QString("bel"));
+	isoLang.insert(QString("bn"), QString("ben"));
+	isoLang.insert(QString("bh"), QString("bih"));
+	isoLang.insert(QString("bi"), QString("bis"));
+	isoLang.insert(QString("bs"), QString("bos"));
+	isoLang.insert(QString("br"), QString("bre"));
+	isoLang.insert(QString("bg"), QString("bul"));
+	isoLang.insert(QString("my"), QString("bur"));
+	isoLang.insert(QString("ca"), QString("cat"));
+	isoLang.insert(QString("ch"), QString("cha"));
+	isoLang.insert(QString("ce"), QString("che"));
+	isoLang.insert(QString("zh"), QString("chi"));
+	isoLang.insert(QString("cu"), QString("chu"));
+	isoLang.insert(QString("cv"), QString("chv"));
+	isoLang.insert(QString("kw"), QString("cor"));
+	isoLang.insert(QString("co"), QString("cos"));
+	isoLang.insert(QString("cr"), QString("cre"));
+	isoLang.insert(QString("cs"), QString("cze"));
+	isoLang.insert(QString("da"), QString("dan"));
+	isoLang.insert(QString("dv"), QString("div"));
+	isoLang.insert(QString("nl"), QString("dut"));
+	isoLang.insert(QString("dz"), QString("dzo"));
+	isoLang.insert(QString("en"), QString("eng"));
+	isoLang.insert(QString("eo"), QString("epo"));
+	isoLang.insert(QString("et"), QString("est"));
+	isoLang.insert(QString("ee"), QString("ewe"));
+	isoLang.insert(QString("fo"), QString("fao"));
+	isoLang.insert(QString("fj"), QString("fij"));
+	isoLang.insert(QString("fi"), QString("fin"));
+	isoLang.insert(QString("fr"), QString("fre"));
+	isoLang.insert(QString("fy"), QString("fry"));
+	isoLang.insert(QString("ff"), QString("ful"));
+	isoLang.insert(QString("ka"), QString("geo"));
+	isoLang.insert(QString("de"), QString("ger"));
+	isoLang.insert(QString("gd"), QString("gla"));
+	isoLang.insert(QString("ga"), QString("gle"));
+	isoLang.insert(QString("gl"), QString("glg"));
+	isoLang.insert(QString("gv"), QString("glv"));
+	isoLang.insert(QString("el"), QString("gre"));
+	isoLang.insert(QString("gn"), QString("grn"));
+	isoLang.insert(QString("gu"), QString("guj"));
+	isoLang.insert(QString("ht"), QString("hat"));
+	isoLang.insert(QString("ha"), QString("hau"));
+	isoLang.insert(QString("he"), QString("heb"));
+	isoLang.insert(QString("hz"), QString("her"));
+	isoLang.insert(QString("hi"), QString("hin"));
+	isoLang.insert(QString("ho"), QString("hmo"));
+	isoLang.insert(QString("hr"), QString("hrv"));
+	isoLang.insert(QString("hu"), QString("hun"));
+	isoLang.insert(QString("ig"), QString("ibo"));
+	isoLang.insert(QString("is"), QString("ice"));
+	isoLang.insert(QString("io"), QString("ido"));
+	isoLang.insert(QString("ii"), QString("iii"));
+	isoLang.insert(QString("iu"), QString("iku"));
+	isoLang.insert(QString("ie"), QString("ile"));
+	isoLang.insert(QString("ia"), QString("ina"));
+	isoLang.insert(QString("id"), QString("ind"));
+	isoLang.insert(QString("ik"), QString("ipk"));
+	isoLang.insert(QString("it"), QString("ita"));
+	isoLang.insert(QString("jv"), QString("jav"));
+	isoLang.insert(QString("ja"), QString("jpn"));
+	isoLang.insert(QString("kl"), QString("kal"));
+	isoLang.insert(QString("kn"), QString("kan"));
+	isoLang.insert(QString("ks"), QString("kas"));
+	isoLang.insert(QString("kr"), QString("kau"));
+	isoLang.insert(QString("kk"), QString("kaz"));
+	isoLang.insert(QString("km"), QString("khm"));
+	isoLang.insert(QString("ki"), QString("kik"));
+	isoLang.insert(QString("rw"), QString("kin"));
+	isoLang.insert(QString("ky"), QString("kir"));
+	isoLang.insert(QString("kv"), QString("kom"));
+	isoLang.insert(QString("kg"), QString("kon"));
+	isoLang.insert(QString("ko"), QString("kor"));
+	isoLang.insert(QString("kj"), QString("kua"));
+	isoLang.insert(QString("ku"), QString("kur"));
+	isoLang.insert(QString("lo"), QString("lao"));
+	isoLang.insert(QString("la"), QString("lat"));
+	isoLang.insert(QString("lv"), QString("lav"));
+	isoLang.insert(QString("li"), QString("lim"));
+	isoLang.insert(QString("ln"), QString("lin"));
+	isoLang.insert(QString("lt"), QString("lit"));
+	isoLang.insert(QString("lb"), QString("ltz"));
+	isoLang.insert(QString("lu"), QString("lub"));
+	isoLang.insert(QString("lg"), QString("lug"));
+	isoLang.insert(QString("mk"), QString("mac"));
+	isoLang.insert(QString("mh"), QString("mah"));
+	isoLang.insert(QString("ml"), QString("mal"));
+	isoLang.insert(QString("mi"), QString("mao"));
+	isoLang.insert(QString("mr"), QString("mar"));
+	isoLang.insert(QString("ms"), QString("may"));
+	isoLang.insert(QString("mg"), QString("mlg"));
+	isoLang.insert(QString("mt"), QString("mlt"));
+	isoLang.insert(QString("mn"), QString("mon"));
+	isoLang.insert(QString("na"), QString("nau"));
+	isoLang.insert(QString("nv"), QString("nav"));
+	isoLang.insert(QString("nr"), QString("nbl"));
+	isoLang.insert(QString("nd"), QString("nde"));
+	isoLang.insert(QString("ng"), QString("ndo"));
+	isoLang.insert(QString("ne"), QString("nep"));
+	isoLang.insert(QString("nn"), QString("nno"));
+	isoLang.insert(QString("nb"), QString("nob"));
+	isoLang.insert(QString("no"), QString("nor"));
+	isoLang.insert(QString("ny"), QString("nya"));
+	isoLang.insert(QString("oc"), QString("oci"));
+	isoLang.insert(QString("oj"), QString("oji"));
+	isoLang.insert(QString("or"), QString("ori"));
+	isoLang.insert(QString("om"), QString("orm"));
+	isoLang.insert(QString("os"), QString("oss"));
+	isoLang.insert(QString("pa"), QString("pan"));
+	isoLang.insert(QString("fa"), QString("per"));
+	isoLang.insert(QString("pi"), QString("pli"));
+	isoLang.insert(QString("pl"), QString("pol"));
+	isoLang.insert(QString("pt"), QString("por"));
+	isoLang.insert(QString("ps"), QString("pus"));
+	isoLang.insert(QString("qu"), QString("que"));
+	isoLang.insert(QString("rm"), QString("roh"));
+	isoLang.insert(QString("ro"), QString("rum"));
+	isoLang.insert(QString("rn"), QString("run"));
+	isoLang.insert(QString("ru"), QString("rus"));
+	isoLang.insert(QString("sg"), QString("sag"));
+	isoLang.insert(QString("sa"), QString("san"));
+	isoLang.insert(QString("si"), QString("sin"));
+	isoLang.insert(QString("sk"), QString("slo"));
+	isoLang.insert(QString("sl"), QString("slv"));
+	isoLang.insert(QString("se"), QString("sme"));
+	isoLang.insert(QString("sm"), QString("smo"));
+	isoLang.insert(QString("sn"), QString("sna"));
+	isoLang.insert(QString("sd"), QString("snd"));
+	isoLang.insert(QString("so"), QString("som"));
+	isoLang.insert(QString("st"), QString("sot"));
+	isoLang.insert(QString("es"), QString("spa"));
+	isoLang.insert(QString("sc"), QString("srd"));
+	isoLang.insert(QString("sr"), QString("srp"));
+	isoLang.insert(QString("ss"), QString("ssw"));
+	isoLang.insert(QString("su"), QString("sun"));
+	isoLang.insert(QString("sw"), QString("swa"));
+	isoLang.insert(QString("sv"), QString("swe"));
+	isoLang.insert(QString("ty"), QString("tah"));
+	isoLang.insert(QString("ta"), QString("tam"));
+	isoLang.insert(QString("tt"), QString("tat"));
+	isoLang.insert(QString("te"), QString("tel"));
+	isoLang.insert(QString("tg"), QString("tgk"));
+	isoLang.insert(QString("tl"), QString("tgl"));
+	isoLang.insert(QString("th"), QString("tha"));
+	isoLang.insert(QString("bo"), QString("tib"));
+	isoLang.insert(QString("ti"), QString("tir"));
+	isoLang.insert(QString("to"), QString("ton"));
+	isoLang.insert(QString("tn"), QString("tsn"));
+	isoLang.insert(QString("ts"), QString("tso"));
+	isoLang.insert(QString("tk"), QString("tuk"));
+	isoLang.insert(QString("tr"), QString("tur"));
+	isoLang.insert(QString("tw"), QString("twi"));
+	isoLang.insert(QString("ug"), QString("uig"));
+	isoLang.insert(QString("uk"), QString("ukr"));
+	isoLang.insert(QString("ur"), QString("urd"));
+	isoLang.insert(QString("uz"), QString("uzb"));
+	isoLang.insert(QString("ve"), QString("ven"));
+	isoLang.insert(QString("vi"), QString("vie"));
+	isoLang.insert(QString("vo"), QString("vol"));
+	isoLang.insert(QString("cy"), QString("wel"));
+	isoLang.insert(QString("wa"), QString("wln"));
+	isoLang.insert(QString("wo"), QString("wol"));
+	isoLang.insert(QString("xh"), QString("xho"));
+	isoLang.insert(QString("yi"), QString("yid"));
+	isoLang.insert(QString("yo"), QString("yor"));
+	isoLang.insert(QString("za"), QString("zha"));
+	isoLang.insert(QString("zu"), QString("zul"));
+
+	// Following lists and maps are somehow reversed (if possible), meaning that  we list only what deviates from default (lazyness inside?)
+
+	// default is LTR
+	RTLLang << QString("ar");
+	RTLLang << QString("he");
+
+	// http://www.microsoft.com/typography/otspec/scripttags.htm
+	// default is "latn"
+	scriptTag.insert(QString("ar"), QString("arab"));
+	scriptTag.insert(QString("hi"), QString("deva"));
+	// TODO_OIF ...continue
+
+	// http://www.microsoft.com/typography/otspec/languagetags.htm
+	// default is "DFLT"
+	// note that a tag _MUST_ be 4 chars long (padded with space)
+	langTag.insert(QString("ar"), QString("ARA "));
+	langTag.insert(QString("hi"), QString("HIN "));
+	// TODO_OIF ...continue
+
 
 }
 
@@ -164,6 +361,25 @@
 	}
 }
 
+const QStringList LanguageManager::getAllLangs(bool getTranslated)
+{
+	QStringList ret;
+	foreach(const langPair& lp, langList)
+	{
+		if(getTranslated)
+		{
+			if(!ret.contains(lp.second))
+				ret << lp.second;
+		}
+		else
+		{
+			if(!ret.contains(lp.first))
+				ret << lp.first;
+		}
+	}
+	return ret;
+}
+
 const QString LanguageManager::getLangFromAbbrev(QString langAbbrev, bool getTranslated)
 {
 	QMap<QString, langPair>::Iterator it;
@@ -239,6 +455,13 @@
 	return "";
 }
 
+const QString LanguageManager::getIsoLangFromAbbr(QString abbr)
+{
+	if(isoLang.contains(abbr))
+		return isoLang.value(abbr);
+	return QString();
+}
+
 void LanguageManager::fillInstalledStringList(QStringList *stringListToFill, bool addDefaults) 
 {
 	if (stringListToFill)
@@ -344,6 +567,11 @@
 	}
 }
 
+bool LanguageManager::isRightToLeft(const QString &langAbbr)
+{
+	return RTLLang.contains(langAbbr);
+}
+
 LanguageManager::~LanguageManager()
 {
 	langList.clear();
@@ -369,6 +597,18 @@
 }
 
 
+const QString LanguageManager::getScriptTag(const QString &abbr)
+{
+	if(scriptTag.contains(abbr))
+		return scriptTag.value(abbr);
+	return QString("latn");
+}
 
+const QString LanguageManager::getLangTag(const QString &abbr)
+{
+	if(langTag.contains(abbr))
+		return langTag.value(abbr);
+	return QString("DFLT");
+}
 
 
diff -Naur Scribus_1.5_120815/scribus/langmgr.h Scribus_1.5_indic/scribus/langmgr.h
--- Scribus_1.5_120815/scribus/langmgr.h	2012-08-15 11:02:06.391825663 +0530
+++ Scribus_1.5_indic/scribus/langmgr.h	2012-08-15 12:08:18.576936458 +0530
@@ -36,22 +36,28 @@
 class SCRIBUS_API LanguageManager
 {
 	static LanguageManager* m_instance;
-	LanguageManager() {};
+	LanguageManager(){}
 	~LanguageManager();
 	void init(bool generateInstalledList = true);
 	
 public:
 	static LanguageManager* instance();
-	
+
+	const QStringList getAllLangs(bool getTranslated=true);
 	const QString getLangFromAbbrev(QString, bool getTranslated=true);
 	const QString getAbbrevFromLang(QString, bool getFromTranslated=true, bool useInstalled=true);
 	const QString getLangFromTransLang(QString lang);
 	const QString getTransLangFromLang(QString lang);
+	const QString getIsoLangFromAbbr(QString abbr);
 	void fillInstalledStringList(QStringList *stringListToFill, bool addDefaults);
 	void printInstalledList();
 	QString numericSequence(QString seq);
 	bool findDictionaries(QStringList& sl);
 	void findDictionarySets(QStringList& dictionaryPaths, QMap<QString, QString>& dictionaryMap);
+	bool isRightToLeft(const QString& langAbbr);
+	const QString getScriptTag(const QString& abbr);
+	const QString getLangTag(const QString& abbr);
+
 	
 	void addHyphLang(const QString& lang, const QString& filename);
 	const QString getHyphFilename(const QString& lang, bool langIsAbbreviated = true);
@@ -61,6 +67,10 @@
 	QMap<QString, langPair > langList;
 	QMap<QString, QString> installedLangList;
 	QMap<QString, QString> hyphLangList; // <lang abbreviated, dict filename>
+	QMap<QString, QString> isoLang; // <lang abbreviated, iso639-2 abbreviation>
+	QStringList RTLLang;
+	QMap<QString, QString> scriptTag; // <lang abbreviated, script tag>
+	QMap<QString, QString> langTag; // <lang abbreviated, lang tag>
 
 	void generateLangList();
 	void generateInstalledLangList();
diff -Naur Scribus_1.5_120815/scribus/pageitem.cpp Scribus_1.5_indic/scribus/pageitem.cpp
--- Scribus_1.5_120815/scribus/pageitem.cpp	2012-08-15 11:02:06.584825668 +0530
+++ Scribus_1.5_indic/scribus/pageitem.cpp	2012-08-15 13:30:50.139074501 +0530
@@ -10,6 +10,9 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
  ***************************************************************************/
 
 /***************************************************************************
@@ -2320,7 +2323,7 @@
 	}
 	else */
 	{
-		layout.glyph = font.char2CMap(chars[0].unicode());
+		//layout.glyph = font.char2CMap(chars[0].unicode());
 	}
 	double tracking = 0.0;
 	if ( (style.effects() & ScStyle_StartOfLine) == 0)
@@ -2349,7 +2352,7 @@
 		layout.scaleV *= style.scaleV() / 1000.0;
 		if (chst & ScStyle_AllCaps)
 		{
-			layout.glyph = font.char2CMap(chars[0].toUpper().unicode());
+			//layout.glyph = font.char2CMap(chars[0].toUpper().unicode());
 		}
 		if (chst & ScStyle_SmallCaps)
 		{
@@ -2390,8 +2393,9 @@
 	if (layout.xadvance > 0)
 		layout.xadvance += tracking;
 
-	if (chars.length() > 1) {
-		layout.grow();
+	//if (chars.length() > 1) {
+	if (layout.more) {
+		//layout.grow();
 		layoutGlyphs(style, chars.mid(1), *layout.more);
 		layout.xadvance += font.glyphKerning(layout.glyph, layout.more->glyph, style.fontSize() / 10) * layout.scaleH;
 		if (layout.more->yadvance > layout.yadvance)
diff -Naur Scribus_1.5_120815/scribus/pageitem_pathtext.cpp Scribus_1.5_indic/scribus/pageitem_pathtext.cpp
--- Scribus_1.5_120815/scribus/pageitem_pathtext.cpp	2012-08-15 11:02:06.457825665 +0530
+++ Scribus_1.5_indic/scribus/pageitem_pathtext.cpp	2012-08-15 13:46:11.969100284 +0530
@@ -10,6 +10,9 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
  ***************************************************************************/
 
 /***************************************************************************
@@ -179,6 +182,7 @@
 	for (a = firstChar; a < itemText.length(); ++a)
 	{
 		hl = itemText.item(a);
+		if (hl->gIdx < 0) continue ;
 		CharStyle nstyle = itemText.charStyle(a);
 		ParagraphStyle pstyle = itemText.paragraphStyle(a);
 		chstr = hl->ch;
@@ -207,6 +211,7 @@
 	{
 		hl = itemRenderText.item(a);
 		chstr = hl->ch;
+		if (hl->gIdx < 0) continue ;
 		if (chstr[0] == SpecialChars::PAGENUMBER || chstr[0] == SpecialChars::PARSEP || chstr[0] == SpecialChars::PAGECOUNT
 			|| chstr[0] == SpecialChars::TAB || chstr[0] == SpecialChars::LINEBREAK)
 			continue;
@@ -260,6 +265,7 @@
 	{
 		CurY = 0;
 		hl = itemRenderText.item(a);
+		if (hl->gIdx < 0) continue ;
 		chstr = hl->ch;
 		if (chstr[0] == SpecialChars::PAGENUMBER || chstr[0] == SpecialChars::PARSEP || chstr[0] == SpecialChars::PAGECOUNT
 			|| chstr[0] == SpecialChars::TAB || chstr[0] == SpecialChars::LINEBREAK)
diff -Naur Scribus_1.5_120815/scribus/pageitem_textframe.cpp Scribus_1.5_indic/scribus/pageitem_textframe.cpp
--- Scribus_1.5_120815/scribus/pageitem_textframe.cpp	2012-08-15 11:02:06.602825668 +0530
+++ Scribus_1.5_indic/scribus/pageitem_textframe.cpp	2012-08-15 14:58:19.302220987 +0530
@@ -10,6 +10,10 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
+
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
  ***************************************************************************/
 
 /***************************************************************************
@@ -45,6 +49,7 @@
 #include "scraction.h"
 #include "scribus.h"
 #include "scribusdoc.h"
+#include "text/shaper.h"
 #include "scribusstructs.h"
 #include "selection.h"
 #include "text/nlsconfig.h"
@@ -1298,6 +1303,7 @@
 {
 // 	qDebug()<<"==Layout==" << itemName() ;
 // 	printBacktrace(24);
+        Shaper *shaper = new Shaper( &itemText);
 	if (BackBox != NULL && BackBox->invalid) {
 //		qDebug("textframe: len=%d, going back", itemText.length());
 		// Why that invalid = false here? Calling prevInChain->layout() does
@@ -1421,6 +1427,7 @@
 
 		//automatic line spacing factor (calculated once)
 		double autoLS = static_cast<double>(m_Doc->typographicPrefs().autoLineSpacing) / 100.0;
+		shaper->shape(firstInFrame(), itemText.length() - 1 ) ;
 
 		// find start of first line
 		if (firstInFrame() < itemText.length())
@@ -1470,6 +1477,7 @@
 		for (int a = firstInFrame(); a < itemText.length(); ++a)
 		{
 			hl = itemText.item(a);
+			if (hl->gIdx < 0) continue ;
 			curStat = SpecialChars::getCJKAttr(hl->ch);
 			if (a > 0 && itemText.text(a-1) == SpecialChars::PARSEP)
 				style = itemText.paragraphStyle(a);
@@ -1653,9 +1661,9 @@
 			{
 				wide = hl->glyph.wide();
 				// apply kerning
-				if (a+1 < itemText.length())
+				if (a+1 < itemText.nOfGlyphs)
 				{
-					uint glyph2 = font.char2CMap(itemText.text(a+1));
+					uint glyph2 = itemText.item(a+1)->glyph.glyph;
 					double kern= font.glyphKerning(hl->glyph.glyph, glyph2, chs / 10.0) * hl->glyph.scaleH;
 					wide += kern;
 					hl->glyph.xadvance += kern;
@@ -2123,7 +2131,7 @@
 							if (tglyph)
 							{
 								tglyph->fillChar = tabs.fillChar;
-								tglyph->glyph    = font.char2CMap(tabs.fillChar);
+								//tglyph->glyph    = font.char2CMap(tabs.fillChar);
 								tglyph->yoffset  = hl->glyph.yoffset;
 								tglyph->scaleV   = tglyph->scaleH = chs / charStyle.fontSize();
 								tglyph->xadvance = 0;
@@ -2822,6 +2830,7 @@
 		nextFrame->firstChar = MaxChars;
 		nextFrame = dynamic_cast<PageItem_TextFrame*>(nextFrame->NextBox);
 	}
+	delete shaper;
 //	qDebug("textframe: len=%d, done relayout", itemText.length());
 	return;
 			
diff -Naur Scribus_1.5_120815/scribus/plugins/import/CMakeLists.txt Scribus_1.5_indic/scribus/plugins/import/CMakeLists.txt
--- Scribus_1.5_120815/scribus/plugins/import/CMakeLists.txt	2012-08-15 11:02:05.580825640 +0530
+++ Scribus_1.5_indic/scribus/plugins/import/CMakeLists.txt	2012-08-15 12:43:31.655995157 +0530
@@ -7,7 +7,6 @@
 ADD_SUBDIRECTORY(pct)
 IF(HAVE_POPPLER)
 	ADD_SUBDIRECTORY(pdf)
-ELSE(HAVE_POPPLER)
 	ADD_SUBDIRECTORY(ps)
 ENDIF(HAVE_POPPLER)
 ADD_SUBDIRECTORY(shape)
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/CMakeLists.txt Scribus_1.5_indic/scribus/plugins/tools/CMakeLists.txt
--- Scribus_1.5_120815/scribus/plugins/tools/CMakeLists.txt	2012-08-15 11:02:04.064825593 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/CMakeLists.txt	2012-08-15 12:44:59.941997777 +0530
@@ -9,6 +9,7 @@
 ADD_SUBDIRECTORY(pathstroker)
 ADD_SUBDIRECTORY(subdivide)
 ADD_SUBDIRECTORY(flattenpath)
+ADD_SUBDIRECTORY(transform)
 ADD_SUBDIRECTORY(smoothpath)
 if (HAVE_ASPELL)
   ADD_SUBDIRECTORY(spellcheck)
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/moc_transformdialog.cxx Scribus_1.5_indic/scribus/plugins/tools/transform/moc_transformdialog.cxx
--- Scribus_1.5_120815/scribus/plugins/tools/transform/moc_transformdialog.cxx	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/moc_transformdialog.cxx	2012-08-15 13:15:55.688049624 +0530
@@ -0,0 +1,136 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'transformdialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 63 (Qt 4.8.2)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "transformdialog.h"
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'transformdialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 63
+#error "This file was generated using the moc from 4.8.2. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+static const uint qt_meta_data_TransformDialog[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+      17,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      17,   16,   16,   16, 0x08,
+      30,   16,   16,   16, 0x08,
+      47,   16,   16,   16, 0x08,
+      61,   16,   16,   16, 0x08,
+      79,   74,   16,   16, 0x08,
+     121,  117,   16,   16, 0x08,
+     142,  117,   16,   16, 0x08,
+     163,   16,   16,   16, 0x08,
+     176,  117,   16,   16, 0x08,
+     203,  117,   16,   16, 0x08,
+     230,  117,   16,   16, 0x08,
+     253,  117,   16,   16, 0x08,
+     273,  117,   16,   16, 0x08,
+     293,   16,   16,   16, 0x08,
+     310,   16,   16,   16, 0x08,
+     328,   16,   16,   16, 0x08,
+     348,   16,   16,   16, 0x08,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_TransformDialog[] = {
+    "TransformDialog\0\0newScaling()\0"
+    "newTranslation()\0newRotation()\0"
+    "newSkewing()\0item\0"
+    "setCurrentTransform(QListWidgetItem*)\0"
+    "val\0changeHScale(double)\0changeVScale(double)\0"
+    "toggleLink()\0changeHTranslation(double)\0"
+    "changeVTranslation(double)\0"
+    "changeRotation(double)\0changeHSkew(double)\0"
+    "changeVSkew(double)\0toggleLinkSkew()\0"
+    "moveTransformUp()\0moveTransformDown()\0"
+    "removeTransform()\0"
+};
+
+void TransformDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        TransformDialog *_t = static_cast<TransformDialog *>(_o);
+        switch (_id) {
+        case 0: _t->newScaling(); break;
+        case 1: _t->newTranslation(); break;
+        case 2: _t->newRotation(); break;
+        case 3: _t->newSkewing(); break;
+        case 4: _t->setCurrentTransform((*reinterpret_cast< QListWidgetItem*(*)>(_a[1]))); break;
+        case 5: _t->changeHScale((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 6: _t->changeVScale((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 7: _t->toggleLink(); break;
+        case 8: _t->changeHTranslation((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 9: _t->changeVTranslation((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 10: _t->changeRotation((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 11: _t->changeHSkew((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 12: _t->changeVSkew((*reinterpret_cast< double(*)>(_a[1]))); break;
+        case 13: _t->toggleLinkSkew(); break;
+        case 14: _t->moveTransformUp(); break;
+        case 15: _t->moveTransformDown(); break;
+        case 16: _t->removeTransform(); break;
+        default: ;
+        }
+    }
+}
+
+const QMetaObjectExtraData TransformDialog::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject TransformDialog::staticMetaObject = {
+    { &QDialog::staticMetaObject, qt_meta_stringdata_TransformDialog,
+      qt_meta_data_TransformDialog, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &TransformDialog::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *TransformDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *TransformDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_TransformDialog))
+        return static_cast<void*>(const_cast< TransformDialog*>(this));
+    if (!strcmp(_clname, "Ui::TransformDialogBase"))
+        return static_cast< Ui::TransformDialogBase*>(const_cast< TransformDialog*>(this));
+    return QDialog::qt_metacast(_clname);
+}
+
+int TransformDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 17)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 17;
+    }
+    return _id;
+}
+QT_END_MOC_NAMESPACE
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/moc_transformeffect.cxx Scribus_1.5_indic/scribus/plugins/tools/transform/moc_transformeffect.cxx
--- Scribus_1.5_120815/scribus/plugins/tools/transform/moc_transformeffect.cxx	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/moc_transformeffect.cxx	2012-08-15 13:15:55.688049624 +0530
@@ -0,0 +1,80 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'transformeffect.h'
+**
+** Created by: The Qt Meta Object Compiler version 63 (Qt 4.8.2)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "transformeffect.h"
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'transformeffect.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 63
+#error "This file was generated using the moc from 4.8.2. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+static const uint qt_meta_data_TransformEffectPlugin[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_TransformEffectPlugin[] = {
+    "TransformEffectPlugin\0"
+};
+
+void TransformEffectPlugin::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData TransformEffectPlugin::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject TransformEffectPlugin::staticMetaObject = {
+    { &ScActionPlugin::staticMetaObject, qt_meta_stringdata_TransformEffectPlugin,
+      qt_meta_data_TransformEffectPlugin, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &TransformEffectPlugin::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *TransformEffectPlugin::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *TransformEffectPlugin::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_TransformEffectPlugin))
+        return static_cast<void*>(const_cast< TransformEffectPlugin*>(this));
+    return ScActionPlugin::qt_metacast(_clname);
+}
+
+int TransformEffectPlugin::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = ScActionPlugin::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    return _id;
+}
+QT_END_MOC_NAMESPACE
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialogbase.ui Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialogbase.ui
--- Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialogbase.ui	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialogbase.ui	2012-08-15 14:29:23.674172574 +0530
@@ -0,0 +1,548 @@
+<ui version="4.0" >
+ <class>TransformDialogBase</class>
+ <widget class="QDialog" name="TransformDialogBase" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>500</width>
+    <height>283</height>
+   </rect>
+  </property>
+  <property name="minimumSize" >
+   <size>
+    <width>500</width>
+    <height>260</height>
+   </size>
+  </property>
+  <property name="windowTitle" >
+   <string>Transform</string>
+  </property>
+  <layout class="QVBoxLayout" >
+   <item>
+    <layout class="QHBoxLayout" >
+     <item>
+      <layout class="QVBoxLayout" >
+       <item>
+        <widget class="QListWidget" name="transformSelector" />
+       </item>
+       <item>
+        <layout class="QHBoxLayout" >
+         <item>
+          <widget class="QToolButton" name="buttonAdd" >
+           <property name="sizePolicy" >
+            <sizepolicy vsizetype="Fixed" hsizetype="Minimum" >
+             <horstretch>0</horstretch>
+             <verstretch>0</verstretch>
+            </sizepolicy>
+           </property>
+           <property name="text" >
+            <string>Add</string>
+           </property>
+           <property name="popupMode" >
+            <enum>QToolButton::InstantPopup</enum>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="buttonRemove" >
+           <property name="enabled" >
+            <bool>false</bool>
+           </property>
+           <property name="text" >
+            <string>Remove</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <spacer>
+           <property name="orientation" >
+            <enum>Qt::Horizontal</enum>
+           </property>
+           <property name="sizeHint" >
+            <size>
+             <width>21</width>
+             <height>26</height>
+            </size>
+           </property>
+          </spacer>
+         </item>
+         <item>
+          <widget class="QPushButton" name="buttonUp" >
+           <property name="enabled" >
+            <bool>false</bool>
+           </property>
+           <property name="text" >
+            <string>u</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="buttonDown" >
+           <property name="enabled" >
+            <bool>false</bool>
+           </property>
+           <property name="sizePolicy" >
+            <sizepolicy vsizetype="Fixed" hsizetype="Fixed" >
+             <horstretch>0</horstretch>
+             <verstretch>0</verstretch>
+            </sizepolicy>
+           </property>
+           <property name="text" >
+            <string>d</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </item>
+      </layout>
+     </item>
+     <item>
+      <layout class="QVBoxLayout" >
+       <item>
+        <widget class="QStackedWidget" name="transformStack" >
+         <property name="sizePolicy" >
+          <sizepolicy vsizetype="Preferred" hsizetype="Preferred" >
+           <horstretch>0</horstretch>
+           <verstretch>0</verstretch>
+          </sizepolicy>
+         </property>
+         <property name="minimumSize" >
+          <size>
+           <width>160</width>
+           <height>16</height>
+          </size>
+         </property>
+         <property name="frameShape" >
+          <enum>QFrame::Panel</enum>
+         </property>
+         <property name="currentIndex" >
+          <number>0</number>
+         </property>
+         <widget class="QWidget" name="blankPage" />
+         <widget class="QWidget" name="pageScale" >
+          <layout class="QGridLayout" >
+           <item row="0" column="0" colspan="3" >
+            <widget class="QLabel" name="label_3" >
+             <property name="font" >
+              <font>
+               <pointsize>11</pointsize>
+              </font>
+             </property>
+             <property name="text" >
+              <string>Scaling</string>
+             </property>
+             <property name="alignment" >
+              <set>Qt::AlignCenter</set>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="0" >
+            <widget class="QLabel" name="label" >
+             <property name="text" >
+              <string>Horizontal</string>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="1" >
+            <widget class="ScrSpinBox" name="horizontalScale" >
+             <property name="sizePolicy" >
+              <sizepolicy vsizetype="Fixed" hsizetype="Expanding" >
+               <horstretch>0</horstretch>
+               <verstretch>0</verstretch>
+              </sizepolicy>
+             </property>
+             <property name="minimumSize" >
+              <size>
+               <width>60</width>
+               <height>0</height>
+              </size>
+             </property>
+             <property name="suffix" >
+              <string> %</string>
+             </property>
+             <property name="decimals" >
+              <number>1</number>
+             </property>
+             <property name="minimum" >
+              <double>0.100000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>1000.000000000000000</double>
+             </property>
+             <property name="value" >
+              <double>100.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+           <item rowspan="2" row="1" column="2" >
+            <widget class="LinkButton" name="scaleLink" >
+             <property name="minimumSize" >
+              <size>
+               <width>15</width>
+               <height>15</height>
+              </size>
+             </property>
+             <property name="maximumSize" >
+              <size>
+               <width>15</width>
+               <height>16777215</height>
+              </size>
+             </property>
+             <property name="text" >
+              <string/>
+             </property>
+             <property name="checkable" >
+              <bool>true</bool>
+             </property>
+             <property name="autoRaise" >
+              <bool>true</bool>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="0" >
+            <widget class="QLabel" name="label_2" >
+             <property name="text" >
+              <string>Vertical</string>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="1" >
+            <widget class="ScrSpinBox" name="verticalScale" >
+             <property name="sizePolicy" >
+              <sizepolicy vsizetype="Fixed" hsizetype="MinimumExpanding" >
+               <horstretch>0</horstretch>
+               <verstretch>0</verstretch>
+              </sizepolicy>
+             </property>
+             <property name="minimumSize" >
+              <size>
+               <width>60</width>
+               <height>0</height>
+              </size>
+             </property>
+             <property name="suffix" >
+              <string> %</string>
+             </property>
+             <property name="decimals" >
+              <number>1</number>
+             </property>
+             <property name="minimum" >
+              <double>0.100000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>1000.000000000000000</double>
+             </property>
+             <property name="value" >
+              <double>100.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+         <widget class="QWidget" name="pageTranslate" >
+          <layout class="QGridLayout" >
+           <item row="0" column="0" colspan="2" >
+            <widget class="QLabel" name="label_4" >
+             <property name="font" >
+              <font>
+               <pointsize>11</pointsize>
+              </font>
+             </property>
+             <property name="text" >
+              <string>Translation</string>
+             </property>
+             <property name="alignment" >
+              <set>Qt::AlignCenter</set>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="0" >
+            <widget class="QLabel" name="label_5" >
+             <property name="text" >
+              <string>Horizontal</string>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="1" >
+            <widget class="ScrSpinBox" name="translateHorizontal" >
+             <property name="minimum" >
+              <double>-30000.000000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>30000.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="0" >
+            <widget class="QLabel" name="label_6" >
+             <property name="text" >
+              <string>Vertical</string>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="1" >
+            <widget class="ScrSpinBox" name="translateVertical" >
+             <property name="minimum" >
+              <double>-30000.000000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>30000.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+         <widget class="QWidget" name="pageRotate" >
+          <layout class="QGridLayout" >
+           <item row="0" column="0" colspan="2" >
+            <widget class="QLabel" name="label_7" >
+             <property name="font" >
+              <font>
+               <pointsize>11</pointsize>
+              </font>
+             </property>
+             <property name="text" >
+              <string>Rotate</string>
+             </property>
+             <property name="alignment" >
+              <set>Qt::AlignCenter</set>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="0" >
+            <widget class="QLabel" name="label_8" >
+             <property name="text" >
+              <string>Angle</string>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="1" >
+            <widget class="ScrSpinBox" name="rotationValue" >
+             <property name="decimals" >
+              <number>1</number>
+             </property>
+             <property name="minimum" >
+              <double>-360.000000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>360.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+         <widget class="QWidget" name="Seite" >
+          <layout class="QGridLayout" >
+           <item row="0" column="0" colspan="3" >
+            <widget class="QLabel" name="label_10" >
+             <property name="font" >
+              <font>
+               <pointsize>11</pointsize>
+              </font>
+             </property>
+             <property name="text" >
+              <string>Skew</string>
+             </property>
+             <property name="alignment" >
+              <set>Qt::AlignCenter</set>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="0" >
+            <widget class="QLabel" name="label_11" >
+             <property name="text" >
+              <string>Horizontal</string>
+             </property>
+            </widget>
+           </item>
+           <item row="1" column="1" >
+            <widget class="ScrSpinBox" name="horizontalSkew" >
+             <property name="decimals" >
+              <number>1</number>
+             </property>
+             <property name="minimum" >
+              <double>-89.000000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>89.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+           <item rowspan="2" row="1" column="2" >
+            <widget class="LinkButton" name="linkSkew" >
+             <property name="minimumSize" >
+              <size>
+               <width>15</width>
+               <height>15</height>
+              </size>
+             </property>
+             <property name="maximumSize" >
+              <size>
+               <width>15</width>
+               <height>16777215</height>
+              </size>
+             </property>
+             <property name="text" >
+              <string/>
+             </property>
+             <property name="checkable" >
+              <bool>true</bool>
+             </property>
+             <property name="autoRaise" >
+              <bool>true</bool>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="0" >
+            <widget class="QLabel" name="label_12" >
+             <property name="text" >
+              <string>Vertical</string>
+             </property>
+            </widget>
+           </item>
+           <item row="2" column="1" >
+            <widget class="ScrSpinBox" name="verticalSkew" >
+             <property name="decimals" >
+              <number>1</number>
+             </property>
+             <property name="minimum" >
+              <double>-89.000000000000000</double>
+             </property>
+             <property name="maximum" >
+              <double>89.000000000000000</double>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </widget>
+        </widget>
+       </item>
+       <item>
+        <layout class="QHBoxLayout" >
+         <item>
+          <widget class="QGroupBox" name="RotationGroup" >
+           <property name="title" >
+            <string>Origin</string>
+           </property>
+           <layout class="QVBoxLayout" >
+            <item>
+             <widget class="BasePointWidget" native="1" name="basePoint" >
+              <property name="minimumSize" >
+               <size>
+                <width>56</width>
+                <height>56</height>
+               </size>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </widget>
+         </item>
+         <item>
+          <layout class="QVBoxLayout" >
+           <item>
+            <widget class="QLabel" name="label_9" >
+             <property name="text" >
+              <string>Copies</string>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QSpinBox" name="numberOfCopies" >
+             <property name="minimum" >
+              <number>0</number>
+             </property>
+             <property name="maximum" >
+              <number>200</number>
+             </property>
+            </widget>
+           </item>
+          </layout>
+         </item>
+        </layout>
+       </item>
+       <item>
+        <spacer>
+         <property name="orientation" >
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" >
+          <size>
+           <width>31</width>
+           <height>21</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="orientation" >
+      <enum>Qt::Horizontal</enum>
+     </property>
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <layoutdefault spacing="5" margin="10" />
+ <customwidgets>
+  <customwidget>
+   <class>ScrSpinBox</class>
+   <extends>QDoubleSpinBox</extends>
+   <header>ui/scrspinbox.h</header>
+  </customwidget>
+  <customwidget>
+   <class>LinkButton</class>
+   <extends>QToolButton</extends>
+   <header>ui/linkbutton.h</header>
+  </customwidget>
+  <customwidget>
+   <class>BasePointWidget</class>
+   <extends>QWidget</extends>
+   <header>ui/basepointwidget.h</header>
+   <container>1</container>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>TransformDialogBase</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>TransformDialogBase</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialog.cpp Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialog.cpp
--- Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialog.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialog.cpp	2012-08-15 13:16:02.622049780 +0530
@@ -0,0 +1,356 @@
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+/**************************************************************************
+*   Copyright (C) 2008 by Franz Schmid                                    *
+*   franz.schmid@altmuehlnet.de                                           *
+*                                                                         *
+*   This program is free software; you can redistribute it and/or modify  *
+*   it under the terms of the GNU General Public License as published by  *
+*   the Free Software Foundation; either version 2 of the License, or     *
+*   (at your option) any later version.                                   *
+*                                                                         *
+*   This program is distributed in the hope that it will be useful,       *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+*   GNU General Public License for more details.                          *
+*                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program; if not, write to the                         *
+*   Free Software Foundation, Inc.,                                       *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+***************************************************************************/
+
+#include "transformdialog.h"
+#include "util_icon.h"
+#include "selection.h"
+#include "commonstrings.h"
+#include "units.h"
+
+#if defined(_MSC_VER)
+#define _USE_MATH_DEFINES
+#endif
+#include <cmath>
+
+TransformItem::TransformItem(QString text, QListWidget* parent, int type, double val1, double val2) : QListWidgetItem(text, parent, type)
+{
+	firstValue = val1;
+	secondValue = val2;
+}
+
+TransformDialog::TransformDialog(QWidget* parent, ScribusDoc *doc) : QDialog(parent)
+{
+	setupUi(this);
+	setModal(true);
+	setWindowIcon(QIcon(loadIcon ( "AppIcon.png" )));
+	transformStack->setCurrentIndex(0);
+	newTransformMenu = new QMenu(buttonAdd);
+	newTransformMenu->addAction( tr("Scaling"), this, SLOT(newScaling()));
+	newTransformMenu->addAction( tr("Translation"), this, SLOT(newTranslation()));
+	newTransformMenu->addAction( tr("Rotation"), this, SLOT(newRotation()));
+	newTransformMenu->addAction( tr("Skewing"), this, SLOT(newSkewing()));
+	buttonAdd->setMenu(newTransformMenu);
+	scaleLink->setChecked(true);
+	buttonUp->setText( "" );
+	buttonUp->setIcon(loadIcon("16/go-up.png"));
+	buttonDown->setText( "" );
+	buttonDown->setIcon(loadIcon("16/go-down.png"));
+	buttonBox->button(QDialogButtonBox::Ok)->setEnabled(false);
+	m_doc = doc;
+	m_unitRatio = unitGetRatioFromIndex(m_doc->unitIndex());
+	m_suffix = unitGetSuffixFromIndex(m_doc->unitIndex());
+	translateHorizontal->setSuffix(m_suffix);
+	translateVertical->setSuffix(m_suffix);
+	rotationValue->setWrapping( true );
+	rotationValue->setValues( -180.0, 180.0, 1, 0);
+	rotationValue->setSuffix(unitGetSuffixFromIndex(6));
+	horizontalSkew->setSuffix(unitGetSuffixFromIndex(6));
+	verticalSkew->setSuffix(unitGetSuffixFromIndex(6));
+	linkSkew->setChecked(true);
+	numberOfCopies->setValue(0);
+	// basePoint->setCheckedId(m_doc->RotMode);
+	connect(transformSelector, SIGNAL(itemClicked(QListWidgetItem*)), this, SLOT(setCurrentTransform(QListWidgetItem*)));
+	connect(horizontalScale, SIGNAL(valueChanged(double)), this, SLOT(changeHScale(double)));
+	connect(verticalScale, SIGNAL(valueChanged(double)), this, SLOT(changeVScale(double)));
+	connect(scaleLink, SIGNAL(clicked()), this, SLOT(toggleLink()));
+	connect(translateHorizontal, SIGNAL(valueChanged(double)), this, SLOT(changeHTranslation(double)));
+	connect(translateVertical, SIGNAL(valueChanged(double)), this, SLOT(changeVTranslation(double)));
+	connect(rotationValue, SIGNAL(valueChanged(double)), this, SLOT(changeRotation(double)));
+	connect(horizontalSkew, SIGNAL(valueChanged(double)), this, SLOT(changeHSkew(double)));
+	connect(verticalSkew, SIGNAL(valueChanged(double)), this, SLOT(changeVSkew(double)));
+	connect(linkSkew, SIGNAL(clicked()), this, SLOT(toggleLinkSkew()));
+	connect(buttonUp, SIGNAL(clicked()), this, SLOT(moveTransformUp()));
+	connect(buttonDown, SIGNAL(clicked()), this, SLOT(moveTransformDown()));
+	connect(buttonRemove, SIGNAL(clicked()), this, SLOT(removeTransform()));
+}
+
+void TransformDialog::newScaling()
+{
+	TransformItem *item = new TransformItem( tr("Scale"), transformSelector, 1001, 100.0, 100.0);
+	transformSelector->setCurrentItem(item);
+	setCurrentTransform(item);
+	item->setText( tr("Scale H = %1 % V = %2 %").arg(100.0).arg(100.0));
+	buttonRemove->setEnabled(true);
+}
+
+void TransformDialog::newTranslation()
+{
+	TransformItem *item = new TransformItem( tr("Translate"), transformSelector, 1002, 0.0, 0.0);
+	transformSelector->setCurrentItem(item);
+	setCurrentTransform(item);
+	item->setText( tr("Translate H = %1%2 V = %3%4").arg(0.0).arg(m_suffix).arg(0.0).arg(m_suffix));
+	buttonRemove->setEnabled(true);
+}
+
+void TransformDialog::newRotation()
+{
+	TransformItem *item = new TransformItem( tr("Rotate"), transformSelector, 1003, 0.0, 0.0);
+	transformSelector->setCurrentItem(item);
+	setCurrentTransform(item);
+	item->setText( tr("Rotate Angle = %1%2").arg(0.0).arg(unitGetSuffixFromIndex(6)));
+	buttonRemove->setEnabled(true);
+}
+
+void TransformDialog::newSkewing()
+{
+	TransformItem *item = new TransformItem( tr("Skew"), transformSelector, 1004, 0.0, 0.0);
+	transformSelector->setCurrentItem(item);
+	setCurrentTransform(item);
+	item->setText( tr("Skew H = %1%2 V = %3%4").arg(0.0).arg(unitGetSuffixFromIndex(6)).arg(0.0).arg(unitGetSuffixFromIndex(6)));
+	buttonRemove->setEnabled(true);
+}
+
+void TransformDialog::setCurrentTransform(QListWidgetItem* item)
+{
+	if (item != NULL)
+	{
+		TransformItem *ite = (TransformItem*)item;
+		switch (item->type())
+		{
+			case 1001:
+				transformStack->setCurrentIndex(1);
+				horizontalScale->setValue(ite->firstValue);
+				verticalScale->setValue(ite->secondValue);
+				break;
+			case 1002:
+				transformStack->setCurrentIndex(2);
+				translateHorizontal->setValue(ite->firstValue);
+				translateVertical->setValue(ite->secondValue);
+				break;
+			case 1003:
+				transformStack->setCurrentIndex(3);
+				rotationValue->setValue(ite->firstValue);
+				break;
+			case 1004:
+				transformStack->setCurrentIndex(4);
+				horizontalSkew->setValue(ite->firstValue);
+				verticalSkew->setValue(ite->secondValue);
+				break;
+			default:
+				transformStack->setCurrentIndex(0);
+				break;
+		}
+		if (transformSelector->count() > 1)
+		{
+			buttonUp->setEnabled(true);
+			buttonDown->setEnabled(true);
+			if (transformSelector->currentRow() == 0)
+				buttonUp->setEnabled(false);
+			if (transformSelector->currentRow() == transformSelector->count()-1)
+				buttonDown->setEnabled(false);
+		}
+		else
+		{
+			buttonUp->setEnabled(false);
+			buttonDown->setEnabled(false);
+		}
+		buttonBox->button(QDialogButtonBox::Ok)->setEnabled(true);
+	}
+	else
+	{
+		transformStack->setCurrentIndex(0);
+		buttonRemove->setEnabled(false);
+		buttonUp->setEnabled(false);
+		buttonDown->setEnabled(false);
+	}
+}
+
+void TransformDialog::changeHScale(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->firstValue = val;
+	if (scaleLink->isChecked())
+	{
+		verticalScale->setValue(horizontalScale->value());
+		ite->secondValue = val;
+	}
+	item->setText( tr("Scale H = %1 % V = %2 %").arg(ite->firstValue).arg(ite->secondValue));
+}
+
+void TransformDialog::changeVScale(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->secondValue = val;
+	if (scaleLink->isChecked())
+	{
+		horizontalScale->setValue(verticalScale->value());
+		ite->firstValue = val;
+	}
+	item->setText( tr("Scale H = %1 % V = %2 %").arg(ite->firstValue).arg(ite->secondValue));
+}
+
+void TransformDialog::toggleLink()
+{
+	if (scaleLink->isChecked())
+		verticalScale->setValue(horizontalScale->value());
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	item->setText( tr("Scale H = %1 % V = %2 %").arg(ite->firstValue).arg(ite->secondValue));
+}
+
+void TransformDialog::changeHTranslation(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->firstValue = val;
+	item->setText( tr("Translate H = %1%2 V = %3%4").arg(ite->firstValue).arg(m_suffix).arg(ite->secondValue).arg(m_suffix));
+}
+
+void TransformDialog::changeVTranslation(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->secondValue = val;
+	item->setText( tr("Translate H = %1%2 V = %3%4").arg(ite->firstValue).arg(m_suffix).arg(ite->secondValue).arg(m_suffix));
+}
+
+void TransformDialog::changeRotation(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->firstValue = val;
+	item->setText( tr("Rotate Angle = %1%2").arg(ite->firstValue).arg(unitGetSuffixFromIndex(6)));
+}
+
+void TransformDialog::changeHSkew(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->firstValue = val;
+	if (linkSkew->isChecked())
+	{
+		verticalSkew->setValue(horizontalSkew->value());
+		ite->secondValue = val;
+	}
+	item->setText( tr("Skew H = %1%2 V = %3%4").arg(ite->firstValue).arg(unitGetSuffixFromIndex(6)).arg(ite->secondValue).arg(unitGetSuffixFromIndex(6)));
+}
+
+void TransformDialog::changeVSkew(double val)
+{
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	ite->secondValue = val;
+	if (linkSkew->isChecked())
+	{
+		horizontalSkew->setValue(verticalSkew->value());
+		ite->firstValue = val;
+	}
+	item->setText( tr("Skew H = %1%2 V = %3%4").arg(ite->firstValue).arg(unitGetSuffixFromIndex(6)).arg(ite->secondValue).arg(unitGetSuffixFromIndex(6)));
+}
+
+void TransformDialog::toggleLinkSkew()
+{
+	if (linkSkew->isChecked())
+		verticalSkew->setValue(horizontalSkew->value());
+	QListWidgetItem* item = transformSelector->currentItem();
+	TransformItem *ite = (TransformItem*)item;
+	item->setText( tr("Skew H = %1%2 V = %3%4").arg(ite->firstValue).arg(unitGetSuffixFromIndex(6)).arg(ite->secondValue).arg(unitGetSuffixFromIndex(6)));
+}
+
+void TransformDialog::moveTransformUp()
+{
+	int curr = transformSelector->currentRow();
+	if (curr == 0)
+		return;
+	QListWidgetItem *it = transformSelector->takeItem(curr);
+	transformSelector->insertItem(curr-1, it);
+	transformSelector->setCurrentItem(it);
+	setCurrentTransform(it);
+}
+
+void TransformDialog::moveTransformDown()
+{
+	int curr = transformSelector->currentRow();
+	if (curr == transformSelector->count()-1)
+		return;
+	QListWidgetItem *it = transformSelector->takeItem(curr);
+	transformSelector->insertItem(curr+1, it);
+	transformSelector->setCurrentItem(it);
+	setCurrentTransform(it);
+}
+
+void TransformDialog::removeTransform()
+{
+	int curr = transformSelector->currentRow();
+	QListWidgetItem *it = transformSelector->takeItem(curr);
+	delete it;
+	transformSelector->clearSelection();
+	if (transformSelector->count() == 0)
+	{
+		transformStack->setCurrentIndex(0);
+		buttonRemove->setEnabled(false);
+		buttonUp->setEnabled(false);
+		buttonDown->setEnabled(false);
+		buttonBox->button(QDialogButtonBox::Ok)->setEnabled(false);
+	}
+	else
+	{
+		transformSelector->setCurrentItem(transformSelector->item(qMax(curr-1, 0)));
+		transformSelector->currentItem()->setSelected(true);
+		setCurrentTransform(transformSelector->currentItem());
+		buttonRemove->setEnabled(true);
+	}
+}
+
+QMatrix TransformDialog::getTransformMatrix()
+{
+	QMatrix ret = QMatrix();
+	for (int a = 0; a < transformSelector->count(); a++)
+	{
+		QListWidgetItem *it = transformSelector->item(a);
+		TransformItem *ite = (TransformItem*)it;
+		switch (it->type())
+		{
+			case 1001:
+				ret.scale(ite->firstValue / 100.0, ite->secondValue / 100.0);
+				break;
+			case 1002:
+				ret.translate(ite->firstValue / m_unitRatio, ite->secondValue / m_unitRatio);
+				break;
+			case 1003:
+				ret.rotate(ite->firstValue);
+				break;
+			case 1004:
+				ret.shear(-sin(ite->firstValue / 180.0 * M_PI), -sin(ite->secondValue / 180.0 * M_PI));
+				break;
+			default:
+				break;
+		}
+	}
+	return ret;
+}
+
+int TransformDialog::getCount()
+{
+	return numberOfCopies->value();
+}
+
+int TransformDialog::getBasepoint()
+{
+	return basePoint->checkedId();
+}
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialog.h Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialog.h
--- Scribus_1.5_120815/scribus/plugins/tools/transform/transformdialog.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/transformdialog.h	2012-08-15 13:16:09.867050026 +0530
@@ -0,0 +1,87 @@
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+/***************************************************************************
+*   Copyright (C) 2008 by Franz Schmid                                     *
+*   franz.schmid@altmuehlnet.de                                            *
+*                                                                          *
+*   This program is free software; you can redistribute it and/or modify   *
+*   it under the terms of the GNU General Public License as published by   *
+*   the Free Software Foundation; either version 2 of the License, or      *
+*   (at your option) any later version.                                    *
+*                                                                          *
+*   This program is distributed in the hope that it will be useful,        *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+*   GNU General Public License for more details.                           *
+*                                                                          *
+*   You should have received a copy of the GNU General Public License      *
+*   along with this program; if not, write to the                          *
+*   Free Software Foundation, Inc.,                                        *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.              *
+****************************************************************************/
+
+#ifndef TRANSFORMDIALOG_H
+#define TRANSFORMDIALOG_H
+
+#include <QDialog>
+#include <QListWidget>
+#include <QListWidgetItem>
+#include <QMatrix>
+#include <QMenu>
+#include <QString>
+#include "ui_transformdialogbase.h"
+#include "pluginapi.h"
+#include "scribusdoc.h"
+#include "scribus.h"
+
+class PLUGIN_API TransformItem : public QListWidgetItem
+{
+public:
+	TransformItem(QString text, QListWidget* parent, int type, double val1, double val2);
+	~TransformItem() {};
+	double firstValue;
+	double secondValue;
+};
+
+class PLUGIN_API TransformDialog : public QDialog, Ui::TransformDialogBase
+{
+	Q_OBJECT
+
+public:
+	TransformDialog(QWidget* parent, ScribusDoc *doc);
+	~TransformDialog() {};
+	QMatrix getTransformMatrix();
+	int getCount();
+	int getBasepoint();
+
+private slots:
+	void newScaling();
+	void newTranslation();
+	void newRotation();
+	void newSkewing();
+	void setCurrentTransform(QListWidgetItem* item);
+	void changeHScale(double val);
+	void changeVScale(double val);
+	void toggleLink();
+	void changeHTranslation(double val);
+	void changeVTranslation(double val);
+	void changeRotation(double val);
+	void changeHSkew(double val);
+	void changeVSkew(double val);
+	void toggleLinkSkew();
+	void moveTransformUp();
+	void moveTransformDown();
+	void removeTransform();
+
+private:
+	QMenu *newTransformMenu;
+	ScribusDoc *m_doc;
+	double m_unitRatio;
+	QString m_suffix;
+};
+
+#endif
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/transformeffect.cpp Scribus_1.5_indic/scribus/plugins/tools/transform/transformeffect.cpp
--- Scribus_1.5_120815/scribus/plugins/tools/transform/transformeffect.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/transformeffect.cpp	2012-08-15 13:16:02.622049780 +0530
@@ -0,0 +1,267 @@
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+/***************************************************************************
+*   Copyright (C) 2008 by Franz Schmid                                     *
+*   franz.schmid@altmuehlnet.de                                            *
+*                                                                          *
+*   This program is free software; you can redistribute it and/or modify   *
+*   it under the terms of the GNU General Public License as published by   *
+*   the Free Software Foundation; either version 2 of the License, or      *
+*   (at your option) any later version.                                    *
+*                                                                          *
+*   This program is distributed in the hope that it will be useful,        *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+*   GNU General Public License for more details.                           *
+*                                                                          *
+*   You should have received a copy of the GNU General Public License      *
+*   along with this program; if not, write to the                          *
+*   Free Software Foundation, Inc.,                                        *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.              *
+****************************************************************************/
+
+#include "transformeffect.h"
+#include "transformdialog.h"
+#include "scribuscore.h"
+
+int transformeffect_getPluginAPIVersion()
+{
+	return PLUGIN_API_VERSION;
+}
+
+ScPlugin* transformeffect_getPlugin()
+{
+	TransformEffectPlugin* plug = new TransformEffectPlugin();
+	Q_CHECK_PTR(plug);
+	return plug;
+}
+
+void transformeffect_freePlugin(ScPlugin* plugin)
+{
+	TransformEffectPlugin* plug = dynamic_cast<TransformEffectPlugin*>(plugin);
+	Q_ASSERT(plug);
+	delete plug;
+}
+
+TransformEffectPlugin::TransformEffectPlugin() : ScActionPlugin()
+{
+	// Set action info in languageChange, so we only have to do
+	// it in one place.
+	languageChange();
+}
+
+TransformEffectPlugin::~TransformEffectPlugin() {};
+
+void TransformEffectPlugin::languageChange()
+{
+	// Note that we leave the unused members unset. They'll be initialised
+	// with their default ctors during construction.
+	// Action name
+	m_actionInfo.name = "TransformEffect";
+	// Action text for menu, including accel
+	m_actionInfo.text = tr("Transform...");
+	// Menu
+	m_actionInfo.menu = "Item";
+	m_actionInfo.menuAfterName = "MulDuplicate";
+	m_actionInfo.enabledOnStartup = false;
+	m_actionInfo.needsNumObjects = 3;
+	m_actionInfo.notSuitableFor.append(PageItem::Line);
+	m_actionInfo.forAppMode.append(modeNormal);
+}
+
+const QString TransformEffectPlugin::fullTrName() const
+{
+	return QObject::tr("Transform Effect");
+}
+
+const ScActionPlugin::AboutData* TransformEffectPlugin::getAboutData() const
+{
+	AboutData* about = new AboutData;
+	Q_CHECK_PTR(about);
+	about->authors = QString::fromUtf8("Franz Schmid <Franz.Schmid@altmuehlnet.de>");
+	about->shortDescription = tr("Transform Effect");
+	about->description = tr("Apply multiple transformations at once");
+	// about->version
+	// about->releaseDate
+	// about->copyright
+	about->license = "GPL";
+	return about;
+}
+
+void TransformEffectPlugin::deleteAboutData(const AboutData* about) const
+{
+	Q_ASSERT(about);
+	delete about;
+}
+
+bool TransformEffectPlugin::run(ScribusDoc* doc, QString)
+{
+	ScribusDoc* currDoc = doc;
+	if (currDoc == 0)
+		currDoc = ScCore->primaryMainWindow()->doc;
+	if (currDoc->m_Selection->count() > 0)
+	{
+		TransformDialog *dia = new TransformDialog(currDoc->scMW(), currDoc);
+		if (dia->exec())
+		{
+			qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
+			int nrOfCopies = dia->getCount();
+			QMatrix matrix = dia->getTransformMatrix();
+			int baseP = dia->getBasepoint();
+			if (nrOfCopies == 0)
+			{
+				double gx, gy, gh, gw;
+				PageItem *currItem = currDoc->m_Selection->itemAt(0);
+				if (currDoc->m_Selection->count() == 1)
+				{
+					gx = currItem->xPos();
+					gy = currItem->yPos();
+					gw = currItem->width();
+					gh = currItem->height();
+				}
+				else
+					currDoc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
+				for (int a = 0; a < currDoc->m_Selection->count(); ++a)
+				{
+					PageItem *currItem = currDoc->m_Selection->itemAt(a);
+					double deltaX = currItem->xPos() - gx;
+					double deltaY = currItem->yPos() - gy;
+					QMatrix matrixPre = QMatrix();
+					QMatrix matrixAft = QMatrix();
+					switch (baseP)
+					{
+						case 2:
+							matrixPre.translate(-gw/2.0, -gh/2.0);
+							matrixAft.translate(gw/2.0, gh/2.0);
+							break;
+						case 4:
+							matrixPre.translate(-gw, -gh);
+							matrixAft.translate(gw, gh);
+							break;
+						case 3:
+							matrixPre.translate(0, -gh);
+							matrixAft.translate(0, gh);
+							break;
+						case 1:
+							matrixPre.translate(-gw, 0);
+							matrixAft.translate(gw, 0);
+							break;
+					}
+					currItem->PoLine.translate(deltaX, deltaY);
+					currItem->PoLine.map(matrixPre);
+					currItem->PoLine.map(matrix);
+					currItem->PoLine.map(matrixAft);
+					currItem->PoLine.translate(-deltaX, -deltaY);
+					currItem->ContourLine.translate(deltaX, deltaY);
+					currItem->ContourLine.map(matrixPre);
+					currItem->ContourLine.map(matrix);
+					currItem->ContourLine.map(matrixAft);
+					currItem->ContourLine.translate(-deltaX, -deltaY);
+					currItem->Frame = false;
+					currItem->ClipEdited = true;
+					currItem->FrameType = 3;
+					currDoc->AdjustItemSize(currItem);
+				}
+			}
+			else
+			{
+				QList<PageItem*> Elements;
+				bool savedAlignGrid = currDoc->useRaster;
+				bool savedAlignGuides = currDoc->SnapGuides;
+				currDoc->useRaster = false;
+				currDoc->SnapGuides = false;
+				currDoc->DoDrawing = false;
+				currDoc->view()->updatesOn(false);
+				currDoc->m_Selection->delaySignalsOn();
+				currDoc->scMW()->setScriptRunning(true);
+				QMatrix comulatedMatrix = matrix;
+				PageItem *currItem = currDoc->m_Selection->itemAt(0);
+				Elements.append(currItem);
+//				int rotBack = currDoc->RotMode;
+//				currDoc->RotMode = 0;
+				currDoc->scMW()->slotEditCopy();
+				currDoc->view()->Deselect(true);
+				for (int b = 0; b < nrOfCopies; b++)
+				{
+					currDoc->scMW()->slotEditPaste();
+					double gx, gy, gh, gw;
+					currItem = currDoc->m_Selection->itemAt(0);
+					if (currDoc->m_Selection->count() == 1)
+					{
+						gx = currItem->xPos();
+						gy = currItem->yPos();
+						gw = currItem->width();
+						gh = currItem->height();
+					}
+					else
+						currDoc->m_Selection->getGroupRect(&gx, &gy, &gw, &gh);
+					for (int a = 0; a < currDoc->m_Selection->count(); ++a)
+					{
+						currItem = currDoc->m_Selection->itemAt(a);
+						double deltaX = currItem->xPos() - gx;
+						double deltaY = currItem->yPos() - gy;
+						QMatrix matrixPre = QMatrix();
+						QMatrix matrixAft = QMatrix();
+						switch (baseP)
+						{
+							case 2:
+								matrixPre.translate(-gw/2.0, -gh/2.0);
+								matrixAft.translate(gw/2.0, gh/2.0);
+								break;
+							case 4:
+								matrixPre.translate(-gw, -gh);
+								matrixAft.translate(gw, gh);
+								break;
+							case 3:
+								matrixPre.translate(0, -gh);
+								matrixAft.translate(0, gh);
+								break;
+							case 1:
+								matrixPre.translate(-gw, 0);
+								matrixAft.translate(gw, 0);
+								break;
+						}
+						currItem->PoLine.translate(deltaX, deltaY);
+						currItem->PoLine.map(matrixPre);
+						currItem->PoLine.map(comulatedMatrix);
+						currItem->PoLine.map(matrixAft);
+						currItem->PoLine.translate(-deltaX, -deltaY);
+						currItem->ContourLine.translate(deltaX, deltaY);
+						currItem->ContourLine.map(matrixPre);
+						currItem->ContourLine.map(comulatedMatrix);
+						currItem->ContourLine.map(matrixAft);
+						currItem->ContourLine.translate(-deltaX, -deltaY);
+						currItem->Frame = false;
+						currItem->ClipEdited = true;
+						currItem->FrameType = 3;
+						currDoc->AdjustItemSize(currItem);
+						Elements.append(currItem);
+					}
+					comulatedMatrix *= matrix;
+				}
+				for (int c = 0; c < Elements.count(); ++c)
+				{
+					currDoc->m_Selection->addItem(Elements.at(c), true);
+				}
+				currDoc->m_Selection->setGroupRect();
+//				currDoc->RotMode = rotBack;
+				currDoc->useRaster = savedAlignGrid;
+				currDoc->SnapGuides = savedAlignGuides;
+				currDoc->DoDrawing = true;
+				currDoc->m_Selection->delaySignalsOff();
+				currDoc->view()->updatesOn(true);
+				currDoc->scMW()->setScriptRunning(false);
+				currDoc->m_Selection->connectItemToGUI();
+			}
+			qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
+			currDoc->view()->DrawNew();
+			currDoc->changed();
+		}
+		delete dia;
+	}
+	return true;
+}
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/transformeffect.h Scribus_1.5_indic/scribus/plugins/tools/transform/transformeffect.h
--- Scribus_1.5_120815/scribus/plugins/tools/transform/transformeffect.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/transformeffect.h	2012-08-15 13:16:09.867050026 +0530
@@ -0,0 +1,60 @@
+/*
+For general Scribus (>=1.3.2) copyright and licensing information please refer
+to the COPYING file provided with the program. Following this notice may exist
+a copyright and/or license notice that predates the release of Scribus 1.3.2
+for which a new license (GPL+exception) is in place.
+*/
+/***************************************************************************
+*   Copyright (C) 2008 by Franz Schmid                                     *
+*   franz.schmid@altmuehlnet.de                                            *
+*                                                                          *
+*   This program is free software; you can redistribute it and/or modify   *
+*   it under the terms of the GNU General Public License as published by   *
+*   the Free Software Foundation; either version 2 of the License, or      *
+*   (at your option) any later version.                                    *
+*                                                                          *
+*   This program is distributed in the hope that it will be useful,        *
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+*   GNU General Public License for more details.                           *
+*                                                                          *
+*   You should have received a copy of the GNU General Public License      *
+*   along with this program; if not, write to the                          *
+*   Free Software Foundation, Inc.,                                        *
+*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.              *
+****************************************************************************/
+
+#ifndef TRANSFORMEFFECT_H
+#define TRANSFORMEFFECT_H
+
+#include "pluginapi.h"
+#include "scplugin.h"
+#include "selection.h"
+
+/** \brief This is a simple "Transform Effect" plugin for Scribus 1.3 and later.
+\author Franz Schmid
+\date May 2008
+*/
+class PLUGIN_API TransformEffectPlugin : public ScActionPlugin
+{
+	Q_OBJECT
+
+	public:
+		// Standard plugin implementation
+		TransformEffectPlugin();
+		virtual ~TransformEffectPlugin();
+		virtual bool run(ScribusDoc* doc, QString target = QString::null);
+		virtual const QString fullTrName() const;
+		virtual const AboutData* getAboutData() const;
+		virtual void deleteAboutData(const AboutData* about) const;
+		virtual void languageChange();
+		virtual void addToMainWindowMenu(ScribusMainWindow *) {};
+
+		// Special features (none)
+};
+
+extern "C" PLUGIN_API int transformeffect_getPluginAPIVersion();
+extern "C" PLUGIN_API ScPlugin* transformeffect_getPlugin();
+extern "C" PLUGIN_API void transformeffect_freePlugin(ScPlugin* plugin);
+
+#endif
diff -Naur Scribus_1.5_120815/scribus/plugins/tools/transform/ui_transformdialogbase.h Scribus_1.5_indic/scribus/plugins/tools/transform/ui_transformdialogbase.h
--- Scribus_1.5_120815/scribus/plugins/tools/transform/ui_transformdialogbase.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/plugins/tools/transform/ui_transformdialogbase.h	2012-08-15 13:16:09.867050026 +0530
@@ -0,0 +1,457 @@
+/********************************************************************************
+** Form generated from reading UI file 'transformdialogbase.ui'
+**
+** Created by: Qt User Interface Compiler version 4.8.2
+**
+** WARNING! All changes made in this file will be lost when recompiling UI file!
+********************************************************************************/
+
+#ifndef UI_TRANSFORMDIALOGBASE_H
+#define UI_TRANSFORMDIALOGBASE_H
+
+#include <QtCore/QVariant>
+#include <QtGui/QAction>
+#include <QtGui/QApplication>
+#include <QtGui/QButtonGroup>
+#include <QtGui/QDialog>
+#include <QtGui/QDialogButtonBox>
+#include <QtGui/QGridLayout>
+#include <QtGui/QGroupBox>
+#include <QtGui/QHBoxLayout>
+#include <QtGui/QHeaderView>
+#include <QtGui/QLabel>
+#include <QtGui/QListWidget>
+#include <QtGui/QPushButton>
+#include <QtGui/QSpacerItem>
+#include <QtGui/QSpinBox>
+#include <QtGui/QStackedWidget>
+#include <QtGui/QToolButton>
+#include <QtGui/QVBoxLayout>
+#include <QtGui/QWidget>
+#include "ui/basepointwidget.h"
+#include "ui/linkbutton.h"
+#include "ui/scrspinbox.h"
+
+QT_BEGIN_NAMESPACE
+
+class Ui_TransformDialogBase
+{
+public:
+    QVBoxLayout *vboxLayout;
+    QHBoxLayout *hboxLayout;
+    QVBoxLayout *vboxLayout1;
+    QListWidget *transformSelector;
+    QHBoxLayout *hboxLayout1;
+    QToolButton *buttonAdd;
+    QPushButton *buttonRemove;
+    QSpacerItem *spacerItem;
+    QPushButton *buttonUp;
+    QPushButton *buttonDown;
+    QVBoxLayout *vboxLayout2;
+    QStackedWidget *transformStack;
+    QWidget *blankPage;
+    QWidget *pageScale;
+    QGridLayout *gridLayout;
+    QLabel *label_3;
+    QLabel *label;
+    ScrSpinBox *horizontalScale;
+    LinkButton *scaleLink;
+    QLabel *label_2;
+    ScrSpinBox *verticalScale;
+    QWidget *pageTranslate;
+    QGridLayout *gridLayout1;
+    QLabel *label_4;
+    QLabel *label_5;
+    ScrSpinBox *translateHorizontal;
+    QLabel *label_6;
+    ScrSpinBox *translateVertical;
+    QWidget *pageRotate;
+    QGridLayout *gridLayout2;
+    QLabel *label_7;
+    QLabel *label_8;
+    ScrSpinBox *rotationValue;
+    QWidget *Seite;
+    QGridLayout *gridLayout3;
+    QLabel *label_10;
+    QLabel *label_11;
+    ScrSpinBox *horizontalSkew;
+    LinkButton *linkSkew;
+    QLabel *label_12;
+    ScrSpinBox *verticalSkew;
+    QHBoxLayout *hboxLayout2;
+    QGroupBox *RotationGroup;
+    QVBoxLayout *vboxLayout3;
+    BasePointWidget *basePoint;
+    QVBoxLayout *vboxLayout4;
+    QLabel *label_9;
+    QSpinBox *numberOfCopies;
+    QSpacerItem *spacerItem1;
+    QDialogButtonBox *buttonBox;
+
+    void setupUi(QDialog *TransformDialogBase)
+    {
+        if (TransformDialogBase->objectName().isEmpty())
+            TransformDialogBase->setObjectName(QString::fromUtf8("TransformDialogBase"));
+        TransformDialogBase->resize(500, 283);
+        TransformDialogBase->setMinimumSize(QSize(500, 260));
+        vboxLayout = new QVBoxLayout(TransformDialogBase);
+        vboxLayout->setSpacing(5);
+        vboxLayout->setContentsMargins(10, 10, 10, 10);
+        vboxLayout->setObjectName(QString::fromUtf8("vboxLayout"));
+        hboxLayout = new QHBoxLayout();
+        hboxLayout->setSpacing(5);
+        hboxLayout->setObjectName(QString::fromUtf8("hboxLayout"));
+        vboxLayout1 = new QVBoxLayout();
+        vboxLayout1->setSpacing(5);
+        vboxLayout1->setObjectName(QString::fromUtf8("vboxLayout1"));
+        transformSelector = new QListWidget(TransformDialogBase);
+        transformSelector->setObjectName(QString::fromUtf8("transformSelector"));
+
+        vboxLayout1->addWidget(transformSelector);
+
+        hboxLayout1 = new QHBoxLayout();
+        hboxLayout1->setSpacing(5);
+        hboxLayout1->setObjectName(QString::fromUtf8("hboxLayout1"));
+        buttonAdd = new QToolButton(TransformDialogBase);
+        buttonAdd->setObjectName(QString::fromUtf8("buttonAdd"));
+        QSizePolicy sizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed);
+        sizePolicy.setHorizontalStretch(0);
+        sizePolicy.setVerticalStretch(0);
+        sizePolicy.setHeightForWidth(buttonAdd->sizePolicy().hasHeightForWidth());
+        buttonAdd->setSizePolicy(sizePolicy);
+        buttonAdd->setPopupMode(QToolButton::InstantPopup);
+
+        hboxLayout1->addWidget(buttonAdd);
+
+        buttonRemove = new QPushButton(TransformDialogBase);
+        buttonRemove->setObjectName(QString::fromUtf8("buttonRemove"));
+        buttonRemove->setEnabled(false);
+
+        hboxLayout1->addWidget(buttonRemove);
+
+        spacerItem = new QSpacerItem(21, 26, QSizePolicy::Expanding, QSizePolicy::Minimum);
+
+        hboxLayout1->addItem(spacerItem);
+
+        buttonUp = new QPushButton(TransformDialogBase);
+        buttonUp->setObjectName(QString::fromUtf8("buttonUp"));
+        buttonUp->setEnabled(false);
+
+        hboxLayout1->addWidget(buttonUp);
+
+        buttonDown = new QPushButton(TransformDialogBase);
+        buttonDown->setObjectName(QString::fromUtf8("buttonDown"));
+        buttonDown->setEnabled(false);
+        QSizePolicy sizePolicy1(QSizePolicy::Fixed, QSizePolicy::Fixed);
+        sizePolicy1.setHorizontalStretch(0);
+        sizePolicy1.setVerticalStretch(0);
+        sizePolicy1.setHeightForWidth(buttonDown->sizePolicy().hasHeightForWidth());
+        buttonDown->setSizePolicy(sizePolicy1);
+
+        hboxLayout1->addWidget(buttonDown);
+
+
+        vboxLayout1->addLayout(hboxLayout1);
+
+
+        hboxLayout->addLayout(vboxLayout1);
+
+        vboxLayout2 = new QVBoxLayout();
+        vboxLayout2->setSpacing(5);
+        vboxLayout2->setObjectName(QString::fromUtf8("vboxLayout2"));
+        transformStack = new QStackedWidget(TransformDialogBase);
+        transformStack->setObjectName(QString::fromUtf8("transformStack"));
+        QSizePolicy sizePolicy2(QSizePolicy::Preferred, QSizePolicy::Preferred);
+        sizePolicy2.setHorizontalStretch(0);
+        sizePolicy2.setVerticalStretch(0);
+        sizePolicy2.setHeightForWidth(transformStack->sizePolicy().hasHeightForWidth());
+        transformStack->setSizePolicy(sizePolicy2);
+        transformStack->setMinimumSize(QSize(160, 16));
+        transformStack->setFrameShape(QFrame::Panel);
+        blankPage = new QWidget();
+        blankPage->setObjectName(QString::fromUtf8("blankPage"));
+        transformStack->addWidget(blankPage);
+        pageScale = new QWidget();
+        pageScale->setObjectName(QString::fromUtf8("pageScale"));
+        gridLayout = new QGridLayout(pageScale);
+        gridLayout->setSpacing(5);
+        gridLayout->setContentsMargins(10, 10, 10, 10);
+        gridLayout->setObjectName(QString::fromUtf8("gridLayout"));
+        label_3 = new QLabel(pageScale);
+        label_3->setObjectName(QString::fromUtf8("label_3"));
+        QFont font;
+        font.setPointSize(11);
+        label_3->setFont(font);
+        label_3->setAlignment(Qt::AlignCenter);
+
+        gridLayout->addWidget(label_3, 0, 0, 1, 3);
+
+        label = new QLabel(pageScale);
+        label->setObjectName(QString::fromUtf8("label"));
+
+        gridLayout->addWidget(label, 1, 0, 1, 1);
+
+        horizontalScale = new ScrSpinBox(pageScale);
+        horizontalScale->setObjectName(QString::fromUtf8("horizontalScale"));
+        QSizePolicy sizePolicy3(QSizePolicy::Expanding, QSizePolicy::Fixed);
+        sizePolicy3.setHorizontalStretch(0);
+        sizePolicy3.setVerticalStretch(0);
+        sizePolicy3.setHeightForWidth(horizontalScale->sizePolicy().hasHeightForWidth());
+        horizontalScale->setSizePolicy(sizePolicy3);
+        horizontalScale->setMinimumSize(QSize(60, 0));
+        horizontalScale->setDecimals(1);
+        horizontalScale->setMinimum(0.1);
+        horizontalScale->setMaximum(1000);
+        horizontalScale->setValue(100);
+
+        gridLayout->addWidget(horizontalScale, 1, 1, 1, 1);
+
+        scaleLink = new LinkButton(pageScale);
+        scaleLink->setObjectName(QString::fromUtf8("scaleLink"));
+        scaleLink->setMinimumSize(QSize(15, 15));
+        scaleLink->setMaximumSize(QSize(15, 16777215));
+        scaleLink->setCheckable(true);
+        scaleLink->setAutoRaise(true);
+
+        gridLayout->addWidget(scaleLink, 1, 2, 2, 1);
+
+        label_2 = new QLabel(pageScale);
+        label_2->setObjectName(QString::fromUtf8("label_2"));
+
+        gridLayout->addWidget(label_2, 2, 0, 1, 1);
+
+        verticalScale = new ScrSpinBox(pageScale);
+        verticalScale->setObjectName(QString::fromUtf8("verticalScale"));
+        QSizePolicy sizePolicy4(QSizePolicy::MinimumExpanding, QSizePolicy::Fixed);
+        sizePolicy4.setHorizontalStretch(0);
+        sizePolicy4.setVerticalStretch(0);
+        sizePolicy4.setHeightForWidth(verticalScale->sizePolicy().hasHeightForWidth());
+        verticalScale->setSizePolicy(sizePolicy4);
+        verticalScale->setMinimumSize(QSize(60, 0));
+        verticalScale->setDecimals(1);
+        verticalScale->setMinimum(0.1);
+        verticalScale->setMaximum(1000);
+        verticalScale->setValue(100);
+
+        gridLayout->addWidget(verticalScale, 2, 1, 1, 1);
+
+        transformStack->addWidget(pageScale);
+        pageTranslate = new QWidget();
+        pageTranslate->setObjectName(QString::fromUtf8("pageTranslate"));
+        gridLayout1 = new QGridLayout(pageTranslate);
+        gridLayout1->setSpacing(5);
+        gridLayout1->setContentsMargins(10, 10, 10, 10);
+        gridLayout1->setObjectName(QString::fromUtf8("gridLayout1"));
+        label_4 = new QLabel(pageTranslate);
+        label_4->setObjectName(QString::fromUtf8("label_4"));
+        label_4->setFont(font);
+        label_4->setAlignment(Qt::AlignCenter);
+
+        gridLayout1->addWidget(label_4, 0, 0, 1, 2);
+
+        label_5 = new QLabel(pageTranslate);
+        label_5->setObjectName(QString::fromUtf8("label_5"));
+
+        gridLayout1->addWidget(label_5, 1, 0, 1, 1);
+
+        translateHorizontal = new ScrSpinBox(pageTranslate);
+        translateHorizontal->setObjectName(QString::fromUtf8("translateHorizontal"));
+        translateHorizontal->setMinimum(-30000);
+        translateHorizontal->setMaximum(30000);
+
+        gridLayout1->addWidget(translateHorizontal, 1, 1, 1, 1);
+
+        label_6 = new QLabel(pageTranslate);
+        label_6->setObjectName(QString::fromUtf8("label_6"));
+
+        gridLayout1->addWidget(label_6, 2, 0, 1, 1);
+
+        translateVertical = new ScrSpinBox(pageTranslate);
+        translateVertical->setObjectName(QString::fromUtf8("translateVertical"));
+        translateVertical->setMinimum(-30000);
+        translateVertical->setMaximum(30000);
+
+        gridLayout1->addWidget(translateVertical, 2, 1, 1, 1);
+
+        transformStack->addWidget(pageTranslate);
+        pageRotate = new QWidget();
+        pageRotate->setObjectName(QString::fromUtf8("pageRotate"));
+        gridLayout2 = new QGridLayout(pageRotate);
+        gridLayout2->setSpacing(5);
+        gridLayout2->setContentsMargins(10, 10, 10, 10);
+        gridLayout2->setObjectName(QString::fromUtf8("gridLayout2"));
+        label_7 = new QLabel(pageRotate);
+        label_7->setObjectName(QString::fromUtf8("label_7"));
+        label_7->setFont(font);
+        label_7->setAlignment(Qt::AlignCenter);
+
+        gridLayout2->addWidget(label_7, 0, 0, 1, 2);
+
+        label_8 = new QLabel(pageRotate);
+        label_8->setObjectName(QString::fromUtf8("label_8"));
+
+        gridLayout2->addWidget(label_8, 1, 0, 1, 1);
+
+        rotationValue = new ScrSpinBox(pageRotate);
+        rotationValue->setObjectName(QString::fromUtf8("rotationValue"));
+        rotationValue->setDecimals(1);
+        rotationValue->setMinimum(-360);
+        rotationValue->setMaximum(360);
+
+        gridLayout2->addWidget(rotationValue, 1, 1, 1, 1);
+
+        transformStack->addWidget(pageRotate);
+        Seite = new QWidget();
+        Seite->setObjectName(QString::fromUtf8("Seite"));
+        gridLayout3 = new QGridLayout(Seite);
+        gridLayout3->setSpacing(5);
+        gridLayout3->setContentsMargins(10, 10, 10, 10);
+        gridLayout3->setObjectName(QString::fromUtf8("gridLayout3"));
+        label_10 = new QLabel(Seite);
+        label_10->setObjectName(QString::fromUtf8("label_10"));
+        label_10->setFont(font);
+        label_10->setAlignment(Qt::AlignCenter);
+
+        gridLayout3->addWidget(label_10, 0, 0, 1, 3);
+
+        label_11 = new QLabel(Seite);
+        label_11->setObjectName(QString::fromUtf8("label_11"));
+
+        gridLayout3->addWidget(label_11, 1, 0, 1, 1);
+
+        horizontalSkew = new ScrSpinBox(Seite);
+        horizontalSkew->setObjectName(QString::fromUtf8("horizontalSkew"));
+        horizontalSkew->setDecimals(1);
+        horizontalSkew->setMinimum(-89);
+        horizontalSkew->setMaximum(89);
+
+        gridLayout3->addWidget(horizontalSkew, 1, 1, 1, 1);
+
+        linkSkew = new LinkButton(Seite);
+        linkSkew->setObjectName(QString::fromUtf8("linkSkew"));
+        linkSkew->setMinimumSize(QSize(15, 15));
+        linkSkew->setMaximumSize(QSize(15, 16777215));
+        linkSkew->setCheckable(true);
+        linkSkew->setAutoRaise(true);
+
+        gridLayout3->addWidget(linkSkew, 1, 2, 2, 1);
+
+        label_12 = new QLabel(Seite);
+        label_12->setObjectName(QString::fromUtf8("label_12"));
+
+        gridLayout3->addWidget(label_12, 2, 0, 1, 1);
+
+        verticalSkew = new ScrSpinBox(Seite);
+        verticalSkew->setObjectName(QString::fromUtf8("verticalSkew"));
+        verticalSkew->setDecimals(1);
+        verticalSkew->setMinimum(-89);
+        verticalSkew->setMaximum(89);
+
+        gridLayout3->addWidget(verticalSkew, 2, 1, 1, 1);
+
+        transformStack->addWidget(Seite);
+
+        vboxLayout2->addWidget(transformStack);
+
+        hboxLayout2 = new QHBoxLayout();
+        hboxLayout2->setSpacing(5);
+        hboxLayout2->setObjectName(QString::fromUtf8("hboxLayout2"));
+        RotationGroup = new QGroupBox(TransformDialogBase);
+        RotationGroup->setObjectName(QString::fromUtf8("RotationGroup"));
+        vboxLayout3 = new QVBoxLayout(RotationGroup);
+        vboxLayout3->setSpacing(5);
+        vboxLayout3->setContentsMargins(10, 10, 10, 10);
+        vboxLayout3->setObjectName(QString::fromUtf8("vboxLayout3"));
+        basePoint = new BasePointWidget(RotationGroup);
+        basePoint->setObjectName(QString::fromUtf8("basePoint"));
+        basePoint->setMinimumSize(QSize(56, 56));
+
+        vboxLayout3->addWidget(basePoint);
+
+
+        hboxLayout2->addWidget(RotationGroup);
+
+        vboxLayout4 = new QVBoxLayout();
+        vboxLayout4->setSpacing(5);
+        vboxLayout4->setObjectName(QString::fromUtf8("vboxLayout4"));
+        label_9 = new QLabel(TransformDialogBase);
+        label_9->setObjectName(QString::fromUtf8("label_9"));
+
+        vboxLayout4->addWidget(label_9);
+
+        numberOfCopies = new QSpinBox(TransformDialogBase);
+        numberOfCopies->setObjectName(QString::fromUtf8("numberOfCopies"));
+        numberOfCopies->setMinimum(0);
+        numberOfCopies->setMaximum(200);
+
+        vboxLayout4->addWidget(numberOfCopies);
+
+
+        hboxLayout2->addLayout(vboxLayout4);
+
+
+        vboxLayout2->addLayout(hboxLayout2);
+
+        spacerItem1 = new QSpacerItem(31, 21, QSizePolicy::Minimum, QSizePolicy::Expanding);
+
+        vboxLayout2->addItem(spacerItem1);
+
+
+        hboxLayout->addLayout(vboxLayout2);
+
+
+        vboxLayout->addLayout(hboxLayout);
+
+        buttonBox = new QDialogButtonBox(TransformDialogBase);
+        buttonBox->setObjectName(QString::fromUtf8("buttonBox"));
+        buttonBox->setOrientation(Qt::Horizontal);
+        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok);
+
+        vboxLayout->addWidget(buttonBox);
+
+
+        retranslateUi(TransformDialogBase);
+        QObject::connect(buttonBox, SIGNAL(accepted()), TransformDialogBase, SLOT(accept()));
+        QObject::connect(buttonBox, SIGNAL(rejected()), TransformDialogBase, SLOT(reject()));
+
+        transformStack->setCurrentIndex(0);
+
+
+        QMetaObject::connectSlotsByName(TransformDialogBase);
+    } // setupUi
+
+    void retranslateUi(QDialog *TransformDialogBase)
+    {
+        TransformDialogBase->setWindowTitle(QApplication::translate("TransformDialogBase", "Transform", 0, QApplication::UnicodeUTF8));
+        buttonAdd->setText(QApplication::translate("TransformDialogBase", "Add", 0, QApplication::UnicodeUTF8));
+        buttonRemove->setText(QApplication::translate("TransformDialogBase", "Remove", 0, QApplication::UnicodeUTF8));
+        buttonUp->setText(QApplication::translate("TransformDialogBase", "u", 0, QApplication::UnicodeUTF8));
+        buttonDown->setText(QApplication::translate("TransformDialogBase", "d", 0, QApplication::UnicodeUTF8));
+        label_3->setText(QApplication::translate("TransformDialogBase", "Scaling", 0, QApplication::UnicodeUTF8));
+        label->setText(QApplication::translate("TransformDialogBase", "Horizontal", 0, QApplication::UnicodeUTF8));
+        horizontalScale->setSuffix(QApplication::translate("TransformDialogBase", " %", 0, QApplication::UnicodeUTF8));
+        scaleLink->setText(QString());
+        label_2->setText(QApplication::translate("TransformDialogBase", "Vertical", 0, QApplication::UnicodeUTF8));
+        verticalScale->setSuffix(QApplication::translate("TransformDialogBase", " %", 0, QApplication::UnicodeUTF8));
+        label_4->setText(QApplication::translate("TransformDialogBase", "Translation", 0, QApplication::UnicodeUTF8));
+        label_5->setText(QApplication::translate("TransformDialogBase", "Horizontal", 0, QApplication::UnicodeUTF8));
+        label_6->setText(QApplication::translate("TransformDialogBase", "Vertical", 0, QApplication::UnicodeUTF8));
+        label_7->setText(QApplication::translate("TransformDialogBase", "Rotate", 0, QApplication::UnicodeUTF8));
+        label_8->setText(QApplication::translate("TransformDialogBase", "Angle", 0, QApplication::UnicodeUTF8));
+        label_10->setText(QApplication::translate("TransformDialogBase", "Skew", 0, QApplication::UnicodeUTF8));
+        label_11->setText(QApplication::translate("TransformDialogBase", "Horizontal", 0, QApplication::UnicodeUTF8));
+        linkSkew->setText(QString());
+        label_12->setText(QApplication::translate("TransformDialogBase", "Vertical", 0, QApplication::UnicodeUTF8));
+        RotationGroup->setTitle(QApplication::translate("TransformDialogBase", "Origin", 0, QApplication::UnicodeUTF8));
+        label_9->setText(QApplication::translate("TransformDialogBase", "Copies", 0, QApplication::UnicodeUTF8));
+    } // retranslateUi
+
+};
+
+namespace Ui {
+    class TransformDialogBase: public Ui_TransformDialogBase {};
+} // namespace Ui
+
+QT_END_NAMESPACE
+
+#endif // UI_TRANSFORMDIALOGBASE_H
diff -Naur Scribus_1.5_120815/scribus/scpageoutput.cpp Scribus_1.5_indic/scribus/scpageoutput.cpp
--- Scribus_1.5_120815/scribus/scpageoutput.cpp	2012-08-15 11:02:06.574825668 +0530
+++ Scribus_1.5_indic/scribus/scpageoutput.cpp	2012-08-15 13:46:48.999101317 +0530
@@ -3,6 +3,9 @@
 to the COPYING file provided with the program. Following this notice may exist
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
 */
 #include "scpageoutput.h"
 
@@ -1111,6 +1114,7 @@
 	for (int a = 0; a < itemText.length(); ++a)
 	{
 		hl = itemText.item(a);
+		if (hl->gIdx < 0) continue ;
 		chstr = hl->ch;
 		if (chstr[0] == SpecialChars::PAGENUMBER || chstr[0] == SpecialChars::PARSEP || chstr[0] == SpecialChars::PAGECOUNT
 			|| chstr[0] == SpecialChars::TAB || chstr == SpecialChars::LINEBREAK)
@@ -1149,6 +1153,7 @@
 	for (int a = item->firstInFrame(); a < itemText.length(); ++a)
 	{
 		hl = itemText.item(a);
+		if (hl->gIdx < 0) continue ;
 		chstr = hl->ch;
 		if (chstr[0] == SpecialChars::PAGENUMBER || chstr[0] == SpecialChars::PARSEP || chstr[0] == SpecialChars::PAGECOUNT
 			|| chstr[0] == SpecialChars::TAB || chstr[0] == SpecialChars::LINEBREAK)
diff -Naur Scribus_1.5_120815/scribus/sctextstruct.h Scribus_1.5_indic/scribus/sctextstruct.h
--- Scribus_1.5_120815/scribus/sctextstruct.h	2012-08-15 11:02:06.463825665 +0530
+++ Scribus_1.5_indic/scribus/sctextstruct.h	2012-08-15 13:30:08.790073418 +0530
@@ -3,6 +3,9 @@
 to the COPYING file provided with the program. Following this notice may exist
 a copyright and/or license notice that predates the release of Scribus 1.3.2
 for which a new license (GPL+exception) is in place.
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
 */
 #ifndef SCTEXTSTRUCT_H
 #define SCTEXTSTRUCT_H
@@ -111,15 +114,17 @@
 	float PDx;
 	int embedded;
 	QChar ch;
+	QChar gch;
+	int gIdx;
 	ScText() : 
 		CharStyle(),
 		parstyle(NULL), glyph(), 
-		PtransX(0.0f), PtransY(0.0f), PRot(0.0f), PDx(0.0f), embedded(0), ch() {}
+		PtransX(0.0f), PtransY(0.0f), PRot(0.0f), PDx(0.0f), embedded(0), ch(), gch(), gIdx(-1) {}
 	ScText(const ScText& other) : 
 		CharStyle(other),
 		parstyle(NULL), glyph(other.glyph), 
 		PtransX(other.PtransX), PtransY(other.PtransY), PRot(other.PRot), PDx(other.PDx), 
-		embedded(other.embedded), ch(other.ch)
+		embedded(other.embedded), ch(other.ch), gch(other.ch), gIdx(other.gIdx)
 	{
 		glyph.more = NULL;
 		GlyphLayout *layout = &glyph;
diff -Naur Scribus_1.5_120815/scribus/text/CMakeLists.txt Scribus_1.5_indic/scribus/text/CMakeLists.txt
--- Scribus_1.5_120815/scribus/text/CMakeLists.txt	2012-08-15 11:01:59.309825464 +0530
+++ Scribus_1.5_indic/scribus/text/CMakeLists.txt	2012-08-15 12:50:14.279006631 +0530
@@ -15,6 +15,8 @@
 sctext_shared.cpp
 fsize.cpp
 frect.cpp
+shaper.cpp
+scbidi.cpp
 )
 
 
diff -Naur Scribus_1.5_120815/scribus/text/scbidi.cpp Scribus_1.5_indic/scribus/text/scbidi.cpp
--- Scribus_1.5_120815/scribus/text/scbidi.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/text/scbidi.cpp	2012-08-15 12:50:53.432007720 +0530
@@ -0,0 +1,95 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "scbidi.h"
+#include <QDebug>
+
+QHash<QChar::Direction, FriBidiCharType> ScBidi::createCTMap()
+{
+	QHash<QChar::Direction, FriBidiCharType> ret;
+	ret.insert(QChar::DirL, FRIBIDI_TYPE_LTR);
+	ret.insert(QChar::DirR, FRIBIDI_TYPE_RTL);
+	ret.insert(QChar::DirAL, FRIBIDI_TYPE_AL);
+	ret.insert(QChar::DirLRE, FRIBIDI_TYPE_LRE);
+	ret.insert(QChar::DirRLE, FRIBIDI_TYPE_RLE);
+	ret.insert(QChar::DirLRO, FRIBIDI_TYPE_LRO);
+	ret.insert(QChar::DirRLO, FRIBIDI_TYPE_RLO);
+	ret.insert(QChar::DirPDF, FRIBIDI_TYPE_PDF);
+	ret.insert(QChar::DirEN, FRIBIDI_TYPE_EN);
+	ret.insert(QChar::DirAN, FRIBIDI_TYPE_AN);
+	ret.insert(QChar::DirES, FRIBIDI_TYPE_ES);
+	ret.insert(QChar::DirET, FRIBIDI_TYPE_ET);
+	ret.insert(QChar::DirCS, FRIBIDI_TYPE_CS);
+	ret.insert(QChar::DirNSM, FRIBIDI_TYPE_NSM);
+	ret.insert(QChar::DirBN, FRIBIDI_TYPE_BN);
+	ret.insert(QChar::DirB, FRIBIDI_TYPE_BS);
+	ret.insert(QChar::DirS, FRIBIDI_TYPE_SS);
+	ret.insert(QChar::DirWS, FRIBIDI_TYPE_WS);
+	ret.insert(QChar::DirON, FRIBIDI_TYPE_ON);
+	return ret;
+}
+
+QHash<QChar::Direction, FriBidiCharType> ScBidi::mapCT = ScBidi::createCTMap();
+
+
+ScBidi::ScBidi(const QString& txt)
+{
+	if(txt.isEmpty())
+		return;
+	const unsigned int tLen(txt.length());
+	FriBidiChar * bidiChar(new FriBidiChar[tLen]);
+	bidiLevel = new FriBidiLevel[tLen];
+//	LToV = new FriBidiStrIndex[tLen];
+	bidiCT = mapCT[txt.at(0).direction()];
+	for(unsigned int i(0); i < tLen; ++i)
+		bidiChar[i] = txt.at(i).unicode();
+	fribidi_log2vis_get_embedding_levels(bidiChar, tLen, &bidiCT, bidiLevel);
+//	fribidi_log2vis(bidiChar, tLen, &bidiCT, 0, LToV, 0, bidiLevel);
+	// DEBUG
+//	QString dbgStr;
+//	for(unsigned int i(0); i < tLen; ++i)
+//		dbgStr += QString("+%1+").arg(txt.at(i));
+//	qDebug()<<dbgStr;
+//	dbgStr.clear();
+//	for(unsigned int i(0); i < tLen; ++i)
+//		dbgStr += QString("+%1+").arg(fribidi_is_char_rtl(bidiLevel, bidiCT, i));
+//	qDebug()<<dbgStr;
+//	//
+	delete bidiChar;
+
+}
+
+
+ScBidi::~ScBidi()
+{
+	delete bidiLevel;
+//	delete LToV;
+}
+
+
+bool ScBidi::isLTR(const unsigned int &idx) const
+{
+	return !fribidi_is_char_rtl(bidiLevel, bidiCT, idx);
+}
+
+bool ScBidi::isRTL(const unsigned int &idx) const
+{
+	return fribidi_is_char_rtl(bidiLevel, bidiCT, idx);
+}
diff -Naur Scribus_1.5_120815/scribus/text/scbidi.h Scribus_1.5_indic/scribus/text/scbidi.h
--- Scribus_1.5_120815/scribus/text/scbidi.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/text/scbidi.h	2012-08-15 12:50:53.437007721 +0530
@@ -0,0 +1,52 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef SCBIDI_H
+#define SCBIDI_H
+
+#include "scribusapi.h"
+#include <QList>
+#include <QString>
+#include <QHash>
+
+#include "third_party/fribidi/fribidi.h"
+
+class SCRIBUS_API ScBidi
+{
+	ScBidi(){}
+
+	FriBidiLevel * bidiLevel;
+	FriBidiStrIndex * LToV;
+	FriBidiCharType bidiCT;
+
+	static QHash<QChar::Direction, FriBidiCharType> mapCT;
+public:
+	ScBidi(const QString& txt);
+	~ScBidi();
+
+	bool isLTR(const unsigned int& idx) const;
+	bool isRTL(const unsigned int& idx) const;
+
+	// helper
+	static QHash<QChar::Direction, FriBidiCharType> createCTMap();
+
+};
+
+#endif // SCBIDI_H
diff -Naur Scribus_1.5_120815/scribus/text/shaper.cpp Scribus_1.5_indic/scribus/text/shaper.cpp
--- Scribus_1.5_120815/scribus/text/shaper.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/text/shaper.cpp	2012-08-15 13:41:02.221091644 +0530
@@ -0,0 +1,155 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
+ ***************************************************************************/
+
+#include "shaper.h"
+
+#include "text/storytext.h"
+#include "text/scbidi.h"
+#include "langmgr.h"
+#include "hyphenator.h"
+
+#include <QDebug>
+
+Shaper::Shaper(StoryText * stry):
+	m_story(stry)
+{
+//printf ( "(%s)(%d)(%s) \n", __FILE__, __LINE__, __func__) ;
+}
+
+
+void Shaper::shape(int start, int end)
+{
+	StoryText * story(const_cast<StoryText *>(m_story));
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) Item length\n", __FILE__, __LINE__, __func__, start, end ) ;
+//	GlyphStore *gs(const_cast<GlyphStore*>(m_story->glyphStore()));
+//	LanguageManager * lm(LanguageManager::instance());
+
+	const QString txt(story->text(start, end - start ));
+	if(txt.isEmpty()) {
+printf ( "(%s)(%d)(%s) start (%d) end (%d)\n", __FILE__, __LINE__, __func__, start, end ) ;
+		return;
+        }
+	ScBidi bidi(txt);
+//	int firstPos(start);
+//	story->hyphenateWord(start, end - start + 1, 0, false);
+//	for(int i(start); i <= end; ++i)
+//	{
+//		if(txt.at(i - start).isSpace() || txt.at(i - start).isPunct() || i == end)
+//		{
+//			story->selfHyphenateWord(firstPos, (i == end) ? i - firstPos + 1 : i - firstPos);
+//			firstPos = i + 1;
+//		}
+//	}
+
+	// DEBUG
+//	QString dbStr;
+//	for(int dbi(start); dbi <= end; dbi++)
+//	{
+//
+//		if(story->charAttributes(dbi).testFlag(TextFlag_HyphenationPossible))
+//		{
+//			dbStr.append("[");
+//			dbStr.append(story->text(dbi, 1));
+//			dbStr.append("]");
+//		}
+//		else
+//			dbStr.append(story->text(dbi, 1));
+//	}
+//	qDebug()<<dbStr;
+
+
+	QList<uint> items;
+	// redo itemization for this run
+	CharStyle ref;
+	int itStart(start);
+	bool first(true);
+	bool currentRTL( bidi.isRTL(0));
+	bool previousRTL(currentRTL);
+	for(int cursor(start); cursor <= end; ++cursor )
+	{
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) cursor (%d)\n", __FILE__, __LINE__, __func__, start, end, cursor ) ;
+		currentRTL = bidi.isRTL(cursor - start);
+//		if(currentRTL)
+//			story->charAttributes(cursor) |= TextFlag_RightToLeft;
+//		else
+//			story->charAttributes(cursor) &= ~TextFlag_RightToLeft;
+		if(first)
+		{
+			first = false;
+			ref = story->charStyle(cursor) ;
+		}
+		else
+		{
+			if((story->charStyle(cursor) != ref)
+					|| (currentRTL != previousRTL)
+					|| (cursor == end) || (story->text(cursor) == SpecialChars::PARSEP) )
+			{
+				if(cursor != end)
+				{
+					ref = story->charStyle(cursor) ;
+					items << story->addItem(itStart, (cursor) - itStart);
+					QString itemStr(story->text(itStart, (cursor) - itStart ));
+//					// qDebug()<<"ADD ITEM"<<itStart<<(cursor) - itStart <<itemStr;
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) cursor (%d)\n", __FILE__, __LINE__, __func__, itStart, end, cursor ) ;
+				}
+				else
+				{
+					items << story->addItem(itStart, (cursor) - itStart + 1);
+					QString itemStr(story->text(itStart, (cursor) - itStart + 1));
+					// qDebug()<<"ADD ITEM"<<itStart<<(cursor) - itStart + 1<<itemStr;
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) cursor (%d)\n", __FILE__, __LINE__, __func__, itStart, end, cursor ) ;
+				}
+				itStart = cursor;
+			}
+		}
+                if ((story->text(cursor).unicode() < 0xff)||(story->text(cursor) == SpecialChars::LINEBREAK)) {
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) cursor (%d)\n", __FILE__, __LINE__, __func__, itStart, end, cursor ) ;
+			items << story->addItem(itStart, (cursor) - itStart + 1);
+			QString itemStr(story->text(itStart, (cursor) - itStart + 1));
+			itStart = cursor;
+                }
+//                if ((cursor > 0) && (story->text(cursor - 1) == SpecialChars::PARSEP)) {
+//printf ( "(%s)(%d)(%s) start (%d) end (%d) cursor (%d)\n", __FILE__, __LINE__, __func__, itStart, end, cursor ) ;
+//			items << story->addItem(itStart, (cursor) - itStart + 1);
+//			QString itemStr(story->text(itStart, (cursor) - itStart + 1));
+//			itStart = cursor;
+//                }
+		previousRTL = currentRTL;
+	}
+
+	foreach(uint it, items)
+	{
+//printf ( "(%s)(%d)(%s) start (%d) len (%d) item (%d)\n", __FILE__, __LINE__, __func__, story->itemTextPosition(it), story->itemCharCount(it), it ) ;
+		if((story->charStyle(story->itemTextPosition(it)).font().type() == ScFace::OTF)
+				|| (story->charStyle(story->itemTextPosition(it)).font().type() == ScFace::TTF))
+		{
+//printf ( "(%s)(%d)(%s) start (%d) len (%d) item (%d) calling shapeText\n", __FILE__, __LINE__, __func__, story->itemTextPosition(it), story->itemCharCount(it), it ) ;
+			story->charStyle(story->itemTextPosition(it)).font().shapeText((char *)story, it);
+		}
+		else
+		{
+//printf ( "(%s)(%d)(%s) start (%d) len (%d) item (%d) not calling shapeText\n", __FILE__, __LINE__, __func__, story->itemTextPosition(it), story->itemCharCount(it), it ) ;
+			// FIXME_OIF
+		}
+	}
+}
diff -Naur Scribus_1.5_120815/scribus/text/shaper.h Scribus_1.5_indic/scribus/text/shaper.h
--- Scribus_1.5_120815/scribus/text/shaper.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/text/shaper.h	2012-08-15 13:41:11.603091906 +0530
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
+ ***************************************************************************/
+
+#ifndef SHAPER_H
+#define SHAPER_H
+
+#include "text/storytext.h"
+        
+class ShaperBase
+{
+public:
+        virtual void shape(int start, int end) = 0; // shaping cannot be a const process - pm
+        virtual ~ShaperBase() {}
+};
+
+
+class SCRIBUS_API Shaper : public ShaperBase
+{
+	const StoryText * m_story;
+	Shaper(){}
+
+public:
+	Shaper(StoryText *stry);
+	void shape(int start, int end);
+};
+
+#endif // SHAPER_H
diff -Naur Scribus_1.5_120815/scribus/text/specialchars.cpp Scribus_1.5_indic/scribus/text/specialchars.cpp
--- Scribus_1.5_120815/scribus/text/specialchars.cpp	2012-08-15 11:01:59.302825464 +0530
+++ Scribus_1.5_indic/scribus/text/specialchars.cpp	2012-08-15 13:42:29.964094092 +0530
@@ -10,7 +10,10 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
-	***************************************************************************/
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
+***************************************************************************/
 
 /***************************************************************************
 *                                                                         *
@@ -24,9 +27,12 @@
 #include "specialchars.h"
 
 QChar SpecialChars::OBJECT       = QChar(25);
+QChar SpecialChars::START_TAG    = QChar(1);
+QChar SpecialChars::END_TAG      = QChar(2);
+QChar SpecialChars::EMPTY_TAG    = QChar(3);
 QChar SpecialChars::TAB          = QChar(9);
 QChar SpecialChars::PARSEP       = QChar(13);
-QChar SpecialChars::LINEBREAK    = QChar(28);
+QChar SpecialChars::LINEBREAK    = QChar(0x2028);
 QChar SpecialChars::COLBREAK     = QChar(26);
 QChar SpecialChars::FRAMEBREAK   = QChar(27);
 QChar SpecialChars::SHYPHEN      = QChar(0xAD);
@@ -40,15 +46,122 @@
 QChar SpecialChars::PAGECOUNT    = QChar(23);
 QChar SpecialChars::BLANK        = QChar(32);      // SPACE is some macro on my machine - av
 
+SpecialChars::SymbolGlyphs SpecialChars::symbols;
+
+SpecialChars::SymbolGlyphs::SymbolGlyphs() : Return(), NewLine(), Tab(), NonBreak(), NewCol(), NewFrame()
+{
+	Return.resize(0);
+	Return.addQuadPoint(1.98438, 9.14062, 1.98438, 9.14062, 1.98438, 4.03125, 1.98438, 4.03125);
+	Return.addQuadPoint(1.98438, 4.03125, 1.98438, 4.03125, 0.546875, 3.45312, 1.09375, 4);
+	Return.addQuadPoint(0.546875, 3.45312, 0.546875, 3.45312, 0, 2.0625, 0, 2.92188);
+	Return.addQuadPoint(0, 2.0625, 0, 2.0625, 0.65625, 0.5, 0, 1.04688);
+	Return.addQuadPoint(0.65625, 0.5, 0.65625, 0.5, 2.3125, 0, 1.28125, 0);
+	Return.addQuadPoint(2.3125, 0, 2.3125, 0, 5.40625, 0, 5.40625, 0);
+	Return.addQuadPoint(5.40625, 0, 5.40625, 0, 5.40625, 0.84375, 5.40625, 0.84375);
+	Return.addQuadPoint(5.40625, 0.84375, 5.40625, 0.84375, 4.70312, 0.84375, 4.70312, 0.84375);
+	Return.addQuadPoint(4.70312, 0.84375, 4.70312, 0.84375, 4.70312, 9.14062, 4.70312, 9.14062);
+	Return.addQuadPoint(4.70312, 9.14062, 4.70312, 9.14062, 3.875, 9.14062, 3.875, 9.14062);
+	Return.addQuadPoint(3.875, 9.14062, 3.875, 9.14062, 3.875, 0.84375, 3.875, 0.84375);
+	Return.addQuadPoint(3.875, 0.84375, 3.875, 0.84375, 2.78125, 0.84375, 2.78125, 0.84375);
+	Return.addQuadPoint(2.78125, 0.84375, 2.78125, 0.84375, 2.78125, 9.14062, 2.78125, 9.14062);
+	Return.addQuadPoint(2.78125, 9.14062, 2.78125, 9.14062, 1.98438, 9.14062, 1.98438, 9.14062);
+	NewLine.resize(0);
+	NewLine.addQuadPoint(6.51562, 2.625, 6.51562, 2.625, 0.90625, 2.64062, 0.90625, 2.64062);
+	NewLine.addQuadPoint(0.90625, 2.64062, 0.90625, 2.64062, 1.4375, 1.92188, 1.26562, 2.1875);
+	NewLine.addQuadPoint(1.4375, 1.92188, 1.4375, 1.92188, 1.76562, 1.14062, 1.75, 1.42188);
+	NewLine.addQuadPoint(1.76562, 1.14062, 1.76562, 1.14062, 1.60938, 1.03125, 1.60938, 1.03125);
+	NewLine.addQuadPoint(1.60938, 1.03125, 1.60938, 1.03125, 0.90625, 1.92188, 0.90625, 1.92188);
+	NewLine.addQuadPoint(0.90625, 1.92188, 0.90625, 1.92188, 0, 2.90625, 0.578125, 2.23438);
+	NewLine.addQuadPoint(0, 2.90625, 0, 2.90625, 0.75, 3.875, 0.75, 3.875);
+	NewLine.addQuadPoint(0.75, 3.875, 0.75, 3.875, 1.57812, 4.78125, 1.1875, 4.40625);
+	NewLine.addQuadPoint(1.57812, 4.78125, 1.57812, 4.78125, 1.65625, 4.79688, 1.65625, 4.79688);
+	NewLine.addQuadPoint(1.65625, 4.79688, 1.65625, 4.79688, 1.76562, 4.65625, 1.76562, 4.65625);
+	NewLine.addQuadPoint(1.76562, 4.65625, 1.76562, 4.65625, 0.90625, 3.17188, 1.73438, 4.34375);
+	NewLine.addQuadPoint(0.90625, 3.17188, 0.90625, 3.17188, 0.96875, 3.125, 0.96875, 3.125);
+	NewLine.addQuadPoint(0.96875, 3.125, 0.96875, 3.125, 6.75, 3.125, 6.75, 3.125);
+	NewLine.addQuadPoint(6.75, 3.125, 6.75, 3.125, 6.51562, 2.625, 6.51562, 2.625);
+	NewLine.addQuadPoint(6.51562, 2.625, 6.51562, 2.625, 6.51562, 2.625, 6.51562, 2.625);
+	NewLine.addQuadPoint(999999, 999999, 999999, 999999, 999999, 999999, 999999, 999999);
+	NewLine.addQuadPoint(6.875, 0, 6.875, 0, 6.51562, 0, 6.51562, 0);
+	NewLine.addQuadPoint(6.51562, 0, 6.51562, 0, 6.51562, 2.84375, 6.51562, 2.84375);
+	NewLine.addQuadPoint(6.51562, 2.84375, 6.51562, 2.84375, 6.75, 3.125, 6.51562, 3.125);
+	NewLine.addQuadPoint(6.75, 3.125, 6.75, 3.125, 6.85938, 3.0625, 6.85938, 3.0625);
+	NewLine.addQuadPoint(6.85938, 3.0625, 6.85938, 3.0625, 6.875, 0, 6.875, 0);
+	Tab.resize(0);
+	Tab.addQuadPoint(4.82812, 3.96875, 4.82812, 3.96875, 4.5625, 3.73438, 4.5625, 3.96875);
+	Tab.addQuadPoint(4.5625, 3.73438, 4.5625, 3.73438, 5.07812, 3.10938, 4.5625, 3.57812);
+	Tab.addQuadPoint(5.07812, 3.10938, 5.07812, 3.10938, 0, 3.10938, 0, 3.10938);
+	Tab.addQuadPoint(0, 3.10938, 0, 3.10938, 0, 2.625, 0, 2.625);
+	Tab.addQuadPoint(0, 2.625, 0, 2.625, 5.53125, 2.625, 5.53125, 2.625);
+	Tab.addQuadPoint(5.53125, 2.625, 5.53125, 2.625, 6.3125, 1.8125, 6.3125, 1.8125);
+	Tab.addQuadPoint(6.3125, 1.8125, 6.3125, 1.8125, 5.64062, 1.29688, 5.64062, 1.29688);
+	Tab.addQuadPoint(5.64062, 1.29688, 5.64062, 1.29688, 0, 1.29688, 0, 1.29688);
+	Tab.addQuadPoint(0, 1.29688, 0, 1.29688, 0, 0.8125, 0, 0.8125);
+	Tab.addQuadPoint(0, 0.8125, 0, 0.8125, 5.01562, 0.8125, 5.01562, 0.8125);
+	Tab.addQuadPoint(5.01562, 0.8125, 5.01562, 0.8125, 4.45312, 0.265625, 4.45312, 0.453125);
+	Tab.addQuadPoint(4.45312, 0.265625, 4.45312, 0.265625, 4.6875, 0, 4.45312, 0);
+	Tab.addQuadPoint(4.6875, 0, 4.6875, 0, 5.90625, 0.828125, 4.875, 0);
+	Tab.addQuadPoint(5.90625, 0.828125, 5.90625, 0.828125, 6.9375, 1.79688, 6.9375, 1.64062);
+	Tab.addQuadPoint(6.9375, 1.79688, 6.9375, 1.79688, 5.95312, 2.96875, 6.9375, 1.95312);
+	Tab.addQuadPoint(5.95312, 2.96875, 5.95312, 2.96875, 4.82812, 3.96875, 4.98438, 3.96875);
+	NonBreak.resize(0);
+	NonBreak.addQuadPoint(1.32812, 2.59375, 1.32812, 2.59375, 0.390625, 2.21875, 0.796875, 2.59375);
+	NonBreak.addQuadPoint(0.390625, 2.21875, 0.390625, 2.21875, 0, 1.3125, 0, 1.84375);
+	NonBreak.addQuadPoint(0, 1.3125, 0, 1.3125, 0.390625, 0.390625, 0, 0.765625);
+	NonBreak.addQuadPoint(0.390625, 0.390625, 0.390625, 0.390625, 1.32812, 0, 0.796875, 0);
+	NonBreak.addQuadPoint(1.32812, 0, 1.32812, 0, 2.23438, 0.390625, 1.85938, 0);
+	NonBreak.addQuadPoint(2.23438, 0.390625, 2.23438, 0.390625, 2.60938, 1.29688, 2.60938, 0.765625);
+	NonBreak.addQuadPoint(2.60938, 1.29688, 2.60938, 1.29688, 2.23438, 2.21875, 2.60938, 1.84375);
+	NonBreak.addQuadPoint(2.23438, 2.21875, 2.23438, 2.21875, 1.32812, 2.59375, 1.875, 2.59375);
+	NewCol.resize(0);
+	NewCol.addQuadPoint(1.73438, 0, 1.73438, 0, 2.67188, 0.109375, 2.03125, 0);
+	NewCol.addQuadPoint(2.67188, 0.109375, 2.67188, 0.109375, 3.59375, 0.203125, 3.26562, 0.21875);
+	NewCol.addQuadPoint(3.59375, 0.203125, 3.59375, 0.203125, 3.79688, 0.1875, 3.64062, 0.203125);
+	NewCol.addQuadPoint(3.79688, 0.1875, 3.79688, 0.1875, 4, 0.171875, 3.92188, 0.171875);
+	NewCol.addQuadPoint(4, 0.171875, 4, 0.171875, 4.20312, 0.1875, 4.20312, 0.1875);
+	NewCol.addQuadPoint(4.20312, 0.1875, 4.20312, 0.1875, 4.3125, 1.39062, 4.20312, 0.5625);
+	NewCol.addQuadPoint(4.3125, 1.39062, 4.3125, 1.39062, 4.42188, 2.64062, 4.42188, 2.21875);
+	NewCol.addQuadPoint(4.42188, 2.64062, 4.42188, 2.64062, 4.28125, 2.73438, 4.28125, 2.73438);
+	NewCol.addQuadPoint(4.28125, 2.73438, 4.28125, 2.73438, 3.75, 1.03125, 4.01562, 2.64062);
+	NewCol.addQuadPoint(3.75, 1.03125, 3.75, 1.03125, 3.67188, 1.03125, 3.67188, 1.03125);
+	NewCol.addQuadPoint(3.67188, 1.03125, 3.67188, 1.03125, 0.28125, 6.20312, 0.28125, 6.20312);
+	NewCol.addQuadPoint(0.28125, 6.20312, 0.28125, 6.20312, 0, 5.95312, 0.03125, 6.17188);
+	NewCol.addQuadPoint(0, 5.95312, 0, 5.95312, 3.35938, 0.71875, 3.35938, 0.71875);
+	NewCol.addQuadPoint(3.35938, 0.71875, 3.35938, 0.71875, 3.375, 0.640625, 3.375, 0.640625);
+	NewCol.addQuadPoint(3.375, 0.640625, 3.375, 0.640625, 2.4375, 0.484375, 2.79688, 0.5625);
+	NewCol.addQuadPoint(2.4375, 0.484375, 2.4375, 0.484375, 1.67188, 0.140625, 1.71875, 0.328125);
+	NewCol.addQuadPoint(1.67188, 0.140625, 1.67188, 0.140625, 1.73438, 0, 1.73438, 0);
+	NewFrame.resize(0);
+	NewFrame.addQuadPoint(1.75, 6.20312, 1.75, 6.20312, 2.67188, 6.09375, 2.0625, 6.20312);
+	NewFrame.addQuadPoint(2.67188, 6.09375, 2.67188, 6.09375, 3.60938, 5.98438, 3.28125, 5.98438);
+	NewFrame.addQuadPoint(3.60938, 5.98438, 3.60938, 5.98438, 3.84375, 6.01562, 3.6875, 5.98438);
+	NewFrame.addQuadPoint(3.84375, 6.01562, 3.84375, 6.01562, 4.07812, 6.03125, 4, 6.03125);
+	NewFrame.addQuadPoint(4.07812, 6.03125, 4.07812, 6.03125, 4.20312, 6.01562, 4.20312, 6.01562);
+	NewFrame.addQuadPoint(4.20312, 6.01562, 4.20312, 6.01562, 4.32812, 4.79688, 4.21875, 5.625);
+	NewFrame.addQuadPoint( 4.32812, 4.79688, 4.32812, 4.79688, 4.42188, 3.5625, 4.42188, 3.98438);
+	NewFrame.addQuadPoint(4.42188, 3.5625, 4.42188, 3.5625, 4.29688, 3.45312, 4.29688, 3.45312);
+	NewFrame.addQuadPoint(4.29688, 3.45312, 4.29688, 3.45312, 3.75, 5.17188, 4.03125, 3.54688);
+	NewFrame.addQuadPoint(3.75, 5.17188, 3.75, 5.17188, 3.67188, 5.17188, 3.67188, 5.17188);
+	NewFrame.addQuadPoint(3.67188, 5.17188, 3.67188, 5.17188, 0.28125, 0, 0.28125, 0);
+	NewFrame.addQuadPoint(0.28125, 0, 0.28125, 0, 0, 0.25, 0.03125, 0.015625);
+	NewFrame.addQuadPoint(0, 0.25, 0, 0.25, 3.375, 5.46875, 3.375, 5.46875);
+	NewFrame.addQuadPoint(3.375, 5.46875, 3.375, 5.46875, 3.39062, 5.54688, 3.39062, 5.54688);
+	NewFrame.addQuadPoint(3.39062, 5.54688, 3.39062, 5.54688, 2.4375, 5.70312, 2.8125, 5.625);
+	NewFrame.addQuadPoint(2.4375, 5.70312, 2.4375, 5.70312, 1.67188, 6.0625, 1.71875, 5.875);
+	NewFrame.addQuadPoint(1.67188, 6.0625, 1.67188, 6.0625, 1.75, 6.20312, 1.75, 6.20312);
+}
+
 
 bool SpecialChars::isBreakingSpace(QChar c)
 {
-	return c == BLANK || c == ZWSPACE;
+//	return c == BLANK || c == ZWSPACE;
+	return c.isSpace() && (c != NBSPACE);
 }
 
 bool SpecialChars::isExpandingSpace(QChar c)
 {
-	return c == BLANK || c == NBSPACE;
+//	return c == BLANK || c == NBSPACE;
+	return c.isSpace() && (c != ZWSPACE);
 }
 
 bool SpecialChars::isBreak(QChar c, bool includeColBreak)
diff -Naur Scribus_1.5_120815/scribus/text/specialchars.h Scribus_1.5_indic/scribus/text/specialchars.h
--- Scribus_1.5_120815/scribus/text/specialchars.h	2012-08-15 11:01:59.307825464 +0530
+++ Scribus_1.5_indic/scribus/text/specialchars.h	2012-08-15 13:42:46.197094544 +0530
@@ -10,7 +10,10 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
-	***************************************************************************/
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
+***************************************************************************/
 
 /***************************************************************************
 *                                                                         *
@@ -28,10 +31,16 @@
 
 #include <QString>
 #include "scribusapi.h"
+#include "fpointarray.h"
+
+
 
 class SCRIBUS_API SpecialChars {
 public:
 	static QChar OBJECT;
+	static QChar START_TAG;
+	static QChar END_TAG;
+	static QChar EMPTY_TAG;
 	static QChar TAB;
 	static QChar PARSEP;
 	static QChar LINEBREAK;
@@ -51,29 +60,43 @@
 	static bool isBreak(QChar c, bool includeColBreak = true);
 	static bool isBreakingSpace(QChar c);
 	static bool isExpandingSpace(QChar c);
-
-		enum {
-			CJK_FENCE_BEGIN = 0x0001,
-			CJK_FENCE_END = 0x0002,
-			CJK_NOTOP = 0x0003,
-			CJK_HYPHEN = 0x0004,
-			CJK_DELMITER = 0x0005,
-			CJK_MIDPOINT = 0x0006,
-			CJK_PERIOD = 0x0007,
-			CJK_COMMA = 0x0008,
-			CJK_BETWEEN = 0x0009,
-			CJK_PREFIX = 0x000a,
-			CJK_POSTFIX = 0x000b,
-			CJK_SPACE = 0x000c,
-			CJK_KANA = 0x000d,
-			CJK_KANJI = 0x000e,
-
-			CJK_CHAR_MASK = 0x00ff,
-
-			CJK_NOBREAK_BEFORE = 0x0100,
-			CJK_NOBREAK_AFTER = 0x0200,
-		};
-		static int getCJKAttr(QChar c);
+	
+	class SymbolGlyphs
+	{
+		friend class SpecialChars;
+		SymbolGlyphs();
+	public:
+		FPointArray Return;
+		FPointArray NewLine;
+		FPointArray Tab;
+		FPointArray NonBreak;
+		FPointArray NewCol;
+		FPointArray NewFrame;		
+	};
+
+	static SymbolGlyphs symbols;
+	enum {
+		CJK_FENCE_BEGIN = 0x0001,
+		CJK_FENCE_END = 0x0002,
+		CJK_NOTOP = 0x0003,
+		CJK_HYPHEN = 0x0004,
+		CJK_DELMITER = 0x0005,
+		CJK_MIDPOINT = 0x0006,
+		CJK_PERIOD = 0x0007,
+		CJK_COMMA = 0x0008,
+		CJK_BETWEEN = 0x0009,
+		CJK_PREFIX = 0x000a,
+		CJK_POSTFIX = 0x000b,
+		CJK_SPACE = 0x000c,
+		CJK_KANA = 0x000d,
+		CJK_KANJI = 0x000e,
+
+		CJK_CHAR_MASK = 0x00ff,
+
+		CJK_NOBREAK_BEFORE = 0x0100,
+		CJK_NOBREAK_AFTER = 0x0200,
+	};
+	static int getCJKAttr(QChar c);
 };
 
 #endif
diff -Naur Scribus_1.5_120815/scribus/text/storytext.cpp Scribus_1.5_indic/scribus/text/storytext.cpp
--- Scribus_1.5_120815/scribus/text/storytext.cpp	2012-08-15 11:01:59.306825464 +0530
+++ Scribus_1.5_indic/scribus/text/storytext.cpp	2012-08-15 13:32:27.788077258 +0530
@@ -10,6 +10,9 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
 ***************************************************************************/
 
 /***************************************************************************
@@ -48,6 +51,7 @@
 	else {
 		d = new ScText_Shared(NULL);
 	}
+//	m_glyphStore = new GlyphStore(this);
 	selFirst = 0;
 	selLast = -1;
 	
@@ -55,6 +59,7 @@
 	lastFrameItem = -1;
 	m_magicX = 0.0;
 	m_lastMagicPos = -1;
+	nOfGlyphs = 0;
 	
 	d->len = 0;
 	invalidateAll();
@@ -63,9 +68,11 @@
 StoryText::StoryText() : doc(NULL)
 {
 	d = new ScText_Shared(NULL);
+	//m_glyphStore = new GlyphStore(this);
 
 	selFirst = 0;
 	selLast = -1;
+	nOfGlyphs = 0;
 	
 	firstFrameItem = 0;
 	lastFrameItem = -1;
@@ -76,6 +83,7 @@
 StoryText::StoryText(const StoryText & other) : QObject(), SaxIO(), doc(other.doc)
 {
 	d = other.d;
+	//m_glyphStore = new GlyphStore(this);
 	d->refs++;
 	
 	if(doc) {
@@ -85,6 +93,7 @@
 	
 	selFirst = 0;
 	selLast = -1;
+	nOfGlyphs = 0;
 	
 	firstFrameItem = 0;
 	lastFrameItem = -1;
@@ -152,6 +161,7 @@
 	
 	firstFrameItem = 0;
 	lastFrameItem = -1;
+	nOfGlyphs = 0;
 
 	invalidateLayout();
 	return *this;
@@ -192,6 +202,9 @@
 
 	d->clear();
 	d->len = 0;
+	nOfGlyphs = 0;
+	clearAllItems(0);
+	m_items.clear();
 	invalidateAll();
 }
 
@@ -293,6 +306,7 @@
 {
 	if (pos < 0)
 		pos += length()+1;
+     nOfGlyphs++ ;
 	
 	CharStyle cstyle(charStyle(pos));
 	ParagraphStyle pstyle(paragraphStyle(pos));
@@ -372,6 +386,7 @@
 //		it->parstyle->charStyle().setContext( d->defaultStyle.charStyleContext() );
 	}
 	d->replaceCharStyleContextInParagraph(pos, it->parstyle->charStyleContext());
+     nOfGlyphs++ ;
 }
 /**
      need to remove the ParagraphStyle structure and replace all pointers
@@ -391,6 +406,7 @@
 	// doesnt choke:
 	it->ch = 0;
 	d->replaceCharStyleContextInParagraph(pos, paragraphStyle(pos+1).charStyleContext());	
+     nOfGlyphs-- ;
 }
 
 void StoryText::removeChars(int pos, uint len)
@@ -661,7 +677,7 @@
 	result.reserve(len);
 
 	StoryText* that(const_cast<StoryText*>(this));
-	for (int i = 0; i < len; ++i) {
+	for (uint i = 0; i < len; ++i) {
 		ch = that->d->at(i)->ch;
 		if (ch == SpecialChars::PARSEP)
 			ch = QLatin1Char('\n');
@@ -735,6 +751,17 @@
 	return result;
 }
 
+//TextFlags& StoryText::charAttributes(int pos)
+//{
+//        return d->charAttributes(pos);
+//}
+//
+//
+//const TextFlags& StoryText::charAttributes(int pos) const
+//{
+//        return d->charAttributes(pos);
+//}
+
 bool StoryText::hasObject(int pos) const
 {
 	if (pos < 0)
@@ -779,7 +806,7 @@
 		return defaultStyle().charStyle();
 	}
 	else if (pos == length()) {
-		qDebug() << "storytext::charstyle: access at end of text %i" << pos;
+//		qDebug() << "storytext::charstyle: access at end of text %i" << pos;
 		--pos;
 	}
 	if (text(pos) == SpecialChars::PARSEP)
@@ -817,7 +844,7 @@
 	}
 	else if ( !that->d->at(pos)->parstyle ) {
 		ScText* current = that->d->at(pos);
-		qDebug("inserting default parstyle at %i", pos);
+		qDebug("(%s)(%i)inserting default parstyle at %i ",__FILE__, __LINE__, pos);
 		current->parstyle = new ParagraphStyle();
 		current->parstyle->setContext( & d->pstyleContext);
 //		current->parstyle->setName( "para(paragraphStyle)" ); // DONT TRANSLATE
@@ -1335,7 +1362,7 @@
 	int tmpPosEnd = qMin(len, pos+1);
 	while (tmpPosEnd < len  && wordBoundaries.indexOf(text(tmpPosEnd)) < 0)
 	{
-		qDebug()<<tmpPosEnd<<text(tmpPosEnd)<<wordBoundaries.indexOf(text(tmpPosEnd));
+		//qDebug()<<tmpPosEnd<<text(tmpPosEnd)<<wordBoundaries.indexOf(text(tmpPosEnd));
 		++tmpPosEnd;
 	}
 	int endWordPos=tmpPosEnd < len ? tmpPosEnd + 1 : tmpPosEnd;
@@ -1751,6 +1778,7 @@
 
 int StoryText::layout(int startItem)
 {
+printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,startItem) ;
 	//FIXME:NLS
 	return -1;
 }
@@ -1943,7 +1971,7 @@
 				if (toInsert > 0)
 					obj->insertChars(obj->length(), txt.mid(lastPos, toInsert));
 				len = obj->length();
-				ScText* lastItem = obj->item(len-1);
+				ScText* lastItem = obj->item_p(len-1);
 				// qreal SHY means user provided SHY, single SHY is automatic one
 				if (lastItem->effects() & ScStyle_HyphenationPossible)
 				{
@@ -2103,7 +2131,7 @@
 		if (lastStyle)
 			delete lastStyle;
 	}
-
+	
 	virtual void reset()
 	{
 		numPara = 0;
@@ -2254,3 +2282,161 @@
 	ruleset.addRule(Digester::concat(spanPrefix, "item"), AppendInlineFrame() );
 	
 }
+
+uint StoryText::addItem(int pos, uint len)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	int end = m_glyphs.count();
+	m_glyphs.reserve(end + len);
+	m_items.append(ItemData(pos, len, end));
+	return m_items.count() - 1;
+}
+
+void StoryText::clearItem(uint i)
+{
+printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	m_items[i].glyphCount = 0;
+}
+
+
+void StoryText::clearAllItems(uint firstItem)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	if(firstItem >= m_items.count())
+		return;
+	int end = m_items[firstItem].glyphIndex;
+	m_glyphs.resize(end);
+	for (int i=firstItem; i < m_items.count(); ++i)
+	{
+		m_items[i].glyphIndex = end;
+		m_items[i].glyphCount = 0;
+	}			 
+}
+
+
+void StoryText::deleteItem(uint i)
+{
+printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	clearItem(i);
+	m_items.removeAt(i);
+}
+
+void StoryText::deleteItems(QList<uint> li)
+{
+printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	foreach(uint it,  li)
+	{
+		clearItem(it);
+	}
+	QList<ItemData> tmpStore(m_items);
+	m_items.clear();
+	for(uint it(0); it < tmpStore.length() ; ++it)
+	{
+		if(!li.contains(it))
+			m_items << tmpStore[it];
+	}
+}
+
+
+uint StoryText::findItem(int pos) const
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	for (uint i=0; i < unsigned(m_items.count()); ++i)
+	{
+		StoryText::ItemData it = m_items[i];
+		if (it.textPosition <= pos && pos < it.textPosition + signed(it.charCount))
+			return i;
+	}
+	return unsigned(m_items.count());		
+}
+
+QList<uint> StoryText::findItems(int start, int end) const
+{
+printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	QList<uint> ret;
+	bool first(true);
+	for (uint i=0; i < unsigned(m_items.count()); ++i)
+	{
+		StoryText::ItemData it = m_items[i];
+		if(first)
+		{
+			if (it.textPosition <= start && start < it.textPosition + signed(it.charCount))
+			{
+				ret << i;
+				first = false;
+			}
+		}
+		else
+		{
+			if((it.textPosition + signed(it.charCount)) < end)
+				ret << i;
+			else
+			{
+				ret << i;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+
+uint StoryText::itemGlyphCount(uint i) const
+{
+	return m_items[i].glyphCount;
+}
+
+void StoryText::itemSetGlyphCount(uint i, int n)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+	ItemData& item(m_items[i]);
+	int delta = n - item.glyphCount;
+	if (delta < 0)
+	{
+		m_glyphs.remove(item.glyphIndex + n, -delta);
+	}
+	else if (delta > 0)
+	{
+		if (signed(item.glyphIndex) == m_glyphs.count())
+		{
+			m_glyphs.resize(m_glyphs.count() + delta);
+		}
+		else
+		{
+			m_glyphs.insert(item.glyphIndex + item.glyphCount, delta, GlyphLayout());
+		}
+	}
+	item.glyphCount = n;
+	for (int j = i+1; j < m_items.count(); ++j)
+	{
+		m_items[j].glyphIndex += delta;
+	}
+}
+
+
+GlyphLayout* StoryText::itemGlyphStart(uint i)
+{
+	return m_glyphs.data() + m_items[i].glyphIndex;
+}
+
+const GlyphLayout* StoryText::itemGlyphStart(uint i) const
+{
+	return m_glyphs.constData() + m_items[i].glyphIndex;
+}
+
+	
+int StoryText::itemTextPosition(uint i) const
+{
+	return m_items[i].textPosition;
+}
+
+uint StoryText::itemCharCount(uint i) const
+{
+	return m_items[i].charCount;
+}
+
+uint StoryText::itemCount() const
+{
+	return m_items.count();
+}
+
diff -Naur Scribus_1.5_120815/scribus/text/storytext.h Scribus_1.5_indic/scribus/text/storytext.h
--- Scribus_1.5_120815/scribus/text/storytext.h	2012-08-15 11:01:59.309825464 +0530
+++ Scribus_1.5_indic/scribus/text/storytext.h	2012-08-15 13:32:42.034077647 +0530
@@ -10,7 +10,10 @@
     begin                : Sat Apr 7 2001
     copyright            : (C) 2001 by Franz Schmid
     email                : Franz.Schmid@altmuehlnet.de
-	***************************************************************************/
+
+    Modified for Indic unicode support , Aug 2012 
+	by 	: Anilkumar KV,  Email: anilankv@gmail.com
+***************************************************************************/
 
 /***************************************************************************
 *                                                                         *
@@ -88,8 +91,18 @@
 class SCRIBUS_API StoryText : public QObject, public SaxIO
 {
 	Q_OBJECT
+	struct ItemData {
+		int textPosition;
+		uint charCount;
+		uint glyphIndex;
+		uint glyphCount;
+		ItemData(int p, uint c, uint i, uint g=0): textPosition(p), charCount(c), glyphIndex(i), glyphCount(g) {}
+	};
+	QVector<GlyphLayout> m_glyphs;
+	QList<ItemData> m_items;
 	
  public:
+        int nOfGlyphs ;
 	StoryText(ScribusDoc *doc);
  	StoryText();
  	StoryText(const StoryText & other);
@@ -100,7 +113,7 @@
 	static const Xml_string saxxDefaultElem;
 	static void  desaxeRules(const Xml_string& prefixPattern, desaxe::Digester& ruleset, Xml_string elemtag = saxxDefaultElem);
 	
-	virtual void saxx(SaxHandler& handler, const Xml_string& elemtag) const;
+	virtual void saxx(SaxHandler& handler, const Xml_string& elemtag) const ;
 	virtual void saxx(SaxHandler& handler)                     const { saxx(handler, saxxDefaultElem); }
 	
 	int  cursorPosition() const;
@@ -334,6 +347,21 @@
 	int firstInFrame() { return firstFrameItem; }
 	int lastInFrame() { return lastFrameItem; }
 
+	uint addItem(int pos, uint len) ;
+	void clearItem(uint i) ;
+	void clearAllItems(uint firstItem) ;
+	void deleteItem(uint i) ;
+	void deleteItems(QList<uint> li) ;
+	uint findItem(int pos) const ;
+	QList<uint> findItems(int start, int end) const ;
+	uint itemGlyphCount(uint i) const ;
+	void itemSetGlyphCount(uint i, int n) ;
+	GlyphLayout* itemGlyphStart(uint i) ;
+	const GlyphLayout* itemGlyphStart(uint i) const ;
+	int itemTextPosition(uint i) const ;
+	uint itemCharCount(uint i) const ;
+        uint itemCount() const ;
+
 private:
 	ScribusDoc * doc; 
 	int selFirst, selLast;
diff -Naur Scribus_1.5_120815/scribus/third_party/CMakeLists.txt Scribus_1.5_indic/scribus/third_party/CMakeLists.txt
--- Scribus_1.5_120815/scribus/third_party/CMakeLists.txt	2012-08-15 11:01:53.617825306 +0530
+++ Scribus_1.5_indic/scribus/third_party/CMakeLists.txt	2012-08-15 13:00:26.857023419 +0530
@@ -13,3 +13,7 @@
 ADD_SUBDIRECTORY(wpg)
 
 ADD_SUBDIRECTORY(pgf)
+
+ADD_SUBDIRECTORY(harfbuzz/src)
+ADD_SUBDIRECTORY(fribidi)
+
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/CMakeLists.txt Scribus_1.5_indic/scribus/third_party/fribidi/CMakeLists.txt
--- Scribus_1.5_120815/scribus/third_party/fribidi/CMakeLists.txt	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/CMakeLists.txt	2012-05-05 23:46:50.945763780 +0530
@@ -0,0 +1,36 @@
+# FRIBIDI
+
+# Note that we have pre-generated include files "fribidi_tab_char_type*" and "fribidi_tab_mirroring.i" as
+# the formers need `sed` to be generated and we don't want to have this dep on some platforms
+
+# In fribidi_config.h, we defined FRIBIDI_NO_CHARSETS to 1
+
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+SET(LIB_TYPE STATIC)
+
+SET( FRIBIDI_SRCS
+	fribidi.c
+	fribidi_types.c
+	fribidi_mem.c
+	fribidi_mirroring.c
+	fribidi_char_type.c
+	fribidi_utils.c
+	wcwidth.c
+)
+
+ADD_DEFINITIONS(-DHAS_FRIBIDI_TAB_CHAR_TYPE_9_I)
+
+SET(SCRIBUS_FRIBIDI_LIB "scribus_fribidi_lib")
+ADD_LIBRARY(${SCRIBUS_FRIBIDI_LIB} STATIC ${FRIBIDI_SRCS})
+
+
+# This is a convenience library that for linkage purposes is part of Scribus's
+# main API.
+SET_TARGET_PROPERTIES(${SCRIBUS_FRIBIDI_LIB}
+  PROPERTIES
+  COMPILE_FLAGS -DCOMPILE_SCRIBUS_MAIN_APP
+  )
+
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/COPYING Scribus_1.5_indic/scribus/third_party/fribidi/COPYING
--- Scribus_1.5_120815/scribus/third_party/fribidi/COPYING	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/COPYING	2012-05-05 23:46:50.943763780 +0530
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_bidi_types.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_bidi_types.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_bidi_types.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_bidi_types.c	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,15 @@
+#include <stdio.h>
+#include <fribidi.h>
+
+int
+main (void)
+{
+
+  FriBidiChar c;
+
+  for (c = 0; c < FRIBIDI_UNICODE_CHARS; c++)
+    printf ("0x%04lx	%s\n", (long) c,
+	    fribidi_type_name (fribidi_get_type (c)));
+
+  return 0;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi.c	2012-05-05 23:46:50.941763780 +0530
@@ -0,0 +1,1453 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 1999,2000 Dov Grobgeld, and
+ * Copyright (C) 2001,2002 Behdad Esfahbod.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public  
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,  
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of   
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License  
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <dov@imagic.weizmann.ac.il> and
+ * <fwpg@sharif.edu>.
+ */
+
+#include <stdlib.h>
+
+#ifdef HAVE_CONFIG_H
+//#include <config.h>
+#endif
+#include "fribidi.h"
+#include "fribidi_mem.h"
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+/* Redefine FRIBIDI_CHUNK_SIZE in config.h to override this. */
+#ifndef FRIBIDI_CHUNK_SIZE
+#ifdef MEM_OPTIMIZED
+#define FRIBIDI_CHUNK_SIZE 16
+#else
+#define FRIBIDI_CHUNK_SIZE 128
+#endif
+#endif
+
+#ifdef DEBUG
+#define DBG(s) do { if (fribidi_debug) { fprintf(stderr, s); } } while (0)
+#define DBG2(s, t) do { if (fribidi_debug) { fprintf(stderr, s, t); } } while (0)
+#else
+#define DBG(s)
+#define DBG2(s, t)
+#endif
+
+#ifdef DEBUG
+char fribidi_char_from_type (FriBidiCharType c);
+#endif
+
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+
+/*======================================================================
+ * Typedef for the run-length list.
+ *----------------------------------------------------------------------*/
+typedef struct _TypeLink TypeLink;
+
+struct _TypeLink
+{
+  TypeLink *prev;
+  TypeLink *next;
+
+  FriBidiCharType type;
+  FriBidiStrIndex pos, len;
+  FriBidiLevel level;
+};
+
+#define FRIBIDI_LEVEL_START   -1
+#define FRIBIDI_LEVEL_END     -1
+#define FRIBIDI_LEVEL_REMOVED -2
+
+typedef struct
+{
+  FriBidiCharType override;	/* only L, R and N are valid */
+  FriBidiLevel level;
+}
+LevelInfo;
+
+#ifdef DEBUG
+static fribidi_boolean fribidi_debug = FRIBIDI_FALSE;
+#endif
+
+fribidi_boolean
+fribidi_set_debug (fribidi_boolean debug)
+{
+#ifdef DEBUG
+  fribidi_debug = debug;
+#else
+  debug = 0;
+#endif
+  return debug;
+}
+
+static void
+bidi_string_reverse (FriBidiChar *str,
+		     FriBidiStrIndex len)
+{
+  FriBidiStrIndex i;
+  for (i = 0; i < len / 2; i++)
+    {
+      FriBidiChar tmp = str[i];
+      str[i] = str[len - 1 - i];
+      str[len - 1 - i] = tmp;
+    }
+}
+
+static void
+index_array_reverse (FriBidiStrIndex *arr,
+		     FriBidiStrIndex len)
+{
+  FriBidiStrIndex i;
+  for (i = 0; i < len / 2; i++)
+    {
+      FriBidiStrIndex tmp = arr[i];
+      arr[i] = arr[len - 1 - i];
+      arr[len - 1 - i] = tmp;
+    }
+}
+
+#ifndef USE_SIMPLE_MALLOC
+static TypeLink *free_type_links = NULL;
+#endif
+
+static TypeLink *
+new_type_link (void)
+{
+  TypeLink *link;
+
+#ifdef USE_SIMPLE_MALLOC
+  link = malloc (sizeof (TypeLink));
+#else /* !USE_SIMPLE_MALLOC */
+  if (free_type_links)
+    {
+      link = free_type_links;
+      free_type_links = free_type_links->next;
+    }
+  else
+    {
+      static FriBidiMemChunk *mem_chunk = NULL;
+
+      if (!mem_chunk)
+	mem_chunk = fribidi_mem_chunk_create (TypeLink,
+					      FRIBIDI_CHUNK_SIZE,
+					      FRIBIDI_ALLOC_ONLY);
+
+      link = fribidi_chunk_new (TypeLink,
+				mem_chunk);
+    }
+#endif /* !USE_SIMPLE_MALLOC */
+
+  link->len = 0;
+  link->pos = 0;
+  link->level = 0;
+  link->next = NULL;
+  link->prev = NULL;
+  return link;
+}
+
+static void
+free_type_link (TypeLink *link)
+{
+#ifdef USE_SIMPLE_MALLOC
+  free (link);
+#else
+  link->next = free_type_links;
+  free_type_links = link;
+#endif
+}
+
+#define FRIBIDI_ADD_TYPE_LINK(p,q) \
+	do {	\
+		(p)->len = (q)->pos - (p)->pos;	\
+		(p)->next = (q);	\
+		(q)->prev = (p);	\
+		(p) = (q);	\
+	} while (0)
+
+static TypeLink *
+run_length_encode_types (FriBidiCharType *char_type,
+			 FriBidiStrIndex type_len)
+{
+  TypeLink *list, *last, *link;
+
+  FriBidiStrIndex i;
+
+  /* Add the starting link */
+  list = new_type_link ();
+  list->type = FRIBIDI_TYPE_SOT;
+  list->level = FRIBIDI_LEVEL_START;
+  last = list;
+
+  /* Sweep over the string_type s */
+  for (i = 0; i < type_len; i++)
+    if (char_type[i] != last->type)
+      {
+	link = new_type_link ();
+	link->type = char_type[i];
+	link->pos = i;
+	FRIBIDI_ADD_TYPE_LINK (last, link);
+      }
+
+  /* Add the ending link */
+  link = new_type_link ();
+  link->type = FRIBIDI_TYPE_EOT;
+  link->level = FRIBIDI_LEVEL_END;
+  link->pos = type_len;
+  FRIBIDI_ADD_TYPE_LINK (last, link);
+
+  return list;
+}
+
+/* explicits_list is a list like type_rl_list, that holds the explicit
+   codes that are removed from rl_list, to reinsert them later by calling
+   the override_list.
+*/
+static void
+init_list (TypeLink **start,
+	   TypeLink **end)
+{
+  TypeLink *list;
+  TypeLink *link;
+
+  /* Add the starting link */
+  list = new_type_link ();
+  list->type = FRIBIDI_TYPE_SOT;
+  list->level = FRIBIDI_LEVEL_START;
+  list->len = 0;
+  list->pos = 0;
+
+  /* Add the ending link */
+  link = new_type_link ();
+  link->type = FRIBIDI_TYPE_EOT;
+  link->level = FRIBIDI_LEVEL_END;
+  link->len = 0;
+  link->pos = 0;
+  list->next = link;
+  link->prev = list;
+
+  *start = list;
+  *end = link;
+}
+
+/* move an element before another element in a list, the list must have a
+   previous element, used to update explicits_list.
+   assuming that p have both prev and next or none of them, also update
+   the list that p is currently in, if any.
+*/
+static void
+move_element_before (TypeLink *p,
+		     TypeLink *list)
+{
+  if (p->prev)
+    {
+      p->prev->next = p->next;
+      p->next->prev = p->prev;
+    }
+  p->prev = list->prev;
+  list->prev->next = p;
+  p->next = list;
+  list->prev = p;
+}
+
+/* override the rl_list 'base', with the elements in the list 'over', to
+   reinsert the previously-removed explicit codes (at X9) from
+   'explicits_list' back into 'type_rl_list'. This is used at the end of I2
+   to restore the explicit marks, and also to reset the character types of
+   characters at L1.
+
+   it is assumed that the 'pos' of the first element in 'base' list is not
+   more than the 'pos' of the first element of the 'over' list, and the
+   'pos' of the last element of the 'base' list is not less than the 'pos'
+   of the last element of the 'over' list. these two conditions are always
+   satisfied for the two usages mentioned above.
+
+   TBD: use some explanatory names instead of p, q, ...
+*/
+static void
+override_list (TypeLink *base,
+	       TypeLink *over)
+{
+  TypeLink *p = base, *q, *r, *s, *t;
+  FriBidiStrIndex pos = 0, pos2;
+
+  if (!over)
+    return;
+  q = over;
+  while (q)
+    {
+      if (!q->len || q->pos < pos)
+	{
+	  t = q;
+	  q = q->next;
+	  free_type_link (t);
+	  continue;
+	}
+      pos = q->pos;
+      while (p->next && p->next->pos <= pos)
+	p = p->next;
+      /* now p is the element that q must be inserted 'in'. */
+      pos2 = pos + q->len;
+      r = p;
+      while (r->next && r->next->pos < pos2)
+	r = r->next;
+      /* now r is the last element that q affects. */
+      if (p == r)
+	{
+	  /* split p into at most 3 interval, and insert q in the place of
+	     the second interval, set r to be the third part. */
+	  /* third part needed? */
+	  if (p->next && p->next->pos == pos2)
+	    r = r->next;
+	  else
+	    {
+	      r = new_type_link ();
+	      *r = *p;
+	      if (r->next)
+		{
+		  r->next->prev = r;
+		  r->len = r->next->pos - pos2;
+		}
+	      else
+		r->len -= pos - p->pos;
+	      r->pos = pos2;
+	    }
+	  /* first part needed? */
+	  if (p->prev && p->pos == pos)
+	    {
+	      t = p;
+	      p = p->prev;
+	      free_type_link (t);
+	    }
+	  else
+	    p->len = pos - p->pos;
+	}
+      else
+	{
+	  /* cut the end of p. */
+	  p->len = pos - p->pos;
+	  /* if all of p is cut, remove it. */
+	  if (!p->len && p->prev)
+	    p = p->prev;
+
+	  /* cut the begining of r. */
+	  r->pos = pos2;
+	  if (r->next)
+	    r->len = r->next->pos - pos2;
+	  /* if all of r is cut, remove it. */
+	  if (!r->len && r->next)
+	    r = r->next;
+
+	  /* remove the elements between p and r. */
+	  for (s = p->next; s != r;)
+	    {
+	      t = s;
+	      s = s->next;
+	      free_type_link (t);
+	    }
+	}
+      /* before updating the next and prev links to point to the inserted q,
+         we must remember the next element of q in the 'over' list.
+       */
+      t = q;
+      q = q->next;
+      p->next = t;
+      t->prev = p;
+      t->next = r;
+      r->prev = t;
+    }
+}
+
+/* Some convenience macros */
+#define RL_TYPE(list) ((list)->type)
+#define RL_LEN(list) ((list)->len)
+#define RL_POS(list) ((list)->pos)
+#define RL_LEVEL(list) ((list)->level)
+
+static TypeLink *
+merge_with_prev (TypeLink *second)
+{
+  TypeLink *first = second->prev;
+  first->next = second->next;
+  first->next->prev = first;
+  RL_LEN (first) += RL_LEN (second);
+  free_type_link (second);
+  return first;
+}
+
+static void
+compact_list (TypeLink *list)
+{
+  if (list->next)
+    for (list = list->next; list; list = list->next)
+      if (RL_TYPE (list->prev) == RL_TYPE (list)
+	  && RL_LEVEL (list->prev) == RL_LEVEL (list))
+	list = merge_with_prev (list);
+}
+
+static void
+compact_neutrals (TypeLink *list)
+{
+  if (list->next)
+    {
+      for (list = list->next; list; list = list->next)
+	{
+	  if (RL_LEVEL (list->prev) == RL_LEVEL (list)
+	      &&
+	      ((RL_TYPE
+		(list->prev) == RL_TYPE (list)
+		|| (FRIBIDI_IS_NEUTRAL (RL_TYPE (list->prev))
+		    && FRIBIDI_IS_NEUTRAL (RL_TYPE (list))))))
+	    list = merge_with_prev (list);
+	}
+    }
+}
+
+/*=========================================================================
+ * define macros for push and pop the status in to / out of the stack
+ *-------------------------------------------------------------------------*/
+
+/* There's some little points in pushing and poping into the status stack:
+   1. when the embedding level is not valid (more than UNI_MAX_BIDI_LEVEL=61),
+   you must reject it, and not to push into the stack, but when you see a
+   PDF, you must find the matching code, and if it was pushed in the stack,
+   pop it, it means you must pop if and only if you have pushed the
+   matching code, the over_pushed var counts the number of rejected codes yet.
+   2. there's a more confusing point too, when the embedding level is exactly
+   UNI_MAX_BIDI_LEVEL-1=60, an LRO or LRE must be rejected because the new
+   level would be UNI_MAX_BIDI_LEVEL+1=62, that is invalid, but an RLO or RLE
+   must be accepted because the new level is UNI_MAX_BIDI_LEVEL=61, that is
+   valid, so the rejected codes may be not continuous in the logical order,
+   in fact there is at most two continuous intervals of codes, with a RLO or
+   RLE between them.  To support this case, the first_interval var counts the
+   number of rejected codes in the first interval, when it is 0, means that
+   there is only one interval yet.
+*/
+
+/* a. If this new level would be valid, then this embedding code is valid.
+   Remember (push) the current embedding level and override status.
+   Reset current level to this new level, and reset the override status to
+   new_override.
+   b. If the new level would not be valid, then this code is invalid. Don't
+   change the current level or override status.
+*/
+#define PUSH_STATUS \
+    do { \
+      if (new_level <= UNI_MAX_BIDI_LEVEL) \
+        { \
+          if (level == UNI_MAX_BIDI_LEVEL - 1) \
+            first_interval = over_pushed; \
+          status_stack[stack_size].level = level; \
+          status_stack[stack_size].override = override; \
+          stack_size++; \
+          level = new_level; \
+          override = new_override; \
+        } else \
+	  over_pushed++; \
+    } while (0)
+
+/* If there was a valid matching code, restore (pop) the last remembered
+   (pushed) embedding level and directional override.
+*/
+#define POP_STATUS \
+    do { \
+      if (over_pushed || stack_size) \
+      { \
+        if (over_pushed > first_interval) \
+          over_pushed--; \
+        else \
+          { \
+            if (over_pushed == first_interval) \
+              first_interval = 0; \
+            stack_size--; \
+            level = status_stack[stack_size].level; \
+            override = status_stack[stack_size].override; \
+          } \
+      } \
+    } while (0)
+
+/*==========================================================================
+ * There was no support for sor and eor in the absence of Explicit Embedding
+ * Levels, so define macros, to support them, with as less change as needed.
+ *--------------------------------------------------------------------------*/
+
+/* Return the type of previous char or the sor, if already at the start of
+   a run level. */
+#define PREV_TYPE_OR_SOR(pp) \
+    ( \
+     RL_LEVEL(pp->prev) == RL_LEVEL(pp) ? \
+      RL_TYPE(pp->prev) : \
+      FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->prev), RL_LEVEL(pp))) \
+    )
+
+/* Return the type of next char or the eor, if already at the end of
+   a run level. */
+#define NEXT_TYPE_OR_EOR(pp) \
+    ( \
+     !pp->next ? \
+      FRIBIDI_LEVEL_TO_DIR(RL_LEVEL(pp)) : \
+      (RL_LEVEL(pp->next) == RL_LEVEL(pp) ? \
+        RL_TYPE(pp->next) : \
+        FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(pp->next), RL_LEVEL(pp))) \
+      ) \
+    )
+
+
+/* Return the embedding direction of a link. */
+#define FRIBIDI_EMBEDDING_DIRECTION(list) \
+    FRIBIDI_LEVEL_TO_DIR(RL_LEVEL(list))
+
+#ifdef DEBUG
+/*======================================================================
+ *  For debugging, define some functions for printing the types and the
+ *  levels.
+ *----------------------------------------------------------------------*/
+
+static char char_from_level_array[] = {
+  'e',				/* FRIBIDI_LEVEL_REMOVED, internal error, this level shouldn't be viewed.  */
+  '_',				/* FRIBIDI_LEVEL_START or _END, indicating start of string and end of string. */
+  /* 0-9,A-F are the only valid levels in debug mode and before resolving
+     implicits. after that the levels X, Y, Z may be appear too. */
+  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+  'A', 'B', 'C', 'D', 'E', 'F',
+  'X', 'Y', 'Z',		/* only must appear after resolving implicits. */
+  'o', 'o', 'o'			/* overflows, this levels and higher levels show a bug!. */
+};
+
+#define fribidi_char_from_level(level) char_from_level_array[(level) + 2]
+
+static void
+print_types_re (TypeLink *pp)
+{
+  fprintf (stderr, "  Run types  : ");
+  while (pp)
+    {
+      fprintf (stderr, "%d:l%d(%s)[%d] ",
+	       pp->pos, pp->len, fribidi_type_name (pp->type), pp->level);
+      pp = pp->next;
+    }
+  fprintf (stderr, "\n");
+}
+
+static void
+print_resolved_levels (TypeLink *pp)
+{
+  fprintf (stderr, "  Res. levels: ");
+  while (pp)
+    {
+      FriBidiStrIndex i;
+      for (i = 0; i < RL_LEN (pp); i++)
+	fprintf (stderr, "%c", fribidi_char_from_level (RL_LEVEL (pp)));
+      pp = pp->next;
+    }
+  fprintf (stderr, "\n");
+}
+
+static void
+print_resolved_types (TypeLink *pp)
+{
+  fprintf (stderr, "  Res. types : ");
+  while (pp)
+    {
+      FriBidiStrIndex i;
+      for (i = 0; i < RL_LEN (pp); i++)
+	fprintf (stderr, "%c", fribidi_char_from_type (pp->type));
+      pp = pp->next;
+    }
+  fprintf (stderr, "\n");
+}
+
+/* Here, only for test porpuses, we have assumed that a fribidi_string
+   ends with a 0 character */
+static void
+print_bidi_string (FriBidiChar *str)
+{
+  FriBidiStrIndex i;
+  fprintf (stderr, "  Org. types : ");
+  for (i = 0; str[i]; i++)
+    fprintf (stderr, "%c",
+	     fribidi_char_from_type (fribidi_get_type (str[i])));
+  fprintf (stderr, "\n");
+}
+#endif
+
+/*======================================================================
+ *  This function should follow the Unicode specification closely!
+ *----------------------------------------------------------------------*/
+static void
+fribidi_analyse_string (	/* input */
+			 FriBidiChar *str,
+			 FriBidiStrIndex len,
+			 FriBidiCharType *pbase_dir,
+			 /* output */
+			 TypeLink **ptype_rl_list,
+			 FriBidiLevel *pmax_level)
+{
+  FriBidiLevel base_level, max_level;
+  FriBidiCharType base_dir;
+  FriBidiStrIndex i;
+  TypeLink *type_rl_list, *explicits_list, *explicits_list_end, *pp;
+
+  DBG ("Entering fribidi_analyse_string()\n");
+
+  /* Determinate character types */
+  DBG ("  Determine character types\n");
+  {
+    FriBidiCharType *char_type =
+      (FriBidiCharType *) malloc (len * sizeof (FriBidiCharType));
+    for (i = 0; i < len; i++)
+      char_type[i] = fribidi_get_type (str[i]);
+
+    /* Run length encode the character types */
+    type_rl_list = run_length_encode_types (char_type, len);
+    free (char_type);
+  }
+  DBG ("  Determine character types, Done\n");
+
+  init_list (&explicits_list, &explicits_list_end);
+
+  /* Find base level */
+  DBG ("  Finding the base level\n");
+  if (FRIBIDI_IS_STRONG (*pbase_dir))
+    base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);
+  /* P2. P3. Search for first strong character and use its direction as
+     base direction */
+  else
+    {
+      /* If no strong base_dir was found, resort to the weak direction
+         that was passed on input. */
+      base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);
+      base_dir = FRIBIDI_TYPE_ON;
+      for (pp = type_rl_list; pp; pp = pp->next)
+	if (FRIBIDI_IS_LETTER (RL_TYPE (pp)))
+	  {
+	    base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));
+	    base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
+	    break;
+	  }
+    }
+  base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);
+  DBG2 ("  Base level : %c\n", fribidi_char_from_level (base_level));
+  DBG2 ("  Base dir   : %c\n", fribidi_char_from_type (base_dir));
+  DBG ("  Finding the base level, Done\n");
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_types_re (type_rl_list);
+    }
+#endif
+
+  /* Explicit Levels and Directions */
+  DBG ("Explicit Levels and Directions\n");
+  {
+    /* X1. Begin by setting the current embedding level to the paragraph
+       embedding level. Set the directional override status to neutral.
+       Process each character iteratively, applying rules X2 through X9.
+       Only embedding levels from 0 to 61 are valid in this phase. */
+    FriBidiLevel level, new_level;
+    FriBidiCharType override, new_override;
+    FriBidiStrIndex i;
+    int stack_size, over_pushed, first_interval;
+    LevelInfo *status_stack;
+    TypeLink temp_link;
+
+    level = base_level;
+    override = FRIBIDI_TYPE_ON;
+    /* stack */
+    stack_size = 0;
+    over_pushed = 0;
+    first_interval = 0;
+    status_stack =
+      (LevelInfo *) malloc (sizeof (LevelInfo) * (UNI_MAX_BIDI_LEVEL + 2));
+
+    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+      {
+	FriBidiCharType this_type = RL_TYPE (pp);
+	if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))
+	  {
+	    if (FRIBIDI_IS_STRONG (this_type))
+	      {			/* LRE, RLE, LRO, RLO */
+		/* 1. Explicit Embeddings */
+		/*   X2. With each RLE, compute the least greater odd embedding level. */
+		/*   X3. With each LRE, compute the least greater even embedding level. */
+		/* 2. Explicit Overrides */
+		/*   X4. With each RLO, compute the least greater odd embedding level. */
+		/*   X5. With each LRO, compute the least greater even embedding level. */
+		new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);
+		for (i = 0; i < RL_LEN (pp); i++)
+		  {
+		    new_level =
+		      ((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -
+		      FRIBIDI_DIR_TO_LEVEL (this_type);
+		    PUSH_STATUS;
+		  }
+	      }
+	    else if (this_type == FRIBIDI_TYPE_PDF)
+	      {
+		/* 3. Terminating Embeddings and overrides */
+		/*   X7. With each PDF, determine the matching embedding or
+		   override code. */
+		for (i = 0; i < RL_LEN (pp); i++)
+		  POP_STATUS;
+	      }
+	    /* X9. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes. */
+	    /* Remove element and add it to explicits_list */
+	    temp_link.next = pp->next;
+	    pp->level = FRIBIDI_LEVEL_REMOVED;
+	    move_element_before (pp, explicits_list_end);
+	    pp = &temp_link;
+	  }
+	else
+	  {
+	    /* X6. For all typed besides RLE, LRE, RLO, LRO, and PDF:
+	       a. Set the level of the current character to the current
+	       embedding level.
+	       b. Whenever the directional override status is not neutral,
+	       reset the current character type to the directional override
+	       status. */
+	    RL_LEVEL (pp) = level;
+	    if (!FRIBIDI_IS_NEUTRAL (override))
+	      RL_TYPE (pp) = override;
+	  }
+	/* X8. All explicit directional embeddings and overrides are
+	   completely terminated at the end of each paragraph. Paragraph
+	   separators are not included in the embedding. */
+	/* This function is running on a single paragraph, so we can do
+	   X8 after all the input is processed. */
+      }
+
+    /* Implementing X8. It has no effect on a single paragraph! */
+    level = base_level;
+    override = FRIBIDI_TYPE_ON;
+    stack_size = 0;
+    over_pushed = 0;
+
+    free (status_stack);
+  }
+  /* X10. The remaining rules are applied to each run of characters at the
+     same level. For each run, determine the start-of-level-run (sor) and
+     end-of-level-run (eor) type, either L or R. This depends on the
+     higher of the two levels on either side of the boundary (at the start
+     or end of the paragraph, the level of the 'other' run is the base
+     embedding level). If the higher level is odd, the type is R, otherwise
+     it is L. */
+  /* Resolving Implicit Levels can be done out of X10 loop, so only change
+     of Resolving Weak Types and Resolving Neutral Types is needed. */
+
+  compact_list (type_rl_list);
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_types_re (type_rl_list);
+      print_bidi_string (str);
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+  /* 4. Resolving weak types */
+  DBG ("Resolving weak types\n");
+  {
+    FriBidiCharType last_strong, prev_type_org;
+    fribidi_boolean w4;
+
+    last_strong = base_dir;
+
+    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+      {
+	FriBidiCharType prev_type, this_type, next_type;
+
+	prev_type = PREV_TYPE_OR_SOR (pp);
+	this_type = RL_TYPE (pp);
+	next_type = NEXT_TYPE_OR_EOR (pp);
+
+	if (FRIBIDI_IS_STRONG (prev_type))
+	  last_strong = prev_type;
+
+	/* W1. NSM
+	   Examine each non-spacing mark (NSM) in the level run, and change the
+	   type of the NSM to the type of the previous character. If the NSM
+	   is at the start of the level run, it will get the type of sor. */
+	/* Implementation note: it is important that if the previous character
+	   is not sor, then we should merge this run with the previous,
+	   because of rules like W5, that we assume all of a sequence of
+	   adjacent ETs are in one TypeLink. */
+	if (this_type == FRIBIDI_TYPE_NSM)
+	  {
+	    if (RL_LEVEL (pp->prev) == RL_LEVEL (pp))
+	      pp = merge_with_prev (pp);
+	    else
+	      RL_TYPE (pp) = prev_type;
+	    continue;		/* As we know the next condition cannot be true. */
+	  }
+
+	/* W2: European numbers. */
+	if (this_type == FRIBIDI_TYPE_EN && last_strong == FRIBIDI_TYPE_AL)
+	  {
+	    RL_TYPE (pp) = FRIBIDI_TYPE_AN;
+
+	    /* Resolving dependency of loops for rules W1 and W2, so we
+	       can merge them in one loop. */
+	    if (next_type == FRIBIDI_TYPE_NSM)
+	      RL_TYPE (pp->next) = FRIBIDI_TYPE_AN;
+	  }
+      }
+
+
+    last_strong = base_dir;
+    /* Resolving dependency of loops for rules W4 and W5, W5 may
+       want to prevent W4 to take effect in the next turn, do this 
+       through "w4". */
+    w4 = FRIBIDI_TRUE;
+    /* Resolving dependency of loops for rules W4 and W5 with W7,
+       W7 may change an EN to L but it sets the prev_type_org if needed,
+       so W4 and W5 in next turn can still do their works. */
+    prev_type_org = FRIBIDI_TYPE_ON;
+
+    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+      {
+	FriBidiCharType prev_type, this_type, next_type;
+
+	prev_type = PREV_TYPE_OR_SOR (pp);
+	this_type = RL_TYPE (pp);
+	next_type = NEXT_TYPE_OR_EOR (pp);
+
+	if (FRIBIDI_IS_STRONG (prev_type))
+	  last_strong = prev_type;
+
+	/* W3: Change ALs to R. */
+	if (this_type == FRIBIDI_TYPE_AL)
+	  {
+	    RL_TYPE (pp) = FRIBIDI_TYPE_RTL;
+	    w4 = FRIBIDI_TRUE;
+	    prev_type_org = FRIBIDI_TYPE_ON;
+	    continue;
+	  }
+
+	/* W4. A single european separator changes to a european number.
+	   A single common separator between two numbers of the same type
+	   changes to that type. */
+	if (w4
+	    && RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)
+	    && FRIBIDI_IS_NUMBER (prev_type_org) && prev_type_org == next_type
+	    && (prev_type_org == FRIBIDI_TYPE_EN
+		|| this_type == FRIBIDI_TYPE_CS))
+	  {
+	    RL_TYPE (pp) = prev_type;
+	    this_type = RL_TYPE (pp);
+	  }
+	w4 = FRIBIDI_TRUE;
+
+	/* W5. A sequence of European terminators adjacent to European
+	   numbers changes to All European numbers. */
+	if (this_type == FRIBIDI_TYPE_ET
+	    && (prev_type_org == FRIBIDI_TYPE_EN
+		|| next_type == FRIBIDI_TYPE_EN))
+	  {
+	    RL_TYPE (pp) = FRIBIDI_TYPE_EN;
+	    w4 = FRIBIDI_FALSE;
+	    this_type = RL_TYPE (pp);
+	  }
+
+	/* W6. Otherwise change separators and terminators to other neutral. */
+	if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))
+	  RL_TYPE (pp) = FRIBIDI_TYPE_ON;
+
+	/* W7. Change european numbers to L. */
+	if (this_type == FRIBIDI_TYPE_EN && last_strong == FRIBIDI_TYPE_LTR)
+	  {
+	    RL_TYPE (pp) = FRIBIDI_TYPE_LTR;
+	    prev_type_org = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?
+			     FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);
+	  }
+	else
+	  prev_type_org = PREV_TYPE_OR_SOR (pp->next);
+      }
+  }
+
+  compact_neutrals (type_rl_list);
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+  /* 5. Resolving Neutral Types */
+  DBG ("Resolving neutral types\n");
+  {
+    /* N1. and N2.
+       For each neutral, resolve it. */
+    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+      {
+	FriBidiCharType prev_type, this_type, next_type;
+
+	/* "European and arabic numbers are treated as though they were R"
+	   FRIBIDI_CHANGE_NUMBER_TO_RTL does this. */
+	this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));
+	prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (PREV_TYPE_OR_SOR (pp));
+	next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (NEXT_TYPE_OR_EOR (pp));
+
+	if (FRIBIDI_IS_NEUTRAL (this_type))
+	  RL_TYPE (pp) = (prev_type == next_type) ?
+	    /* N1. */ prev_type :
+	    /* N2. */ FRIBIDI_EMBEDDING_DIRECTION (pp);
+      }
+  }
+
+  compact_list (type_rl_list);
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+  /* 6. Resolving implicit levels */
+  DBG ("Resolving implicit levels\n");
+  {
+    max_level = base_level;
+
+    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+      {
+	FriBidiCharType this_type;
+	int level;
+
+	this_type = RL_TYPE (pp);
+	level = RL_LEVEL (pp);
+
+	/* I1. Even */
+	/* I2. Odd */
+	if (FRIBIDI_IS_NUMBER (this_type))
+	  RL_LEVEL (pp) = (level + 2) & ~1;
+	else
+	  RL_LEVEL (pp) = (level ^ FRIBIDI_DIR_TO_LEVEL (this_type)) +
+	    (level & 1);
+
+	if (RL_LEVEL (pp) > max_level)
+	  max_level = RL_LEVEL (pp);
+      }
+  }
+
+  compact_list (type_rl_list);
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_bidi_string (str);
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+/* Reinsert the explicit codes & bn's that already removed, from the
+   explicits_list to type_rl_list. */
+  DBG ("Reinserting explicit codes\n");
+  {
+    TypeLink *p;
+
+    override_list (type_rl_list, explicits_list);
+    p = type_rl_list->next;
+    if (p->level < 0)
+      p->level = base_level;
+    for (; p->next; p = p->next)
+      if (p->level < 0)
+	p->level = p->prev->level;
+  }
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_types_re (type_rl_list);
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+  DBG ("Reset the embedding levels\n");
+  {
+    int j, k, state, pos;
+    TypeLink *p, *q, *list, *list_end;
+
+    /* L1. Reset the embedding levels of some chars. */
+    init_list (&list, &list_end);
+    q = list_end;
+    state = 1;
+    pos = len - 1;
+    for (j = len - 1; j >= -1; j--)
+      {
+	/* if state is on at the very first of string, do this too. */
+	if (j >= 0)
+	  k = fribidi_get_type (str[j]);
+	else
+	  k = FRIBIDI_TYPE_ON;
+	if (!state && FRIBIDI_IS_SEPARATOR (k))
+	  {
+	    state = 1;
+	    pos = j;
+	  }
+	else if (state && !FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS (k))
+	  {
+	    state = 0;
+	    p = new_type_link ();
+	    p->prev = p->next = NULL;
+	    p->pos = j + 1;
+	    p->len = pos - j;
+	    p->type = base_dir;
+	    p->level = base_level;
+	    move_element_before (p, q);
+	    q = p;
+	  }
+      }
+    override_list (type_rl_list, list);
+  }
+
+#ifdef DEBUG
+  if (fribidi_debug)
+    {
+      print_types_re (type_rl_list);
+      print_resolved_levels (type_rl_list);
+      print_resolved_types (type_rl_list);
+    }
+#endif
+
+  *ptype_rl_list = type_rl_list;
+  *pmax_level = max_level;
+  *pbase_dir = base_dir;
+
+  DBG ("Leaving fribidi_analyse_string()\n");
+  return;
+}
+
+/*======================================================================
+ *  Frees up the rl_list, must be called after each call to
+ *  fribidi_analyse_string(), after the list is not needed anymore.
+ *----------------------------------------------------------------------*/
+static void
+free_rl_list (TypeLink *type_rl_list)
+{
+
+  TypeLink *pp;
+
+  DBG ("Entering free_rl_list()\n");
+
+  if (!type_rl_list)
+    {
+      DBG ("Leaving free_rl_list()\n");
+      return;
+    }
+
+#ifdef USE_SIMPLE_MALLOC
+  pp = type_rl_list;
+  while (pp)
+    {
+      TypeLink *p;
+
+      p = pp;
+      pp = pp->next;
+      free_type_link (p);
+    };
+#else
+  for (pp = type_rl_list->next; pp->next; pp = pp->next)
+    /* Nothing */ ;
+  pp->next = free_type_links;
+  free_type_links = type_rl_list;
+  type_rl_list = NULL;
+#endif
+
+  DBG ("Leaving free_rl_list()\n");
+  return;
+}
+
+static fribidi_boolean mirroring = FRIBIDI_TRUE;
+
+FRIBIDI_API fribidi_boolean
+fribidi_mirroring_status (void)
+{
+  return mirroring;
+}
+
+FRIBIDI_API void
+fribidi_set_mirroring (fribidi_boolean mirror)
+{
+  mirroring = mirror;
+}
+
+static fribidi_boolean reorder_nsm = FRIBIDI_FALSE;
+
+fribidi_boolean
+fribidi_reorder_nsm_status (void)
+{
+  return reorder_nsm;
+}
+
+FRIBIDI_API void
+fribidi_set_reorder_nsm (fribidi_boolean reorder)
+{
+  reorder_nsm = reorder;
+}
+
+/*======================================================================
+ *  Here starts the exposed front end functions.
+ *----------------------------------------------------------------------*/
+
+/*======================================================================
+ *  fribidi_remove_bidi_marks() removes bidirectional marks, and returns
+ *  the new length, updates each of other inputs if not NULL.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API FriBidiStrIndex
+fribidi_remove_bidi_marks (FriBidiChar *str,
+			   FriBidiStrIndex length,
+			   FriBidiStrIndex *position_to_this_list,
+			   FriBidiStrIndex *position_from_this_list,
+			   FriBidiLevel *embedding_level_list)
+{
+  FriBidiStrIndex i, j;
+  fribidi_boolean private_from_this = FRIBIDI_FALSE;
+
+  DBG ("Entering fribidi_remove_bidi_marks()\n");
+
+  /* If to_this is to not null, we must have from_this as well. If it is
+     not given by the caller, we have to make a private instance of it. */
+  if (position_to_this_list && !position_from_this_list)
+    {
+      private_from_this = FRIBIDI_TRUE;
+      position_from_this_list =
+	(FriBidiStrIndex *) malloc (sizeof (FriBidiStrIndex) * length);
+    }
+
+  j = 0;
+  for (i = 0; i < length; i++)
+    if (!FRIBIDI_IS_EXPLICIT (fribidi_get_type (str[i]))
+	&& str[i] != UNI_LRM && str[i] != UNI_RLM)
+      {
+	str[j] = str[i];
+	if (embedding_level_list)
+	  embedding_level_list[j] = embedding_level_list[i];
+	if (position_from_this_list)
+	  position_from_this_list[j] = position_from_this_list[i];
+	j++;
+      }
+
+  /* Convert the from_this list to to_this */
+  if (position_to_this_list)
+    {
+      DBG ("  Converting from_this list to to_this\n");
+      for (i = 0; i < length; i++)
+	position_to_this_list[i] = -1;
+      for (i = 0; i < length; i++)
+	position_to_this_list[position_from_this_list[i]] = i;
+      DBG ("  Converting from_this list to to_this, Done\n");
+    }
+
+  if (private_from_this)
+    free (position_from_this_list);
+
+  DBG ("Leaving fribidi_remove_bidi_marks()\n");
+  return j;
+}
+
+
+/*======================================================================
+ *  fribidi_log2vis() calls the function_analyse_string() and then
+ *  does reordering and fills in the output strings.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API fribidi_boolean
+fribidi_log2vis (		/* input */
+		  FriBidiChar *str,
+		  FriBidiStrIndex len,
+		  FriBidiCharType *pbase_dir,
+		  /* output */
+		  FriBidiChar *visual_str,
+		  FriBidiStrIndex *position_L_to_V_list,
+		  FriBidiStrIndex *position_V_to_L_list,
+		  FriBidiLevel *embedding_level_list)
+{
+  TypeLink *type_rl_list, *pp = NULL;
+  FriBidiLevel max_level;
+  fribidi_boolean private_V_to_L = FRIBIDI_FALSE;
+
+  DBG ("Entering fribidi_log2vis()\n");
+
+  if (len == 0)
+    {
+      DBG ("Leaving fribidi_log2vis()\n");
+      return FRIBIDI_TRUE;
+    }
+
+  /* If l2v is to be calculated we must have v2l as well. If it is not
+     given by the caller, we have to make a private instance of it. */
+  if (position_L_to_V_list && !position_V_to_L_list)
+    {
+      private_V_to_L = FRIBIDI_TRUE;
+      position_V_to_L_list =
+	(FriBidiStrIndex *) malloc (sizeof (FriBidiStrIndex) * len);
+    }
+
+  if (len > FRIBIDI_MAX_STRING_LENGTH && position_V_to_L_list)
+    {
+#ifdef DEBUG
+      fprintf (stderr, "%s: cannot handle strings > %ld characters\n",
+	       FRIBIDI_PACKAGE, (long) FRIBIDI_MAX_STRING_LENGTH);
+#endif
+      return FRIBIDI_FALSE;
+    }
+  fribidi_analyse_string (str, len, pbase_dir,
+			  /* output */
+			  &type_rl_list, &max_level);
+
+  /* 7. Reordering resolved levels */
+  DBG ("Reordering resolved levels\n");
+  {
+    FriBidiLevel level_idx;
+    FriBidiStrIndex i;
+
+    /* Set up the ordering array to sorted order */
+    if (position_V_to_L_list)
+      {
+	DBG ("  Initialize position_V_to_L_list\n");
+	for (i = 0; i < len; i++)
+	  position_V_to_L_list[i] = i;
+	DBG ("  Initialize position_V_to_L_list, Done\n");
+      }
+    /* Copy the logical string to the visual */
+    if (visual_str)
+      {
+	DBG ("  Initialize visual_str\n");
+	for (i = 0; i < len; i++)
+	  visual_str[i] = str[i];
+	visual_str[len] = 0;
+	DBG ("  Initialize visual_str, Done\n");
+      }
+
+    /* Assign the embedding level array */
+    if (embedding_level_list)
+      {
+	DBG ("  Fill the embedding levels array\n");
+	for (pp = type_rl_list->next; pp->next; pp = pp->next)
+	  {
+	    FriBidiStrIndex i, pos, len;
+	    FriBidiLevel level;
+
+	    pos = pp->pos;
+	    len = pp->len;
+	    level = pp->level;
+	    for (i = 0; i < len; i++)
+	      embedding_level_list[pos + i] = level;
+	  }
+	DBG ("  Fill the embedding levels array, Done\n");
+      }
+
+    /* Reorder both the outstring and the order array */
+    if (visual_str || position_V_to_L_list)
+      {
+	if (mirroring && visual_str)
+	  {
+	    /* L4. Mirror all characters that are in odd levels and have mirrors. */
+	    DBG ("  Mirroring\n");
+	    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+	      {
+		if (pp->level & 1)
+		  {
+		    FriBidiStrIndex i;
+		    for (i = RL_POS (pp); i < RL_POS (pp) + RL_LEN (pp); i++)
+		      {
+			FriBidiChar mirrored_ch;
+			if (fribidi_get_mirror_char
+			    (visual_str[i], &mirrored_ch))
+			  visual_str[i] = mirrored_ch;
+		      }
+		  }
+	      }
+	    DBG ("  Mirroring, Done\n");
+	  }
+
+	if (reorder_nsm)
+	  {
+	    /* L3. Reorder NSMs. */
+	    DBG ("  Reordering NSM sequences\n");
+	    /* We apply this rule before L2, so go backward in odd levels. */
+	    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+	      {
+		if (pp->level & 1)
+		  {
+		    FriBidiStrIndex i, seq_end = 0;
+		    fribidi_boolean is_nsm_seq;
+
+		    is_nsm_seq = FRIBIDI_FALSE;
+		    for (i = RL_POS (pp) + RL_LEN (pp) - 1; i >= RL_POS (pp);
+			 i--)
+		      {
+			FriBidiCharType this_type;
+
+			this_type = fribidi_get_type (str[i]);
+			if (is_nsm_seq && this_type != FRIBIDI_TYPE_NSM)
+			  {
+			    if (visual_str)
+			      {
+				bidi_string_reverse (visual_str + i,
+						     seq_end - i + 1);
+			      }
+			    if (position_V_to_L_list)
+			      {
+				index_array_reverse (position_V_to_L_list + i,
+						     seq_end - i + 1);
+			      }
+			    is_nsm_seq = 0;
+			  }
+			else if (!is_nsm_seq && this_type == FRIBIDI_TYPE_NSM)
+			  {
+			    seq_end = i;
+			    is_nsm_seq = 1;
+			  }
+		      }
+		    if (is_nsm_seq)
+		      {
+			DBG
+			  ("Warning: NSMs at the beggining of run level.\n");
+		      }
+		  }
+	      }
+	    DBG ("  Reordering NSM sequences, Done\n");
+	  }
+
+	/* L2. Reorder. */
+	DBG ("  Reordering\n");
+	for (level_idx = max_level; level_idx > 0; level_idx--)
+	  {
+	    for (pp = type_rl_list->next; pp->next; pp = pp->next)
+	      {
+		if (RL_LEVEL (pp) >= level_idx)
+		  {
+		    /* Find all stretches that are >= level_idx */
+		    FriBidiStrIndex len = RL_LEN (pp),
+		      pos = RL_POS (pp);
+		    TypeLink *pp1 = pp->next;
+		    while (pp1->next && RL_LEVEL (pp1) >= level_idx)
+		      {
+			len += RL_LEN (pp1);
+			pp1 = pp1->next;
+		      }
+		    pp = pp1->prev;
+		    if (visual_str)
+		      bidi_string_reverse (visual_str + pos, len);
+		    if (position_V_to_L_list)
+		      index_array_reverse (position_V_to_L_list + pos, len);
+		  }
+	      }
+	  }
+	DBG ("  Reordering, Done\n");
+      }
+
+    /* Convert the v2l list to l2v */
+    if (position_L_to_V_list)
+      {
+	DBG ("  Converting v2l list to l2v\n");
+	for (i = 0; i < len; i++)
+	  position_L_to_V_list[position_V_to_L_list[i]] = i;
+	DBG ("  Converting v2l list to l2v, Done\n");
+      }
+  }
+  DBG ("Reordering resolved levels, Done\n");
+
+  if (private_V_to_L)
+    free (position_V_to_L_list);
+
+  free_rl_list (type_rl_list);
+
+  DBG ("Leaving fribidi_log2vis()\n");
+  return FRIBIDI_TRUE;
+
+}
+
+/*======================================================================
+ *  fribidi_log2vis_get_embedding_levels() is used in order to just get
+ *  the embedding levels.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API fribidi_boolean
+fribidi_log2vis_get_embedding_levels (	/* input */
+				       FriBidiChar *str,
+				       FriBidiStrIndex len,
+				       FriBidiCharType *pbase_dir,
+				       /* output */
+				       FriBidiLevel *embedding_level_list)
+{
+  TypeLink *type_rl_list, *pp;
+  FriBidiLevel max_level;
+
+  DBG ("Entering fribidi_log2vis_get_embedding_levels()\n");
+
+  if (len == 0)
+    {
+      DBG ("Leaving fribidi_log2vis_get_embedding_levels()\n");
+      return FRIBIDI_TRUE;
+    }
+
+  fribidi_analyse_string (str, len, pbase_dir,
+			  /* output */
+			  &type_rl_list, &max_level);
+
+  for (pp = type_rl_list->next; pp->next; pp = pp->next)
+    {
+      FriBidiStrIndex i, pos = RL_POS (pp),
+        len = RL_LEN (pp);
+      FriBidiLevel level = RL_LEVEL (pp);
+      for (i = 0; i < len; i++)
+	embedding_level_list[pos + i] = level;
+    }
+
+  free_rl_list (type_rl_list);
+
+  DBG ("Leaving fribidi_log2vis_get_embedding_levels()\n");
+  return FRIBIDI_TRUE;
+}
+
+
+
+const char *fribidi_version_info =
+  FRIBIDI_PACKAGE " " FRIBIDI_VERSION "\n" "interface version "
+  TOSTR (FRIBIDI_INTERFACE_VERSION)
+  "\n"
+  "Unicode version " FRIBIDI_UNICODE_VERSION "\n"
+  "\n"
+  "Copyright (C) 2001,2002,2005  Behdad Esfahbod <fribidi@behdad.org>.\n"
+  "Copyright (C) 1999,2000 Dov Grobgeld\n"
+  FRIBIDI_PACKAGE " comes with NO WARRANTY, to the extent permitted by law.\n"
+  "You may redistribute copies of " FRIBIDI_PACKAGE " under the terms of\n"
+  "the GNU Lesser General Public License.\n"
+  "For more information about these matters, see the files named COPYING.\n"
+  "\n" "Configured with following options:\n"
+#ifdef DEBUG
+  "--enable-debug\n"
+#endif
+#ifdef MEM_OPTIMIZED
+  "--enable-memopt\n"
+#endif
+#ifdef USE_SIMPLE_MALLOC
+  "--enable-malloc\n"
+#endif
+#ifdef FRIBIDI_NO_CHARSETS
+  "--without-charsts\n"
+#endif
+;
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_char_type.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_char_type.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_char_type.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_char_type.c	2012-05-05 23:46:50.941763780 +0530
@@ -0,0 +1,100 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 2001,2002 Behdad Esfahbod. 
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <fwpg@sharif.edu>. 
+ */
+
+#ifdef HAVE_CONFIG_H
+//#include <config.h>
+#endif
+#include "fribidi.h"
+
+/*======================================================================
+ *  fribidi_get_type() returns the bidi type of a character.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API FriBidiCharType fribidi_get_type_internal (FriBidiChar uch);
+
+FRIBIDI_API FriBidiCharType
+fribidi_get_type (FriBidiChar uch)
+{
+  return fribidi_get_type_internal (uch);
+}
+
+FRIBIDI_API void
+fribidi_get_types (		/* input */
+		    FriBidiChar *str, FriBidiStrIndex len,
+		    /* output */
+		    FriBidiCharType *type)
+{
+  FriBidiStrIndex i;
+
+  for (i = 0; i < len; i++)
+    type[i] = fribidi_get_type (str[i]);
+}
+
+#ifdef MEM_OPTIMIZED
+
+#if   HAS_FRIBIDI_TAB_CHAR_TYPE_9_I
+#include "fribidi_tab_char_type_9.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_8_I
+#include "fribidi_tab_char_type_8.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_7_I
+#include "fribidi_tab_char_type_7.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_6_I
+#include "fribidi_tab_char_type_6.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_5_I
+#include "fribidi_tab_char_type_5.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_4_I
+#include "fribidi_tab_char_type_4.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_3_I
+#include "fribidi_tab_char_type_3.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_2_I
+#include "fribidi_tab_char_type_2.i"
+#else
+#error You have no fribidi_tab_char_type_*.i file, please first make one by \
+       make fribidi_tab_char_type_n.i which n is the compress level, a digit \
+       between 2 and 9, or simply run make fribidi_tab_char_type_small, \
+       retry to make.
+#endif
+
+#else
+
+#if   HAS_FRIBIDI_TAB_CHAR_TYPE_2_I
+#include "fribidi_tab_char_type_2.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_3_I
+#include "fribidi_tab_char_type_3.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_4_I
+#include "fribidi_tab_char_type_4.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_5_I
+#include "fribidi_tab_char_type_5.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_6_I
+#include "fribidi_tab_char_type_6.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_7_I
+#include "fribidi_tab_char_type_7.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_8_I
+#include "fribidi_tab_char_type_8.i"
+#elif HAS_FRIBIDI_TAB_CHAR_TYPE_9_I
+#include "fribidi_tab_char_type_9.i"
+#else
+#error You have no fribidi_tab_char_type_*.i file, please first make one by \
+       make fribidi_tab_char_type_n.i which n is the compress level, a digit \
+       between 2 and 9, or simply run make fribidi_tab_char_type_large, \
+       retry to make.
+#endif
+
+#endif
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_config.h Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_config.h
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_config.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_config.h	2012-05-05 23:46:50.941763780 +0530
@@ -0,0 +1,48 @@
+
+#define FRIBIDI_PACKAGE "fribidi"
+
+#define FRIBIDI_VERSION "0.10.9"
+#define FRIBIDI_MAJOR_VERSION 0
+#define FRIBIDI_MINOR_VERSION 10
+#define FRIBIDI_MICRO_VERSION 9
+#define FRIBIDI_INTERFACE_VERSION 2
+
+#if 1 /* FRIBIDI_NO_CHARSETS */
+#define FRIBIDI_NO_CHARSETS 1
+#else /* NOT FRIBIDI_NO_CHARSETS */
+#undef FRIBIDI_NO_CHARSETS
+#endif /* FRIBIDI_NO_CHARSETS */
+
+#define TOSTR(x) #x
+
+#ifdef WIN32
+
+#ifdef FRIBIDI_STATIC
+#define FRIBIDI_API
+#elif defined(FRIBIDI_EXPORTS)
+#define FRIBIDI_API __declspec(dllexport)
+#else
+#define FRIBIDI_API __declspec(dllimport)
+#endif
+
+#define snprintf _snprintf
+
+#else /* NOT WIN32 */
+
+#define FRIBIDI_API
+
+#endif /* WIN32 */
+
+#define FRIBIDI_TRUE    1
+#define FRIBIDI_FALSE   0
+
+#ifndef TRUE
+#define TRUE FRIBIDI_TRUE
+#endif /* TRUE */
+#ifndef FALSE
+#define FALSE FRIBIDI_FALSE
+#endif /* FALSE */
+
+#define FRIBIDI_SIZEOF_SHORT 2
+#define FRIBIDI_SIZEOF_INT 4
+#define FRIBIDI_SIZEOF_LONG 4
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi.h Scribus_1.5_indic/scribus/third_party/fribidi/fribidi.h
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi.h	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,282 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 1999,2000 Dov Grobgeld, and
+ * Copyright (C) 2001,2002 Behdad Esfahbod. 
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <dov@imagic.weizmann.ac.il> and 
+ * <fwpg@sharif.edu>. 
+ */
+
+#ifndef FRIBIDI_H
+#define FRIBIDI_H
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#include "fribidi_config.h"
+#include "fribidi_unicode.h"
+#include "fribidi_types.h"
+#ifndef FRIBIDI_NO_CHARSETS
+#include "fribidi_char_sets.h"
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+  FRIBIDI_API fribidi_boolean fribidi_log2vis (	/* input */
+						FriBidiChar *str,
+						FriBidiStrIndex len,
+						FriBidiCharType *pbase_dirs,
+						/* output */
+						FriBidiChar *visual_str,
+						FriBidiStrIndex
+						*position_L_to_V_list,
+						FriBidiStrIndex
+						*position_V_to_L_list,
+						FriBidiLevel
+						*embedding_level_list);
+
+  FRIBIDI_API fribidi_boolean fribidi_log2vis_get_embedding_levels (	/* input */
+								     FriBidiChar
+								     *str,
+								     FriBidiStrIndex
+								     len,
+								     FriBidiCharType
+								     *pbase_dir,
+								     /* output */
+								     FriBidiLevel
+								     *embedding_level_list);
+
+/*======================================================================
+ *  fribidi_remove_bidi_marks() removes bidirectional marks, and returns
+ *  the new length, also updates each of other inputs if not NULL.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API FriBidiStrIndex fribidi_remove_bidi_marks (FriBidiChar *str,
+							 FriBidiStrIndex
+							 length,
+							 FriBidiStrIndex
+							 *position_to_this_list,
+							 FriBidiStrIndex
+							 *position_from_this_list,
+							 FriBidiLevel
+							 *embedding_level_list);
+
+/*======================================================================
+ *  fribidi_get_type() returns bidi type of a character.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API FriBidiCharType fribidi_get_type (FriBidiChar uch);
+
+/*======================================================================
+ *  fribidi_get_types() returns bidi type of a string.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_get_types (	/* input */
+				       FriBidiChar *str,
+				       FriBidiStrIndex len,
+				       /* output */
+				       FriBidiCharType *type);
+
+/*======================================================================
+ *  fribidi_get_mirror_char() returns the mirrored character, if input
+ *  character has a mirror, or the input itself.
+ *  if mirrored_ch is NULL, just returns if character has a mirror or not.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API fribidi_boolean fribidi_get_mirror_char (	/* Input */
+							FriBidiChar ch,
+							/* Output */
+							FriBidiChar
+							*mirrored_ch);
+
+/*======================================================================
+ *  fribidi_mirroring_status() returns whether mirroring is on or off,
+ *  default is on.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API fribidi_boolean fribidi_mirroring_status (void);
+
+/*======================================================================
+ *  fribidi_set_mirroring() sets mirroring on or off.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_set_mirroring (fribidi_boolean mirror);
+
+/*======================================================================
+ *  fribidi_reorder_nsm_status() returns whether reordering of NSM
+ *  sequences is on or off, default is off.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API fribidi_boolean fribidi_reorder_nsm_status (void);
+
+/*======================================================================
+ *  fribidi_set_reorder_nsm() sets reordering of NSM characters on or off.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_set_reorder_nsm (fribidi_boolean);
+
+/*======================================================================
+ *  fribidi_set_debug() turn on or off debugging, default is off, return
+ *  false is fribidi is not compiled with debug enabled.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API fribidi_boolean fribidi_set_debug (fribidi_boolean debug);
+
+/* fribidi_utils.c */
+
+/*======================================================================
+ *  fribidi_find_string_changes() finds the bounding box of the section
+ *  of characters that need redrawing. It returns the start and the
+ *  length of the section in the new string that needs redrawing.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_find_string_changes (	/* input */
+						 FriBidiChar *old_str,
+						 FriBidiStrIndex old_len,
+						 FriBidiChar *new_str,
+						 FriBidiStrIndex new_len,
+						 /* output */
+						 FriBidiStrIndex
+						 *change_start,
+						 FriBidiStrIndex *change_len);
+
+
+/*======================================================================
+ *  The find_visual_ranges() function is used to convert between a
+ *  continous span in either logical or visual space to a one, two or
+ *  three discontinous spans in the other space. The function outputs
+ *  the number of ranges needed to display the mapped range as
+ *  well as the resolved ranges.
+ *
+ *  The variable is_v2l_map indicates whether the position map is
+ *  is in the direction of visual-to-logical. This information is
+ *  needed in order to look up the correct character from the
+ *  embedding_level_list which is assumed to be in logical order.
+ *
+ *  This function is typically used to resolve a logical range to visual
+ *  ranges e.g. to display the selection.
+ *
+ *  Example:
+ *     The selection is between logical characters 10 to 45. Calculate
+ *     the corresponding visual selection(s):
+ *
+ *     FriBidiStrIndex sel_span[2] = {10,45};
+ *
+ *     fribidi_map_range(sel_span,
+ *                       TRUE,
+ *                       length,
+ *                       vis2log_map,
+ *                       embedding_levels,
+ *                       // output
+ *                       &num_vis_ranges, *vis_ranges);
+ **----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_map_range (FriBidiStrIndex span[2],
+				      FriBidiStrIndex len,
+				      fribidi_boolean is_v2l_map,
+				      FriBidiStrIndex *position_map,
+				      FriBidiLevel *embedding_level_list,
+				      /* output */
+				      int *num_mapped_spans,
+				      FriBidiStrIndex spans[3][2]);
+
+/*======================================================================
+ *  fribidi_is_char_rtl() answers the question whether a character
+ *  was resolved in the rtl direction. This simply involves asking
+ *  if the embedding level for the character is odd.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API fribidi_boolean fribidi_is_char_rtl (FriBidiLevel
+						   *embedding_level_list,
+						   FriBidiCharType base_dir,
+						   FriBidiStrIndex idx);
+
+/*======================================================================
+ *  fribidi_xpos_resolve() does the complicated translation of
+ *  an x-coordinate, e.g. as received through a mouse press event,
+ *  to the logical and the visual position the xcoordinate is closest
+ *  to. It will also resolve the direction of the cursor according
+ *  to the embedding level of the closest character.
+ *
+ *  It does this through the following logics:
+ *  Here are the different possibilities:
+ *
+ *        Pointer              =>          Log Pos         Vis pos
+ *  
+ *     Before first vis char             log_pos(vis=0)L       0
+ *     After last vis char               log_pos(vis=n-1)R     n
+ *     Within 1/2 width of vis char i    log_pos(vis=i)L       i
+ *     Within last 1/2 width of vchar i  log_pos(vis=i)R       i+1
+ *     Border between vis chars i,i+1       resolve!           i+1
+ *
+ *  Input:
+ *     x_pos        The pixel position to be resolved measured in pixels.
+ *     x_offset     The x_offset is the pixel position of the left side
+ *                  of the leftmost visual character. 
+ *     len          The length of the embedding level, the vis2log and
+ *                  the char width arrays.
+ *     base_dir     The resolved base direction of the line.
+ *     vis2log      The vis2log mapping.
+ *                  x_position and the character widths. The position
+ *                  (x_pos-x_offset) is number of pixels from the left
+ *                  of logical character 0.
+ *     char_widths  Width in pixels of each character. Note that the
+ *                  widths should be provided in logical order.
+ *
+ *  Output:
+ *     res_log_pos  Resolved logical position.
+ *     res_vis_pos  Resolved visual position
+ *     res_cursor_x_pos   The resolved pixel position to the left or
+ *                  the right of the character position x_pos.
+ *     res_cursor_dir_is_rtl   Whether the resolved dir of the character
+ *                  at position x_pos is rtl.
+ *     res_attach_before  Whether the x_pos is cutting the bounding
+ *                  box in such a way that the visual cursor should be
+ *                  be positioned before the following logical character.
+ *                  Note that in the bidi context, the positions "after
+ *                  a logical character" and "before the following logical
+ *                  character" is not necessarily the same. If x_pos is
+ *                  beyond the end of the line, res_attach_before is true.
+ *
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_xpos_resolve (int x_pos,
+					 int x_offset,
+					 FriBidiStrIndex len,
+					 FriBidiLevel *embedding_level_list,
+					 FriBidiCharType base_dir,
+					 FriBidiStrIndex *vis2log,
+					 int *char_widths,
+					 /* output */
+					 FriBidiStrIndex *res_log_pos,
+					 FriBidiStrIndex *res_vis_pos,
+					 int *res_cursor_x_pos,
+					 fribidi_boolean
+					 *res_cursor_dir_is_rtl,
+					 fribidi_boolean *res_attach_before);
+
+/*======================================================================
+ *  fribidi_runs_log2vis takes a list of logical runs and returns a
+ *  a list of visual runs. A run is defined as a sequence that has
+ *  the same attributes.
+ *----------------------------------------------------------------------*/
+  FRIBIDI_API void fribidi_runs_log2vis (	/* input */
+					  FriBidiList *logical_runs,	/* List of FriBidiRunType */
+
+					  FriBidiStrIndex len,
+					  FriBidiStrIndex *log2vis,
+					  FriBidiCharType base_dir,
+					  /* output */
+					  FriBidiList **visual_runs);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif				/* FRIBIDI_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mem.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mem.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mem.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mem.c	2012-05-05 23:46:50.941763780 +0530
@@ -0,0 +1,108 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 2001,2002 Behdad Esfahbod.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public  
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,  
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of   
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License  
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <fwpg@sharif.edu>.
+ */
+
+#include "fribidi_mem.h"
+
+#include <stdlib.h>
+
+struct _FriBidiMemChunk
+{
+  const char *name;
+  int atom_size;
+  int area_size;
+  int type;
+
+  int empty_size;
+  void *chunk;
+};
+
+FriBidiList *
+fribidi_list_append (FriBidiList *list, void *data)
+{
+  FriBidiList *node, *last;
+
+  node = malloc (sizeof (FriBidiList));
+  node->data = data;
+  node->next = NULL;
+  node->prev = NULL;
+
+  if (!list)
+    return node;
+
+  for (last = list; !last->next; last = last->next);
+  node->prev = last;
+  last->next = node;
+  return list;
+}
+
+FriBidiMemChunk *
+fribidi_mem_chunk_new (const char *name,
+		       int atom_size, unsigned long area_size, int type)
+{
+  FriBidiMemChunk *m = (FriBidiMemChunk *) malloc (sizeof (FriBidiMemChunk));
+
+  m->name = name;
+  m->atom_size = atom_size;
+  m->area_size = area_size;
+  m->type = type;
+
+  m->empty_size = 0;
+  m->chunk = NULL;
+
+  return m;
+}
+
+void
+fribidi_mem_chunk_destroy (FriBidiMemChunk *mem_chunk)
+{
+  free (mem_chunk);
+  return;
+}
+
+void *
+fribidi_mem_chunk_alloc (FriBidiMemChunk *mem_chunk)
+{
+  void *m;
+
+  if (mem_chunk->type == FRIBIDI_ALLOC_ONLY)
+    {
+      if (mem_chunk->empty_size < mem_chunk->atom_size)
+	{
+	  mem_chunk->chunk = malloc (mem_chunk->area_size);
+	  mem_chunk->empty_size = mem_chunk->area_size;
+	}
+      m = mem_chunk->chunk;
+      mem_chunk->chunk = (void *)
+	((char *) mem_chunk->chunk + mem_chunk->atom_size);
+      mem_chunk->empty_size -= mem_chunk->atom_size;
+    }
+  else
+    m = (void *) malloc (mem_chunk->atom_size);
+  return m;
+}
+
+void
+fribidi_mem_chunk_free (FriBidiMemChunk *mem_chunk, void *mem)
+{
+  if (mem_chunk->type == FRIBIDI_ALLOC_AND_FREE)
+    free (mem);
+  return;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mem.h Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mem.h
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mem.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mem.h	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,62 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 2001,2002 Behdad Esfahbod.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser FriBidieneral Public  
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,  
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of   
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser FriBidieneral Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser FriBidieneral Public License  
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <fwpg@sharif.edu>.
+ */
+
+#ifndef FRIBIDI_MEM_H
+#define FRIBIDI_MEM_H
+
+#include "fribidi_config.h"
+#include "fribidi_types.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+  FriBidiList *fribidi_list_append (FriBidiList *list, void *data);
+
+  typedef struct _FriBidiMemChunk FriBidiMemChunk;
+
+#define FRIBIDI_ALLOC_ONLY      1
+#define FRIBIDI_ALLOC_AND_FREE  2
+
+  FriBidiMemChunk *fribidi_mem_chunk_new (const char *name,
+					  int atom_size,
+					  unsigned long area_size, int type);
+  void fribidi_mem_chunk_destroy (FriBidiMemChunk *mem_chunk);
+  void *fribidi_mem_chunk_alloc (FriBidiMemChunk *mem_chunk);
+  void *fribidi_mem_chunk_alloc0 (FriBidiMemChunk *mem_chunk);
+  void fribidi_mem_chunk_free (FriBidiMemChunk *mem_chunk, void *mem);
+
+#define fribidi_mem_chunk_create(type, pre_alloc, alloc_type) ( \
+  fribidi_mem_chunk_new (#type " mem chunks (" #pre_alloc ")", \
+                   sizeof (type), \
+                   sizeof (type) * (pre_alloc), \
+                   (alloc_type)) \
+)
+#define fribidi_chunk_new(type, chunk)        ( \
+  (type *) fribidi_mem_chunk_alloc (chunk) \
+)
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif				/* FRIBIDI_MEM_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mirroring.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mirroring.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_mirroring.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_mirroring.c	2012-05-05 23:46:50.940763780 +0530
@@ -0,0 +1,68 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 1999,2000 Dov Grobgeld, and
+ * Copyright (C) 2001,2002 Behdad Esfahbod. 
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <dov@imagic.weizmann.ac.il> and 
+ * <fwpg@sharif.edu>. 
+ */
+
+#ifdef HAVE_CONFIG_H
+//#include <config.h>
+#endif
+#include <stdlib.h>
+#include "fribidi.h"
+
+#include "fribidi_tab_mirroring.i"
+
+FRIBIDI_API fribidi_boolean
+fribidi_get_mirror_char (	/* Input */
+			  FriBidiChar ch,
+			  /* Output */
+			  FriBidiChar *mirrored_ch)
+{
+  int pos, step;
+  fribidi_boolean found;
+
+  pos = step = (nFriBidiMirroredChars / 2) + 1;
+
+  while (step > 1)
+    {
+      FriBidiChar cmp_ch = FriBidiMirroredChars[pos].ch;
+      step = (step + 1) / 2;
+
+      if (cmp_ch < ch)
+	{
+	  pos += step;
+	  if (pos > nFriBidiMirroredChars - 1)
+	    pos = nFriBidiMirroredChars - 1;
+	}
+      else if (cmp_ch > ch)
+	{
+	  pos -= step;
+	  if (pos < 0)
+	    pos = 0;
+	}
+      else
+	break;
+    }
+  found = FriBidiMirroredChars[pos].ch == ch;
+  if (mirrored_ch)
+    *mirrored_ch = found ? FriBidiMirroredChars[pos].mirrored_ch : ch;
+
+  return found;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_char_type_2.i Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_char_type_2.i
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_char_type_2.i	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_char_type_2.i	2012-05-05 23:46:50.943763780 +0530
@@ -0,0 +1,5607 @@
+/*
+  This file was automatically created from UnicodeData.txt version 4.1.0
+  by fribidi_create_char_types
+*/
+
+#ifndef FRIBIDI_TAB_CHAR_TYPE_2_I
+#define FRIBIDI_TAB_CHAR_TYPE_2_I
+
+#include "fribidi.h"
+
+#define LTR FRIBIDI_PROP_TYPE_LTR
+#define RTL FRIBIDI_PROP_TYPE_RTL
+#define AL FRIBIDI_PROP_TYPE_AL
+#define ON FRIBIDI_PROP_TYPE_ON
+#define BN FRIBIDI_PROP_TYPE_BN
+#define AN FRIBIDI_PROP_TYPE_AN
+#define BS FRIBIDI_PROP_TYPE_BS
+#define CS FRIBIDI_PROP_TYPE_CS
+#define EN FRIBIDI_PROP_TYPE_EN
+#define ES FRIBIDI_PROP_TYPE_ES
+#define ET FRIBIDI_PROP_TYPE_ET
+#define LRE FRIBIDI_PROP_TYPE_LRE
+#define LRO FRIBIDI_PROP_TYPE_LRO
+#define NSM FRIBIDI_PROP_TYPE_NSM
+#define PDF FRIBIDI_PROP_TYPE_PDF
+#define RLE FRIBIDI_PROP_TYPE_RLE
+#define RLO FRIBIDI_PROP_TYPE_RLO
+#define SS FRIBIDI_PROP_TYPE_SS
+#define WS FRIBIDI_PROP_TYPE_WS
+
+#define PACKTAB_UINT8 fribidi_uint8
+#define PACKTAB_UINT16 fribidi_uint16
+#define PACKTAB_UINT32 fribidi_uint32
+/*
+  Automatically generated by packtab.c version 2
+
+  just use FRIBIDI_GET_TYPE(key)
+
+  assumed sizeof(FriBidiPropCharType) == 1
+  required memory: 24320
+  lookups: 2
+  partition shape: FriBidiPropertyBlock[4352][256]
+  different table entries: 1 61
+*/
+
+/* *INDENT-OFF* */
+
+static const FriBidiPropCharType FriBidiPropertyBlockLevel1[256*61] = {
+
+#define FriBidiPropertyBlockLevel1_0000 0x0
+
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, SS, BS, SS, WS, BS, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BS, BS, BS, SS,
+   WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, BN,
+   BN, BN, BN, BN, BN, BS, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   CS, ON, ET, ET, ET, ET, ON, ON, ON, ON,LTR, ON, ON, BN, ON, ON,
+   ET, ET, EN, EN, ON,LTR, ON, ON, ON, EN,LTR, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0100 0x100
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0200 0x200
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_0300 0x300
+
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,
+  LTR,LTR,LTR,LTR, ON, ON,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0400 0x400
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0500 0x500
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,LTR,
+  RTL,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,RTL,NSM,
+  RTL,NSM,NSM,RTL,NSM,NSM,RTL,NSM,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+
+#define FriBidiPropertyBlockLevel1_0600 0x600
+
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, CS, AL, ON, ON,
+  NSM,NSM,NSM,NSM,NSM,NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL,
+   AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, ET, AN, AN, AL, AL, AL,
+  NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM, AL, AL,NSM,NSM, ON,NSM,NSM,NSM,NSM, AL, AL,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, AL, AL, AL, AL, AL, AL,
+
+#define FriBidiPropertyBlockLevel1_0700 0x700
+
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, BN,
+   AL,NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,RTL,RTL, ON, ON, ON, ON,RTL,RTL,RTL,RTL,RTL,RTL,
+
+#define FriBidiPropertyBlockLevel1_0800 0x800
+
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+
+#define FriBidiPropertyBlockLevel1_0900 0x900
+
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR, ET, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0A00 0xA00
+
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0B00 0xB00
+
+  LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,NSM,
+  LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ET, ON,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0C00 0xC00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,
+  NSM,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0D00 0xD00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0E00 0xE00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR, ET,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_0F00 0xF00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,LTR,NSM,LTR,NSM, ON, ON, ON, ON,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,
+  NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1000 0x1000
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,
+  NSM,LTR,NSM,LTR,LTR,LTR,NSM,NSM,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1300 0x1100
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1600 0x1200
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   WS,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1700 0x1300
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ET,LTR,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1800 0x1400
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,NSM,NSM,NSM, WS,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1900 0x1500
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,
+   ON,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_1A00 0x1600
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1B00 0x1700
+
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,NSM,LTR,NSM,NSM,NSM,NSM,NSM,LTR,NSM,LTR,LTR,LTR,
+  LTR,LTR,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1D00 0x1800
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,
+
+#define FriBidiPropertyBlockLevel1_1F00 0x1900
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR, ON,
+   ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,
+
+#define FriBidiPropertyBlockLevel1_2000 0x1A00
+
+   WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN,LTR,RTL,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, WS, BS,LRE,RLE,PDF,LRO,RLO, CS,
+   ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   EN,LTR,LTR,LTR, EN, EN, EN, EN, EN, EN, ES, ES, ON, ON, ON,LTR,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, ES, ES, ON, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET, ET,
+   ET, ET, ET, ET, ET, ET,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_2100 0x1B00
+
+   ON, ON,LTR, ON, ON, ON, ON,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR, ON,LTR, ON, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON,
+   ON, ON, ON, ON,LTR, ON,LTR, ON,LTR, ON,LTR,LTR,LTR,LTR, ET,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,
+  LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2200 0x1C00
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ES, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2300 0x1D00
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_2400 0x1E00
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2500 0x1F00
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2600 0x2000
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON,
+   ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_2700 0x2100
+
+  LTR, ON, ON, ON, ON,LTR, ON, ON, ON, ON,LTR,LTR, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON,LTR, ON,
+   ON, ON, ON,LTR,LTR,LTR, ON,LTR, ON, ON, ON, ON, ON, ON, ON,LTR,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2B00 0x2200
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_2C00 0x2300
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_2E00 0x2400
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_2F00 0x2500
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_3000 0x2600
+
+   WS, ON, ON, ON, ON,LTR,LTR,LTR, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,
+   ON,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM, ON, ON,LTR,LTR,LTR,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_3100 0x2700
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_3200 0x2800
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_3300 0x2900
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON,
+
+#define FriBidiPropertyBlockLevel1_4D00 0x2A00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+
+#define FriBidiPropertyBlockLevel1_A400 0x2B00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_A700 0x2C00
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+   ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_A800 0x2D00
+
+  LTR,LTR,NSM,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,NSM,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,NSM,NSM,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_FB00 0x2E00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,RTL,NSM,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, ES,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+
+#define FriBidiPropertyBlockLevel1_FC00 0x2F00
+
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+
+#define FriBidiPropertyBlockLevel1_FD00 0x3000
+
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, ON, ON,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, ON, AL, AL,
+
+#define FriBidiPropertyBlockLevel1_FE00 0x3100
+
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,
+  NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   CS, ON, CS,LTR, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ET,
+   ON, ON, ES, ES, ON, ON, ON,LTR, ON, ET, ET, ON,LTR,LTR,LTR,LTR,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+   AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, BN,
+
+#define FriBidiPropertyBlockLevel1_FF00 0x3200
+
+  LTR, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ET, ET, ON, ON, ON, ET, ET,LTR, ON, ON, ON, ON, ON, ON, ON,LTR,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, ON, ON, ON, ON, ON, BN, BN,
+
+#define FriBidiPropertyBlockLevel1_10100 0x3300
+
+  LTR, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_10900 0x3400
+
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL, ON,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+
+#define FriBidiPropertyBlockLevel1_10A00 0x3500
+
+  RTL,NSM,NSM,NSM,RTL,NSM,NSM,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,NSM,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,NSM,NSM,NSM,RTL,RTL,RTL,RTL,NSM,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+  RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,RTL,
+
+#define FriBidiPropertyBlockLevel1_1D100 0x3600
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR, BN, BN, BN, BN, BN, BN, BN, BN,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,LTR,LTR,NSM,NSM,NSM,NSM,NSM,NSM,NSM,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,NSM,NSM,NSM,NSM,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1D200 0x3700
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON,NSM,NSM,NSM, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1D300 0x3800
+
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
+   ON, ON, ON, ON, ON, ON, ON,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+
+#define FriBidiPropertyBlockLevel1_1D700 0x3900
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+   EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, EN,
+
+#define FriBidiPropertyBlockLevel1_1FF00 0x3A00
+
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,
+  LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR,LTR, BN, BN,
+
+#define FriBidiPropertyBlockLevel1_E0000 0x3B00
+
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+
+#define FriBidiPropertyBlockLevel1_E0100 0x3C00
+
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+  NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,NSM,
+   BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
+};
+
+static const PACKTAB_UINT16 FriBidiPropertyBlockLevel0[4352*1] = {
+
+#define FriBidiPropertyBlockLevel0_0000 0x0
+
+  FriBidiPropertyBlockLevel1_0000,  /* 0000..00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 0100..01FF */
+  FriBidiPropertyBlockLevel1_0200,  /* 0200..02FF */
+  FriBidiPropertyBlockLevel1_0300,  /* 0300..03FF */
+  FriBidiPropertyBlockLevel1_0400,  /* 0400..04FF */
+  FriBidiPropertyBlockLevel1_0500,  /* 0500..05FF */
+  FriBidiPropertyBlockLevel1_0600,  /* 0600..06FF */
+  FriBidiPropertyBlockLevel1_0700,  /* 0700..07FF */
+  FriBidiPropertyBlockLevel1_0800,  /* 0800..08FF */
+  FriBidiPropertyBlockLevel1_0900,  /* 0900..09FF */
+  FriBidiPropertyBlockLevel1_0A00,  /* 0A00..0AFF */
+  FriBidiPropertyBlockLevel1_0B00,  /* 0B00..0BFF */
+  FriBidiPropertyBlockLevel1_0C00,  /* 0C00..0CFF */
+  FriBidiPropertyBlockLevel1_0D00,  /* 0D00..0DFF */
+  FriBidiPropertyBlockLevel1_0E00,  /* 0E00..0EFF */
+  FriBidiPropertyBlockLevel1_0F00,  /* 0F00..0FFF */
+  FriBidiPropertyBlockLevel1_1000,  /* 1000..10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1100..11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1200..12FF */
+  FriBidiPropertyBlockLevel1_1300,  /* 1300..13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1400..14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1500..15FF */
+  FriBidiPropertyBlockLevel1_1600,  /* 1600..16FF */
+  FriBidiPropertyBlockLevel1_1700,  /* 1700..17FF */
+  FriBidiPropertyBlockLevel1_1800,  /* 1800..18FF */
+  FriBidiPropertyBlockLevel1_1900,  /* 1900..19FF */
+  FriBidiPropertyBlockLevel1_1A00,  /* 1A00..1AFF */
+  FriBidiPropertyBlockLevel1_1B00,  /* 1B00..1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C00..1CFF */
+  FriBidiPropertyBlockLevel1_1D00,  /* 1D00..1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E00..1EFF */
+  FriBidiPropertyBlockLevel1_1F00,  /* 1F00..1FFF */
+  FriBidiPropertyBlockLevel1_2000,  /* 2000..20FF */
+  FriBidiPropertyBlockLevel1_2100,  /* 2100..21FF */
+  FriBidiPropertyBlockLevel1_2200,  /* 2200..22FF */
+  FriBidiPropertyBlockLevel1_2300,  /* 2300..23FF */
+  FriBidiPropertyBlockLevel1_2400,  /* 2400..24FF */
+  FriBidiPropertyBlockLevel1_2500,  /* 2500..25FF */
+  FriBidiPropertyBlockLevel1_2600,  /* 2600..26FF */
+  FriBidiPropertyBlockLevel1_2700,  /* 2700..27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2800..28FF */
+  FriBidiPropertyBlockLevel1_2500,  /* 2900..29FF */
+  FriBidiPropertyBlockLevel1_2500,  /* 2A00..2AFF */
+  FriBidiPropertyBlockLevel1_2B00,  /* 2B00..2BFF */
+  FriBidiPropertyBlockLevel1_2C00,  /* 2C00..2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D00..2DFF */
+  FriBidiPropertyBlockLevel1_2E00,  /* 2E00..2EFF */
+  FriBidiPropertyBlockLevel1_2F00,  /* 2F00..2FFF */
+  FriBidiPropertyBlockLevel1_3000,  /* 3000..30FF */
+  FriBidiPropertyBlockLevel1_3100,  /* 3100..31FF */
+  FriBidiPropertyBlockLevel1_3200,  /* 3200..32FF */
+  FriBidiPropertyBlockLevel1_3300,  /* 3300..33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3400..34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3500..35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3600..36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3700..37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3800..38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3900..39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A00..3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B00..3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C00..3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D00..3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E00..3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F00..3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4000..40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4100..41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4200..42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4300..43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4400..44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4500..45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4600..46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4700..47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4800..48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4900..49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A00..4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B00..4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C00..4CFF */
+  FriBidiPropertyBlockLevel1_4D00,  /* 4D00..4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E00..4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F00..4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5000..50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5100..51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5200..52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5300..53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5400..54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5500..55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5600..56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5700..57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5800..58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5900..59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A00..5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B00..5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C00..5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D00..5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E00..5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F00..5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6000..60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6100..61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6200..62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6300..63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6400..64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6500..65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6600..66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6700..67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6800..68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6900..69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A00..6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B00..6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C00..6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D00..6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E00..6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F00..6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7000..70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7100..71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7200..72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7300..73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7400..74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7500..75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7600..76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7700..77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7800..78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7900..79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A00..7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B00..7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C00..7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D00..7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E00..7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F00..7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8000..80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8100..81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8200..82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8300..83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8400..84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8500..85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8600..86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8700..87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8800..88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8900..89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A00..8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B00..8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C00..8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D00..8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E00..8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F00..8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9000..90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9100..91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9200..92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9300..93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9400..94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9500..95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9600..96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9700..97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9800..98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9900..99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A00..9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B00..9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C00..9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D00..9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E00..9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F00..9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A000..A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A100..A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A200..A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A300..A3FF */
+  FriBidiPropertyBlockLevel1_A400,  /* A400..A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A500..A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A600..A6FF */
+  FriBidiPropertyBlockLevel1_A700,  /* A700..A7FF */
+  FriBidiPropertyBlockLevel1_A800,  /* A800..A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A900..A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA00..AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB00..ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC00..ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD00..ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE00..AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF00..AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B000..B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B100..B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B200..B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B300..B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B400..B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B500..B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B600..B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B700..B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B800..B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B900..B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA00..BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB00..BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC00..BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD00..BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE00..BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF00..BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C000..C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C100..C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C200..C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C300..C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C400..C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C500..C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C600..C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C700..C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C800..C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C900..C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA00..CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB00..CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC00..CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD00..CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE00..CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF00..CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D000..D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D100..D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D200..D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D300..D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D400..D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D500..D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D600..D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D700..D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D800..D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D900..D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA00..DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB00..DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC00..DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD00..DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE00..DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF00..DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E000..E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E100..E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E200..E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E300..E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E400..E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E500..E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E600..E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E700..E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E800..E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E900..E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA00..EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB00..EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC00..ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED00..EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE00..EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF00..EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F000..F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F100..F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F200..F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F300..F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F400..F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F500..F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F600..F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F700..F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F800..F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F900..F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA00..FAFF */
+  FriBidiPropertyBlockLevel1_FB00,  /* FB00..FBFF */
+  FriBidiPropertyBlockLevel1_FC00,  /* FC00..FCFF */
+  FriBidiPropertyBlockLevel1_FD00,  /* FD00..FDFF */
+  FriBidiPropertyBlockLevel1_FE00,  /* FE00..FEFF */
+  FriBidiPropertyBlockLevel1_FF00,  /* FF00..FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10000..100FF */
+  FriBidiPropertyBlockLevel1_10100,  /* 10100..101FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10200..102FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10300..103FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10400..104FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10500..105FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10600..106FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10700..107FF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10800..108FF */
+  FriBidiPropertyBlockLevel1_10900,  /* 10900..109FF */
+  FriBidiPropertyBlockLevel1_10A00,  /* 10A00..10AFF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10B00..10BFF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10C00..10CFF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10D00..10DFF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10E00..10EFF */
+  FriBidiPropertyBlockLevel1_0800,  /* 10F00..10FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11000..110FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11100..111FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11200..112FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11300..113FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11400..114FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11500..115FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11600..116FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11700..117FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11800..118FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11900..119FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11A00..11AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11B00..11BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11C00..11CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11D00..11DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11E00..11EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 11F00..11FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12000..120FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12100..121FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12200..122FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12300..123FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12400..124FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12500..125FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12600..126FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12700..127FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12800..128FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12900..129FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12A00..12AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12B00..12BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12C00..12CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12D00..12DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12E00..12EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 12F00..12FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13000..130FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13100..131FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13200..132FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13300..133FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13400..134FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13500..135FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13600..136FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13700..137FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13800..138FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13900..139FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13A00..13AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13B00..13BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13C00..13CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13D00..13DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13E00..13EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 13F00..13FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14000..140FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14100..141FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14200..142FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14300..143FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14400..144FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14500..145FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14600..146FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14700..147FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14800..148FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14900..149FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14A00..14AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14B00..14BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14C00..14CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14D00..14DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14E00..14EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 14F00..14FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15000..150FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15100..151FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15200..152FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15300..153FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15400..154FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15500..155FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15600..156FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15700..157FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15800..158FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15900..159FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15A00..15AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15B00..15BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15C00..15CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15D00..15DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15E00..15EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 15F00..15FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16000..160FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16100..161FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16200..162FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16300..163FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16400..164FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16500..165FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16600..166FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16700..167FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16800..168FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16900..169FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16A00..16AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16B00..16BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16C00..16CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16D00..16DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16E00..16EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 16F00..16FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17000..170FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17100..171FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17200..172FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17300..173FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17400..174FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17500..175FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17600..176FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17700..177FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17800..178FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17900..179FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17A00..17AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17B00..17BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17C00..17CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17D00..17DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17E00..17EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 17F00..17FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18000..180FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18100..181FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18200..182FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18300..183FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18400..184FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18500..185FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18600..186FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18700..187FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18800..188FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18900..189FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18A00..18AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18B00..18BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18C00..18CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18D00..18DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18E00..18EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 18F00..18FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19000..190FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19100..191FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19200..192FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19300..193FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19400..194FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19500..195FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19600..196FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19700..197FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19800..198FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19900..199FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19A00..19AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19B00..19BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19C00..19CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19D00..19DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19E00..19EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 19F00..19FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A000..1A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A100..1A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A200..1A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A300..1A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A400..1A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A500..1A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A600..1A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A700..1A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A800..1A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1A900..1A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AA00..1AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AB00..1ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AC00..1ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AD00..1ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AE00..1AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1AF00..1AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B000..1B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B100..1B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B200..1B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B300..1B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B400..1B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B500..1B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B600..1B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B700..1B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B800..1B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1B900..1B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BA00..1BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BB00..1BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BC00..1BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BD00..1BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BE00..1BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1BF00..1BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C000..1C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C100..1C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C200..1C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C300..1C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C400..1C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C500..1C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C600..1C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C700..1C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C800..1C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1C900..1C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CA00..1CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CB00..1CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CC00..1CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CD00..1CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CE00..1CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1CF00..1CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D000..1D0FF */
+  FriBidiPropertyBlockLevel1_1D100,  /* 1D100..1D1FF */
+  FriBidiPropertyBlockLevel1_1D200,  /* 1D200..1D2FF */
+  FriBidiPropertyBlockLevel1_1D300,  /* 1D300..1D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D400..1D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D500..1D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D600..1D6FF */
+  FriBidiPropertyBlockLevel1_1D700,  /* 1D700..1D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D800..1D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1D900..1D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DA00..1DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DB00..1DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DC00..1DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DD00..1DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DE00..1DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1DF00..1DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E000..1E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E100..1E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E200..1E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E300..1E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E400..1E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E500..1E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E600..1E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E700..1E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E800..1E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1E900..1E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1EA00..1EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1EB00..1EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1EC00..1ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1ED00..1EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1EE00..1EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1EF00..1EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F000..1F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F100..1F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F200..1F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F300..1F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F400..1F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F500..1F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F600..1F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F700..1F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F800..1F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1F900..1F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1FA00..1FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1FB00..1FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1FC00..1FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1FD00..1FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 1FE00..1FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 1FF00..1FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20000..200FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20100..201FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20200..202FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20300..203FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20400..204FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20500..205FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20600..206FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20700..207FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20800..208FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20900..209FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20A00..20AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20B00..20BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20C00..20CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20D00..20DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20E00..20EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 20F00..20FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21000..210FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21100..211FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21200..212FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21300..213FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21400..214FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21500..215FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21600..216FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21700..217FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21800..218FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21900..219FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21A00..21AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21B00..21BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21C00..21CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21D00..21DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21E00..21EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 21F00..21FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22000..220FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22100..221FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22200..222FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22300..223FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22400..224FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22500..225FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22600..226FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22700..227FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22800..228FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22900..229FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22A00..22AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22B00..22BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22C00..22CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22D00..22DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22E00..22EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 22F00..22FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23000..230FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23100..231FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23200..232FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23300..233FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23400..234FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23500..235FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23600..236FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23700..237FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23800..238FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23900..239FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23A00..23AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23B00..23BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23C00..23CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23D00..23DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23E00..23EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 23F00..23FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24000..240FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24100..241FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24200..242FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24300..243FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24400..244FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24500..245FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24600..246FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24700..247FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24800..248FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24900..249FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24A00..24AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24B00..24BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24C00..24CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24D00..24DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24E00..24EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 24F00..24FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25000..250FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25100..251FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25200..252FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25300..253FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25400..254FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25500..255FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25600..256FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25700..257FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25800..258FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25900..259FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25A00..25AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25B00..25BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25C00..25CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25D00..25DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25E00..25EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 25F00..25FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26000..260FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26100..261FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26200..262FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26300..263FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26400..264FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26500..265FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26600..266FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26700..267FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26800..268FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26900..269FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26A00..26AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26B00..26BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26C00..26CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26D00..26DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26E00..26EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 26F00..26FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27000..270FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27100..271FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27200..272FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27300..273FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27400..274FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27500..275FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27600..276FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27700..277FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27800..278FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27900..279FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27A00..27AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27B00..27BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27C00..27CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27D00..27DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27E00..27EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 27F00..27FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28000..280FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28100..281FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28200..282FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28300..283FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28400..284FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28500..285FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28600..286FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28700..287FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28800..288FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28900..289FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28A00..28AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28B00..28BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28C00..28CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28D00..28DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28E00..28EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 28F00..28FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29000..290FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29100..291FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29200..292FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29300..293FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29400..294FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29500..295FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29600..296FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29700..297FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29800..298FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29900..299FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29A00..29AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29B00..29BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29C00..29CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29D00..29DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29E00..29EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 29F00..29FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A000..2A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A100..2A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A200..2A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A300..2A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A400..2A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A500..2A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A600..2A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A700..2A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A800..2A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2A900..2A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AA00..2AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AB00..2ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AC00..2ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AD00..2ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AE00..2AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2AF00..2AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B000..2B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B100..2B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B200..2B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B300..2B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B400..2B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B500..2B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B600..2B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B700..2B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B800..2B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2B900..2B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BA00..2BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BB00..2BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BC00..2BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BD00..2BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BE00..2BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2BF00..2BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C000..2C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C100..2C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C200..2C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C300..2C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C400..2C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C500..2C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C600..2C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C700..2C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C800..2C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2C900..2C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CA00..2CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CB00..2CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CC00..2CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CD00..2CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CE00..2CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2CF00..2CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D000..2D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D100..2D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D200..2D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D300..2D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D400..2D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D500..2D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D600..2D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D700..2D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D800..2D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2D900..2D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DA00..2DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DB00..2DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DC00..2DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DD00..2DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DE00..2DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2DF00..2DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E000..2E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E100..2E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E200..2E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E300..2E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E400..2E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E500..2E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E600..2E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E700..2E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E800..2E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2E900..2E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2EA00..2EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2EB00..2EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2EC00..2ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2ED00..2EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2EE00..2EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2EF00..2EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F000..2F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F100..2F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F200..2F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F300..2F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F400..2F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F500..2F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F600..2F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F700..2F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F800..2F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2F900..2F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2FA00..2FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2FB00..2FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2FC00..2FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2FD00..2FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 2FE00..2FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 2FF00..2FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30000..300FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30100..301FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30200..302FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30300..303FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30400..304FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30500..305FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30600..306FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30700..307FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30800..308FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30900..309FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30A00..30AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30B00..30BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30C00..30CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30D00..30DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30E00..30EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 30F00..30FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31000..310FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31100..311FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31200..312FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31300..313FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31400..314FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31500..315FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31600..316FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31700..317FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31800..318FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31900..319FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31A00..31AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31B00..31BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31C00..31CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31D00..31DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31E00..31EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 31F00..31FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32000..320FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32100..321FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32200..322FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32300..323FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32400..324FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32500..325FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32600..326FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32700..327FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32800..328FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32900..329FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32A00..32AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32B00..32BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32C00..32CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32D00..32DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32E00..32EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 32F00..32FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33000..330FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33100..331FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33200..332FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33300..333FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33400..334FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33500..335FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33600..336FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33700..337FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33800..338FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33900..339FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33A00..33AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33B00..33BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33C00..33CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33D00..33DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33E00..33EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 33F00..33FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34000..340FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34100..341FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34200..342FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34300..343FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34400..344FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34500..345FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34600..346FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34700..347FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34800..348FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34900..349FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34A00..34AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34B00..34BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34C00..34CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34D00..34DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34E00..34EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 34F00..34FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35000..350FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35100..351FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35200..352FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35300..353FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35400..354FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35500..355FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35600..356FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35700..357FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35800..358FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35900..359FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35A00..35AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35B00..35BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35C00..35CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35D00..35DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35E00..35EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 35F00..35FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36000..360FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36100..361FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36200..362FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36300..363FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36400..364FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36500..365FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36600..366FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36700..367FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36800..368FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36900..369FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36A00..36AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36B00..36BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36C00..36CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36D00..36DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36E00..36EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 36F00..36FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37000..370FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37100..371FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37200..372FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37300..373FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37400..374FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37500..375FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37600..376FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37700..377FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37800..378FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37900..379FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37A00..37AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37B00..37BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37C00..37CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37D00..37DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37E00..37EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 37F00..37FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38000..380FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38100..381FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38200..382FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38300..383FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38400..384FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38500..385FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38600..386FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38700..387FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38800..388FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38900..389FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38A00..38AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38B00..38BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38C00..38CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38D00..38DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38E00..38EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 38F00..38FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39000..390FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39100..391FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39200..392FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39300..393FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39400..394FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39500..395FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39600..396FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39700..397FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39800..398FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39900..399FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39A00..39AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39B00..39BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39C00..39CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39D00..39DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39E00..39EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 39F00..39FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A000..3A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A100..3A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A200..3A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A300..3A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A400..3A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A500..3A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A600..3A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A700..3A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A800..3A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3A900..3A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AA00..3AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AB00..3ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AC00..3ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AD00..3ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AE00..3AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3AF00..3AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B000..3B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B100..3B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B200..3B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B300..3B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B400..3B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B500..3B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B600..3B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B700..3B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B800..3B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3B900..3B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BA00..3BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BB00..3BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BC00..3BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BD00..3BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BE00..3BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3BF00..3BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C000..3C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C100..3C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C200..3C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C300..3C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C400..3C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C500..3C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C600..3C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C700..3C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C800..3C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3C900..3C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CA00..3CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CB00..3CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CC00..3CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CD00..3CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CE00..3CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3CF00..3CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D000..3D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D100..3D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D200..3D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D300..3D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D400..3D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D500..3D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D600..3D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D700..3D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D800..3D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3D900..3D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DA00..3DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DB00..3DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DC00..3DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DD00..3DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DE00..3DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3DF00..3DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E000..3E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E100..3E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E200..3E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E300..3E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E400..3E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E500..3E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E600..3E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E700..3E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E800..3E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3E900..3E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3EA00..3EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3EB00..3EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3EC00..3ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3ED00..3EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3EE00..3EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3EF00..3EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F000..3F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F100..3F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F200..3F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F300..3F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F400..3F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F500..3F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F600..3F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F700..3F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F800..3F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3F900..3F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3FA00..3FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3FB00..3FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3FC00..3FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3FD00..3FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 3FE00..3FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 3FF00..3FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40000..400FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40100..401FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40200..402FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40300..403FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40400..404FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40500..405FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40600..406FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40700..407FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40800..408FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40900..409FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40A00..40AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40B00..40BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40C00..40CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40D00..40DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40E00..40EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 40F00..40FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41000..410FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41100..411FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41200..412FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41300..413FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41400..414FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41500..415FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41600..416FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41700..417FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41800..418FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41900..419FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41A00..41AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41B00..41BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41C00..41CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41D00..41DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41E00..41EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 41F00..41FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42000..420FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42100..421FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42200..422FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42300..423FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42400..424FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42500..425FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42600..426FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42700..427FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42800..428FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42900..429FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42A00..42AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42B00..42BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42C00..42CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42D00..42DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42E00..42EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 42F00..42FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43000..430FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43100..431FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43200..432FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43300..433FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43400..434FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43500..435FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43600..436FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43700..437FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43800..438FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43900..439FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43A00..43AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43B00..43BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43C00..43CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43D00..43DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43E00..43EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 43F00..43FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44000..440FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44100..441FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44200..442FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44300..443FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44400..444FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44500..445FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44600..446FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44700..447FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44800..448FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44900..449FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44A00..44AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44B00..44BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44C00..44CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44D00..44DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44E00..44EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 44F00..44FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45000..450FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45100..451FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45200..452FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45300..453FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45400..454FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45500..455FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45600..456FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45700..457FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45800..458FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45900..459FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45A00..45AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45B00..45BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45C00..45CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45D00..45DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45E00..45EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 45F00..45FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46000..460FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46100..461FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46200..462FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46300..463FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46400..464FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46500..465FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46600..466FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46700..467FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46800..468FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46900..469FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46A00..46AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46B00..46BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46C00..46CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46D00..46DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46E00..46EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 46F00..46FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47000..470FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47100..471FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47200..472FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47300..473FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47400..474FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47500..475FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47600..476FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47700..477FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47800..478FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47900..479FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47A00..47AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47B00..47BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47C00..47CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47D00..47DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47E00..47EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 47F00..47FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48000..480FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48100..481FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48200..482FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48300..483FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48400..484FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48500..485FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48600..486FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48700..487FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48800..488FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48900..489FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48A00..48AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48B00..48BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48C00..48CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48D00..48DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48E00..48EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 48F00..48FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49000..490FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49100..491FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49200..492FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49300..493FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49400..494FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49500..495FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49600..496FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49700..497FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49800..498FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49900..499FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49A00..49AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49B00..49BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49C00..49CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49D00..49DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49E00..49EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 49F00..49FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A000..4A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A100..4A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A200..4A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A300..4A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A400..4A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A500..4A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A600..4A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A700..4A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A800..4A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4A900..4A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AA00..4AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AB00..4ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AC00..4ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AD00..4ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AE00..4AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4AF00..4AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B000..4B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B100..4B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B200..4B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B300..4B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B400..4B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B500..4B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B600..4B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B700..4B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B800..4B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4B900..4B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BA00..4BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BB00..4BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BC00..4BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BD00..4BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BE00..4BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4BF00..4BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C000..4C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C100..4C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C200..4C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C300..4C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C400..4C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C500..4C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C600..4C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C700..4C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C800..4C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4C900..4C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CA00..4CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CB00..4CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CC00..4CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CD00..4CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CE00..4CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4CF00..4CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D000..4D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D100..4D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D200..4D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D300..4D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D400..4D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D500..4D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D600..4D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D700..4D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D800..4D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4D900..4D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DA00..4DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DB00..4DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DC00..4DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DD00..4DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DE00..4DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4DF00..4DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E000..4E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E100..4E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E200..4E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E300..4E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E400..4E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E500..4E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E600..4E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E700..4E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E800..4E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4E900..4E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4EA00..4EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4EB00..4EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4EC00..4ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4ED00..4EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4EE00..4EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4EF00..4EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F000..4F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F100..4F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F200..4F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F300..4F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F400..4F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F500..4F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F600..4F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F700..4F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F800..4F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4F900..4F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4FA00..4FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4FB00..4FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4FC00..4FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4FD00..4FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 4FE00..4FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 4FF00..4FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50000..500FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50100..501FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50200..502FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50300..503FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50400..504FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50500..505FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50600..506FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50700..507FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50800..508FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50900..509FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50A00..50AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50B00..50BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50C00..50CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50D00..50DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50E00..50EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 50F00..50FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51000..510FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51100..511FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51200..512FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51300..513FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51400..514FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51500..515FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51600..516FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51700..517FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51800..518FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51900..519FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51A00..51AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51B00..51BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51C00..51CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51D00..51DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51E00..51EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 51F00..51FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52000..520FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52100..521FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52200..522FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52300..523FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52400..524FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52500..525FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52600..526FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52700..527FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52800..528FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52900..529FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52A00..52AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52B00..52BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52C00..52CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52D00..52DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52E00..52EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 52F00..52FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53000..530FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53100..531FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53200..532FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53300..533FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53400..534FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53500..535FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53600..536FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53700..537FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53800..538FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53900..539FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53A00..53AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53B00..53BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53C00..53CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53D00..53DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53E00..53EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 53F00..53FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54000..540FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54100..541FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54200..542FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54300..543FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54400..544FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54500..545FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54600..546FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54700..547FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54800..548FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54900..549FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54A00..54AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54B00..54BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54C00..54CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54D00..54DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54E00..54EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 54F00..54FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55000..550FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55100..551FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55200..552FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55300..553FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55400..554FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55500..555FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55600..556FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55700..557FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55800..558FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55900..559FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55A00..55AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55B00..55BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55C00..55CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55D00..55DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55E00..55EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 55F00..55FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56000..560FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56100..561FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56200..562FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56300..563FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56400..564FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56500..565FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56600..566FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56700..567FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56800..568FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56900..569FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56A00..56AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56B00..56BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56C00..56CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56D00..56DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56E00..56EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 56F00..56FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57000..570FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57100..571FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57200..572FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57300..573FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57400..574FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57500..575FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57600..576FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57700..577FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57800..578FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57900..579FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57A00..57AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57B00..57BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57C00..57CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57D00..57DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57E00..57EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 57F00..57FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58000..580FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58100..581FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58200..582FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58300..583FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58400..584FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58500..585FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58600..586FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58700..587FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58800..588FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58900..589FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58A00..58AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58B00..58BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58C00..58CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58D00..58DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58E00..58EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 58F00..58FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59000..590FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59100..591FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59200..592FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59300..593FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59400..594FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59500..595FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59600..596FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59700..597FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59800..598FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59900..599FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59A00..59AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59B00..59BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59C00..59CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59D00..59DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59E00..59EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 59F00..59FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A000..5A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A100..5A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A200..5A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A300..5A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A400..5A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A500..5A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A600..5A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A700..5A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A800..5A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5A900..5A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AA00..5AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AB00..5ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AC00..5ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AD00..5ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AE00..5AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5AF00..5AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B000..5B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B100..5B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B200..5B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B300..5B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B400..5B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B500..5B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B600..5B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B700..5B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B800..5B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5B900..5B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BA00..5BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BB00..5BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BC00..5BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BD00..5BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BE00..5BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5BF00..5BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C000..5C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C100..5C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C200..5C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C300..5C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C400..5C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C500..5C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C600..5C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C700..5C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C800..5C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5C900..5C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CA00..5CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CB00..5CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CC00..5CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CD00..5CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CE00..5CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5CF00..5CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D000..5D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D100..5D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D200..5D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D300..5D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D400..5D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D500..5D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D600..5D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D700..5D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D800..5D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5D900..5D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DA00..5DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DB00..5DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DC00..5DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DD00..5DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DE00..5DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5DF00..5DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E000..5E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E100..5E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E200..5E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E300..5E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E400..5E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E500..5E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E600..5E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E700..5E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E800..5E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5E900..5E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5EA00..5EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5EB00..5EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5EC00..5ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5ED00..5EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5EE00..5EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5EF00..5EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F000..5F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F100..5F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F200..5F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F300..5F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F400..5F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F500..5F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F600..5F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F700..5F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F800..5F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5F900..5F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5FA00..5FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5FB00..5FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5FC00..5FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5FD00..5FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 5FE00..5FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 5FF00..5FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60000..600FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60100..601FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60200..602FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60300..603FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60400..604FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60500..605FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60600..606FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60700..607FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60800..608FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60900..609FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60A00..60AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60B00..60BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60C00..60CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60D00..60DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60E00..60EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 60F00..60FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61000..610FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61100..611FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61200..612FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61300..613FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61400..614FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61500..615FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61600..616FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61700..617FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61800..618FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61900..619FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61A00..61AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61B00..61BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61C00..61CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61D00..61DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61E00..61EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 61F00..61FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62000..620FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62100..621FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62200..622FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62300..623FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62400..624FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62500..625FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62600..626FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62700..627FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62800..628FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62900..629FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62A00..62AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62B00..62BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62C00..62CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62D00..62DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62E00..62EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 62F00..62FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63000..630FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63100..631FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63200..632FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63300..633FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63400..634FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63500..635FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63600..636FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63700..637FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63800..638FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63900..639FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63A00..63AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63B00..63BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63C00..63CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63D00..63DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63E00..63EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 63F00..63FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64000..640FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64100..641FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64200..642FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64300..643FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64400..644FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64500..645FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64600..646FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64700..647FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64800..648FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64900..649FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64A00..64AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64B00..64BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64C00..64CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64D00..64DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64E00..64EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 64F00..64FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65000..650FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65100..651FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65200..652FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65300..653FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65400..654FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65500..655FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65600..656FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65700..657FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65800..658FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65900..659FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65A00..65AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65B00..65BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65C00..65CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65D00..65DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65E00..65EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 65F00..65FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66000..660FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66100..661FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66200..662FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66300..663FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66400..664FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66500..665FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66600..666FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66700..667FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66800..668FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66900..669FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66A00..66AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66B00..66BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66C00..66CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66D00..66DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66E00..66EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 66F00..66FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67000..670FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67100..671FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67200..672FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67300..673FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67400..674FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67500..675FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67600..676FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67700..677FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67800..678FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67900..679FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67A00..67AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67B00..67BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67C00..67CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67D00..67DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67E00..67EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 67F00..67FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68000..680FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68100..681FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68200..682FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68300..683FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68400..684FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68500..685FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68600..686FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68700..687FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68800..688FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68900..689FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68A00..68AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68B00..68BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68C00..68CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68D00..68DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68E00..68EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 68F00..68FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69000..690FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69100..691FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69200..692FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69300..693FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69400..694FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69500..695FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69600..696FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69700..697FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69800..698FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69900..699FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69A00..69AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69B00..69BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69C00..69CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69D00..69DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69E00..69EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 69F00..69FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A000..6A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A100..6A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A200..6A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A300..6A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A400..6A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A500..6A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A600..6A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A700..6A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A800..6A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6A900..6A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AA00..6AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AB00..6ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AC00..6ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AD00..6ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AE00..6AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6AF00..6AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B000..6B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B100..6B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B200..6B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B300..6B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B400..6B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B500..6B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B600..6B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B700..6B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B800..6B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6B900..6B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BA00..6BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BB00..6BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BC00..6BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BD00..6BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BE00..6BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6BF00..6BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C000..6C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C100..6C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C200..6C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C300..6C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C400..6C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C500..6C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C600..6C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C700..6C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C800..6C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6C900..6C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CA00..6CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CB00..6CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CC00..6CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CD00..6CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CE00..6CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6CF00..6CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D000..6D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D100..6D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D200..6D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D300..6D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D400..6D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D500..6D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D600..6D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D700..6D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D800..6D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6D900..6D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DA00..6DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DB00..6DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DC00..6DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DD00..6DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DE00..6DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6DF00..6DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E000..6E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E100..6E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E200..6E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E300..6E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E400..6E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E500..6E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E600..6E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E700..6E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E800..6E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6E900..6E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6EA00..6EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6EB00..6EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6EC00..6ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6ED00..6EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6EE00..6EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6EF00..6EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F000..6F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F100..6F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F200..6F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F300..6F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F400..6F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F500..6F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F600..6F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F700..6F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F800..6F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6F900..6F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6FA00..6FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6FB00..6FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6FC00..6FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6FD00..6FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 6FE00..6FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 6FF00..6FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70000..700FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70100..701FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70200..702FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70300..703FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70400..704FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70500..705FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70600..706FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70700..707FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70800..708FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70900..709FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70A00..70AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70B00..70BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70C00..70CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70D00..70DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70E00..70EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 70F00..70FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71000..710FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71100..711FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71200..712FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71300..713FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71400..714FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71500..715FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71600..716FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71700..717FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71800..718FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71900..719FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71A00..71AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71B00..71BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71C00..71CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71D00..71DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71E00..71EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 71F00..71FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72000..720FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72100..721FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72200..722FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72300..723FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72400..724FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72500..725FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72600..726FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72700..727FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72800..728FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72900..729FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72A00..72AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72B00..72BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72C00..72CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72D00..72DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72E00..72EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 72F00..72FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73000..730FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73100..731FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73200..732FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73300..733FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73400..734FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73500..735FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73600..736FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73700..737FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73800..738FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73900..739FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73A00..73AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73B00..73BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73C00..73CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73D00..73DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73E00..73EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 73F00..73FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74000..740FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74100..741FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74200..742FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74300..743FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74400..744FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74500..745FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74600..746FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74700..747FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74800..748FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74900..749FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74A00..74AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74B00..74BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74C00..74CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74D00..74DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74E00..74EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 74F00..74FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75000..750FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75100..751FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75200..752FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75300..753FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75400..754FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75500..755FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75600..756FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75700..757FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75800..758FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75900..759FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75A00..75AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75B00..75BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75C00..75CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75D00..75DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75E00..75EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 75F00..75FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76000..760FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76100..761FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76200..762FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76300..763FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76400..764FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76500..765FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76600..766FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76700..767FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76800..768FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76900..769FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76A00..76AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76B00..76BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76C00..76CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76D00..76DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76E00..76EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 76F00..76FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77000..770FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77100..771FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77200..772FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77300..773FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77400..774FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77500..775FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77600..776FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77700..777FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77800..778FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77900..779FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77A00..77AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77B00..77BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77C00..77CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77D00..77DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77E00..77EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 77F00..77FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78000..780FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78100..781FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78200..782FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78300..783FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78400..784FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78500..785FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78600..786FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78700..787FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78800..788FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78900..789FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78A00..78AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78B00..78BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78C00..78CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78D00..78DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78E00..78EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 78F00..78FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79000..790FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79100..791FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79200..792FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79300..793FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79400..794FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79500..795FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79600..796FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79700..797FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79800..798FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79900..799FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79A00..79AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79B00..79BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79C00..79CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79D00..79DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79E00..79EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 79F00..79FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A000..7A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A100..7A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A200..7A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A300..7A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A400..7A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A500..7A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A600..7A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A700..7A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A800..7A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7A900..7A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AA00..7AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AB00..7ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AC00..7ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AD00..7ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AE00..7AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7AF00..7AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B000..7B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B100..7B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B200..7B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B300..7B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B400..7B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B500..7B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B600..7B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B700..7B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B800..7B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7B900..7B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BA00..7BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BB00..7BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BC00..7BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BD00..7BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BE00..7BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7BF00..7BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C000..7C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C100..7C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C200..7C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C300..7C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C400..7C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C500..7C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C600..7C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C700..7C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C800..7C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7C900..7C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CA00..7CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CB00..7CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CC00..7CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CD00..7CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CE00..7CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7CF00..7CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D000..7D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D100..7D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D200..7D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D300..7D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D400..7D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D500..7D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D600..7D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D700..7D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D800..7D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7D900..7D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DA00..7DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DB00..7DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DC00..7DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DD00..7DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DE00..7DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7DF00..7DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E000..7E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E100..7E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E200..7E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E300..7E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E400..7E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E500..7E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E600..7E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E700..7E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E800..7E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7E900..7E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7EA00..7EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7EB00..7EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7EC00..7ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7ED00..7EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7EE00..7EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7EF00..7EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F000..7F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F100..7F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F200..7F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F300..7F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F400..7F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F500..7F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F600..7F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F700..7F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F800..7F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7F900..7F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7FA00..7FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7FB00..7FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7FC00..7FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7FD00..7FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 7FE00..7FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 7FF00..7FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80000..800FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80100..801FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80200..802FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80300..803FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80400..804FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80500..805FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80600..806FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80700..807FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80800..808FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80900..809FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80A00..80AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80B00..80BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80C00..80CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80D00..80DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80E00..80EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 80F00..80FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81000..810FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81100..811FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81200..812FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81300..813FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81400..814FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81500..815FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81600..816FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81700..817FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81800..818FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81900..819FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81A00..81AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81B00..81BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81C00..81CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81D00..81DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81E00..81EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 81F00..81FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82000..820FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82100..821FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82200..822FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82300..823FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82400..824FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82500..825FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82600..826FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82700..827FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82800..828FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82900..829FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82A00..82AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82B00..82BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82C00..82CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82D00..82DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82E00..82EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 82F00..82FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83000..830FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83100..831FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83200..832FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83300..833FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83400..834FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83500..835FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83600..836FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83700..837FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83800..838FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83900..839FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83A00..83AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83B00..83BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83C00..83CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83D00..83DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83E00..83EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 83F00..83FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84000..840FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84100..841FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84200..842FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84300..843FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84400..844FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84500..845FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84600..846FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84700..847FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84800..848FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84900..849FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84A00..84AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84B00..84BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84C00..84CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84D00..84DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84E00..84EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 84F00..84FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85000..850FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85100..851FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85200..852FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85300..853FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85400..854FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85500..855FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85600..856FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85700..857FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85800..858FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85900..859FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85A00..85AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85B00..85BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85C00..85CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85D00..85DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85E00..85EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 85F00..85FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86000..860FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86100..861FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86200..862FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86300..863FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86400..864FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86500..865FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86600..866FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86700..867FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86800..868FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86900..869FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86A00..86AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86B00..86BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86C00..86CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86D00..86DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86E00..86EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 86F00..86FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87000..870FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87100..871FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87200..872FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87300..873FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87400..874FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87500..875FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87600..876FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87700..877FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87800..878FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87900..879FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87A00..87AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87B00..87BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87C00..87CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87D00..87DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87E00..87EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 87F00..87FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88000..880FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88100..881FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88200..882FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88300..883FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88400..884FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88500..885FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88600..886FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88700..887FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88800..888FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88900..889FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88A00..88AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88B00..88BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88C00..88CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88D00..88DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88E00..88EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 88F00..88FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89000..890FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89100..891FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89200..892FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89300..893FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89400..894FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89500..895FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89600..896FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89700..897FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89800..898FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89900..899FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89A00..89AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89B00..89BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89C00..89CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89D00..89DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89E00..89EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 89F00..89FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A000..8A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A100..8A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A200..8A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A300..8A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A400..8A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A500..8A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A600..8A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A700..8A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A800..8A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8A900..8A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AA00..8AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AB00..8ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AC00..8ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AD00..8ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AE00..8AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8AF00..8AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B000..8B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B100..8B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B200..8B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B300..8B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B400..8B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B500..8B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B600..8B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B700..8B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B800..8B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8B900..8B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BA00..8BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BB00..8BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BC00..8BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BD00..8BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BE00..8BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8BF00..8BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C000..8C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C100..8C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C200..8C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C300..8C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C400..8C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C500..8C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C600..8C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C700..8C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C800..8C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8C900..8C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CA00..8CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CB00..8CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CC00..8CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CD00..8CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CE00..8CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8CF00..8CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D000..8D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D100..8D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D200..8D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D300..8D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D400..8D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D500..8D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D600..8D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D700..8D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D800..8D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8D900..8D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DA00..8DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DB00..8DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DC00..8DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DD00..8DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DE00..8DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8DF00..8DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E000..8E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E100..8E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E200..8E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E300..8E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E400..8E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E500..8E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E600..8E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E700..8E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E800..8E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8E900..8E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8EA00..8EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8EB00..8EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8EC00..8ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8ED00..8EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8EE00..8EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8EF00..8EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F000..8F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F100..8F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F200..8F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F300..8F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F400..8F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F500..8F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F600..8F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F700..8F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F800..8F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8F900..8F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8FA00..8FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8FB00..8FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8FC00..8FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8FD00..8FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 8FE00..8FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 8FF00..8FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90000..900FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90100..901FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90200..902FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90300..903FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90400..904FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90500..905FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90600..906FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90700..907FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90800..908FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90900..909FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90A00..90AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90B00..90BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90C00..90CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90D00..90DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90E00..90EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 90F00..90FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91000..910FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91100..911FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91200..912FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91300..913FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91400..914FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91500..915FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91600..916FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91700..917FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91800..918FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91900..919FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91A00..91AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91B00..91BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91C00..91CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91D00..91DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91E00..91EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 91F00..91FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92000..920FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92100..921FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92200..922FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92300..923FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92400..924FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92500..925FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92600..926FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92700..927FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92800..928FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92900..929FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92A00..92AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92B00..92BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92C00..92CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92D00..92DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92E00..92EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 92F00..92FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93000..930FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93100..931FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93200..932FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93300..933FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93400..934FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93500..935FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93600..936FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93700..937FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93800..938FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93900..939FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93A00..93AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93B00..93BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93C00..93CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93D00..93DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93E00..93EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 93F00..93FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94000..940FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94100..941FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94200..942FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94300..943FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94400..944FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94500..945FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94600..946FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94700..947FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94800..948FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94900..949FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94A00..94AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94B00..94BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94C00..94CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94D00..94DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94E00..94EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 94F00..94FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95000..950FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95100..951FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95200..952FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95300..953FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95400..954FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95500..955FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95600..956FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95700..957FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95800..958FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95900..959FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95A00..95AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95B00..95BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95C00..95CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95D00..95DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95E00..95EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 95F00..95FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96000..960FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96100..961FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96200..962FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96300..963FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96400..964FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96500..965FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96600..966FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96700..967FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96800..968FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96900..969FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96A00..96AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96B00..96BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96C00..96CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96D00..96DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96E00..96EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 96F00..96FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97000..970FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97100..971FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97200..972FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97300..973FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97400..974FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97500..975FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97600..976FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97700..977FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97800..978FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97900..979FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97A00..97AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97B00..97BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97C00..97CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97D00..97DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97E00..97EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 97F00..97FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98000..980FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98100..981FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98200..982FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98300..983FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98400..984FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98500..985FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98600..986FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98700..987FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98800..988FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98900..989FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98A00..98AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98B00..98BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98C00..98CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98D00..98DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98E00..98EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 98F00..98FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99000..990FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99100..991FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99200..992FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99300..993FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99400..994FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99500..995FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99600..996FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99700..997FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99800..998FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99900..999FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99A00..99AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99B00..99BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99C00..99CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99D00..99DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99E00..99EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 99F00..99FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A000..9A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A100..9A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A200..9A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A300..9A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A400..9A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A500..9A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A600..9A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A700..9A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A800..9A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9A900..9A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AA00..9AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AB00..9ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AC00..9ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AD00..9ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AE00..9AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9AF00..9AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B000..9B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B100..9B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B200..9B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B300..9B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B400..9B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B500..9B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B600..9B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B700..9B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B800..9B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9B900..9B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BA00..9BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BB00..9BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BC00..9BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BD00..9BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BE00..9BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9BF00..9BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C000..9C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C100..9C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C200..9C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C300..9C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C400..9C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C500..9C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C600..9C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C700..9C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C800..9C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9C900..9C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CA00..9CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CB00..9CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CC00..9CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CD00..9CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CE00..9CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9CF00..9CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D000..9D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D100..9D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D200..9D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D300..9D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D400..9D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D500..9D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D600..9D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D700..9D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D800..9D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9D900..9D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DA00..9DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DB00..9DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DC00..9DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DD00..9DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DE00..9DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9DF00..9DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E000..9E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E100..9E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E200..9E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E300..9E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E400..9E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E500..9E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E600..9E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E700..9E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E800..9E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9E900..9E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9EA00..9EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9EB00..9EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9EC00..9ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9ED00..9EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9EE00..9EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9EF00..9EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F000..9F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F100..9F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F200..9F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F300..9F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F400..9F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F500..9F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F600..9F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F700..9F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F800..9F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9F900..9F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9FA00..9FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9FB00..9FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9FC00..9FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9FD00..9FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 9FE00..9FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 9FF00..9FFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0000..A00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0100..A01FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0200..A02FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0300..A03FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0400..A04FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0500..A05FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0600..A06FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0700..A07FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0800..A08FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0900..A09FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0A00..A0AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0B00..A0BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0C00..A0CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0D00..A0DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0E00..A0EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A0F00..A0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1000..A10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1100..A11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1200..A12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1300..A13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1400..A14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1500..A15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1600..A16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1700..A17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1800..A18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1900..A19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1A00..A1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1B00..A1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1C00..A1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1D00..A1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1E00..A1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A1F00..A1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2000..A20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2100..A21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2200..A22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2300..A23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2400..A24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2500..A25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2600..A26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2700..A27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2800..A28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2900..A29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2A00..A2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2B00..A2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2C00..A2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2D00..A2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2E00..A2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A2F00..A2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3000..A30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3100..A31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3200..A32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3300..A33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3400..A34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3500..A35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3600..A36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3700..A37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3800..A38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3900..A39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3A00..A3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3B00..A3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3C00..A3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3D00..A3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3E00..A3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A3F00..A3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4000..A40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4100..A41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4200..A42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4300..A43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4400..A44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4500..A45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4600..A46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4700..A47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4800..A48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4900..A49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4A00..A4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4B00..A4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4C00..A4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4D00..A4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4E00..A4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A4F00..A4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5000..A50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5100..A51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5200..A52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5300..A53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5400..A54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5500..A55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5600..A56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5700..A57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5800..A58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5900..A59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5A00..A5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5B00..A5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5C00..A5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5D00..A5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5E00..A5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A5F00..A5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6000..A60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6100..A61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6200..A62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6300..A63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6400..A64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6500..A65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6600..A66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6700..A67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6800..A68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6900..A69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6A00..A6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6B00..A6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6C00..A6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6D00..A6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6E00..A6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A6F00..A6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7000..A70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7100..A71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7200..A72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7300..A73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7400..A74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7500..A75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7600..A76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7700..A77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7800..A78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7900..A79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7A00..A7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7B00..A7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7C00..A7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7D00..A7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7E00..A7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A7F00..A7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8000..A80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8100..A81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8200..A82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8300..A83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8400..A84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8500..A85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8600..A86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8700..A87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8800..A88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8900..A89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8A00..A8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8B00..A8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8C00..A8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8D00..A8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8E00..A8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A8F00..A8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9000..A90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9100..A91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9200..A92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9300..A93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9400..A94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9500..A95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9600..A96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9700..A97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9800..A98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9900..A99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9A00..A9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9B00..A9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9C00..A9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9D00..A9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9E00..A9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* A9F00..A9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA000..AA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA100..AA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA200..AA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA300..AA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA400..AA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA500..AA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA600..AA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA700..AA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA800..AA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AA900..AA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAA00..AAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAB00..AABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAC00..AACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAD00..AADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAE00..AAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AAF00..AAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB000..AB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB100..AB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB200..AB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB300..AB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB400..AB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB500..AB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB600..AB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB700..AB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB800..AB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AB900..AB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABA00..ABAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABB00..ABBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABC00..ABCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABD00..ABDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABE00..ABEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ABF00..ABFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC000..AC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC100..AC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC200..AC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC300..AC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC400..AC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC500..AC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC600..AC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC700..AC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC800..AC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AC900..AC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACA00..ACAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACB00..ACBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACC00..ACCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACD00..ACDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACE00..ACEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ACF00..ACFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD000..AD0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD100..AD1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD200..AD2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD300..AD3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD400..AD4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD500..AD5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD600..AD6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD700..AD7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD800..AD8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AD900..AD9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADA00..ADAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADB00..ADBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADC00..ADCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADD00..ADDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADE00..ADEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ADF00..ADFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE000..AE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE100..AE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE200..AE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE300..AE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE400..AE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE500..AE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE600..AE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE700..AE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE800..AE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AE900..AE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AEA00..AEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AEB00..AEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AEC00..AECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AED00..AEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AEE00..AEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AEF00..AEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF000..AF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF100..AF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF200..AF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF300..AF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF400..AF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF500..AF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF600..AF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF700..AF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF800..AF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AF900..AF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* AFA00..AFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AFB00..AFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AFC00..AFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AFD00..AFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* AFE00..AFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* AFF00..AFFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0000..B00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0100..B01FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0200..B02FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0300..B03FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0400..B04FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0500..B05FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0600..B06FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0700..B07FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0800..B08FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0900..B09FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0A00..B0AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0B00..B0BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0C00..B0CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0D00..B0DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0E00..B0EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B0F00..B0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1000..B10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1100..B11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1200..B12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1300..B13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1400..B14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1500..B15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1600..B16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1700..B17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1800..B18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1900..B19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1A00..B1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1B00..B1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1C00..B1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1D00..B1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1E00..B1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B1F00..B1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2000..B20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2100..B21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2200..B22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2300..B23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2400..B24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2500..B25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2600..B26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2700..B27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2800..B28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2900..B29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2A00..B2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2B00..B2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2C00..B2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2D00..B2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2E00..B2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B2F00..B2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3000..B30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3100..B31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3200..B32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3300..B33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3400..B34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3500..B35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3600..B36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3700..B37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3800..B38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3900..B39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3A00..B3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3B00..B3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3C00..B3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3D00..B3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3E00..B3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B3F00..B3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4000..B40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4100..B41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4200..B42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4300..B43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4400..B44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4500..B45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4600..B46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4700..B47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4800..B48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4900..B49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4A00..B4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4B00..B4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4C00..B4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4D00..B4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4E00..B4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B4F00..B4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5000..B50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5100..B51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5200..B52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5300..B53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5400..B54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5500..B55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5600..B56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5700..B57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5800..B58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5900..B59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5A00..B5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5B00..B5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5C00..B5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5D00..B5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5E00..B5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B5F00..B5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6000..B60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6100..B61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6200..B62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6300..B63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6400..B64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6500..B65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6600..B66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6700..B67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6800..B68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6900..B69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6A00..B6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6B00..B6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6C00..B6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6D00..B6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6E00..B6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B6F00..B6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7000..B70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7100..B71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7200..B72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7300..B73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7400..B74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7500..B75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7600..B76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7700..B77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7800..B78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7900..B79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7A00..B7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7B00..B7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7C00..B7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7D00..B7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7E00..B7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B7F00..B7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8000..B80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8100..B81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8200..B82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8300..B83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8400..B84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8500..B85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8600..B86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8700..B87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8800..B88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8900..B89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8A00..B8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8B00..B8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8C00..B8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8D00..B8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8E00..B8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B8F00..B8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9000..B90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9100..B91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9200..B92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9300..B93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9400..B94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9500..B95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9600..B96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9700..B97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9800..B98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9900..B99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9A00..B9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9B00..B9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9C00..B9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9D00..B9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9E00..B9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* B9F00..B9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA000..BA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA100..BA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA200..BA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA300..BA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA400..BA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA500..BA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA600..BA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA700..BA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA800..BA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BA900..BA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAA00..BAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAB00..BABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAC00..BACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAD00..BADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAE00..BAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BAF00..BAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB000..BB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB100..BB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB200..BB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB300..BB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB400..BB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB500..BB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB600..BB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB700..BB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB800..BB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BB900..BB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBA00..BBAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBB00..BBBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBC00..BBCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBD00..BBDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBE00..BBEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BBF00..BBFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC000..BC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC100..BC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC200..BC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC300..BC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC400..BC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC500..BC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC600..BC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC700..BC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC800..BC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BC900..BC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCA00..BCAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCB00..BCBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCC00..BCCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCD00..BCDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCE00..BCEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BCF00..BCFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD000..BD0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD100..BD1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD200..BD2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD300..BD3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD400..BD4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD500..BD5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD600..BD6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD700..BD7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD800..BD8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BD900..BD9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDA00..BDAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDB00..BDBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDC00..BDCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDD00..BDDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDE00..BDEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BDF00..BDFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE000..BE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE100..BE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE200..BE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE300..BE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE400..BE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE500..BE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE600..BE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE700..BE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE800..BE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BE900..BE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BEA00..BEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BEB00..BEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BEC00..BECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BED00..BEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BEE00..BEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BEF00..BEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF000..BF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF100..BF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF200..BF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF300..BF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF400..BF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF500..BF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF600..BF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF700..BF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF800..BF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BF900..BF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* BFA00..BFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BFB00..BFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BFC00..BFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BFD00..BFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* BFE00..BFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* BFF00..BFFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0000..C00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0100..C01FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0200..C02FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0300..C03FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0400..C04FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0500..C05FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0600..C06FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0700..C07FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0800..C08FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0900..C09FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0A00..C0AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0B00..C0BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0C00..C0CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0D00..C0DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0E00..C0EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C0F00..C0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1000..C10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1100..C11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1200..C12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1300..C13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1400..C14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1500..C15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1600..C16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1700..C17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1800..C18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1900..C19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1A00..C1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1B00..C1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1C00..C1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1D00..C1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1E00..C1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C1F00..C1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2000..C20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2100..C21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2200..C22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2300..C23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2400..C24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2500..C25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2600..C26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2700..C27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2800..C28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2900..C29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2A00..C2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2B00..C2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2C00..C2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2D00..C2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2E00..C2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C2F00..C2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3000..C30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3100..C31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3200..C32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3300..C33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3400..C34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3500..C35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3600..C36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3700..C37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3800..C38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3900..C39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3A00..C3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3B00..C3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3C00..C3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3D00..C3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3E00..C3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C3F00..C3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4000..C40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4100..C41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4200..C42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4300..C43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4400..C44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4500..C45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4600..C46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4700..C47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4800..C48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4900..C49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4A00..C4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4B00..C4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4C00..C4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4D00..C4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4E00..C4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C4F00..C4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5000..C50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5100..C51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5200..C52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5300..C53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5400..C54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5500..C55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5600..C56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5700..C57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5800..C58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5900..C59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5A00..C5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5B00..C5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5C00..C5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5D00..C5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5E00..C5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C5F00..C5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6000..C60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6100..C61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6200..C62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6300..C63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6400..C64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6500..C65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6600..C66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6700..C67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6800..C68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6900..C69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6A00..C6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6B00..C6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6C00..C6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6D00..C6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6E00..C6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C6F00..C6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7000..C70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7100..C71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7200..C72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7300..C73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7400..C74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7500..C75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7600..C76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7700..C77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7800..C78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7900..C79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7A00..C7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7B00..C7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7C00..C7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7D00..C7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7E00..C7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C7F00..C7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8000..C80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8100..C81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8200..C82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8300..C83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8400..C84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8500..C85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8600..C86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8700..C87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8800..C88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8900..C89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8A00..C8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8B00..C8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8C00..C8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8D00..C8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8E00..C8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C8F00..C8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9000..C90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9100..C91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9200..C92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9300..C93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9400..C94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9500..C95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9600..C96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9700..C97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9800..C98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9900..C99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9A00..C9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9B00..C9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9C00..C9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9D00..C9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9E00..C9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* C9F00..C9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA000..CA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA100..CA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA200..CA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA300..CA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA400..CA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA500..CA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA600..CA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA700..CA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA800..CA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CA900..CA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAA00..CAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAB00..CABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAC00..CACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAD00..CADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAE00..CAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CAF00..CAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB000..CB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB100..CB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB200..CB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB300..CB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB400..CB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB500..CB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB600..CB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB700..CB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB800..CB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CB900..CB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBA00..CBAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBB00..CBBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBC00..CBCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBD00..CBDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBE00..CBEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CBF00..CBFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC000..CC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC100..CC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC200..CC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC300..CC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC400..CC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC500..CC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC600..CC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC700..CC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC800..CC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CC900..CC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCA00..CCAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCB00..CCBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCC00..CCCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCD00..CCDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCE00..CCEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CCF00..CCFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD000..CD0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD100..CD1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD200..CD2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD300..CD3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD400..CD4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD500..CD5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD600..CD6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD700..CD7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD800..CD8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CD900..CD9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDA00..CDAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDB00..CDBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDC00..CDCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDD00..CDDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDE00..CDEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CDF00..CDFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE000..CE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE100..CE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE200..CE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE300..CE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE400..CE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE500..CE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE600..CE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE700..CE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE800..CE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CE900..CE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CEA00..CEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CEB00..CEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CEC00..CECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CED00..CEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CEE00..CEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CEF00..CEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF000..CF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF100..CF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF200..CF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF300..CF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF400..CF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF500..CF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF600..CF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF700..CF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF800..CF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CF900..CF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* CFA00..CFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CFB00..CFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CFC00..CFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CFD00..CFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* CFE00..CFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* CFF00..CFFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0000..D00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0100..D01FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0200..D02FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0300..D03FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0400..D04FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0500..D05FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0600..D06FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0700..D07FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0800..D08FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0900..D09FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0A00..D0AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0B00..D0BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0C00..D0CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0D00..D0DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0E00..D0EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D0F00..D0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1000..D10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1100..D11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1200..D12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1300..D13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1400..D14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1500..D15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1600..D16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1700..D17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1800..D18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1900..D19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1A00..D1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1B00..D1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1C00..D1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1D00..D1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1E00..D1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D1F00..D1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2000..D20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2100..D21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2200..D22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2300..D23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2400..D24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2500..D25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2600..D26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2700..D27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2800..D28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2900..D29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2A00..D2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2B00..D2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2C00..D2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2D00..D2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2E00..D2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D2F00..D2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3000..D30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3100..D31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3200..D32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3300..D33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3400..D34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3500..D35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3600..D36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3700..D37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3800..D38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3900..D39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3A00..D3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3B00..D3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3C00..D3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3D00..D3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3E00..D3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D3F00..D3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4000..D40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4100..D41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4200..D42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4300..D43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4400..D44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4500..D45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4600..D46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4700..D47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4800..D48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4900..D49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4A00..D4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4B00..D4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4C00..D4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4D00..D4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4E00..D4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D4F00..D4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5000..D50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5100..D51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5200..D52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5300..D53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5400..D54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5500..D55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5600..D56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5700..D57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5800..D58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5900..D59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5A00..D5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5B00..D5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5C00..D5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5D00..D5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5E00..D5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D5F00..D5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6000..D60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6100..D61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6200..D62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6300..D63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6400..D64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6500..D65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6600..D66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6700..D67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6800..D68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6900..D69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6A00..D6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6B00..D6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6C00..D6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6D00..D6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6E00..D6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D6F00..D6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7000..D70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7100..D71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7200..D72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7300..D73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7400..D74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7500..D75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7600..D76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7700..D77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7800..D78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7900..D79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7A00..D7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7B00..D7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7C00..D7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7D00..D7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7E00..D7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D7F00..D7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8000..D80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8100..D81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8200..D82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8300..D83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8400..D84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8500..D85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8600..D86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8700..D87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8800..D88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8900..D89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8A00..D8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8B00..D8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8C00..D8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8D00..D8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8E00..D8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D8F00..D8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9000..D90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9100..D91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9200..D92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9300..D93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9400..D94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9500..D95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9600..D96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9700..D97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9800..D98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9900..D99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9A00..D9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9B00..D9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9C00..D9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9D00..D9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9E00..D9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* D9F00..D9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA000..DA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA100..DA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA200..DA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA300..DA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA400..DA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA500..DA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA600..DA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA700..DA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA800..DA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DA900..DA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAA00..DAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAB00..DABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAC00..DACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAD00..DADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAE00..DAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DAF00..DAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB000..DB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB100..DB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB200..DB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB300..DB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB400..DB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB500..DB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB600..DB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB700..DB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB800..DB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DB900..DB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBA00..DBAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBB00..DBBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBC00..DBCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBD00..DBDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBE00..DBEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DBF00..DBFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC000..DC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC100..DC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC200..DC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC300..DC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC400..DC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC500..DC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC600..DC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC700..DC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC800..DC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DC900..DC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCA00..DCAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCB00..DCBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCC00..DCCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCD00..DCDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCE00..DCEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DCF00..DCFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD000..DD0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD100..DD1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD200..DD2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD300..DD3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD400..DD4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD500..DD5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD600..DD6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD700..DD7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD800..DD8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DD900..DD9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDA00..DDAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDB00..DDBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDC00..DDCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDD00..DDDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDE00..DDEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DDF00..DDFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE000..DE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE100..DE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE200..DE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE300..DE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE400..DE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE500..DE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE600..DE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE700..DE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE800..DE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DE900..DE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DEA00..DEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DEB00..DEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DEC00..DECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DED00..DEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DEE00..DEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DEF00..DEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF000..DF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF100..DF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF200..DF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF300..DF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF400..DF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF500..DF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF600..DF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF700..DF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF800..DF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DF900..DF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* DFA00..DFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DFB00..DFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DFC00..DFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DFD00..DFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* DFE00..DFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* DFF00..DFFFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0000..E00FF */
+  FriBidiPropertyBlockLevel1_E0100,  /* E0100..E01FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0200..E02FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0300..E03FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0400..E04FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0500..E05FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0600..E06FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0700..E07FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0800..E08FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0900..E09FF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0A00..E0AFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0B00..E0BFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0C00..E0CFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0D00..E0DFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0E00..E0EFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0F00..E0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1000..E10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1100..E11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1200..E12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1300..E13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1400..E14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1500..E15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1600..E16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1700..E17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1800..E18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1900..E19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1A00..E1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1B00..E1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1C00..E1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1D00..E1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1E00..E1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E1F00..E1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2000..E20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2100..E21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2200..E22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2300..E23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2400..E24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2500..E25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2600..E26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2700..E27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2800..E28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2900..E29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2A00..E2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2B00..E2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2C00..E2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2D00..E2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2E00..E2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E2F00..E2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3000..E30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3100..E31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3200..E32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3300..E33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3400..E34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3500..E35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3600..E36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3700..E37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3800..E38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3900..E39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3A00..E3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3B00..E3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3C00..E3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3D00..E3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3E00..E3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E3F00..E3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4000..E40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4100..E41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4200..E42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4300..E43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4400..E44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4500..E45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4600..E46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4700..E47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4800..E48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4900..E49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4A00..E4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4B00..E4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4C00..E4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4D00..E4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4E00..E4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E4F00..E4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5000..E50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5100..E51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5200..E52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5300..E53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5400..E54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5500..E55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5600..E56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5700..E57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5800..E58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5900..E59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5A00..E5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5B00..E5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5C00..E5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5D00..E5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5E00..E5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E5F00..E5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6000..E60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6100..E61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6200..E62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6300..E63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6400..E64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6500..E65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6600..E66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6700..E67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6800..E68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6900..E69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6A00..E6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6B00..E6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6C00..E6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6D00..E6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6E00..E6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E6F00..E6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7000..E70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7100..E71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7200..E72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7300..E73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7400..E74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7500..E75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7600..E76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7700..E77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7800..E78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7900..E79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7A00..E7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7B00..E7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7C00..E7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7D00..E7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7E00..E7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E7F00..E7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8000..E80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8100..E81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8200..E82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8300..E83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8400..E84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8500..E85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8600..E86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8700..E87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8800..E88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8900..E89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8A00..E8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8B00..E8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8C00..E8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8D00..E8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8E00..E8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E8F00..E8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9000..E90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9100..E91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9200..E92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9300..E93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9400..E94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9500..E95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9600..E96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9700..E97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9800..E98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9900..E99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9A00..E9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9B00..E9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9C00..E9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9D00..E9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9E00..E9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* E9F00..E9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA000..EA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA100..EA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA200..EA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA300..EA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA400..EA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA500..EA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA600..EA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA700..EA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA800..EA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EA900..EA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAA00..EAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAB00..EABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAC00..EACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAD00..EADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAE00..EAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EAF00..EAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB000..EB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB100..EB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB200..EB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB300..EB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB400..EB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB500..EB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB600..EB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB700..EB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB800..EB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EB900..EB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBA00..EBAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBB00..EBBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBC00..EBCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBD00..EBDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBE00..EBEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EBF00..EBFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC000..EC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC100..EC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC200..EC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC300..EC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC400..EC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC500..EC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC600..EC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC700..EC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC800..EC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EC900..EC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECA00..ECAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECB00..ECBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECC00..ECCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECD00..ECDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECE00..ECEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ECF00..ECFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED000..ED0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED100..ED1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED200..ED2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED300..ED3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED400..ED4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED500..ED5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED600..ED6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED700..ED7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED800..ED8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* ED900..ED9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDA00..EDAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDB00..EDBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDC00..EDCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDD00..EDDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDE00..EDEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EDF00..EDFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE000..EE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE100..EE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE200..EE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE300..EE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE400..EE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE500..EE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE600..EE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE700..EE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE800..EE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EE900..EE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EEA00..EEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EEB00..EEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EEC00..EECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EED00..EEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EEE00..EEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EEF00..EEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF000..EF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF100..EF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF200..EF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF300..EF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF400..EF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF500..EF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF600..EF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF700..EF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF800..EF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EF900..EF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* EFA00..EFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EFB00..EFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EFC00..EFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EFD00..EFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* EFE00..EFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* EFF00..EFFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0000..F00FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0100..F01FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0200..F02FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0300..F03FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0400..F04FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0500..F05FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0600..F06FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0700..F07FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0800..F08FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0900..F09FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0A00..F0AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0B00..F0BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0C00..F0CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0D00..F0DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0E00..F0EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F0F00..F0FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1000..F10FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1100..F11FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1200..F12FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1300..F13FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1400..F14FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1500..F15FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1600..F16FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1700..F17FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1800..F18FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1900..F19FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1A00..F1AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1B00..F1BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1C00..F1CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1D00..F1DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1E00..F1EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F1F00..F1FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2000..F20FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2100..F21FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2200..F22FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2300..F23FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2400..F24FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2500..F25FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2600..F26FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2700..F27FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2800..F28FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2900..F29FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2A00..F2AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2B00..F2BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2C00..F2CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2D00..F2DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2E00..F2EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F2F00..F2FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3000..F30FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3100..F31FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3200..F32FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3300..F33FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3400..F34FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3500..F35FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3600..F36FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3700..F37FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3800..F38FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3900..F39FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3A00..F3AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3B00..F3BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3C00..F3CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3D00..F3DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3E00..F3EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F3F00..F3FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4000..F40FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4100..F41FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4200..F42FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4300..F43FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4400..F44FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4500..F45FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4600..F46FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4700..F47FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4800..F48FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4900..F49FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4A00..F4AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4B00..F4BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4C00..F4CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4D00..F4DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4E00..F4EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F4F00..F4FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5000..F50FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5100..F51FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5200..F52FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5300..F53FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5400..F54FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5500..F55FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5600..F56FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5700..F57FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5800..F58FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5900..F59FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5A00..F5AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5B00..F5BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5C00..F5CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5D00..F5DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5E00..F5EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F5F00..F5FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6000..F60FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6100..F61FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6200..F62FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6300..F63FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6400..F64FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6500..F65FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6600..F66FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6700..F67FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6800..F68FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6900..F69FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6A00..F6AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6B00..F6BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6C00..F6CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6D00..F6DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6E00..F6EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F6F00..F6FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7000..F70FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7100..F71FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7200..F72FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7300..F73FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7400..F74FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7500..F75FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7600..F76FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7700..F77FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7800..F78FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7900..F79FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7A00..F7AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7B00..F7BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7C00..F7CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7D00..F7DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7E00..F7EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F7F00..F7FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8000..F80FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8100..F81FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8200..F82FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8300..F83FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8400..F84FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8500..F85FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8600..F86FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8700..F87FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8800..F88FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8900..F89FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8A00..F8AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8B00..F8BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8C00..F8CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8D00..F8DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8E00..F8EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F8F00..F8FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9000..F90FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9100..F91FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9200..F92FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9300..F93FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9400..F94FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9500..F95FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9600..F96FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9700..F97FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9800..F98FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9900..F99FF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9A00..F9AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9B00..F9BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9C00..F9CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9D00..F9DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9E00..F9EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* F9F00..F9FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA000..FA0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA100..FA1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA200..FA2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA300..FA3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA400..FA4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA500..FA5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA600..FA6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA700..FA7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA800..FA8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FA900..FA9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAA00..FAAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAB00..FABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAC00..FACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAD00..FADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAE00..FAEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FAF00..FAFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB000..FB0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB100..FB1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB200..FB2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB300..FB3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB400..FB4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB500..FB5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB600..FB6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB700..FB7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB800..FB8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FB900..FB9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBA00..FBAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBB00..FBBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBC00..FBCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBD00..FBDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBE00..FBEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FBF00..FBFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC000..FC0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC100..FC1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC200..FC2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC300..FC3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC400..FC4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC500..FC5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC600..FC6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC700..FC7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC800..FC8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FC900..FC9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCA00..FCAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCB00..FCBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCC00..FCCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCD00..FCDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCE00..FCEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FCF00..FCFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD000..FD0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD100..FD1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD200..FD2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD300..FD3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD400..FD4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD500..FD5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD600..FD6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD700..FD7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD800..FD8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FD900..FD9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDA00..FDAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDB00..FDBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDC00..FDCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDD00..FDDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDE00..FDEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FDF00..FDFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE000..FE0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE100..FE1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE200..FE2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE300..FE3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE400..FE4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE500..FE5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE600..FE6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE700..FE7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE800..FE8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FE900..FE9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FEA00..FEAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FEB00..FEBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FEC00..FECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FED00..FEDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FEE00..FEEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FEF00..FEFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF000..FF0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF100..FF1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF200..FF2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF300..FF3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF400..FF4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF500..FF5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF600..FF6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF700..FF7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF800..FF8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FF900..FF9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* FFA00..FFAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FFB00..FFBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FFC00..FFCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FFD00..FFDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* FFE00..FFEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* FFF00..FFFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100000..1000FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100100..1001FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100200..1002FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100300..1003FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100400..1004FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100500..1005FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100600..1006FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100700..1007FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100800..1008FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100900..1009FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100A00..100AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100B00..100BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100C00..100CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100D00..100DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100E00..100EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 100F00..100FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101000..1010FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101100..1011FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101200..1012FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101300..1013FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101400..1014FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101500..1015FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101600..1016FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101700..1017FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101800..1018FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101900..1019FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101A00..101AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101B00..101BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101C00..101CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101D00..101DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101E00..101EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 101F00..101FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102000..1020FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102100..1021FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102200..1022FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102300..1023FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102400..1024FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102500..1025FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102600..1026FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102700..1027FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102800..1028FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102900..1029FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102A00..102AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102B00..102BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102C00..102CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102D00..102DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102E00..102EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 102F00..102FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103000..1030FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103100..1031FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103200..1032FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103300..1033FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103400..1034FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103500..1035FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103600..1036FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103700..1037FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103800..1038FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103900..1039FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103A00..103AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103B00..103BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103C00..103CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103D00..103DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103E00..103EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 103F00..103FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104000..1040FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104100..1041FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104200..1042FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104300..1043FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104400..1044FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104500..1045FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104600..1046FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104700..1047FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104800..1048FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104900..1049FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104A00..104AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104B00..104BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104C00..104CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104D00..104DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104E00..104EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 104F00..104FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105000..1050FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105100..1051FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105200..1052FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105300..1053FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105400..1054FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105500..1055FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105600..1056FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105700..1057FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105800..1058FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105900..1059FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105A00..105AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105B00..105BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105C00..105CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105D00..105DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105E00..105EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 105F00..105FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106000..1060FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106100..1061FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106200..1062FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106300..1063FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106400..1064FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106500..1065FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106600..1066FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106700..1067FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106800..1068FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106900..1069FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106A00..106AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106B00..106BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106C00..106CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106D00..106DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106E00..106EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 106F00..106FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107000..1070FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107100..1071FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107200..1072FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107300..1073FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107400..1074FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107500..1075FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107600..1076FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107700..1077FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107800..1078FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107900..1079FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107A00..107AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107B00..107BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107C00..107CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107D00..107DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107E00..107EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 107F00..107FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108000..1080FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108100..1081FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108200..1082FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108300..1083FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108400..1084FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108500..1085FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108600..1086FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108700..1087FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108800..1088FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108900..1089FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108A00..108AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108B00..108BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108C00..108CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108D00..108DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108E00..108EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 108F00..108FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109000..1090FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109100..1091FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109200..1092FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109300..1093FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109400..1094FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109500..1095FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109600..1096FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109700..1097FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109800..1098FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109900..1099FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109A00..109AFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109B00..109BFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109C00..109CFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109D00..109DFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109E00..109EFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 109F00..109FFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A000..10A0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A100..10A1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A200..10A2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A300..10A3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A400..10A4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A500..10A5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A600..10A6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A700..10A7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A800..10A8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10A900..10A9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AA00..10AAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AB00..10ABFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AC00..10ACFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AD00..10ADFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AE00..10AEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10AF00..10AFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B000..10B0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B100..10B1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B200..10B2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B300..10B3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B400..10B4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B500..10B5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B600..10B6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B700..10B7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B800..10B8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10B900..10B9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BA00..10BAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BB00..10BBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BC00..10BCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BD00..10BDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BE00..10BEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10BF00..10BFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C000..10C0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C100..10C1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C200..10C2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C300..10C3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C400..10C4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C500..10C5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C600..10C6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C700..10C7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C800..10C8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10C900..10C9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CA00..10CAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CB00..10CBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CC00..10CCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CD00..10CDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CE00..10CEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10CF00..10CFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D000..10D0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D100..10D1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D200..10D2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D300..10D3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D400..10D4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D500..10D5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D600..10D6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D700..10D7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D800..10D8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10D900..10D9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DA00..10DAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DB00..10DBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DC00..10DCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DD00..10DDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DE00..10DEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10DF00..10DFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E000..10E0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E100..10E1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E200..10E2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E300..10E3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E400..10E4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E500..10E5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E600..10E6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E700..10E7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E800..10E8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10E900..10E9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10EA00..10EAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10EB00..10EBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10EC00..10ECFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10ED00..10EDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10EE00..10EEFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10EF00..10EFFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F000..10F0FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F100..10F1FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F200..10F2FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F300..10F3FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F400..10F4FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F500..10F5FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F600..10F6FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F700..10F7FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F800..10F8FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10F900..10F9FF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10FA00..10FAFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10FB00..10FBFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10FC00..10FCFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10FD00..10FDFF */
+  FriBidiPropertyBlockLevel1_0100,  /* 10FE00..10FEFF */
+  FriBidiPropertyBlockLevel1_1FF00,  /* 10FF00..10FFFF */
+};
+
+/* *INDENT-ON* */
+
+#define FRIBIDI_GET_TYPE(x)	\
+	FriBidiPropertyBlockLevel1[(x)%256 +	\
+	FriBidiPropertyBlockLevel0[(x)/256]]
+
+#undef WS
+#undef SS
+#undef RLO
+#undef RLE
+#undef PDF
+#undef NSM
+#undef LRO
+#undef LRE
+#undef ET
+#undef ES
+#undef EN
+#undef CS
+#undef BS
+#undef AN
+#undef BN
+#undef ON
+#undef AL
+#undef RTL
+#undef LTR
+/*======================================================================
+ *  fribidi_get_type_internal() returns the bidi type of a character.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API FriBidiCharType
+fribidi_get_type_internal (FriBidiChar uch)
+{
+  if (uch < 0x110000)
+    return fribidi_prop_to_type[(unsigned char)FRIBIDI_GET_TYPE (uch)];
+  else
+    return FRIBIDI_TYPE_LTR;
+  /* Non-Unicode chars */
+}
+
+
+#endif /* FRIBIDI_TAB_CHAR_TYPE_2_I */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_char_type_9.i Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_char_type_9.i
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_char_type_9.i	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_char_type_9.i	2012-05-05 23:46:50.944763780 +0530
@@ -0,0 +1,4006 @@
+/*
+  This file was automatically created from UnicodeData.txt version 4.1.0
+  by fribidi_create_char_types
+*/
+
+#ifndef FRIBIDI_TAB_CHAR_TYPE_9_I
+#define FRIBIDI_TAB_CHAR_TYPE_9_I
+
+#include "fribidi.h"
+
+#define LTR FRIBIDI_PROP_TYPE_LTR
+#define RTL FRIBIDI_PROP_TYPE_RTL
+#define AL FRIBIDI_PROP_TYPE_AL
+#define ON FRIBIDI_PROP_TYPE_ON
+#define BN FRIBIDI_PROP_TYPE_BN
+#define AN FRIBIDI_PROP_TYPE_AN
+#define BS FRIBIDI_PROP_TYPE_BS
+#define CS FRIBIDI_PROP_TYPE_CS
+#define EN FRIBIDI_PROP_TYPE_EN
+#define ES FRIBIDI_PROP_TYPE_ES
+#define ET FRIBIDI_PROP_TYPE_ET
+#define LRE FRIBIDI_PROP_TYPE_LRE
+#define LRO FRIBIDI_PROP_TYPE_LRO
+#define NSM FRIBIDI_PROP_TYPE_NSM
+#define PDF FRIBIDI_PROP_TYPE_PDF
+#define RLE FRIBIDI_PROP_TYPE_RLE
+#define RLO FRIBIDI_PROP_TYPE_RLO
+#define SS FRIBIDI_PROP_TYPE_SS
+#define WS FRIBIDI_PROP_TYPE_WS
+
+#define PACKTAB_UINT8 fribidi_uint8
+#define PACKTAB_UINT16 fribidi_uint16
+#define PACKTAB_UINT32 fribidi_uint32
+/*
+  Automatically generated by packtab.c version 2
+
+  just use FRIBIDI_GET_TYPE(key)
+
+  assumed sizeof(FriBidiPropCharType) == 1
+  required memory: 2807
+  lookups: 9
+  partition shape: FriBidiPropertyBlock[17][16][4][8][2][4][4][2][2]
+  different table entries: 1 4 12 27 91 131 177 113 58
+*/
+
+/* *INDENT-OFF* */
+
+static const FriBidiPropCharType FriBidiPropertyBlockLevel8[2*58] = {
+
+#define FriBidiPropertyBlockLevel8_0000 0x0
+
+   BN, BN,
+
+#define FriBidiPropertyBlockLevel8_0008 0x2
+
+   BN, SS,
+
+#define FriBidiPropertyBlockLevel8_000A 0x4
+
+   BS, SS,
+
+#define FriBidiPropertyBlockLevel8_000C 0x6
+
+   WS, BS,
+
+#define FriBidiPropertyBlockLevel8_001C 0x8
+
+   BS, BS,
+
+#define FriBidiPropertyBlockLevel8_0020 0xA
+
+   WS, ON,
+
+#define FriBidiPropertyBlockLevel8_0022 0xC
+
+   ON, ET,
+
+#define FriBidiPropertyBlockLevel8_0024 0xE
+
+   ET, ET,
+
+#define FriBidiPropertyBlockLevel8_0026 0x10
+
+   ON, ON,
+
+#define FriBidiPropertyBlockLevel8_002A 0x12
+
+   ON, ES,
+
+#define FriBidiPropertyBlockLevel8_002C 0x14
+
+   CS, ES,
+
+#define FriBidiPropertyBlockLevel8_002E 0x16
+
+   CS, CS,
+
+#define FriBidiPropertyBlockLevel8_0030 0x18
+
+   EN, EN,
+
+#define FriBidiPropertyBlockLevel8_003A 0x1A
+
+   CS, ON,
+
+#define FriBidiPropertyBlockLevel8_0040 0x1C
+
+   ON,LTR,
+
+#define FriBidiPropertyBlockLevel8_0042 0x1E
+
+  LTR,LTR,
+
+#define FriBidiPropertyBlockLevel8_005A 0x20
+
+  LTR, ON,
+
+#define FriBidiPropertyBlockLevel8_007E 0x22
+
+   ON, BN,
+
+#define FriBidiPropertyBlockLevel8_0084 0x24
+
+   BN, BS,
+
+#define FriBidiPropertyBlockLevel8_00B8 0x26
+
+   ON, EN,
+
+#define FriBidiPropertyBlockLevel8_0300 0x28
+
+  NSM,NSM,
+
+#define FriBidiPropertyBlockLevel8_0482 0x2A
+
+  LTR,NSM,
+
+#define FriBidiPropertyBlockLevel8_0486 0x2C
+
+  NSM,LTR,
+
+#define FriBidiPropertyBlockLevel8_0590 0x2E
+
+  RTL,NSM,
+
+#define FriBidiPropertyBlockLevel8_05C2 0x30
+
+  NSM,RTL,
+
+#define FriBidiPropertyBlockLevel8_05C8 0x32
+
+  RTL,RTL,
+
+#define FriBidiPropertyBlockLevel8_0600 0x34
+
+   AL, AL,
+
+#define FriBidiPropertyBlockLevel8_060C 0x36
+
+   CS, AL,
+
+#define FriBidiPropertyBlockLevel8_064A 0x38
+
+   AL,NSM,
+
+#define FriBidiPropertyBlockLevel8_065E 0x3A
+
+  NSM, AL,
+
+#define FriBidiPropertyBlockLevel8_0660 0x3C
+
+   AN, AN,
+
+#define FriBidiPropertyBlockLevel8_066A 0x3E
+
+   ET, AN,
+
+#define FriBidiPropertyBlockLevel8_066C 0x40
+
+   AN, AL,
+
+#define FriBidiPropertyBlockLevel8_06E8 0x42
+
+  NSM, ON,
+
+#define FriBidiPropertyBlockLevel8_070E 0x44
+
+   AL, BN,
+
+#define FriBidiPropertyBlockLevel8_0AF0 0x46
+
+  LTR, ET,
+
+#define FriBidiPropertyBlockLevel8_1680 0x48
+
+   WS,LTR,
+
+#define FriBidiPropertyBlockLevel8_180A 0x4A
+
+   ON,NSM,
+
+#define FriBidiPropertyBlockLevel8_2000 0x4C
+
+   WS, WS,
+
+#define FriBidiPropertyBlockLevel8_200A 0x4E
+
+   WS, BN,
+
+#define FriBidiPropertyBlockLevel8_200E 0x50
+
+  LTR,RTL,
+
+#define FriBidiPropertyBlockLevel8_202A 0x52
+
+  LRE,RLE,
+
+#define FriBidiPropertyBlockLevel8_202C 0x54
+
+  PDF,LRO,
+
+#define FriBidiPropertyBlockLevel8_202E 0x56
+
+  RLO, CS,
+
+#define FriBidiPropertyBlockLevel8_2034 0x58
+
+   ET, ON,
+
+#define FriBidiPropertyBlockLevel8_205E 0x5A
+
+   ON, WS,
+
+#define FriBidiPropertyBlockLevel8_2070 0x5C
+
+   EN,LTR,
+
+#define FriBidiPropertyBlockLevel8_207A 0x5E
+
+   ES, ES,
+
+#define FriBidiPropertyBlockLevel8_212E 0x60
+
+   ET,LTR,
+
+#define FriBidiPropertyBlockLevel8_2212 0x62
+
+   ES, ET,
+
+#define FriBidiPropertyBlockLevel8_FB28 0x64
+
+  RTL, ES,
+
+#define FriBidiPropertyBlockLevel8_FDFC 0x66
+
+   AL, ON,
+
+#define FriBidiPropertyBlockLevel8_FE52 0x68
+
+   CS,LTR,
+
+#define FriBidiPropertyBlockLevel8_FE54 0x6A
+
+   ON, CS,
+
+#define FriBidiPropertyBlockLevel8_FFF8 0x6C
+
+   BN, ON,
+
+#define FriBidiPropertyBlockLevel8_1091E 0x6E
+
+  RTL, ON,
+
+#define FriBidiPropertyBlockLevel8_1D172 0x70
+
+  LTR, BN,
+
+#define FriBidiPropertyBlockLevel8_1D17A 0x72
+
+   BN,NSM,
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel7[2*113] = {
+
+#define FriBidiPropertyBlockLevel7_0000 0x0
+
+  FriBidiPropertyBlockLevel8_0000,  /* 0000..0001 */
+  FriBidiPropertyBlockLevel8_0000,  /* 0002..0003 */
+
+#define FriBidiPropertyBlockLevel7_0008 0x2
+
+  FriBidiPropertyBlockLevel8_0008,  /* 0008..0009 */
+  FriBidiPropertyBlockLevel8_000A,  /* 000A..000B */
+
+#define FriBidiPropertyBlockLevel7_000C 0x4
+
+  FriBidiPropertyBlockLevel8_000C,  /* 000C..000D */
+  FriBidiPropertyBlockLevel8_0000,  /* 000E..000F */
+
+#define FriBidiPropertyBlockLevel7_001C 0x6
+
+  FriBidiPropertyBlockLevel8_001C,  /* 001C..001D */
+  FriBidiPropertyBlockLevel8_000A,  /* 001E..001F */
+
+#define FriBidiPropertyBlockLevel7_0020 0x8
+
+  FriBidiPropertyBlockLevel8_0020,  /* 0020..0021 */
+  FriBidiPropertyBlockLevel8_0022,  /* 0022..0023 */
+
+#define FriBidiPropertyBlockLevel7_0024 0xA
+
+  FriBidiPropertyBlockLevel8_0024,  /* 0024..0025 */
+  FriBidiPropertyBlockLevel8_0026,  /* 0026..0027 */
+
+#define FriBidiPropertyBlockLevel7_0028 0xC
+
+  FriBidiPropertyBlockLevel8_0026,  /* 0028..0029 */
+  FriBidiPropertyBlockLevel8_002A,  /* 002A..002B */
+
+#define FriBidiPropertyBlockLevel7_002C 0xE
+
+  FriBidiPropertyBlockLevel8_002C,  /* 002C..002D */
+  FriBidiPropertyBlockLevel8_002E,  /* 002E..002F */
+
+#define FriBidiPropertyBlockLevel7_0030 0x10
+
+  FriBidiPropertyBlockLevel8_0030,  /* 0030..0031 */
+  FriBidiPropertyBlockLevel8_0030,  /* 0032..0033 */
+
+#define FriBidiPropertyBlockLevel7_0038 0x12
+
+  FriBidiPropertyBlockLevel8_0030,  /* 0038..0039 */
+  FriBidiPropertyBlockLevel8_003A,  /* 003A..003B */
+
+#define FriBidiPropertyBlockLevel7_003C 0x14
+
+  FriBidiPropertyBlockLevel8_0026,  /* 003C..003D */
+  FriBidiPropertyBlockLevel8_0026,  /* 003E..003F */
+
+#define FriBidiPropertyBlockLevel7_0040 0x16
+
+  FriBidiPropertyBlockLevel8_0040,  /* 0040..0041 */
+  FriBidiPropertyBlockLevel8_0042,  /* 0042..0043 */
+
+#define FriBidiPropertyBlockLevel7_0044 0x18
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0044..0045 */
+  FriBidiPropertyBlockLevel8_0042,  /* 0046..0047 */
+
+#define FriBidiPropertyBlockLevel7_0058 0x1A
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0058..0059 */
+  FriBidiPropertyBlockLevel8_005A,  /* 005A..005B */
+
+#define FriBidiPropertyBlockLevel7_007C 0x1C
+
+  FriBidiPropertyBlockLevel8_0026,  /* 007C..007D */
+  FriBidiPropertyBlockLevel8_007E,  /* 007E..007F */
+
+#define FriBidiPropertyBlockLevel7_0084 0x1E
+
+  FriBidiPropertyBlockLevel8_0084,  /* 0084..0085 */
+  FriBidiPropertyBlockLevel8_0000,  /* 0086..0087 */
+
+#define FriBidiPropertyBlockLevel7_00A0 0x20
+
+  FriBidiPropertyBlockLevel8_003A,  /* 00A0..00A1 */
+  FriBidiPropertyBlockLevel8_0024,  /* 00A2..00A3 */
+
+#define FriBidiPropertyBlockLevel7_00A8 0x22
+
+  FriBidiPropertyBlockLevel8_0026,  /* 00A8..00A9 */
+  FriBidiPropertyBlockLevel8_005A,  /* 00AA..00AB */
+
+#define FriBidiPropertyBlockLevel7_00AC 0x24
+
+  FriBidiPropertyBlockLevel8_007E,  /* 00AC..00AD */
+  FriBidiPropertyBlockLevel8_0026,  /* 00AE..00AF */
+
+#define FriBidiPropertyBlockLevel7_00B0 0x26
+
+  FriBidiPropertyBlockLevel8_0024,  /* 00B0..00B1 */
+  FriBidiPropertyBlockLevel8_0030,  /* 00B2..00B3 */
+
+#define FriBidiPropertyBlockLevel7_00B4 0x28
+
+  FriBidiPropertyBlockLevel8_0040,  /* 00B4..00B5 */
+  FriBidiPropertyBlockLevel8_0026,  /* 00B6..00B7 */
+
+#define FriBidiPropertyBlockLevel7_00B8 0x2A
+
+  FriBidiPropertyBlockLevel8_00B8,  /* 00B8..00B9 */
+  FriBidiPropertyBlockLevel8_005A,  /* 00BA..00BB */
+
+#define FriBidiPropertyBlockLevel7_02B8 0x2C
+
+  FriBidiPropertyBlockLevel8_005A,  /* 02B8..02B9 */
+  FriBidiPropertyBlockLevel8_0040,  /* 02BA..02BB */
+
+#define FriBidiPropertyBlockLevel7_02C0 0x2E
+
+  FriBidiPropertyBlockLevel8_0042,  /* 02C0..02C1 */
+  FriBidiPropertyBlockLevel8_0026,  /* 02C2..02C3 */
+
+#define FriBidiPropertyBlockLevel7_02E4 0x30
+
+  FriBidiPropertyBlockLevel8_005A,  /* 02E4..02E5 */
+  FriBidiPropertyBlockLevel8_0026,  /* 02E6..02E7 */
+
+#define FriBidiPropertyBlockLevel7_0300 0x32
+
+  FriBidiPropertyBlockLevel8_0300,  /* 0300..0301 */
+  FriBidiPropertyBlockLevel8_0300,  /* 0302..0303 */
+
+#define FriBidiPropertyBlockLevel7_0374 0x34
+
+  FriBidiPropertyBlockLevel8_0026,  /* 0374..0375 */
+  FriBidiPropertyBlockLevel8_0042,  /* 0376..0377 */
+
+#define FriBidiPropertyBlockLevel7_037C 0x36
+
+  FriBidiPropertyBlockLevel8_0042,  /* 037C..037D */
+  FriBidiPropertyBlockLevel8_0040,  /* 037E..037F */
+
+#define FriBidiPropertyBlockLevel7_0480 0x38
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0480..0481 */
+  FriBidiPropertyBlockLevel8_0482,  /* 0482..0483 */
+
+#define FriBidiPropertyBlockLevel7_0484 0x3A
+
+  FriBidiPropertyBlockLevel8_0300,  /* 0484..0485 */
+  FriBidiPropertyBlockLevel8_0486,  /* 0486..0487 */
+
+#define FriBidiPropertyBlockLevel7_0488 0x3C
+
+  FriBidiPropertyBlockLevel8_0300,  /* 0488..0489 */
+  FriBidiPropertyBlockLevel8_0042,  /* 048A..048B */
+
+#define FriBidiPropertyBlockLevel7_0590 0x3E
+
+  FriBidiPropertyBlockLevel8_0590,  /* 0590..0591 */
+  FriBidiPropertyBlockLevel8_0300,  /* 0592..0593 */
+
+#define FriBidiPropertyBlockLevel7_05BC 0x40
+
+  FriBidiPropertyBlockLevel8_0300,  /* 05BC..05BD */
+  FriBidiPropertyBlockLevel8_0590,  /* 05BE..05BF */
+
+#define FriBidiPropertyBlockLevel7_05C0 0x42
+
+  FriBidiPropertyBlockLevel8_0590,  /* 05C0..05C1 */
+  FriBidiPropertyBlockLevel8_05C2,  /* 05C2..05C3 */
+
+#define FriBidiPropertyBlockLevel7_05C8 0x44
+
+  FriBidiPropertyBlockLevel8_05C8,  /* 05C8..05C9 */
+  FriBidiPropertyBlockLevel8_05C8,  /* 05CA..05CB */
+
+#define FriBidiPropertyBlockLevel7_0600 0x46
+
+  FriBidiPropertyBlockLevel8_0600,  /* 0600..0601 */
+  FriBidiPropertyBlockLevel8_0600,  /* 0602..0603 */
+
+#define FriBidiPropertyBlockLevel7_060C 0x48
+
+  FriBidiPropertyBlockLevel8_060C,  /* 060C..060D */
+  FriBidiPropertyBlockLevel8_0026,  /* 060E..060F */
+
+#define FriBidiPropertyBlockLevel7_0614 0x4A
+
+  FriBidiPropertyBlockLevel8_0300,  /* 0614..0615 */
+  FriBidiPropertyBlockLevel8_0600,  /* 0616..0617 */
+
+#define FriBidiPropertyBlockLevel7_0648 0x4C
+
+  FriBidiPropertyBlockLevel8_0600,  /* 0648..0649 */
+  FriBidiPropertyBlockLevel8_064A,  /* 064A..064B */
+
+#define FriBidiPropertyBlockLevel7_065C 0x4E
+
+  FriBidiPropertyBlockLevel8_0300,  /* 065C..065D */
+  FriBidiPropertyBlockLevel8_065E,  /* 065E..065F */
+
+#define FriBidiPropertyBlockLevel7_0660 0x50
+
+  FriBidiPropertyBlockLevel8_0660,  /* 0660..0661 */
+  FriBidiPropertyBlockLevel8_0660,  /* 0662..0663 */
+
+#define FriBidiPropertyBlockLevel7_0668 0x52
+
+  FriBidiPropertyBlockLevel8_0660,  /* 0668..0669 */
+  FriBidiPropertyBlockLevel8_066A,  /* 066A..066B */
+
+#define FriBidiPropertyBlockLevel7_066C 0x54
+
+  FriBidiPropertyBlockLevel8_066C,  /* 066C..066D */
+  FriBidiPropertyBlockLevel8_0600,  /* 066E..066F */
+
+#define FriBidiPropertyBlockLevel7_0670 0x56
+
+  FriBidiPropertyBlockLevel8_065E,  /* 0670..0671 */
+  FriBidiPropertyBlockLevel8_0600,  /* 0672..0673 */
+
+#define FriBidiPropertyBlockLevel7_06D4 0x58
+
+  FriBidiPropertyBlockLevel8_0600,  /* 06D4..06D5 */
+  FriBidiPropertyBlockLevel8_0300,  /* 06D6..06D7 */
+
+#define FriBidiPropertyBlockLevel7_06DC 0x5A
+
+  FriBidiPropertyBlockLevel8_065E,  /* 06DC..06DD */
+  FriBidiPropertyBlockLevel8_0300,  /* 06DE..06DF */
+
+#define FriBidiPropertyBlockLevel7_06E4 0x5C
+
+  FriBidiPropertyBlockLevel8_065E,  /* 06E4..06E5 */
+  FriBidiPropertyBlockLevel8_064A,  /* 06E6..06E7 */
+
+#define FriBidiPropertyBlockLevel7_06E8 0x5E
+
+  FriBidiPropertyBlockLevel8_06E8,  /* 06E8..06E9 */
+  FriBidiPropertyBlockLevel8_0300,  /* 06EA..06EB */
+
+#define FriBidiPropertyBlockLevel7_06F8 0x60
+
+  FriBidiPropertyBlockLevel8_0030,  /* 06F8..06F9 */
+  FriBidiPropertyBlockLevel8_0600,  /* 06FA..06FB */
+
+#define FriBidiPropertyBlockLevel7_070C 0x62
+
+  FriBidiPropertyBlockLevel8_0600,  /* 070C..070D */
+  FriBidiPropertyBlockLevel8_070E,  /* 070E..070F */
+
+#define FriBidiPropertyBlockLevel7_0710 0x64
+
+  FriBidiPropertyBlockLevel8_064A,  /* 0710..0711 */
+  FriBidiPropertyBlockLevel8_0600,  /* 0712..0713 */
+
+#define FriBidiPropertyBlockLevel7_07E8 0x66
+
+  FriBidiPropertyBlockLevel8_05C8,  /* 07E8..07E9 */
+  FriBidiPropertyBlockLevel8_0590,  /* 07EA..07EB */
+
+#define FriBidiPropertyBlockLevel7_07F4 0x68
+
+  FriBidiPropertyBlockLevel8_05C8,  /* 07F4..07F5 */
+  FriBidiPropertyBlockLevel8_0026,  /* 07F6..07F7 */
+
+#define FriBidiPropertyBlockLevel7_07F8 0x6A
+
+  FriBidiPropertyBlockLevel8_0026,  /* 07F8..07F9 */
+  FriBidiPropertyBlockLevel8_05C8,  /* 07FA..07FB */
+
+#define FriBidiPropertyBlockLevel7_0900 0x6C
+
+  FriBidiPropertyBlockLevel8_0482,  /* 0900..0901 */
+  FriBidiPropertyBlockLevel8_0486,  /* 0902..0903 */
+
+#define FriBidiPropertyBlockLevel7_093C 0x6E
+
+  FriBidiPropertyBlockLevel8_0486,  /* 093C..093D */
+  FriBidiPropertyBlockLevel8_0042,  /* 093E..093F */
+
+#define FriBidiPropertyBlockLevel7_0940 0x70
+
+  FriBidiPropertyBlockLevel8_0482,  /* 0940..0941 */
+  FriBidiPropertyBlockLevel8_0300,  /* 0942..0943 */
+
+#define FriBidiPropertyBlockLevel7_094C 0x72
+
+  FriBidiPropertyBlockLevel8_0482,  /* 094C..094D */
+  FriBidiPropertyBlockLevel8_0042,  /* 094E..094F */
+
+#define FriBidiPropertyBlockLevel7_0960 0x74
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0960..0961 */
+  FriBidiPropertyBlockLevel8_0300,  /* 0962..0963 */
+
+#define FriBidiPropertyBlockLevel7_09F0 0x76
+
+  FriBidiPropertyBlockLevel8_0042,  /* 09F0..09F1 */
+  FriBidiPropertyBlockLevel8_0024,  /* 09F2..09F3 */
+
+#define FriBidiPropertyBlockLevel7_0A48 0x78
+
+  FriBidiPropertyBlockLevel8_0486,  /* 0A48..0A49 */
+  FriBidiPropertyBlockLevel8_0482,  /* 0A4A..0A4B */
+
+#define FriBidiPropertyBlockLevel7_0AC4 0x7A
+
+  FriBidiPropertyBlockLevel8_0300,  /* 0AC4..0AC5 */
+  FriBidiPropertyBlockLevel8_0482,  /* 0AC6..0AC7 */
+
+#define FriBidiPropertyBlockLevel7_0AF0 0x7C
+
+  FriBidiPropertyBlockLevel8_0AF0,  /* 0AF0..0AF1 */
+  FriBidiPropertyBlockLevel8_0042,  /* 0AF2..0AF3 */
+
+#define FriBidiPropertyBlockLevel7_0B54 0x7E
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0B54..0B55 */
+  FriBidiPropertyBlockLevel8_0486,  /* 0B56..0B57 */
+
+#define FriBidiPropertyBlockLevel7_0BF8 0x80
+
+  FriBidiPropertyBlockLevel8_0022,  /* 0BF8..0BF9 */
+  FriBidiPropertyBlockLevel8_0040,  /* 0BFA..0BFB */
+
+#define FriBidiPropertyBlockLevel7_0C48 0x82
+
+  FriBidiPropertyBlockLevel8_0486,  /* 0C48..0C49 */
+  FriBidiPropertyBlockLevel8_0300,  /* 0C4A..0C4B */
+
+#define FriBidiPropertyBlockLevel7_0DD4 0x84
+
+  FriBidiPropertyBlockLevel8_0486,  /* 0DD4..0DD5 */
+  FriBidiPropertyBlockLevel8_0486,  /* 0DD6..0DD7 */
+
+#define FriBidiPropertyBlockLevel7_0E3C 0x86
+
+  FriBidiPropertyBlockLevel8_0042,  /* 0E3C..0E3D */
+  FriBidiPropertyBlockLevel8_0AF0,  /* 0E3E..0E3F */
+
+#define FriBidiPropertyBlockLevel7_0F34 0x88
+
+  FriBidiPropertyBlockLevel8_0482,  /* 0F34..0F35 */
+  FriBidiPropertyBlockLevel8_0482,  /* 0F36..0F37 */
+
+#define FriBidiPropertyBlockLevel7_0F38 0x8A
+
+  FriBidiPropertyBlockLevel8_0482,  /* 0F38..0F39 */
+  FriBidiPropertyBlockLevel8_0026,  /* 0F3A..0F3B */
+
+#define FriBidiPropertyBlockLevel7_1680 0x8C
+
+  FriBidiPropertyBlockLevel8_1680,  /* 1680..1681 */
+  FriBidiPropertyBlockLevel8_0042,  /* 1682..1683 */
+
+#define FriBidiPropertyBlockLevel7_1808 0x8E
+
+  FriBidiPropertyBlockLevel8_0026,  /* 1808..1809 */
+  FriBidiPropertyBlockLevel8_180A,  /* 180A..180B */
+
+#define FriBidiPropertyBlockLevel7_180C 0x90
+
+  FriBidiPropertyBlockLevel8_0300,  /* 180C..180D */
+  FriBidiPropertyBlockLevel8_1680,  /* 180E..180F */
+
+#define FriBidiPropertyBlockLevel7_1FBC 0x92
+
+  FriBidiPropertyBlockLevel8_005A,  /* 1FBC..1FBD */
+  FriBidiPropertyBlockLevel8_005A,  /* 1FBE..1FBF */
+
+#define FriBidiPropertyBlockLevel7_2000 0x94
+
+  FriBidiPropertyBlockLevel8_2000,  /* 2000..2001 */
+  FriBidiPropertyBlockLevel8_2000,  /* 2002..2003 */
+
+#define FriBidiPropertyBlockLevel7_2008 0x96
+
+  FriBidiPropertyBlockLevel8_2000,  /* 2008..2009 */
+  FriBidiPropertyBlockLevel8_200A,  /* 200A..200B */
+
+#define FriBidiPropertyBlockLevel7_200C 0x98
+
+  FriBidiPropertyBlockLevel8_0000,  /* 200C..200D */
+  FriBidiPropertyBlockLevel8_200E,  /* 200E..200F */
+
+#define FriBidiPropertyBlockLevel7_2028 0x9A
+
+  FriBidiPropertyBlockLevel8_000C,  /* 2028..2029 */
+  FriBidiPropertyBlockLevel8_202A,  /* 202A..202B */
+
+#define FriBidiPropertyBlockLevel7_202C 0x9C
+
+  FriBidiPropertyBlockLevel8_202C,  /* 202C..202D */
+  FriBidiPropertyBlockLevel8_202E,  /* 202E..202F */
+
+#define FriBidiPropertyBlockLevel7_2030 0x9E
+
+  FriBidiPropertyBlockLevel8_0024,  /* 2030..2031 */
+  FriBidiPropertyBlockLevel8_0024,  /* 2032..2033 */
+
+#define FriBidiPropertyBlockLevel7_2034 0xA0
+
+  FriBidiPropertyBlockLevel8_2034,  /* 2034..2035 */
+  FriBidiPropertyBlockLevel8_0026,  /* 2036..2037 */
+
+#define FriBidiPropertyBlockLevel7_2044 0xA2
+
+  FriBidiPropertyBlockLevel8_003A,  /* 2044..2045 */
+  FriBidiPropertyBlockLevel8_0026,  /* 2046..2047 */
+
+#define FriBidiPropertyBlockLevel7_205C 0xA4
+
+  FriBidiPropertyBlockLevel8_0026,  /* 205C..205D */
+  FriBidiPropertyBlockLevel8_205E,  /* 205E..205F */
+
+#define FriBidiPropertyBlockLevel7_2070 0xA6
+
+  FriBidiPropertyBlockLevel8_2070,  /* 2070..2071 */
+  FriBidiPropertyBlockLevel8_0042,  /* 2072..2073 */
+
+#define FriBidiPropertyBlockLevel7_2078 0xA8
+
+  FriBidiPropertyBlockLevel8_0030,  /* 2078..2079 */
+  FriBidiPropertyBlockLevel8_207A,  /* 207A..207B */
+
+#define FriBidiPropertyBlockLevel7_207C 0xAA
+
+  FriBidiPropertyBlockLevel8_0026,  /* 207C..207D */
+  FriBidiPropertyBlockLevel8_0040,  /* 207E..207F */
+
+#define FriBidiPropertyBlockLevel7_20B4 0xAC
+
+  FriBidiPropertyBlockLevel8_0024,  /* 20B4..20B5 */
+  FriBidiPropertyBlockLevel8_0042,  /* 20B6..20B7 */
+
+#define FriBidiPropertyBlockLevel7_2128 0xAE
+
+  FriBidiPropertyBlockLevel8_005A,  /* 2128..2129 */
+  FriBidiPropertyBlockLevel8_0042,  /* 212A..212B */
+
+#define FriBidiPropertyBlockLevel7_212C 0xB0
+
+  FriBidiPropertyBlockLevel8_0042,  /* 212C..212D */
+  FriBidiPropertyBlockLevel8_212E,  /* 212E..212F */
+
+#define FriBidiPropertyBlockLevel7_2210 0xB2
+
+  FriBidiPropertyBlockLevel8_0026,  /* 2210..2211 */
+  FriBidiPropertyBlockLevel8_2212,  /* 2212..2213 */
+
+#define FriBidiPropertyBlockLevel7_3000 0xB4
+
+  FriBidiPropertyBlockLevel8_0020,  /* 3000..3001 */
+  FriBidiPropertyBlockLevel8_0026,  /* 3002..3003 */
+
+#define FriBidiPropertyBlockLevel7_3098 0xB6
+
+  FriBidiPropertyBlockLevel8_0482,  /* 3098..3099 */
+  FriBidiPropertyBlockLevel8_06E8,  /* 309A..309B */
+
+#define FriBidiPropertyBlockLevel7_FB1C 0xB8
+
+  FriBidiPropertyBlockLevel8_200E,  /* FB1C..FB1D */
+  FriBidiPropertyBlockLevel8_05C2,  /* FB1E..FB1F */
+
+#define FriBidiPropertyBlockLevel7_FB28 0xBA
+
+  FriBidiPropertyBlockLevel8_FB28,  /* FB28..FB29 */
+  FriBidiPropertyBlockLevel8_05C8,  /* FB2A..FB2B */
+
+#define FriBidiPropertyBlockLevel7_FD3C 0xBC
+
+  FriBidiPropertyBlockLevel8_0600,  /* FD3C..FD3D */
+  FriBidiPropertyBlockLevel8_0026,  /* FD3E..FD3F */
+
+#define FriBidiPropertyBlockLevel7_FDFC 0xBE
+
+  FriBidiPropertyBlockLevel8_FDFC,  /* FDFC..FDFD */
+  FriBidiPropertyBlockLevel8_0600,  /* FDFE..FDFF */
+
+#define FriBidiPropertyBlockLevel7_FE50 0xC0
+
+  FriBidiPropertyBlockLevel8_003A,  /* FE50..FE51 */
+  FriBidiPropertyBlockLevel8_FE52,  /* FE52..FE53 */
+
+#define FriBidiPropertyBlockLevel7_FE54 0xC2
+
+  FriBidiPropertyBlockLevel8_FE54,  /* FE54..FE55 */
+  FriBidiPropertyBlockLevel8_0026,  /* FE56..FE57 */
+
+#define FriBidiPropertyBlockLevel7_FE5C 0xC4
+
+  FriBidiPropertyBlockLevel8_0026,  /* FE5C..FE5D */
+  FriBidiPropertyBlockLevel8_0022,  /* FE5E..FE5F */
+
+#define FriBidiPropertyBlockLevel7_FE60 0xC6
+
+  FriBidiPropertyBlockLevel8_0026,  /* FE60..FE61 */
+  FriBidiPropertyBlockLevel8_207A,  /* FE62..FE63 */
+
+#define FriBidiPropertyBlockLevel7_FE68 0xC8
+
+  FriBidiPropertyBlockLevel8_0022,  /* FE68..FE69 */
+  FriBidiPropertyBlockLevel8_2034,  /* FE6A..FE6B */
+
+#define FriBidiPropertyBlockLevel7_FF00 0xCA
+
+  FriBidiPropertyBlockLevel8_005A,  /* FF00..FF01 */
+  FriBidiPropertyBlockLevel8_0022,  /* FF02..FF03 */
+
+#define FriBidiPropertyBlockLevel7_FFE4 0xCC
+
+  FriBidiPropertyBlockLevel8_0022,  /* FFE4..FFE5 */
+  FriBidiPropertyBlockLevel8_212E,  /* FFE6..FFE7 */
+
+#define FriBidiPropertyBlockLevel7_FFF8 0xCE
+
+  FriBidiPropertyBlockLevel8_FFF8,  /* FFF8..FFF9 */
+  FriBidiPropertyBlockLevel8_0026,  /* FFFA..FFFB */
+
+#define FriBidiPropertyBlockLevel7_FFFC 0xD0
+
+  FriBidiPropertyBlockLevel8_0026,  /* FFFC..FFFD */
+  FriBidiPropertyBlockLevel8_0000,  /* FFFE..FFFF */
+
+#define FriBidiPropertyBlockLevel7_1091C 0xD2
+
+  FriBidiPropertyBlockLevel8_05C8,  /* 1091C..1091D */
+  FriBidiPropertyBlockLevel8_1091E,  /* 1091E..1091F */
+
+#define FriBidiPropertyBlockLevel7_10A38 0xD4
+
+  FriBidiPropertyBlockLevel8_0300,  /* 10A38..10A39 */
+  FriBidiPropertyBlockLevel8_05C2,  /* 10A3A..10A3B */
+
+#define FriBidiPropertyBlockLevel7_1D170 0xD6
+
+  FriBidiPropertyBlockLevel8_0042,  /* 1D170..1D171 */
+  FriBidiPropertyBlockLevel8_1D172,  /* 1D172..1D173 */
+
+#define FriBidiPropertyBlockLevel7_1D178 0xD8
+
+  FriBidiPropertyBlockLevel8_0000,  /* 1D178..1D179 */
+  FriBidiPropertyBlockLevel8_1D17A,  /* 1D17A..1D17B */
+
+#define FriBidiPropertyBlockLevel7_1D240 0xDA
+
+  FriBidiPropertyBlockLevel8_0026,  /* 1D240..1D241 */
+  FriBidiPropertyBlockLevel8_0300,  /* 1D242..1D243 */
+
+#define FriBidiPropertyBlockLevel7_1D244 0xDC
+
+  FriBidiPropertyBlockLevel8_06E8,  /* 1D244..1D245 */
+  FriBidiPropertyBlockLevel8_0042,  /* 1D246..1D247 */
+
+#define FriBidiPropertyBlockLevel7_1D7CC 0xDE
+
+  FriBidiPropertyBlockLevel8_0042,  /* 1D7CC..1D7CD */
+  FriBidiPropertyBlockLevel8_0030,  /* 1D7CE..1D7CF */
+
+#define FriBidiPropertyBlockLevel7_1FFFC 0xE0
+
+  FriBidiPropertyBlockLevel8_0042,  /* 1FFFC..1FFFD */
+  FriBidiPropertyBlockLevel8_0000,  /* 1FFFE..1FFFF */
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel6[4*177] = {
+
+#define FriBidiPropertyBlockLevel6_0000 0x0
+
+  FriBidiPropertyBlockLevel7_0000,  /* 0000..0003 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0004..0007 */
+  FriBidiPropertyBlockLevel7_0008,  /* 0008..000B */
+  FriBidiPropertyBlockLevel7_000C,  /* 000C..000F */
+
+#define FriBidiPropertyBlockLevel6_0010 0x4
+
+  FriBidiPropertyBlockLevel7_0000,  /* 0010..0013 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0014..0017 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0018..001B */
+  FriBidiPropertyBlockLevel7_001C,  /* 001C..001F */
+
+#define FriBidiPropertyBlockLevel6_0020 0x8
+
+  FriBidiPropertyBlockLevel7_0020,  /* 0020..0023 */
+  FriBidiPropertyBlockLevel7_0024,  /* 0024..0027 */
+  FriBidiPropertyBlockLevel7_0028,  /* 0028..002B */
+  FriBidiPropertyBlockLevel7_002C,  /* 002C..002F */
+
+#define FriBidiPropertyBlockLevel6_0030 0xC
+
+  FriBidiPropertyBlockLevel7_0030,  /* 0030..0033 */
+  FriBidiPropertyBlockLevel7_0030,  /* 0034..0037 */
+  FriBidiPropertyBlockLevel7_0038,  /* 0038..003B */
+  FriBidiPropertyBlockLevel7_003C,  /* 003C..003F */
+
+#define FriBidiPropertyBlockLevel6_0040 0x10
+
+  FriBidiPropertyBlockLevel7_0040,  /* 0040..0043 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0044..0047 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0048..004B */
+  FriBidiPropertyBlockLevel7_0044,  /* 004C..004F */
+
+#define FriBidiPropertyBlockLevel6_0050 0x14
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0050..0053 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0054..0057 */
+  FriBidiPropertyBlockLevel7_0058,  /* 0058..005B */
+  FriBidiPropertyBlockLevel7_003C,  /* 005C..005F */
+
+#define FriBidiPropertyBlockLevel6_0070 0x18
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0070..0073 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0074..0077 */
+  FriBidiPropertyBlockLevel7_0058,  /* 0078..007B */
+  FriBidiPropertyBlockLevel7_007C,  /* 007C..007F */
+
+#define FriBidiPropertyBlockLevel6_0080 0x1C
+
+  FriBidiPropertyBlockLevel7_0000,  /* 0080..0083 */
+  FriBidiPropertyBlockLevel7_0084,  /* 0084..0087 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0088..008B */
+  FriBidiPropertyBlockLevel7_0000,  /* 008C..008F */
+
+#define FriBidiPropertyBlockLevel6_0090 0x20
+
+  FriBidiPropertyBlockLevel7_0000,  /* 0090..0093 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0094..0097 */
+  FriBidiPropertyBlockLevel7_0000,  /* 0098..009B */
+  FriBidiPropertyBlockLevel7_0000,  /* 009C..009F */
+
+#define FriBidiPropertyBlockLevel6_00A0 0x24
+
+  FriBidiPropertyBlockLevel7_00A0,  /* 00A0..00A3 */
+  FriBidiPropertyBlockLevel7_0024,  /* 00A4..00A7 */
+  FriBidiPropertyBlockLevel7_00A8,  /* 00A8..00AB */
+  FriBidiPropertyBlockLevel7_00AC,  /* 00AC..00AF */
+
+#define FriBidiPropertyBlockLevel6_00B0 0x28
+
+  FriBidiPropertyBlockLevel7_00B0,  /* 00B0..00B3 */
+  FriBidiPropertyBlockLevel7_00B4,  /* 00B4..00B7 */
+  FriBidiPropertyBlockLevel7_00B8,  /* 00B8..00BB */
+  FriBidiPropertyBlockLevel7_003C,  /* 00BC..00BF */
+
+#define FriBidiPropertyBlockLevel6_00C0 0x2C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 00C0..00C3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 00C4..00C7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 00C8..00CB */
+  FriBidiPropertyBlockLevel7_0044,  /* 00CC..00CF */
+
+#define FriBidiPropertyBlockLevel6_00D0 0x30
+
+  FriBidiPropertyBlockLevel7_0044,  /* 00D0..00D3 */
+  FriBidiPropertyBlockLevel7_0058,  /* 00D4..00D7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 00D8..00DB */
+  FriBidiPropertyBlockLevel7_0044,  /* 00DC..00DF */
+
+#define FriBidiPropertyBlockLevel6_02B0 0x34
+
+  FriBidiPropertyBlockLevel7_0044,  /* 02B0..02B3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 02B4..02B7 */
+  FriBidiPropertyBlockLevel7_02B8,  /* 02B8..02BB */
+  FriBidiPropertyBlockLevel7_0044,  /* 02BC..02BF */
+
+#define FriBidiPropertyBlockLevel6_02C0 0x38
+
+  FriBidiPropertyBlockLevel7_02C0,  /* 02C0..02C3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 02C4..02C7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 02C8..02CB */
+  FriBidiPropertyBlockLevel7_003C,  /* 02CC..02CF */
+
+#define FriBidiPropertyBlockLevel6_02E0 0x3C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 02E0..02E3 */
+  FriBidiPropertyBlockLevel7_02E4,  /* 02E4..02E7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 02E8..02EB */
+  FriBidiPropertyBlockLevel7_00A8,  /* 02EC..02EF */
+
+#define FriBidiPropertyBlockLevel6_02F0 0x40
+
+  FriBidiPropertyBlockLevel7_003C,  /* 02F0..02F3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 02F4..02F7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 02F8..02FB */
+  FriBidiPropertyBlockLevel7_003C,  /* 02FC..02FF */
+
+#define FriBidiPropertyBlockLevel6_0300 0x44
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0300..0303 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0304..0307 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0308..030B */
+  FriBidiPropertyBlockLevel7_0300,  /* 030C..030F */
+
+#define FriBidiPropertyBlockLevel6_0370 0x48
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0370..0373 */
+  FriBidiPropertyBlockLevel7_0374,  /* 0374..0377 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0378..037B */
+  FriBidiPropertyBlockLevel7_037C,  /* 037C..037F */
+
+#define FriBidiPropertyBlockLevel6_0380 0x4C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0380..0383 */
+  FriBidiPropertyBlockLevel7_00A8,  /* 0384..0387 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0388..038B */
+  FriBidiPropertyBlockLevel7_0044,  /* 038C..038F */
+
+#define FriBidiPropertyBlockLevel6_03F0 0x50
+
+  FriBidiPropertyBlockLevel7_0044,  /* 03F0..03F3 */
+  FriBidiPropertyBlockLevel7_037C,  /* 03F4..03F7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 03F8..03FB */
+  FriBidiPropertyBlockLevel7_0044,  /* 03FC..03FF */
+
+#define FriBidiPropertyBlockLevel6_0480 0x54
+
+  FriBidiPropertyBlockLevel7_0480,  /* 0480..0483 */
+  FriBidiPropertyBlockLevel7_0484,  /* 0484..0487 */
+  FriBidiPropertyBlockLevel7_0488,  /* 0488..048B */
+  FriBidiPropertyBlockLevel7_0044,  /* 048C..048F */
+
+#define FriBidiPropertyBlockLevel6_0580 0x58
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0580..0583 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0584..0587 */
+  FriBidiPropertyBlockLevel7_037C,  /* 0588..058B */
+  FriBidiPropertyBlockLevel7_0044,  /* 058C..058F */
+
+#define FriBidiPropertyBlockLevel6_0590 0x5C
+
+  FriBidiPropertyBlockLevel7_0590,  /* 0590..0593 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0594..0597 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0598..059B */
+  FriBidiPropertyBlockLevel7_0300,  /* 059C..059F */
+
+#define FriBidiPropertyBlockLevel6_05B0 0x60
+
+  FriBidiPropertyBlockLevel7_0300,  /* 05B0..05B3 */
+  FriBidiPropertyBlockLevel7_0300,  /* 05B4..05B7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 05B8..05BB */
+  FriBidiPropertyBlockLevel7_05BC,  /* 05BC..05BF */
+
+#define FriBidiPropertyBlockLevel6_05C0 0x64
+
+  FriBidiPropertyBlockLevel7_05C0,  /* 05C0..05C3 */
+  FriBidiPropertyBlockLevel7_05BC,  /* 05C4..05C7 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 05C8..05CB */
+  FriBidiPropertyBlockLevel7_05C8,  /* 05CC..05CF */
+
+#define FriBidiPropertyBlockLevel6_05D0 0x68
+
+  FriBidiPropertyBlockLevel7_05C8,  /* 05D0..05D3 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 05D4..05D7 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 05D8..05DB */
+  FriBidiPropertyBlockLevel7_05C8,  /* 05DC..05DF */
+
+#define FriBidiPropertyBlockLevel6_0600 0x6C
+
+  FriBidiPropertyBlockLevel7_0600,  /* 0600..0603 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0604..0607 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0608..060B */
+  FriBidiPropertyBlockLevel7_060C,  /* 060C..060F */
+
+#define FriBidiPropertyBlockLevel6_0610 0x70
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0610..0613 */
+  FriBidiPropertyBlockLevel7_0614,  /* 0614..0617 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0618..061B */
+  FriBidiPropertyBlockLevel7_0600,  /* 061C..061F */
+
+#define FriBidiPropertyBlockLevel6_0620 0x74
+
+  FriBidiPropertyBlockLevel7_0600,  /* 0620..0623 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0624..0627 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0628..062B */
+  FriBidiPropertyBlockLevel7_0600,  /* 062C..062F */
+
+#define FriBidiPropertyBlockLevel6_0640 0x78
+
+  FriBidiPropertyBlockLevel7_0600,  /* 0640..0643 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0644..0647 */
+  FriBidiPropertyBlockLevel7_0648,  /* 0648..064B */
+  FriBidiPropertyBlockLevel7_0300,  /* 064C..064F */
+
+#define FriBidiPropertyBlockLevel6_0650 0x7C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0650..0653 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0654..0657 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0658..065B */
+  FriBidiPropertyBlockLevel7_065C,  /* 065C..065F */
+
+#define FriBidiPropertyBlockLevel6_0660 0x80
+
+  FriBidiPropertyBlockLevel7_0660,  /* 0660..0663 */
+  FriBidiPropertyBlockLevel7_0660,  /* 0664..0667 */
+  FriBidiPropertyBlockLevel7_0668,  /* 0668..066B */
+  FriBidiPropertyBlockLevel7_066C,  /* 066C..066F */
+
+#define FriBidiPropertyBlockLevel6_0670 0x84
+
+  FriBidiPropertyBlockLevel7_0670,  /* 0670..0673 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0674..0677 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0678..067B */
+  FriBidiPropertyBlockLevel7_0600,  /* 067C..067F */
+
+#define FriBidiPropertyBlockLevel6_06D0 0x88
+
+  FriBidiPropertyBlockLevel7_0600,  /* 06D0..06D3 */
+  FriBidiPropertyBlockLevel7_06D4,  /* 06D4..06D7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 06D8..06DB */
+  FriBidiPropertyBlockLevel7_06DC,  /* 06DC..06DF */
+
+#define FriBidiPropertyBlockLevel6_06E0 0x8C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 06E0..06E3 */
+  FriBidiPropertyBlockLevel7_06E4,  /* 06E4..06E7 */
+  FriBidiPropertyBlockLevel7_06E8,  /* 06E8..06EB */
+  FriBidiPropertyBlockLevel7_0614,  /* 06EC..06EF */
+
+#define FriBidiPropertyBlockLevel6_06F0 0x90
+
+  FriBidiPropertyBlockLevel7_0030,  /* 06F0..06F3 */
+  FriBidiPropertyBlockLevel7_0030,  /* 06F4..06F7 */
+  FriBidiPropertyBlockLevel7_06F8,  /* 06F8..06FB */
+  FriBidiPropertyBlockLevel7_0600,  /* 06FC..06FF */
+
+#define FriBidiPropertyBlockLevel6_0700 0x94
+
+  FriBidiPropertyBlockLevel7_0600,  /* 0700..0703 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0704..0707 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0708..070B */
+  FriBidiPropertyBlockLevel7_070C,  /* 070C..070F */
+
+#define FriBidiPropertyBlockLevel6_0710 0x98
+
+  FriBidiPropertyBlockLevel7_0710,  /* 0710..0713 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0714..0717 */
+  FriBidiPropertyBlockLevel7_0600,  /* 0718..071B */
+  FriBidiPropertyBlockLevel7_0600,  /* 071C..071F */
+
+#define FriBidiPropertyBlockLevel6_0740 0x9C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0740..0743 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0744..0747 */
+  FriBidiPropertyBlockLevel7_065C,  /* 0748..074B */
+  FriBidiPropertyBlockLevel7_0600,  /* 074C..074F */
+
+#define FriBidiPropertyBlockLevel6_07A0 0xA0
+
+  FriBidiPropertyBlockLevel7_0600,  /* 07A0..07A3 */
+  FriBidiPropertyBlockLevel7_06D4,  /* 07A4..07A7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 07A8..07AB */
+  FriBidiPropertyBlockLevel7_0300,  /* 07AC..07AF */
+
+#define FriBidiPropertyBlockLevel6_07E0 0xA4
+
+  FriBidiPropertyBlockLevel7_05C8,  /* 07E0..07E3 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 07E4..07E7 */
+  FriBidiPropertyBlockLevel7_07E8,  /* 07E8..07EB */
+  FriBidiPropertyBlockLevel7_0300,  /* 07EC..07EF */
+
+#define FriBidiPropertyBlockLevel6_07F0 0xA8
+
+  FriBidiPropertyBlockLevel7_0300,  /* 07F0..07F3 */
+  FriBidiPropertyBlockLevel7_07F4,  /* 07F4..07F7 */
+  FriBidiPropertyBlockLevel7_07F8,  /* 07F8..07FB */
+  FriBidiPropertyBlockLevel7_05C8,  /* 07FC..07FF */
+
+#define FriBidiPropertyBlockLevel6_0900 0xAC
+
+  FriBidiPropertyBlockLevel7_0900,  /* 0900..0903 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0904..0907 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0908..090B */
+  FriBidiPropertyBlockLevel7_0044,  /* 090C..090F */
+
+#define FriBidiPropertyBlockLevel6_0930 0xB0
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0930..0933 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0934..0937 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0938..093B */
+  FriBidiPropertyBlockLevel7_093C,  /* 093C..093F */
+
+#define FriBidiPropertyBlockLevel6_0940 0xB4
+
+  FriBidiPropertyBlockLevel7_0940,  /* 0940..0943 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0944..0947 */
+  FriBidiPropertyBlockLevel7_093C,  /* 0948..094B */
+  FriBidiPropertyBlockLevel7_094C,  /* 094C..094F */
+
+#define FriBidiPropertyBlockLevel6_0950 0xB8
+
+  FriBidiPropertyBlockLevel7_0940,  /* 0950..0953 */
+  FriBidiPropertyBlockLevel7_093C,  /* 0954..0957 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0958..095B */
+  FriBidiPropertyBlockLevel7_0044,  /* 095C..095F */
+
+#define FriBidiPropertyBlockLevel6_0960 0xBC
+
+  FriBidiPropertyBlockLevel7_0960,  /* 0960..0963 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0964..0967 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0968..096B */
+  FriBidiPropertyBlockLevel7_0044,  /* 096C..096F */
+
+#define FriBidiPropertyBlockLevel6_0980 0xC0
+
+  FriBidiPropertyBlockLevel7_094C,  /* 0980..0983 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0984..0987 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0988..098B */
+  FriBidiPropertyBlockLevel7_0044,  /* 098C..098F */
+
+#define FriBidiPropertyBlockLevel6_09C0 0xC4
+
+  FriBidiPropertyBlockLevel7_0940,  /* 09C0..09C3 */
+  FriBidiPropertyBlockLevel7_093C,  /* 09C4..09C7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 09C8..09CB */
+  FriBidiPropertyBlockLevel7_094C,  /* 09CC..09CF */
+
+#define FriBidiPropertyBlockLevel6_09F0 0xC8
+
+  FriBidiPropertyBlockLevel7_09F0,  /* 09F0..09F3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 09F4..09F7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 09F8..09FB */
+  FriBidiPropertyBlockLevel7_0044,  /* 09FC..09FF */
+
+#define FriBidiPropertyBlockLevel6_0A40 0xCC
+
+  FriBidiPropertyBlockLevel7_0900,  /* 0A40..0A43 */
+  FriBidiPropertyBlockLevel7_0480,  /* 0A44..0A47 */
+  FriBidiPropertyBlockLevel7_0A48,  /* 0A48..0A4B */
+  FriBidiPropertyBlockLevel7_0488,  /* 0A4C..0A4F */
+
+#define FriBidiPropertyBlockLevel6_0A70 0xD0
+
+  FriBidiPropertyBlockLevel7_0488,  /* 0A70..0A73 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0A74..0A77 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0A78..0A7B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0A7C..0A7F */
+
+#define FriBidiPropertyBlockLevel6_0AC0 0xD4
+
+  FriBidiPropertyBlockLevel7_0940,  /* 0AC0..0AC3 */
+  FriBidiPropertyBlockLevel7_0AC4,  /* 0AC4..0AC7 */
+  FriBidiPropertyBlockLevel7_093C,  /* 0AC8..0ACB */
+  FriBidiPropertyBlockLevel7_094C,  /* 0ACC..0ACF */
+
+#define FriBidiPropertyBlockLevel6_0AF0 0xD8
+
+  FriBidiPropertyBlockLevel7_0AF0,  /* 0AF0..0AF3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0AF4..0AF7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0AF8..0AFB */
+  FriBidiPropertyBlockLevel7_0044,  /* 0AFC..0AFF */
+
+#define FriBidiPropertyBlockLevel6_0B30 0xDC
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0B30..0B33 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B34..0B37 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B38..0B3B */
+  FriBidiPropertyBlockLevel7_0A48,  /* 0B3C..0B3F */
+
+#define FriBidiPropertyBlockLevel6_0B40 0xE0
+
+  FriBidiPropertyBlockLevel7_0940,  /* 0B40..0B43 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B44..0B47 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B48..0B4B */
+  FriBidiPropertyBlockLevel7_094C,  /* 0B4C..0B4F */
+
+#define FriBidiPropertyBlockLevel6_0B50 0xE4
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0B50..0B53 */
+  FriBidiPropertyBlockLevel7_0B54,  /* 0B54..0B57 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B58..0B5B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B5C..0B5F */
+
+#define FriBidiPropertyBlockLevel6_0B80 0xE8
+
+  FriBidiPropertyBlockLevel7_0B54,  /* 0B80..0B83 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B84..0B87 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B88..0B8B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0B8C..0B8F */
+
+#define FriBidiPropertyBlockLevel6_0BC0 0xEC
+
+  FriBidiPropertyBlockLevel7_093C,  /* 0BC0..0BC3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0BC4..0BC7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0BC8..0BCB */
+  FriBidiPropertyBlockLevel7_094C,  /* 0BCC..0BCF */
+
+#define FriBidiPropertyBlockLevel6_0BF0 0xF0
+
+  FriBidiPropertyBlockLevel7_0058,  /* 0BF0..0BF3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 0BF4..0BF7 */
+  FriBidiPropertyBlockLevel7_0BF8,  /* 0BF8..0BFB */
+  FriBidiPropertyBlockLevel7_0044,  /* 0BFC..0BFF */
+
+#define FriBidiPropertyBlockLevel6_0C30 0xF4
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0C30..0C33 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0C34..0C37 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0C38..0C3B */
+  FriBidiPropertyBlockLevel7_0960,  /* 0C3C..0C3F */
+
+#define FriBidiPropertyBlockLevel6_0C40 0xF8
+
+  FriBidiPropertyBlockLevel7_093C,  /* 0C40..0C43 */
+  FriBidiPropertyBlockLevel7_0960,  /* 0C44..0C47 */
+  FriBidiPropertyBlockLevel7_0C48,  /* 0C48..0C4B */
+  FriBidiPropertyBlockLevel7_0488,  /* 0C4C..0C4F */
+
+#define FriBidiPropertyBlockLevel6_0C50 0xFC
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0C50..0C53 */
+  FriBidiPropertyBlockLevel7_0900,  /* 0C54..0C57 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0C58..0C5B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0C5C..0C5F */
+
+#define FriBidiPropertyBlockLevel6_0CC0 0x100
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0CC0..0CC3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0CC4..0CC7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0CC8..0CCB */
+  FriBidiPropertyBlockLevel7_0488,  /* 0CCC..0CCF */
+
+#define FriBidiPropertyBlockLevel6_0CF0 0x104
+
+  FriBidiPropertyBlockLevel7_02B8,  /* 0CF0..0CF3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0CF4..0CF7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0CF8..0CFB */
+  FriBidiPropertyBlockLevel7_0044,  /* 0CFC..0CFF */
+
+#define FriBidiPropertyBlockLevel6_0DC0 0x108
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0DC0..0DC3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0DC4..0DC7 */
+  FriBidiPropertyBlockLevel7_0B54,  /* 0DC8..0DCB */
+  FriBidiPropertyBlockLevel7_0044,  /* 0DCC..0DCF */
+
+#define FriBidiPropertyBlockLevel6_0DD0 0x10C
+
+  FriBidiPropertyBlockLevel7_0960,  /* 0DD0..0DD3 */
+  FriBidiPropertyBlockLevel7_0DD4,  /* 0DD4..0DD7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0DD8..0DDB */
+  FriBidiPropertyBlockLevel7_0044,  /* 0DDC..0DDF */
+
+#define FriBidiPropertyBlockLevel6_0E30 0x110
+
+  FriBidiPropertyBlockLevel7_094C,  /* 0E30..0E33 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0E34..0E37 */
+  FriBidiPropertyBlockLevel7_0484,  /* 0E38..0E3B */
+  FriBidiPropertyBlockLevel7_0E3C,  /* 0E3C..0E3F */
+
+#define FriBidiPropertyBlockLevel6_0E40 0x114
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0E40..0E43 */
+  FriBidiPropertyBlockLevel7_0480,  /* 0E44..0E47 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0E48..0E4B */
+  FriBidiPropertyBlockLevel7_0484,  /* 0E4C..0E4F */
+
+#define FriBidiPropertyBlockLevel6_0EB0 0x118
+
+  FriBidiPropertyBlockLevel7_094C,  /* 0EB0..0EB3 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0EB4..0EB7 */
+  FriBidiPropertyBlockLevel7_0AC4,  /* 0EB8..0EBB */
+  FriBidiPropertyBlockLevel7_093C,  /* 0EBC..0EBF */
+
+#define FriBidiPropertyBlockLevel6_0EC0 0x11C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0EC0..0EC3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0EC4..0EC7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0EC8..0ECB */
+  FriBidiPropertyBlockLevel7_0488,  /* 0ECC..0ECF */
+
+#define FriBidiPropertyBlockLevel6_0F10 0x120
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0F10..0F13 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0F14..0F17 */
+  FriBidiPropertyBlockLevel7_0488,  /* 0F18..0F1B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0F1C..0F1F */
+
+#define FriBidiPropertyBlockLevel6_0F30 0x124
+
+  FriBidiPropertyBlockLevel7_0044,  /* 0F30..0F33 */
+  FriBidiPropertyBlockLevel7_0F34,  /* 0F34..0F37 */
+  FriBidiPropertyBlockLevel7_0F38,  /* 0F38..0F3B */
+  FriBidiPropertyBlockLevel7_0374,  /* 0F3C..0F3F */
+
+#define FriBidiPropertyBlockLevel6_0F70 0x128
+
+  FriBidiPropertyBlockLevel7_0940,  /* 0F70..0F73 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0F74..0F77 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0F78..0F7B */
+  FriBidiPropertyBlockLevel7_0484,  /* 0F7C..0F7F */
+
+#define FriBidiPropertyBlockLevel6_0F80 0x12C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0F80..0F83 */
+  FriBidiPropertyBlockLevel7_0C48,  /* 0F84..0F87 */
+  FriBidiPropertyBlockLevel7_0044,  /* 0F88..0F8B */
+  FriBidiPropertyBlockLevel7_0044,  /* 0F8C..0F8F */
+
+#define FriBidiPropertyBlockLevel6_0F90 0x130
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0F90..0F93 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0F94..0F97 */
+  FriBidiPropertyBlockLevel7_0940,  /* 0F98..0F9B */
+  FriBidiPropertyBlockLevel7_0300,  /* 0F9C..0F9F */
+
+#define FriBidiPropertyBlockLevel6_0FB0 0x134
+
+  FriBidiPropertyBlockLevel7_0300,  /* 0FB0..0FB3 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0FB4..0FB7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 0FB8..0FBB */
+  FriBidiPropertyBlockLevel7_093C,  /* 0FBC..0FBF */
+
+#define FriBidiPropertyBlockLevel6_1020 0x138
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1020..1023 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1024..1027 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1028..102B */
+  FriBidiPropertyBlockLevel7_0940,  /* 102C..102F */
+
+#define FriBidiPropertyBlockLevel6_1030 0x13C
+
+  FriBidiPropertyBlockLevel7_0DD4,  /* 1030..1033 */
+  FriBidiPropertyBlockLevel7_0960,  /* 1034..1037 */
+  FriBidiPropertyBlockLevel7_094C,  /* 1038..103B */
+  FriBidiPropertyBlockLevel7_0044,  /* 103C..103F */
+
+#define FriBidiPropertyBlockLevel6_1350 0x140
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1350..1353 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1354..1357 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1358..135B */
+  FriBidiPropertyBlockLevel7_0480,  /* 135C..135F */
+
+#define FriBidiPropertyBlockLevel6_1390 0x144
+
+  FriBidiPropertyBlockLevel7_003C,  /* 1390..1393 */
+  FriBidiPropertyBlockLevel7_003C,  /* 1394..1397 */
+  FriBidiPropertyBlockLevel7_0374,  /* 1398..139B */
+  FriBidiPropertyBlockLevel7_0044,  /* 139C..139F */
+
+#define FriBidiPropertyBlockLevel6_1680 0x148
+
+  FriBidiPropertyBlockLevel7_1680,  /* 1680..1683 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1684..1687 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1688..168B */
+  FriBidiPropertyBlockLevel7_0044,  /* 168C..168F */
+
+#define FriBidiPropertyBlockLevel6_1690 0x14C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1690..1693 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1694..1697 */
+  FriBidiPropertyBlockLevel7_0058,  /* 1698..169B */
+  FriBidiPropertyBlockLevel7_0040,  /* 169C..169F */
+
+#define FriBidiPropertyBlockLevel6_1710 0x150
+
+  FriBidiPropertyBlockLevel7_0960,  /* 1710..1713 */
+  FriBidiPropertyBlockLevel7_093C,  /* 1714..1717 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1718..171B */
+  FriBidiPropertyBlockLevel7_0044,  /* 171C..171F */
+
+#define FriBidiPropertyBlockLevel6_17B0 0x154
+
+  FriBidiPropertyBlockLevel7_0044,  /* 17B0..17B3 */
+  FriBidiPropertyBlockLevel7_0480,  /* 17B4..17B7 */
+  FriBidiPropertyBlockLevel7_0300,  /* 17B8..17BB */
+  FriBidiPropertyBlockLevel7_0488,  /* 17BC..17BF */
+
+#define FriBidiPropertyBlockLevel6_17C0 0x158
+
+  FriBidiPropertyBlockLevel7_0044,  /* 17C0..17C3 */
+  FriBidiPropertyBlockLevel7_0B54,  /* 17C4..17C7 */
+  FriBidiPropertyBlockLevel7_0940,  /* 17C8..17CB */
+  FriBidiPropertyBlockLevel7_0300,  /* 17CC..17CF */
+
+#define FriBidiPropertyBlockLevel6_17D0 0x15C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 17D0..17D3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 17D4..17D7 */
+  FriBidiPropertyBlockLevel7_0E3C,  /* 17D8..17DB */
+  FriBidiPropertyBlockLevel7_094C,  /* 17DC..17DF */
+
+#define FriBidiPropertyBlockLevel6_1800 0x160
+
+  FriBidiPropertyBlockLevel7_003C,  /* 1800..1803 */
+  FriBidiPropertyBlockLevel7_003C,  /* 1804..1807 */
+  FriBidiPropertyBlockLevel7_1808,  /* 1808..180B */
+  FriBidiPropertyBlockLevel7_180C,  /* 180C..180F */
+
+#define FriBidiPropertyBlockLevel6_18A0 0x164
+
+  FriBidiPropertyBlockLevel7_0044,  /* 18A0..18A3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 18A4..18A7 */
+  FriBidiPropertyBlockLevel7_094C,  /* 18A8..18AB */
+  FriBidiPropertyBlockLevel7_0044,  /* 18AC..18AF */
+
+#define FriBidiPropertyBlockLevel6_1920 0x168
+
+  FriBidiPropertyBlockLevel7_0484,  /* 1920..1923 */
+  FriBidiPropertyBlockLevel7_0480,  /* 1924..1927 */
+  FriBidiPropertyBlockLevel7_0300,  /* 1928..192B */
+  FriBidiPropertyBlockLevel7_0044,  /* 192C..192F */
+
+#define FriBidiPropertyBlockLevel6_1930 0x16C
+
+  FriBidiPropertyBlockLevel7_0B54,  /* 1930..1933 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1934..1937 */
+  FriBidiPropertyBlockLevel7_0940,  /* 1938..193B */
+  FriBidiPropertyBlockLevel7_0044,  /* 193C..193F */
+
+#define FriBidiPropertyBlockLevel6_1940 0x170
+
+  FriBidiPropertyBlockLevel7_0040,  /* 1940..1943 */
+  FriBidiPropertyBlockLevel7_0374,  /* 1944..1947 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1948..194B */
+  FriBidiPropertyBlockLevel7_0044,  /* 194C..194F */
+
+#define FriBidiPropertyBlockLevel6_19D0 0x174
+
+  FriBidiPropertyBlockLevel7_0044,  /* 19D0..19D3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 19D4..19D7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 19D8..19DB */
+  FriBidiPropertyBlockLevel7_02C0,  /* 19DC..19DF */
+
+#define FriBidiPropertyBlockLevel6_1A10 0x178
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1A10..1A13 */
+  FriBidiPropertyBlockLevel7_0480,  /* 1A14..1A17 */
+  FriBidiPropertyBlockLevel7_093C,  /* 1A18..1A1B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1A1C..1A1F */
+
+#define FriBidiPropertyBlockLevel6_1B00 0x17C
+
+  FriBidiPropertyBlockLevel7_0300,  /* 1B00..1B03 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1B04..1B07 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1B08..1B0B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1B0C..1B0F */
+
+#define FriBidiPropertyBlockLevel6_1B30 0x180
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1B30..1B33 */
+  FriBidiPropertyBlockLevel7_0C48,  /* 1B34..1B37 */
+  FriBidiPropertyBlockLevel7_0484,  /* 1B38..1B3B */
+  FriBidiPropertyBlockLevel7_093C,  /* 1B3C..1B3F */
+
+#define FriBidiPropertyBlockLevel6_1B60 0x184
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1B60..1B63 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1B64..1B67 */
+  FriBidiPropertyBlockLevel7_0480,  /* 1B68..1B6B */
+  FriBidiPropertyBlockLevel7_0300,  /* 1B6C..1B6F */
+
+#define FriBidiPropertyBlockLevel6_1DC0 0x188
+
+  FriBidiPropertyBlockLevel7_0300,  /* 1DC0..1DC3 */
+  FriBidiPropertyBlockLevel7_0300,  /* 1DC4..1DC7 */
+  FriBidiPropertyBlockLevel7_0484,  /* 1DC8..1DCB */
+  FriBidiPropertyBlockLevel7_0044,  /* 1DCC..1DCF */
+
+#define FriBidiPropertyBlockLevel6_1FB0 0x18C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1FB0..1FB3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FB4..1FB7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FB8..1FBB */
+  FriBidiPropertyBlockLevel7_1FBC,  /* 1FBC..1FBF */
+
+#define FriBidiPropertyBlockLevel6_1FC0 0x190
+
+  FriBidiPropertyBlockLevel7_0374,  /* 1FC0..1FC3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FC4..1FC7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FC8..1FCB */
+  FriBidiPropertyBlockLevel7_02E4,  /* 1FCC..1FCF */
+
+#define FriBidiPropertyBlockLevel6_1FD0 0x194
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1FD0..1FD3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FD4..1FD7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FD8..1FDB */
+  FriBidiPropertyBlockLevel7_02E4,  /* 1FDC..1FDF */
+
+#define FriBidiPropertyBlockLevel6_1FF0 0x198
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1FF0..1FF3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FF4..1FF7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FF8..1FFB */
+  FriBidiPropertyBlockLevel7_02B8,  /* 1FFC..1FFF */
+
+#define FriBidiPropertyBlockLevel6_2000 0x19C
+
+  FriBidiPropertyBlockLevel7_2000,  /* 2000..2003 */
+  FriBidiPropertyBlockLevel7_2000,  /* 2004..2007 */
+  FriBidiPropertyBlockLevel7_2008,  /* 2008..200B */
+  FriBidiPropertyBlockLevel7_200C,  /* 200C..200F */
+
+#define FriBidiPropertyBlockLevel6_2020 0x1A0
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2020..2023 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2024..2027 */
+  FriBidiPropertyBlockLevel7_2028,  /* 2028..202B */
+  FriBidiPropertyBlockLevel7_202C,  /* 202C..202F */
+
+#define FriBidiPropertyBlockLevel6_2030 0x1A4
+
+  FriBidiPropertyBlockLevel7_2030,  /* 2030..2033 */
+  FriBidiPropertyBlockLevel7_2034,  /* 2034..2037 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2038..203B */
+  FriBidiPropertyBlockLevel7_003C,  /* 203C..203F */
+
+#define FriBidiPropertyBlockLevel6_2040 0x1A8
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2040..2043 */
+  FriBidiPropertyBlockLevel7_2044,  /* 2044..2047 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2048..204B */
+  FriBidiPropertyBlockLevel7_003C,  /* 204C..204F */
+
+#define FriBidiPropertyBlockLevel6_2050 0x1AC
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2050..2053 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2054..2057 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2058..205B */
+  FriBidiPropertyBlockLevel7_205C,  /* 205C..205F */
+
+#define FriBidiPropertyBlockLevel6_2070 0x1B0
+
+  FriBidiPropertyBlockLevel7_2070,  /* 2070..2073 */
+  FriBidiPropertyBlockLevel7_0030,  /* 2074..2077 */
+  FriBidiPropertyBlockLevel7_2078,  /* 2078..207B */
+  FriBidiPropertyBlockLevel7_207C,  /* 207C..207F */
+
+#define FriBidiPropertyBlockLevel6_2080 0x1B4
+
+  FriBidiPropertyBlockLevel7_0030,  /* 2080..2083 */
+  FriBidiPropertyBlockLevel7_0030,  /* 2084..2087 */
+  FriBidiPropertyBlockLevel7_2078,  /* 2088..208B */
+  FriBidiPropertyBlockLevel7_207C,  /* 208C..208F */
+
+#define FriBidiPropertyBlockLevel6_20A0 0x1B8
+
+  FriBidiPropertyBlockLevel7_2030,  /* 20A0..20A3 */
+  FriBidiPropertyBlockLevel7_2030,  /* 20A4..20A7 */
+  FriBidiPropertyBlockLevel7_2030,  /* 20A8..20AB */
+  FriBidiPropertyBlockLevel7_2030,  /* 20AC..20AF */
+
+#define FriBidiPropertyBlockLevel6_20B0 0x1BC
+
+  FriBidiPropertyBlockLevel7_2030,  /* 20B0..20B3 */
+  FriBidiPropertyBlockLevel7_20B4,  /* 20B4..20B7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 20B8..20BB */
+  FriBidiPropertyBlockLevel7_0044,  /* 20BC..20BF */
+
+#define FriBidiPropertyBlockLevel6_2100 0x1C0
+
+  FriBidiPropertyBlockLevel7_00A8,  /* 2100..2103 */
+  FriBidiPropertyBlockLevel7_207C,  /* 2104..2107 */
+  FriBidiPropertyBlockLevel7_0374,  /* 2108..210B */
+  FriBidiPropertyBlockLevel7_0044,  /* 210C..210F */
+
+#define FriBidiPropertyBlockLevel6_2110 0x1C4
+
+  FriBidiPropertyBlockLevel7_0044,  /* 2110..2113 */
+  FriBidiPropertyBlockLevel7_00B4,  /* 2114..2117 */
+  FriBidiPropertyBlockLevel7_0040,  /* 2118..211B */
+  FriBidiPropertyBlockLevel7_02C0,  /* 211C..211F */
+
+#define FriBidiPropertyBlockLevel6_2120 0x1C8
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2120..2123 */
+  FriBidiPropertyBlockLevel7_1FBC,  /* 2124..2127 */
+  FriBidiPropertyBlockLevel7_2128,  /* 2128..212B */
+  FriBidiPropertyBlockLevel7_212C,  /* 212C..212F */
+
+#define FriBidiPropertyBlockLevel6_2130 0x1CC
+
+  FriBidiPropertyBlockLevel7_0044,  /* 2130..2133 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2134..2137 */
+  FriBidiPropertyBlockLevel7_02C0,  /* 2138..213B */
+  FriBidiPropertyBlockLevel7_0044,  /* 213C..213F */
+
+#define FriBidiPropertyBlockLevel6_2140 0x1D0
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2140..2143 */
+  FriBidiPropertyBlockLevel7_0040,  /* 2144..2147 */
+  FriBidiPropertyBlockLevel7_02C0,  /* 2148..214B */
+  FriBidiPropertyBlockLevel7_0374,  /* 214C..214F */
+
+#define FriBidiPropertyBlockLevel6_2150 0x1D4
+
+  FriBidiPropertyBlockLevel7_0058,  /* 2150..2153 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2154..2157 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2158..215B */
+  FriBidiPropertyBlockLevel7_003C,  /* 215C..215F */
+
+#define FriBidiPropertyBlockLevel6_2210 0x1D8
+
+  FriBidiPropertyBlockLevel7_2210,  /* 2210..2213 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2214..2217 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2218..221B */
+  FriBidiPropertyBlockLevel7_003C,  /* 221C..221F */
+
+#define FriBidiPropertyBlockLevel6_2330 0x1DC
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2330..2333 */
+  FriBidiPropertyBlockLevel7_0374,  /* 2334..2337 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2338..233B */
+  FriBidiPropertyBlockLevel7_0044,  /* 233C..233F */
+
+#define FriBidiPropertyBlockLevel6_2390 0x1E0
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2390..2393 */
+  FriBidiPropertyBlockLevel7_00B4,  /* 2394..2397 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2398..239B */
+  FriBidiPropertyBlockLevel7_003C,  /* 239C..239F */
+
+#define FriBidiPropertyBlockLevel6_23E0 0x1E4
+
+  FriBidiPropertyBlockLevel7_003C,  /* 23E0..23E3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 23E4..23E7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 23E8..23EB */
+  FriBidiPropertyBlockLevel7_0044,  /* 23EC..23EF */
+
+#define FriBidiPropertyBlockLevel6_2420 0x1E8
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2420..2423 */
+  FriBidiPropertyBlockLevel7_207C,  /* 2424..2427 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2428..242B */
+  FriBidiPropertyBlockLevel7_0044,  /* 242C..242F */
+
+#define FriBidiPropertyBlockLevel6_2440 0x1EC
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2440..2443 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2444..2447 */
+  FriBidiPropertyBlockLevel7_207C,  /* 2448..244B */
+  FriBidiPropertyBlockLevel7_0044,  /* 244C..244F */
+
+#define FriBidiPropertyBlockLevel6_2480 0x1F0
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2480..2483 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2484..2487 */
+  FriBidiPropertyBlockLevel7_0030,  /* 2488..248B */
+  FriBidiPropertyBlockLevel7_0030,  /* 248C..248F */
+
+#define FriBidiPropertyBlockLevel6_2490 0x1F4
+
+  FriBidiPropertyBlockLevel7_0030,  /* 2490..2493 */
+  FriBidiPropertyBlockLevel7_0030,  /* 2494..2497 */
+  FriBidiPropertyBlockLevel7_0030,  /* 2498..249B */
+  FriBidiPropertyBlockLevel7_0044,  /* 249C..249F */
+
+#define FriBidiPropertyBlockLevel6_24E0 0x1F8
+
+  FriBidiPropertyBlockLevel7_0044,  /* 24E0..24E3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 24E4..24E7 */
+  FriBidiPropertyBlockLevel7_02C0,  /* 24E8..24EB */
+  FriBidiPropertyBlockLevel7_003C,  /* 24EC..24EF */
+
+#define FriBidiPropertyBlockLevel6_2690 0x1FC
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2690..2693 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2694..2697 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2698..269B */
+  FriBidiPropertyBlockLevel7_0040,  /* 269C..269F */
+
+#define FriBidiPropertyBlockLevel6_26A0 0x200
+
+  FriBidiPropertyBlockLevel7_003C,  /* 26A0..26A3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 26A4..26A7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 26A8..26AB */
+  FriBidiPropertyBlockLevel7_02E4,  /* 26AC..26AF */
+
+#define FriBidiPropertyBlockLevel6_26B0 0x204
+
+  FriBidiPropertyBlockLevel7_207C,  /* 26B0..26B3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 26B4..26B7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 26B8..26BB */
+  FriBidiPropertyBlockLevel7_0044,  /* 26BC..26BF */
+
+#define FriBidiPropertyBlockLevel6_2700 0x208
+
+  FriBidiPropertyBlockLevel7_02E4,  /* 2700..2703 */
+  FriBidiPropertyBlockLevel7_00B4,  /* 2704..2707 */
+  FriBidiPropertyBlockLevel7_0374,  /* 2708..270B */
+  FriBidiPropertyBlockLevel7_003C,  /* 270C..270F */
+
+#define FriBidiPropertyBlockLevel6_2720 0x20C
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2720..2723 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2724..2727 */
+  FriBidiPropertyBlockLevel7_02E4,  /* 2728..272B */
+  FriBidiPropertyBlockLevel7_003C,  /* 272C..272F */
+
+#define FriBidiPropertyBlockLevel6_2740 0x210
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2740..2743 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2744..2747 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2748..274B */
+  FriBidiPropertyBlockLevel7_1FBC,  /* 274C..274F */
+
+#define FriBidiPropertyBlockLevel6_2750 0x214
+
+  FriBidiPropertyBlockLevel7_207C,  /* 2750..2753 */
+  FriBidiPropertyBlockLevel7_037C,  /* 2754..2757 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2758..275B */
+  FriBidiPropertyBlockLevel7_207C,  /* 275C..275F */
+
+#define FriBidiPropertyBlockLevel6_2760 0x218
+
+  FriBidiPropertyBlockLevel7_02E4,  /* 2760..2763 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2764..2767 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2768..276B */
+  FriBidiPropertyBlockLevel7_003C,  /* 276C..276F */
+
+#define FriBidiPropertyBlockLevel6_2790 0x21C
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2790..2793 */
+  FriBidiPropertyBlockLevel7_0040,  /* 2794..2797 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2798..279B */
+  FriBidiPropertyBlockLevel7_003C,  /* 279C..279F */
+
+#define FriBidiPropertyBlockLevel6_27B0 0x220
+
+  FriBidiPropertyBlockLevel7_02E4,  /* 27B0..27B3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 27B4..27B7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 27B8..27BB */
+  FriBidiPropertyBlockLevel7_207C,  /* 27BC..27BF */
+
+#define FriBidiPropertyBlockLevel6_27E0 0x224
+
+  FriBidiPropertyBlockLevel7_003C,  /* 27E0..27E3 */
+  FriBidiPropertyBlockLevel7_003C,  /* 27E4..27E7 */
+  FriBidiPropertyBlockLevel7_003C,  /* 27E8..27EB */
+  FriBidiPropertyBlockLevel7_0044,  /* 27EC..27EF */
+
+#define FriBidiPropertyBlockLevel6_2B20 0x228
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2B20..2B23 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2B24..2B27 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2B28..2B2B */
+  FriBidiPropertyBlockLevel7_0044,  /* 2B2C..2B2F */
+
+#define FriBidiPropertyBlockLevel6_2CE0 0x22C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 2CE0..2CE3 */
+  FriBidiPropertyBlockLevel7_02E4,  /* 2CE4..2CE7 */
+  FriBidiPropertyBlockLevel7_207C,  /* 2CE8..2CEB */
+  FriBidiPropertyBlockLevel7_0044,  /* 2CEC..2CEF */
+
+#define FriBidiPropertyBlockLevel6_2CF0 0x230
+
+  FriBidiPropertyBlockLevel7_0044,  /* 2CF0..2CF3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2CF4..2CF7 */
+  FriBidiPropertyBlockLevel7_02E4,  /* 2CF8..2CFB */
+  FriBidiPropertyBlockLevel7_003C,  /* 2CFC..2CFF */
+
+#define FriBidiPropertyBlockLevel6_2E10 0x234
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2E10..2E13 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2E14..2E17 */
+  FriBidiPropertyBlockLevel7_0044,  /* 2E18..2E1B */
+  FriBidiPropertyBlockLevel7_0374,  /* 2E1C..2E1F */
+
+#define FriBidiPropertyBlockLevel6_2E90 0x238
+
+  FriBidiPropertyBlockLevel7_003C,  /* 2E90..2E93 */
+  FriBidiPropertyBlockLevel7_003C,  /* 2E94..2E97 */
+  FriBidiPropertyBlockLevel7_00A8,  /* 2E98..2E9B */
+  FriBidiPropertyBlockLevel7_003C,  /* 2E9C..2E9F */
+
+#define FriBidiPropertyBlockLevel6_3000 0x23C
+
+  FriBidiPropertyBlockLevel7_3000,  /* 3000..3003 */
+  FriBidiPropertyBlockLevel7_0040,  /* 3004..3007 */
+  FriBidiPropertyBlockLevel7_003C,  /* 3008..300B */
+  FriBidiPropertyBlockLevel7_003C,  /* 300C..300F */
+
+#define FriBidiPropertyBlockLevel6_3020 0x240
+
+  FriBidiPropertyBlockLevel7_0040,  /* 3020..3023 */
+  FriBidiPropertyBlockLevel7_0044,  /* 3024..3027 */
+  FriBidiPropertyBlockLevel7_0960,  /* 3028..302B */
+  FriBidiPropertyBlockLevel7_0300,  /* 302C..302F */
+
+#define FriBidiPropertyBlockLevel6_3030 0x244
+
+  FriBidiPropertyBlockLevel7_0040,  /* 3030..3033 */
+  FriBidiPropertyBlockLevel7_02C0,  /* 3034..3037 */
+  FriBidiPropertyBlockLevel7_0044,  /* 3038..303B */
+  FriBidiPropertyBlockLevel7_02E4,  /* 303C..303F */
+
+#define FriBidiPropertyBlockLevel6_3090 0x248
+
+  FriBidiPropertyBlockLevel7_0044,  /* 3090..3093 */
+  FriBidiPropertyBlockLevel7_0044,  /* 3094..3097 */
+  FriBidiPropertyBlockLevel7_3098,  /* 3098..309B */
+  FriBidiPropertyBlockLevel7_0040,  /* 309C..309F */
+
+#define FriBidiPropertyBlockLevel6_30F0 0x24C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 30F0..30F3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 30F4..30F7 */
+  FriBidiPropertyBlockLevel7_0058,  /* 30F8..30FB */
+  FriBidiPropertyBlockLevel7_0044,  /* 30FC..30FF */
+
+#define FriBidiPropertyBlockLevel6_3270 0x250
+
+  FriBidiPropertyBlockLevel7_0044,  /* 3270..3273 */
+  FriBidiPropertyBlockLevel7_0044,  /* 3274..3277 */
+  FriBidiPropertyBlockLevel7_0044,  /* 3278..327B */
+  FriBidiPropertyBlockLevel7_207C,  /* 327C..327F */
+
+#define FriBidiPropertyBlockLevel6_32C0 0x254
+
+  FriBidiPropertyBlockLevel7_0044,  /* 32C0..32C3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 32C4..32C7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 32C8..32CB */
+  FriBidiPropertyBlockLevel7_003C,  /* 32CC..32CF */
+
+#define FriBidiPropertyBlockLevel6_3370 0x258
+
+  FriBidiPropertyBlockLevel7_0044,  /* 3370..3373 */
+  FriBidiPropertyBlockLevel7_0058,  /* 3374..3377 */
+  FriBidiPropertyBlockLevel7_207C,  /* 3378..337B */
+  FriBidiPropertyBlockLevel7_0044,  /* 337C..337F */
+
+#define FriBidiPropertyBlockLevel6_33F0 0x25C
+
+  FriBidiPropertyBlockLevel7_0044,  /* 33F0..33F3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 33F4..33F7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 33F8..33FB */
+  FriBidiPropertyBlockLevel7_0058,  /* 33FC..33FF */
+
+#define FriBidiPropertyBlockLevel6_A720 0x260
+
+  FriBidiPropertyBlockLevel7_0374,  /* A720..A723 */
+  FriBidiPropertyBlockLevel7_0044,  /* A724..A727 */
+  FriBidiPropertyBlockLevel7_0044,  /* A728..A72B */
+  FriBidiPropertyBlockLevel7_0044,  /* A72C..A72F */
+
+#define FriBidiPropertyBlockLevel6_A800 0x264
+
+  FriBidiPropertyBlockLevel7_0B54,  /* A800..A803 */
+  FriBidiPropertyBlockLevel7_0B54,  /* A804..A807 */
+  FriBidiPropertyBlockLevel7_0480,  /* A808..A80B */
+  FriBidiPropertyBlockLevel7_0044,  /* A80C..A80F */
+
+#define FriBidiPropertyBlockLevel6_A820 0x268
+
+  FriBidiPropertyBlockLevel7_0044,  /* A820..A823 */
+  FriBidiPropertyBlockLevel7_0900,  /* A824..A827 */
+  FriBidiPropertyBlockLevel7_003C,  /* A828..A82B */
+  FriBidiPropertyBlockLevel7_0044,  /* A82C..A82F */
+
+#define FriBidiPropertyBlockLevel6_A870 0x26C
+
+  FriBidiPropertyBlockLevel7_0044,  /* A870..A873 */
+  FriBidiPropertyBlockLevel7_003C,  /* A874..A877 */
+  FriBidiPropertyBlockLevel7_0044,  /* A878..A87B */
+  FriBidiPropertyBlockLevel7_0044,  /* A87C..A87F */
+
+#define FriBidiPropertyBlockLevel6_FB10 0x270
+
+  FriBidiPropertyBlockLevel7_0044,  /* FB10..FB13 */
+  FriBidiPropertyBlockLevel7_0044,  /* FB14..FB17 */
+  FriBidiPropertyBlockLevel7_0044,  /* FB18..FB1B */
+  FriBidiPropertyBlockLevel7_FB1C,  /* FB1C..FB1F */
+
+#define FriBidiPropertyBlockLevel6_FB20 0x274
+
+  FriBidiPropertyBlockLevel7_05C8,  /* FB20..FB23 */
+  FriBidiPropertyBlockLevel7_05C8,  /* FB24..FB27 */
+  FriBidiPropertyBlockLevel7_FB28,  /* FB28..FB2B */
+  FriBidiPropertyBlockLevel7_05C8,  /* FB2C..FB2F */
+
+#define FriBidiPropertyBlockLevel6_FD30 0x278
+
+  FriBidiPropertyBlockLevel7_0600,  /* FD30..FD33 */
+  FriBidiPropertyBlockLevel7_0600,  /* FD34..FD37 */
+  FriBidiPropertyBlockLevel7_0600,  /* FD38..FD3B */
+  FriBidiPropertyBlockLevel7_FD3C,  /* FD3C..FD3F */
+
+#define FriBidiPropertyBlockLevel6_FDF0 0x27C
+
+  FriBidiPropertyBlockLevel7_0600,  /* FDF0..FDF3 */
+  FriBidiPropertyBlockLevel7_0600,  /* FDF4..FDF7 */
+  FriBidiPropertyBlockLevel7_0600,  /* FDF8..FDFB */
+  FriBidiPropertyBlockLevel7_FDFC,  /* FDFC..FDFF */
+
+#define FriBidiPropertyBlockLevel6_FE50 0x280
+
+  FriBidiPropertyBlockLevel7_FE50,  /* FE50..FE53 */
+  FriBidiPropertyBlockLevel7_FE54,  /* FE54..FE57 */
+  FriBidiPropertyBlockLevel7_003C,  /* FE58..FE5B */
+  FriBidiPropertyBlockLevel7_FE5C,  /* FE5C..FE5F */
+
+#define FriBidiPropertyBlockLevel6_FE60 0x284
+
+  FriBidiPropertyBlockLevel7_FE60,  /* FE60..FE63 */
+  FriBidiPropertyBlockLevel7_207C,  /* FE64..FE67 */
+  FriBidiPropertyBlockLevel7_FE68,  /* FE68..FE6B */
+  FriBidiPropertyBlockLevel7_0044,  /* FE6C..FE6F */
+
+#define FriBidiPropertyBlockLevel6_FF00 0x288
+
+  FriBidiPropertyBlockLevel7_FF00,  /* FF00..FF03 */
+  FriBidiPropertyBlockLevel7_0024,  /* FF04..FF07 */
+  FriBidiPropertyBlockLevel7_0028,  /* FF08..FF0B */
+  FriBidiPropertyBlockLevel7_002C,  /* FF0C..FF0F */
+
+#define FriBidiPropertyBlockLevel6_FFE0 0x28C
+
+  FriBidiPropertyBlockLevel7_0024,  /* FFE0..FFE3 */
+  FriBidiPropertyBlockLevel7_FFE4,  /* FFE4..FFE7 */
+  FriBidiPropertyBlockLevel7_003C,  /* FFE8..FFEB */
+  FriBidiPropertyBlockLevel7_207C,  /* FFEC..FFEF */
+
+#define FriBidiPropertyBlockLevel6_FFF0 0x290
+
+  FriBidiPropertyBlockLevel7_0000,  /* FFF0..FFF3 */
+  FriBidiPropertyBlockLevel7_0000,  /* FFF4..FFF7 */
+  FriBidiPropertyBlockLevel7_FFF8,  /* FFF8..FFFB */
+  FriBidiPropertyBlockLevel7_FFFC,  /* FFFC..FFFF */
+
+#define FriBidiPropertyBlockLevel6_10100 0x294
+
+  FriBidiPropertyBlockLevel7_2128,  /* 10100..10103 */
+  FriBidiPropertyBlockLevel7_0044,  /* 10104..10107 */
+  FriBidiPropertyBlockLevel7_0044,  /* 10108..1010B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1010C..1010F */
+
+#define FriBidiPropertyBlockLevel6_10910 0x298
+
+  FriBidiPropertyBlockLevel7_05C8,  /* 10910..10913 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 10914..10917 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 10918..1091B */
+  FriBidiPropertyBlockLevel7_1091C,  /* 1091C..1091F */
+
+#define FriBidiPropertyBlockLevel6_10A00 0x29C
+
+  FriBidiPropertyBlockLevel7_0590,  /* 10A00..10A03 */
+  FriBidiPropertyBlockLevel7_05C0,  /* 10A04..10A07 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 10A08..10A0B */
+  FriBidiPropertyBlockLevel7_0300,  /* 10A0C..10A0F */
+
+#define FriBidiPropertyBlockLevel6_10A30 0x2A0
+
+  FriBidiPropertyBlockLevel7_05C8,  /* 10A30..10A33 */
+  FriBidiPropertyBlockLevel7_05C8,  /* 10A34..10A37 */
+  FriBidiPropertyBlockLevel7_10A38,  /* 10A38..10A3B */
+  FriBidiPropertyBlockLevel7_07E8,  /* 10A3C..10A3F */
+
+#define FriBidiPropertyBlockLevel6_1D160 0x2A4
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1D160..1D163 */
+  FriBidiPropertyBlockLevel7_0480,  /* 1D164..1D167 */
+  FriBidiPropertyBlockLevel7_0488,  /* 1D168..1D16B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D16C..1D16F */
+
+#define FriBidiPropertyBlockLevel6_1D170 0x2A8
+
+  FriBidiPropertyBlockLevel7_1D170,  /* 1D170..1D173 */
+  FriBidiPropertyBlockLevel7_0000,  /* 1D174..1D177 */
+  FriBidiPropertyBlockLevel7_1D178,  /* 1D178..1D17B */
+  FriBidiPropertyBlockLevel7_0300,  /* 1D17C..1D17F */
+
+#define FriBidiPropertyBlockLevel6_1D180 0x2AC
+
+  FriBidiPropertyBlockLevel7_0484,  /* 1D180..1D183 */
+  FriBidiPropertyBlockLevel7_0940,  /* 1D184..1D187 */
+  FriBidiPropertyBlockLevel7_0300,  /* 1D188..1D18B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D18C..1D18F */
+
+#define FriBidiPropertyBlockLevel6_1D1A0 0x2B0
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1D1A0..1D1A3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D1A4..1D1A7 */
+  FriBidiPropertyBlockLevel7_0960,  /* 1D1A8..1D1AB */
+  FriBidiPropertyBlockLevel7_0488,  /* 1D1AC..1D1AF */
+
+#define FriBidiPropertyBlockLevel6_1D240 0x2B4
+
+  FriBidiPropertyBlockLevel7_1D240,  /* 1D240..1D243 */
+  FriBidiPropertyBlockLevel7_1D244,  /* 1D244..1D247 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D248..1D24B */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D24C..1D24F */
+
+#define FriBidiPropertyBlockLevel6_1D7C0 0x2B8
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1D7C0..1D7C3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D7C4..1D7C7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1D7C8..1D7CB */
+  FriBidiPropertyBlockLevel7_1D7CC,  /* 1D7CC..1D7CF */
+
+#define FriBidiPropertyBlockLevel6_1D7D0 0x2BC
+
+  FriBidiPropertyBlockLevel7_0030,  /* 1D7D0..1D7D3 */
+  FriBidiPropertyBlockLevel7_0030,  /* 1D7D4..1D7D7 */
+  FriBidiPropertyBlockLevel7_0030,  /* 1D7D8..1D7DB */
+  FriBidiPropertyBlockLevel7_0030,  /* 1D7DC..1D7DF */
+
+#define FriBidiPropertyBlockLevel6_1FFF0 0x2C0
+
+  FriBidiPropertyBlockLevel7_0044,  /* 1FFF0..1FFF3 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FFF4..1FFF7 */
+  FriBidiPropertyBlockLevel7_0044,  /* 1FFF8..1FFFB */
+  FriBidiPropertyBlockLevel7_1FFFC,  /* 1FFFC..1FFFF */
+};
+
+static const PACKTAB_UINT16 FriBidiPropertyBlockLevel5[4*131] = {
+
+#define FriBidiPropertyBlockLevel5_0000 0x0
+
+  FriBidiPropertyBlockLevel6_0000,  /* 0000..000F */
+  FriBidiPropertyBlockLevel6_0010,  /* 0010..001F */
+  FriBidiPropertyBlockLevel6_0020,  /* 0020..002F */
+  FriBidiPropertyBlockLevel6_0030,  /* 0030..003F */
+
+#define FriBidiPropertyBlockLevel5_0040 0x4
+
+  FriBidiPropertyBlockLevel6_0040,  /* 0040..004F */
+  FriBidiPropertyBlockLevel6_0050,  /* 0050..005F */
+  FriBidiPropertyBlockLevel6_0040,  /* 0060..006F */
+  FriBidiPropertyBlockLevel6_0070,  /* 0070..007F */
+
+#define FriBidiPropertyBlockLevel5_0080 0x8
+
+  FriBidiPropertyBlockLevel6_0080,  /* 0080..008F */
+  FriBidiPropertyBlockLevel6_0090,  /* 0090..009F */
+  FriBidiPropertyBlockLevel6_00A0,  /* 00A0..00AF */
+  FriBidiPropertyBlockLevel6_00B0,  /* 00B0..00BF */
+
+#define FriBidiPropertyBlockLevel5_00C0 0xC
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 00C0..00CF */
+  FriBidiPropertyBlockLevel6_00D0,  /* 00D0..00DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 00E0..00EF */
+  FriBidiPropertyBlockLevel6_00D0,  /* 00F0..00FF */
+
+#define FriBidiPropertyBlockLevel5_0100 0x10
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0100..010F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0110..011F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0120..012F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0130..013F */
+
+#define FriBidiPropertyBlockLevel5_0280 0x14
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0280..028F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0290..029F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 02A0..02AF */
+  FriBidiPropertyBlockLevel6_02B0,  /* 02B0..02BF */
+
+#define FriBidiPropertyBlockLevel5_02C0 0x18
+
+  FriBidiPropertyBlockLevel6_02C0,  /* 02C0..02CF */
+  FriBidiPropertyBlockLevel6_02C0,  /* 02D0..02DF */
+  FriBidiPropertyBlockLevel6_02E0,  /* 02E0..02EF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 02F0..02FF */
+
+#define FriBidiPropertyBlockLevel5_0300 0x1C
+
+  FriBidiPropertyBlockLevel6_0300,  /* 0300..030F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0310..031F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0320..032F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0330..033F */
+
+#define FriBidiPropertyBlockLevel5_0340 0x20
+
+  FriBidiPropertyBlockLevel6_0300,  /* 0340..034F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0350..035F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0360..036F */
+  FriBidiPropertyBlockLevel6_0370,  /* 0370..037F */
+
+#define FriBidiPropertyBlockLevel5_0380 0x24
+
+  FriBidiPropertyBlockLevel6_0380,  /* 0380..038F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0390..039F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 03A0..03AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 03B0..03BF */
+
+#define FriBidiPropertyBlockLevel5_03C0 0x28
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 03C0..03CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 03D0..03DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 03E0..03EF */
+  FriBidiPropertyBlockLevel6_03F0,  /* 03F0..03FF */
+
+#define FriBidiPropertyBlockLevel5_0480 0x2C
+
+  FriBidiPropertyBlockLevel6_0480,  /* 0480..048F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0490..049F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 04A0..04AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 04B0..04BF */
+
+#define FriBidiPropertyBlockLevel5_0580 0x30
+
+  FriBidiPropertyBlockLevel6_0580,  /* 0580..058F */
+  FriBidiPropertyBlockLevel6_0590,  /* 0590..059F */
+  FriBidiPropertyBlockLevel6_0300,  /* 05A0..05AF */
+  FriBidiPropertyBlockLevel6_05B0,  /* 05B0..05BF */
+
+#define FriBidiPropertyBlockLevel5_05C0 0x34
+
+  FriBidiPropertyBlockLevel6_05C0,  /* 05C0..05CF */
+  FriBidiPropertyBlockLevel6_05D0,  /* 05D0..05DF */
+  FriBidiPropertyBlockLevel6_05D0,  /* 05E0..05EF */
+  FriBidiPropertyBlockLevel6_05D0,  /* 05F0..05FF */
+
+#define FriBidiPropertyBlockLevel5_0600 0x38
+
+  FriBidiPropertyBlockLevel6_0600,  /* 0600..060F */
+  FriBidiPropertyBlockLevel6_0610,  /* 0610..061F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0620..062F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0630..063F */
+
+#define FriBidiPropertyBlockLevel5_0640 0x3C
+
+  FriBidiPropertyBlockLevel6_0640,  /* 0640..064F */
+  FriBidiPropertyBlockLevel6_0650,  /* 0650..065F */
+  FriBidiPropertyBlockLevel6_0660,  /* 0660..066F */
+  FriBidiPropertyBlockLevel6_0670,  /* 0670..067F */
+
+#define FriBidiPropertyBlockLevel5_0680 0x40
+
+  FriBidiPropertyBlockLevel6_0620,  /* 0680..068F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0690..069F */
+  FriBidiPropertyBlockLevel6_0620,  /* 06A0..06AF */
+  FriBidiPropertyBlockLevel6_0620,  /* 06B0..06BF */
+
+#define FriBidiPropertyBlockLevel5_06C0 0x44
+
+  FriBidiPropertyBlockLevel6_0620,  /* 06C0..06CF */
+  FriBidiPropertyBlockLevel6_06D0,  /* 06D0..06DF */
+  FriBidiPropertyBlockLevel6_06E0,  /* 06E0..06EF */
+  FriBidiPropertyBlockLevel6_06F0,  /* 06F0..06FF */
+
+#define FriBidiPropertyBlockLevel5_0700 0x48
+
+  FriBidiPropertyBlockLevel6_0700,  /* 0700..070F */
+  FriBidiPropertyBlockLevel6_0710,  /* 0710..071F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0720..072F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0730..073F */
+
+#define FriBidiPropertyBlockLevel5_0740 0x4C
+
+  FriBidiPropertyBlockLevel6_0740,  /* 0740..074F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0750..075F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0760..076F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0770..077F */
+
+#define FriBidiPropertyBlockLevel5_0780 0x50
+
+  FriBidiPropertyBlockLevel6_0620,  /* 0780..078F */
+  FriBidiPropertyBlockLevel6_0620,  /* 0790..079F */
+  FriBidiPropertyBlockLevel6_07A0,  /* 07A0..07AF */
+  FriBidiPropertyBlockLevel6_0670,  /* 07B0..07BF */
+
+#define FriBidiPropertyBlockLevel5_07C0 0x54
+
+  FriBidiPropertyBlockLevel6_05D0,  /* 07C0..07CF */
+  FriBidiPropertyBlockLevel6_05D0,  /* 07D0..07DF */
+  FriBidiPropertyBlockLevel6_07E0,  /* 07E0..07EF */
+  FriBidiPropertyBlockLevel6_07F0,  /* 07F0..07FF */
+
+#define FriBidiPropertyBlockLevel5_0800 0x58
+
+  FriBidiPropertyBlockLevel6_05D0,  /* 0800..080F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 0810..081F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 0820..082F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 0830..083F */
+
+#define FriBidiPropertyBlockLevel5_0900 0x5C
+
+  FriBidiPropertyBlockLevel6_0900,  /* 0900..090F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0910..091F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0920..092F */
+  FriBidiPropertyBlockLevel6_0930,  /* 0930..093F */
+
+#define FriBidiPropertyBlockLevel5_0940 0x60
+
+  FriBidiPropertyBlockLevel6_0940,  /* 0940..094F */
+  FriBidiPropertyBlockLevel6_0950,  /* 0950..095F */
+  FriBidiPropertyBlockLevel6_0960,  /* 0960..096F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0970..097F */
+
+#define FriBidiPropertyBlockLevel5_0980 0x64
+
+  FriBidiPropertyBlockLevel6_0980,  /* 0980..098F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0990..099F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 09A0..09AF */
+  FriBidiPropertyBlockLevel6_0930,  /* 09B0..09BF */
+
+#define FriBidiPropertyBlockLevel5_09C0 0x68
+
+  FriBidiPropertyBlockLevel6_09C0,  /* 09C0..09CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 09D0..09DF */
+  FriBidiPropertyBlockLevel6_0960,  /* 09E0..09EF */
+  FriBidiPropertyBlockLevel6_09F0,  /* 09F0..09FF */
+
+#define FriBidiPropertyBlockLevel5_0A40 0x6C
+
+  FriBidiPropertyBlockLevel6_0A40,  /* 0A40..0A4F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0A50..0A5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0A60..0A6F */
+  FriBidiPropertyBlockLevel6_0A70,  /* 0A70..0A7F */
+
+#define FriBidiPropertyBlockLevel5_0AC0 0x70
+
+  FriBidiPropertyBlockLevel6_0AC0,  /* 0AC0..0ACF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0AD0..0ADF */
+  FriBidiPropertyBlockLevel6_0960,  /* 0AE0..0AEF */
+  FriBidiPropertyBlockLevel6_0AF0,  /* 0AF0..0AFF */
+
+#define FriBidiPropertyBlockLevel5_0B00 0x74
+
+  FriBidiPropertyBlockLevel6_0980,  /* 0B00..0B0F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0B10..0B1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0B20..0B2F */
+  FriBidiPropertyBlockLevel6_0B30,  /* 0B30..0B3F */
+
+#define FriBidiPropertyBlockLevel5_0B40 0x78
+
+  FriBidiPropertyBlockLevel6_0B40,  /* 0B40..0B4F */
+  FriBidiPropertyBlockLevel6_0B50,  /* 0B50..0B5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0B60..0B6F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0B70..0B7F */
+
+#define FriBidiPropertyBlockLevel5_0B80 0x7C
+
+  FriBidiPropertyBlockLevel6_0B80,  /* 0B80..0B8F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0B90..0B9F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0BA0..0BAF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0BB0..0BBF */
+
+#define FriBidiPropertyBlockLevel5_0BC0 0x80
+
+  FriBidiPropertyBlockLevel6_0BC0,  /* 0BC0..0BCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0BD0..0BDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0BE0..0BEF */
+  FriBidiPropertyBlockLevel6_0BF0,  /* 0BF0..0BFF */
+
+#define FriBidiPropertyBlockLevel5_0C00 0x84
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C00..0C0F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C10..0C1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C20..0C2F */
+  FriBidiPropertyBlockLevel6_0C30,  /* 0C30..0C3F */
+
+#define FriBidiPropertyBlockLevel5_0C40 0x88
+
+  FriBidiPropertyBlockLevel6_0C40,  /* 0C40..0C4F */
+  FriBidiPropertyBlockLevel6_0C50,  /* 0C50..0C5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C60..0C6F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C70..0C7F */
+
+#define FriBidiPropertyBlockLevel5_0C80 0x8C
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C80..0C8F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0C90..0C9F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0CA0..0CAF */
+  FriBidiPropertyBlockLevel6_0930,  /* 0CB0..0CBF */
+
+#define FriBidiPropertyBlockLevel5_0CC0 0x90
+
+  FriBidiPropertyBlockLevel6_0CC0,  /* 0CC0..0CCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0CD0..0CDF */
+  FriBidiPropertyBlockLevel6_0960,  /* 0CE0..0CEF */
+  FriBidiPropertyBlockLevel6_0CF0,  /* 0CF0..0CFF */
+
+#define FriBidiPropertyBlockLevel5_0D40 0x94
+
+  FriBidiPropertyBlockLevel6_0B40,  /* 0D40..0D4F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0D50..0D5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0D60..0D6F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0D70..0D7F */
+
+#define FriBidiPropertyBlockLevel5_0DC0 0x98
+
+  FriBidiPropertyBlockLevel6_0DC0,  /* 0DC0..0DCF */
+  FriBidiPropertyBlockLevel6_0DD0,  /* 0DD0..0DDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0DE0..0DEF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0DF0..0DFF */
+
+#define FriBidiPropertyBlockLevel5_0E00 0x9C
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E00..0E0F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E10..0E1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E20..0E2F */
+  FriBidiPropertyBlockLevel6_0E30,  /* 0E30..0E3F */
+
+#define FriBidiPropertyBlockLevel5_0E40 0xA0
+
+  FriBidiPropertyBlockLevel6_0E40,  /* 0E40..0E4F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E50..0E5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E60..0E6F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E70..0E7F */
+
+#define FriBidiPropertyBlockLevel5_0E80 0xA4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E80..0E8F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0E90..0E9F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0EA0..0EAF */
+  FriBidiPropertyBlockLevel6_0EB0,  /* 0EB0..0EBF */
+
+#define FriBidiPropertyBlockLevel5_0EC0 0xA8
+
+  FriBidiPropertyBlockLevel6_0EC0,  /* 0EC0..0ECF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0ED0..0EDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0EE0..0EEF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0EF0..0EFF */
+
+#define FriBidiPropertyBlockLevel5_0F00 0xAC
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0F00..0F0F */
+  FriBidiPropertyBlockLevel6_0F10,  /* 0F10..0F1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0F20..0F2F */
+  FriBidiPropertyBlockLevel6_0F30,  /* 0F30..0F3F */
+
+#define FriBidiPropertyBlockLevel5_0F40 0xB0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 0F40..0F4F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0F50..0F5F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0F60..0F6F */
+  FriBidiPropertyBlockLevel6_0F70,  /* 0F70..0F7F */
+
+#define FriBidiPropertyBlockLevel5_0F80 0xB4
+
+  FriBidiPropertyBlockLevel6_0F80,  /* 0F80..0F8F */
+  FriBidiPropertyBlockLevel6_0F90,  /* 0F90..0F9F */
+  FriBidiPropertyBlockLevel6_0300,  /* 0FA0..0FAF */
+  FriBidiPropertyBlockLevel6_0FB0,  /* 0FB0..0FBF */
+
+#define FriBidiPropertyBlockLevel5_0FC0 0xB8
+
+  FriBidiPropertyBlockLevel6_0B50,  /* 0FC0..0FCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0FD0..0FDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0FE0..0FEF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 0FF0..0FFF */
+
+#define FriBidiPropertyBlockLevel5_1000 0xBC
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1000..100F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1010..101F */
+  FriBidiPropertyBlockLevel6_1020,  /* 1020..102F */
+  FriBidiPropertyBlockLevel6_1030,  /* 1030..103F */
+
+#define FriBidiPropertyBlockLevel5_1040 0xC0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1040..104F */
+  FriBidiPropertyBlockLevel6_0F10,  /* 1050..105F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1060..106F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1070..107F */
+
+#define FriBidiPropertyBlockLevel5_1340 0xC4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1340..134F */
+  FriBidiPropertyBlockLevel6_1350,  /* 1350..135F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1360..136F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1370..137F */
+
+#define FriBidiPropertyBlockLevel5_1380 0xC8
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1380..138F */
+  FriBidiPropertyBlockLevel6_1390,  /* 1390..139F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 13A0..13AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 13B0..13BF */
+
+#define FriBidiPropertyBlockLevel5_1680 0xCC
+
+  FriBidiPropertyBlockLevel6_1680,  /* 1680..168F */
+  FriBidiPropertyBlockLevel6_1690,  /* 1690..169F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 16A0..16AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 16B0..16BF */
+
+#define FriBidiPropertyBlockLevel5_1700 0xD0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1700..170F */
+  FriBidiPropertyBlockLevel6_1710,  /* 1710..171F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1720..172F */
+  FriBidiPropertyBlockLevel6_1710,  /* 1730..173F */
+
+#define FriBidiPropertyBlockLevel5_1740 0xD4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1740..174F */
+  FriBidiPropertyBlockLevel6_0960,  /* 1750..175F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1760..176F */
+  FriBidiPropertyBlockLevel6_0960,  /* 1770..177F */
+
+#define FriBidiPropertyBlockLevel5_1780 0xD8
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1780..178F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1790..179F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 17A0..17AF */
+  FriBidiPropertyBlockLevel6_17B0,  /* 17B0..17BF */
+
+#define FriBidiPropertyBlockLevel5_17C0 0xDC
+
+  FriBidiPropertyBlockLevel6_17C0,  /* 17C0..17CF */
+  FriBidiPropertyBlockLevel6_17D0,  /* 17D0..17DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 17E0..17EF */
+  FriBidiPropertyBlockLevel6_1390,  /* 17F0..17FF */
+
+#define FriBidiPropertyBlockLevel5_1800 0xE0
+
+  FriBidiPropertyBlockLevel6_1800,  /* 1800..180F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1810..181F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1820..182F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1830..183F */
+
+#define FriBidiPropertyBlockLevel5_1880 0xE4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1880..188F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1890..189F */
+  FriBidiPropertyBlockLevel6_18A0,  /* 18A0..18AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 18B0..18BF */
+
+#define FriBidiPropertyBlockLevel5_1900 0xE8
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1900..190F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1910..191F */
+  FriBidiPropertyBlockLevel6_1920,  /* 1920..192F */
+  FriBidiPropertyBlockLevel6_1930,  /* 1930..193F */
+
+#define FriBidiPropertyBlockLevel5_1940 0xEC
+
+  FriBidiPropertyBlockLevel6_1940,  /* 1940..194F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1950..195F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1960..196F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1970..197F */
+
+#define FriBidiPropertyBlockLevel5_19C0 0xF0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 19C0..19CF */
+  FriBidiPropertyBlockLevel6_19D0,  /* 19D0..19DF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 19E0..19EF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 19F0..19FF */
+
+#define FriBidiPropertyBlockLevel5_1A00 0xF4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1A00..1A0F */
+  FriBidiPropertyBlockLevel6_1A10,  /* 1A10..1A1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1A20..1A2F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1A30..1A3F */
+
+#define FriBidiPropertyBlockLevel5_1B00 0xF8
+
+  FriBidiPropertyBlockLevel6_1B00,  /* 1B00..1B0F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1B10..1B1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1B20..1B2F */
+  FriBidiPropertyBlockLevel6_1B30,  /* 1B30..1B3F */
+
+#define FriBidiPropertyBlockLevel5_1B40 0xFC
+
+  FriBidiPropertyBlockLevel6_0B80,  /* 1B40..1B4F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1B50..1B5F */
+  FriBidiPropertyBlockLevel6_1B60,  /* 1B60..1B6F */
+  FriBidiPropertyBlockLevel6_1B00,  /* 1B70..1B7F */
+
+#define FriBidiPropertyBlockLevel5_1DC0 0x100
+
+  FriBidiPropertyBlockLevel6_1DC0,  /* 1DC0..1DCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1DD0..1DDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1DE0..1DEF */
+  FriBidiPropertyBlockLevel6_0C30,  /* 1DF0..1DFF */
+
+#define FriBidiPropertyBlockLevel5_1F80 0x104
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1F80..1F8F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1F90..1F9F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1FA0..1FAF */
+  FriBidiPropertyBlockLevel6_1FB0,  /* 1FB0..1FBF */
+
+#define FriBidiPropertyBlockLevel5_1FC0 0x108
+
+  FriBidiPropertyBlockLevel6_1FC0,  /* 1FC0..1FCF */
+  FriBidiPropertyBlockLevel6_1FD0,  /* 1FD0..1FDF */
+  FriBidiPropertyBlockLevel6_1FD0,  /* 1FE0..1FEF */
+  FriBidiPropertyBlockLevel6_1FF0,  /* 1FF0..1FFF */
+
+#define FriBidiPropertyBlockLevel5_2000 0x10C
+
+  FriBidiPropertyBlockLevel6_2000,  /* 2000..200F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2010..201F */
+  FriBidiPropertyBlockLevel6_2020,  /* 2020..202F */
+  FriBidiPropertyBlockLevel6_2030,  /* 2030..203F */
+
+#define FriBidiPropertyBlockLevel5_2040 0x110
+
+  FriBidiPropertyBlockLevel6_2040,  /* 2040..204F */
+  FriBidiPropertyBlockLevel6_2050,  /* 2050..205F */
+  FriBidiPropertyBlockLevel6_0090,  /* 2060..206F */
+  FriBidiPropertyBlockLevel6_2070,  /* 2070..207F */
+
+#define FriBidiPropertyBlockLevel5_2080 0x114
+
+  FriBidiPropertyBlockLevel6_2080,  /* 2080..208F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2090..209F */
+  FriBidiPropertyBlockLevel6_20A0,  /* 20A0..20AF */
+  FriBidiPropertyBlockLevel6_20B0,  /* 20B0..20BF */
+
+#define FriBidiPropertyBlockLevel5_20C0 0x118
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 20C0..20CF */
+  FriBidiPropertyBlockLevel6_0300,  /* 20D0..20DF */
+  FriBidiPropertyBlockLevel6_0300,  /* 20E0..20EF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 20F0..20FF */
+
+#define FriBidiPropertyBlockLevel5_2100 0x11C
+
+  FriBidiPropertyBlockLevel6_2100,  /* 2100..210F */
+  FriBidiPropertyBlockLevel6_2110,  /* 2110..211F */
+  FriBidiPropertyBlockLevel6_2120,  /* 2120..212F */
+  FriBidiPropertyBlockLevel6_2130,  /* 2130..213F */
+
+#define FriBidiPropertyBlockLevel5_2140 0x120
+
+  FriBidiPropertyBlockLevel6_2140,  /* 2140..214F */
+  FriBidiPropertyBlockLevel6_2150,  /* 2150..215F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2160..216F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2170..217F */
+
+#define FriBidiPropertyBlockLevel5_2180 0x124
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 2180..218F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2190..219F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 21A0..21AF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 21B0..21BF */
+
+#define FriBidiPropertyBlockLevel5_21C0 0x128
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 21C0..21CF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 21D0..21DF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 21E0..21EF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 21F0..21FF */
+
+#define FriBidiPropertyBlockLevel5_2200 0x12C
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2200..220F */
+  FriBidiPropertyBlockLevel6_2210,  /* 2210..221F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2220..222F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2230..223F */
+
+#define FriBidiPropertyBlockLevel5_2300 0x130
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2300..230F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2310..231F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2320..232F */
+  FriBidiPropertyBlockLevel6_2330,  /* 2330..233F */
+
+#define FriBidiPropertyBlockLevel5_2340 0x134
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 2340..234F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2350..235F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2360..236F */
+  FriBidiPropertyBlockLevel6_0050,  /* 2370..237F */
+
+#define FriBidiPropertyBlockLevel5_2380 0x138
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2380..238F */
+  FriBidiPropertyBlockLevel6_2390,  /* 2390..239F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 23A0..23AF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 23B0..23BF */
+
+#define FriBidiPropertyBlockLevel5_23C0 0x13C
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 23C0..23CF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 23D0..23DF */
+  FriBidiPropertyBlockLevel6_23E0,  /* 23E0..23EF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 23F0..23FF */
+
+#define FriBidiPropertyBlockLevel5_2400 0x140
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2400..240F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2410..241F */
+  FriBidiPropertyBlockLevel6_2420,  /* 2420..242F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2430..243F */
+
+#define FriBidiPropertyBlockLevel5_2440 0x144
+
+  FriBidiPropertyBlockLevel6_2440,  /* 2440..244F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2450..245F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2460..246F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2470..247F */
+
+#define FriBidiPropertyBlockLevel5_2480 0x148
+
+  FriBidiPropertyBlockLevel6_2480,  /* 2480..248F */
+  FriBidiPropertyBlockLevel6_2490,  /* 2490..249F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 24A0..24AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 24B0..24BF */
+
+#define FriBidiPropertyBlockLevel5_24C0 0x14C
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 24C0..24CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 24D0..24DF */
+  FriBidiPropertyBlockLevel6_24E0,  /* 24E0..24EF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 24F0..24FF */
+
+#define FriBidiPropertyBlockLevel5_2680 0x150
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2680..268F */
+  FriBidiPropertyBlockLevel6_2690,  /* 2690..269F */
+  FriBidiPropertyBlockLevel6_26A0,  /* 26A0..26AF */
+  FriBidiPropertyBlockLevel6_26B0,  /* 26B0..26BF */
+
+#define FriBidiPropertyBlockLevel5_2700 0x154
+
+  FriBidiPropertyBlockLevel6_2700,  /* 2700..270F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2710..271F */
+  FriBidiPropertyBlockLevel6_2720,  /* 2720..272F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2730..273F */
+
+#define FriBidiPropertyBlockLevel5_2740 0x158
+
+  FriBidiPropertyBlockLevel6_2740,  /* 2740..274F */
+  FriBidiPropertyBlockLevel6_2750,  /* 2750..275F */
+  FriBidiPropertyBlockLevel6_2760,  /* 2760..276F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2770..277F */
+
+#define FriBidiPropertyBlockLevel5_2780 0x15C
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2780..278F */
+  FriBidiPropertyBlockLevel6_2790,  /* 2790..279F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 27A0..27AF */
+  FriBidiPropertyBlockLevel6_27B0,  /* 27B0..27BF */
+
+#define FriBidiPropertyBlockLevel5_27C0 0x160
+
+  FriBidiPropertyBlockLevel6_2440,  /* 27C0..27CF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 27D0..27DF */
+  FriBidiPropertyBlockLevel6_27E0,  /* 27E0..27EF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 27F0..27FF */
+
+#define FriBidiPropertyBlockLevel5_2B00 0x164
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2B00..2B0F */
+  FriBidiPropertyBlockLevel6_2440,  /* 2B10..2B1F */
+  FriBidiPropertyBlockLevel6_2B20,  /* 2B20..2B2F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2B30..2B3F */
+
+#define FriBidiPropertyBlockLevel5_2CC0 0x168
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 2CC0..2CCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2CD0..2CDF */
+  FriBidiPropertyBlockLevel6_2CE0,  /* 2CE0..2CEF */
+  FriBidiPropertyBlockLevel6_2CF0,  /* 2CF0..2CFF */
+
+#define FriBidiPropertyBlockLevel5_2E00 0x16C
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2E00..2E0F */
+  FriBidiPropertyBlockLevel6_2E10,  /* 2E10..2E1F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2E20..2E2F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2E30..2E3F */
+
+#define FriBidiPropertyBlockLevel5_2E80 0x170
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2E80..2E8F */
+  FriBidiPropertyBlockLevel6_2E90,  /* 2E90..2E9F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2EA0..2EAF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2EB0..2EBF */
+
+#define FriBidiPropertyBlockLevel5_2EC0 0x174
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2EC0..2ECF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2ED0..2EDF */
+  FriBidiPropertyBlockLevel6_02F0,  /* 2EE0..2EEF */
+  FriBidiPropertyBlockLevel6_2B20,  /* 2EF0..2EFF */
+
+#define FriBidiPropertyBlockLevel5_2FC0 0x178
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 2FC0..2FCF */
+  FriBidiPropertyBlockLevel6_2330,  /* 2FD0..2FDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 2FE0..2FEF */
+  FriBidiPropertyBlockLevel6_27E0,  /* 2FF0..2FFF */
+
+#define FriBidiPropertyBlockLevel5_3000 0x17C
+
+  FriBidiPropertyBlockLevel6_3000,  /* 3000..300F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 3010..301F */
+  FriBidiPropertyBlockLevel6_3020,  /* 3020..302F */
+  FriBidiPropertyBlockLevel6_3030,  /* 3030..303F */
+
+#define FriBidiPropertyBlockLevel5_3080 0x180
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 3080..308F */
+  FriBidiPropertyBlockLevel6_3090,  /* 3090..309F */
+  FriBidiPropertyBlockLevel6_0040,  /* 30A0..30AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 30B0..30BF */
+
+#define FriBidiPropertyBlockLevel5_30C0 0x184
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 30C0..30CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 30D0..30DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 30E0..30EF */
+  FriBidiPropertyBlockLevel6_30F0,  /* 30F0..30FF */
+
+#define FriBidiPropertyBlockLevel5_31C0 0x188
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 31C0..31CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 31D0..31DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 31E0..31EF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 31F0..31FF */
+
+#define FriBidiPropertyBlockLevel5_3200 0x18C
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 3200..320F */
+  FriBidiPropertyBlockLevel6_1FF0,  /* 3210..321F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3220..322F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3230..323F */
+
+#define FriBidiPropertyBlockLevel5_3240 0x190
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 3240..324F */
+  FriBidiPropertyBlockLevel6_02F0,  /* 3250..325F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3260..326F */
+  FriBidiPropertyBlockLevel6_3270,  /* 3270..327F */
+
+#define FriBidiPropertyBlockLevel5_3280 0x194
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 3280..328F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3290..329F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 32A0..32AF */
+  FriBidiPropertyBlockLevel6_2760,  /* 32B0..32BF */
+
+#define FriBidiPropertyBlockLevel5_32C0 0x198
+
+  FriBidiPropertyBlockLevel6_32C0,  /* 32C0..32CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 32D0..32DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 32E0..32EF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 32F0..32FF */
+
+#define FriBidiPropertyBlockLevel5_3340 0x19C
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 3340..334F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3350..335F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 3360..336F */
+  FriBidiPropertyBlockLevel6_3370,  /* 3370..337F */
+
+#define FriBidiPropertyBlockLevel5_33C0 0x1A0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 33C0..33CF */
+  FriBidiPropertyBlockLevel6_19D0,  /* 33D0..33DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 33E0..33EF */
+  FriBidiPropertyBlockLevel6_33F0,  /* 33F0..33FF */
+
+#define FriBidiPropertyBlockLevel5_A4C0 0x1A4
+
+  FriBidiPropertyBlockLevel6_2420,  /* A4C0..A4CF */
+  FriBidiPropertyBlockLevel6_00C0,  /* A4D0..A4DF */
+  FriBidiPropertyBlockLevel6_00C0,  /* A4E0..A4EF */
+  FriBidiPropertyBlockLevel6_00C0,  /* A4F0..A4FF */
+
+#define FriBidiPropertyBlockLevel5_A700 0x1A8
+
+  FriBidiPropertyBlockLevel6_02F0,  /* A700..A70F */
+  FriBidiPropertyBlockLevel6_2440,  /* A710..A71F */
+  FriBidiPropertyBlockLevel6_A720,  /* A720..A72F */
+  FriBidiPropertyBlockLevel6_00C0,  /* A730..A73F */
+
+#define FriBidiPropertyBlockLevel5_A800 0x1AC
+
+  FriBidiPropertyBlockLevel6_A800,  /* A800..A80F */
+  FriBidiPropertyBlockLevel6_00C0,  /* A810..A81F */
+  FriBidiPropertyBlockLevel6_A820,  /* A820..A82F */
+  FriBidiPropertyBlockLevel6_00C0,  /* A830..A83F */
+
+#define FriBidiPropertyBlockLevel5_A840 0x1B0
+
+  FriBidiPropertyBlockLevel6_00C0,  /* A840..A84F */
+  FriBidiPropertyBlockLevel6_00C0,  /* A850..A85F */
+  FriBidiPropertyBlockLevel6_00C0,  /* A860..A86F */
+  FriBidiPropertyBlockLevel6_A870,  /* A870..A87F */
+
+#define FriBidiPropertyBlockLevel5_FB00 0x1B4
+
+  FriBidiPropertyBlockLevel6_00C0,  /* FB00..FB0F */
+  FriBidiPropertyBlockLevel6_FB10,  /* FB10..FB1F */
+  FriBidiPropertyBlockLevel6_FB20,  /* FB20..FB2F */
+  FriBidiPropertyBlockLevel6_05D0,  /* FB30..FB3F */
+
+#define FriBidiPropertyBlockLevel5_FB40 0x1B8
+
+  FriBidiPropertyBlockLevel6_05D0,  /* FB40..FB4F */
+  FriBidiPropertyBlockLevel6_0620,  /* FB50..FB5F */
+  FriBidiPropertyBlockLevel6_0620,  /* FB60..FB6F */
+  FriBidiPropertyBlockLevel6_0620,  /* FB70..FB7F */
+
+#define FriBidiPropertyBlockLevel5_FD00 0x1BC
+
+  FriBidiPropertyBlockLevel6_0620,  /* FD00..FD0F */
+  FriBidiPropertyBlockLevel6_0620,  /* FD10..FD1F */
+  FriBidiPropertyBlockLevel6_0620,  /* FD20..FD2F */
+  FriBidiPropertyBlockLevel6_FD30,  /* FD30..FD3F */
+
+#define FriBidiPropertyBlockLevel5_FDC0 0x1C0
+
+  FriBidiPropertyBlockLevel6_0620,  /* FDC0..FDCF */
+  FriBidiPropertyBlockLevel6_0090,  /* FDD0..FDDF */
+  FriBidiPropertyBlockLevel6_0090,  /* FDE0..FDEF */
+  FriBidiPropertyBlockLevel6_FDF0,  /* FDF0..FDFF */
+
+#define FriBidiPropertyBlockLevel5_FE00 0x1C4
+
+  FriBidiPropertyBlockLevel6_0300,  /* FE00..FE0F */
+  FriBidiPropertyBlockLevel6_1390,  /* FE10..FE1F */
+  FriBidiPropertyBlockLevel6_1B00,  /* FE20..FE2F */
+  FriBidiPropertyBlockLevel6_02F0,  /* FE30..FE3F */
+
+#define FriBidiPropertyBlockLevel5_FE40 0x1C8
+
+  FriBidiPropertyBlockLevel6_02F0,  /* FE40..FE4F */
+  FriBidiPropertyBlockLevel6_FE50,  /* FE50..FE5F */
+  FriBidiPropertyBlockLevel6_FE60,  /* FE60..FE6F */
+  FriBidiPropertyBlockLevel6_0620,  /* FE70..FE7F */
+
+#define FriBidiPropertyBlockLevel5_FEC0 0x1CC
+
+  FriBidiPropertyBlockLevel6_0620,  /* FEC0..FECF */
+  FriBidiPropertyBlockLevel6_0620,  /* FED0..FEDF */
+  FriBidiPropertyBlockLevel6_0620,  /* FEE0..FEEF */
+  FriBidiPropertyBlockLevel6_0700,  /* FEF0..FEFF */
+
+#define FriBidiPropertyBlockLevel5_FF00 0x1D0
+
+  FriBidiPropertyBlockLevel6_FF00,  /* FF00..FF0F */
+  FriBidiPropertyBlockLevel6_0030,  /* FF10..FF1F */
+  FriBidiPropertyBlockLevel6_0040,  /* FF20..FF2F */
+  FriBidiPropertyBlockLevel6_0050,  /* FF30..FF3F */
+
+#define FriBidiPropertyBlockLevel5_FF40 0x1D4
+
+  FriBidiPropertyBlockLevel6_0040,  /* FF40..FF4F */
+  FriBidiPropertyBlockLevel6_0050,  /* FF50..FF5F */
+  FriBidiPropertyBlockLevel6_2330,  /* FF60..FF6F */
+  FriBidiPropertyBlockLevel6_00C0,  /* FF70..FF7F */
+
+#define FriBidiPropertyBlockLevel5_FFC0 0x1D8
+
+  FriBidiPropertyBlockLevel6_00C0,  /* FFC0..FFCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* FFD0..FFDF */
+  FriBidiPropertyBlockLevel6_FFE0,  /* FFE0..FFEF */
+  FriBidiPropertyBlockLevel6_FFF0,  /* FFF0..FFFF */
+
+#define FriBidiPropertyBlockLevel5_10100 0x1DC
+
+  FriBidiPropertyBlockLevel6_10100,  /* 10100..1010F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 10110..1011F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 10120..1012F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 10130..1013F */
+
+#define FriBidiPropertyBlockLevel5_10180 0x1E0
+
+  FriBidiPropertyBlockLevel6_2440,  /* 10180..1018F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 10190..1019F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 101A0..101AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 101B0..101BF */
+
+#define FriBidiPropertyBlockLevel5_10900 0x1E4
+
+  FriBidiPropertyBlockLevel6_05D0,  /* 10900..1090F */
+  FriBidiPropertyBlockLevel6_10910,  /* 10910..1091F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 10920..1092F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 10930..1093F */
+
+#define FriBidiPropertyBlockLevel5_10A00 0x1E8
+
+  FriBidiPropertyBlockLevel6_10A00,  /* 10A00..10A0F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 10A10..10A1F */
+  FriBidiPropertyBlockLevel6_05D0,  /* 10A20..10A2F */
+  FriBidiPropertyBlockLevel6_10A30,  /* 10A30..10A3F */
+
+#define FriBidiPropertyBlockLevel5_1D140 0x1EC
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D140..1D14F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D150..1D15F */
+  FriBidiPropertyBlockLevel6_1D160,  /* 1D160..1D16F */
+  FriBidiPropertyBlockLevel6_1D170,  /* 1D170..1D17F */
+
+#define FriBidiPropertyBlockLevel5_1D180 0x1F0
+
+  FriBidiPropertyBlockLevel6_1D180,  /* 1D180..1D18F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D190..1D19F */
+  FriBidiPropertyBlockLevel6_1D1A0,  /* 1D1A0..1D1AF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D1B0..1D1BF */
+
+#define FriBidiPropertyBlockLevel5_1D240 0x1F4
+
+  FriBidiPropertyBlockLevel6_1D240,  /* 1D240..1D24F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D250..1D25F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D260..1D26F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D270..1D27F */
+
+#define FriBidiPropertyBlockLevel5_1D340 0x1F8
+
+  FriBidiPropertyBlockLevel6_02F0,  /* 1D340..1D34F */
+  FriBidiPropertyBlockLevel6_2420,  /* 1D350..1D35F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D360..1D36F */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1D370..1D37F */
+
+#define FriBidiPropertyBlockLevel5_1D7C0 0x1FC
+
+  FriBidiPropertyBlockLevel6_1D7C0,  /* 1D7C0..1D7CF */
+  FriBidiPropertyBlockLevel6_1D7D0,  /* 1D7D0..1D7DF */
+  FriBidiPropertyBlockLevel6_1D7D0,  /* 1D7E0..1D7EF */
+  FriBidiPropertyBlockLevel6_1D7D0,  /* 1D7F0..1D7FF */
+
+#define FriBidiPropertyBlockLevel5_1FFC0 0x200
+
+  FriBidiPropertyBlockLevel6_00C0,  /* 1FFC0..1FFCF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1FFD0..1FFDF */
+  FriBidiPropertyBlockLevel6_00C0,  /* 1FFE0..1FFEF */
+  FriBidiPropertyBlockLevel6_1FFF0,  /* 1FFF0..1FFFF */
+
+#define FriBidiPropertyBlockLevel5_E0000 0x204
+
+  FriBidiPropertyBlockLevel6_0090,  /* E0000..E000F */
+  FriBidiPropertyBlockLevel6_0090,  /* E0010..E001F */
+  FriBidiPropertyBlockLevel6_0090,  /* E0020..E002F */
+  FriBidiPropertyBlockLevel6_0090,  /* E0030..E003F */
+
+#define FriBidiPropertyBlockLevel5_E01C0 0x208
+
+  FriBidiPropertyBlockLevel6_0300,  /* E01C0..E01CF */
+  FriBidiPropertyBlockLevel6_0300,  /* E01D0..E01DF */
+  FriBidiPropertyBlockLevel6_0300,  /* E01E0..E01EF */
+  FriBidiPropertyBlockLevel6_0090,  /* E01F0..E01FF */
+};
+
+static const PACKTAB_UINT16 FriBidiPropertyBlockLevel4[2*91] = {
+
+#define FriBidiPropertyBlockLevel4_0000 0x0
+
+  FriBidiPropertyBlockLevel5_0000,  /* 0000..003F */
+  FriBidiPropertyBlockLevel5_0040,  /* 0040..007F */
+
+#define FriBidiPropertyBlockLevel4_0080 0x2
+
+  FriBidiPropertyBlockLevel5_0080,  /* 0080..00BF */
+  FriBidiPropertyBlockLevel5_00C0,  /* 00C0..00FF */
+
+#define FriBidiPropertyBlockLevel4_0100 0x4
+
+  FriBidiPropertyBlockLevel5_0100,  /* 0100..013F */
+  FriBidiPropertyBlockLevel5_0100,  /* 0140..017F */
+
+#define FriBidiPropertyBlockLevel4_0280 0x6
+
+  FriBidiPropertyBlockLevel5_0280,  /* 0280..02BF */
+  FriBidiPropertyBlockLevel5_02C0,  /* 02C0..02FF */
+
+#define FriBidiPropertyBlockLevel4_0300 0x8
+
+  FriBidiPropertyBlockLevel5_0300,  /* 0300..033F */
+  FriBidiPropertyBlockLevel5_0340,  /* 0340..037F */
+
+#define FriBidiPropertyBlockLevel4_0380 0xA
+
+  FriBidiPropertyBlockLevel5_0380,  /* 0380..03BF */
+  FriBidiPropertyBlockLevel5_03C0,  /* 03C0..03FF */
+
+#define FriBidiPropertyBlockLevel4_0480 0xC
+
+  FriBidiPropertyBlockLevel5_0480,  /* 0480..04BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 04C0..04FF */
+
+#define FriBidiPropertyBlockLevel4_0580 0xE
+
+  FriBidiPropertyBlockLevel5_0580,  /* 0580..05BF */
+  FriBidiPropertyBlockLevel5_05C0,  /* 05C0..05FF */
+
+#define FriBidiPropertyBlockLevel4_0600 0x10
+
+  FriBidiPropertyBlockLevel5_0600,  /* 0600..063F */
+  FriBidiPropertyBlockLevel5_0640,  /* 0640..067F */
+
+#define FriBidiPropertyBlockLevel4_0680 0x12
+
+  FriBidiPropertyBlockLevel5_0680,  /* 0680..06BF */
+  FriBidiPropertyBlockLevel5_06C0,  /* 06C0..06FF */
+
+#define FriBidiPropertyBlockLevel4_0700 0x14
+
+  FriBidiPropertyBlockLevel5_0700,  /* 0700..073F */
+  FriBidiPropertyBlockLevel5_0740,  /* 0740..077F */
+
+#define FriBidiPropertyBlockLevel4_0780 0x16
+
+  FriBidiPropertyBlockLevel5_0780,  /* 0780..07BF */
+  FriBidiPropertyBlockLevel5_07C0,  /* 07C0..07FF */
+
+#define FriBidiPropertyBlockLevel4_0800 0x18
+
+  FriBidiPropertyBlockLevel5_0800,  /* 0800..083F */
+  FriBidiPropertyBlockLevel5_0800,  /* 0840..087F */
+
+#define FriBidiPropertyBlockLevel4_0900 0x1A
+
+  FriBidiPropertyBlockLevel5_0900,  /* 0900..093F */
+  FriBidiPropertyBlockLevel5_0940,  /* 0940..097F */
+
+#define FriBidiPropertyBlockLevel4_0980 0x1C
+
+  FriBidiPropertyBlockLevel5_0980,  /* 0980..09BF */
+  FriBidiPropertyBlockLevel5_09C0,  /* 09C0..09FF */
+
+#define FriBidiPropertyBlockLevel4_0A00 0x1E
+
+  FriBidiPropertyBlockLevel5_0900,  /* 0A00..0A3F */
+  FriBidiPropertyBlockLevel5_0A40,  /* 0A40..0A7F */
+
+#define FriBidiPropertyBlockLevel4_0A80 0x20
+
+  FriBidiPropertyBlockLevel5_0900,  /* 0A80..0ABF */
+  FriBidiPropertyBlockLevel5_0AC0,  /* 0AC0..0AFF */
+
+#define FriBidiPropertyBlockLevel4_0B00 0x22
+
+  FriBidiPropertyBlockLevel5_0B00,  /* 0B00..0B3F */
+  FriBidiPropertyBlockLevel5_0B40,  /* 0B40..0B7F */
+
+#define FriBidiPropertyBlockLevel4_0B80 0x24
+
+  FriBidiPropertyBlockLevel5_0B80,  /* 0B80..0BBF */
+  FriBidiPropertyBlockLevel5_0BC0,  /* 0BC0..0BFF */
+
+#define FriBidiPropertyBlockLevel4_0C00 0x26
+
+  FriBidiPropertyBlockLevel5_0C00,  /* 0C00..0C3F */
+  FriBidiPropertyBlockLevel5_0C40,  /* 0C40..0C7F */
+
+#define FriBidiPropertyBlockLevel4_0C80 0x28
+
+  FriBidiPropertyBlockLevel5_0C80,  /* 0C80..0CBF */
+  FriBidiPropertyBlockLevel5_0CC0,  /* 0CC0..0CFF */
+
+#define FriBidiPropertyBlockLevel4_0D00 0x2A
+
+  FriBidiPropertyBlockLevel5_0100,  /* 0D00..0D3F */
+  FriBidiPropertyBlockLevel5_0D40,  /* 0D40..0D7F */
+
+#define FriBidiPropertyBlockLevel4_0D80 0x2C
+
+  FriBidiPropertyBlockLevel5_0100,  /* 0D80..0DBF */
+  FriBidiPropertyBlockLevel5_0DC0,  /* 0DC0..0DFF */
+
+#define FriBidiPropertyBlockLevel4_0E00 0x2E
+
+  FriBidiPropertyBlockLevel5_0E00,  /* 0E00..0E3F */
+  FriBidiPropertyBlockLevel5_0E40,  /* 0E40..0E7F */
+
+#define FriBidiPropertyBlockLevel4_0E80 0x30
+
+  FriBidiPropertyBlockLevel5_0E80,  /* 0E80..0EBF */
+  FriBidiPropertyBlockLevel5_0EC0,  /* 0EC0..0EFF */
+
+#define FriBidiPropertyBlockLevel4_0F00 0x32
+
+  FriBidiPropertyBlockLevel5_0F00,  /* 0F00..0F3F */
+  FriBidiPropertyBlockLevel5_0F40,  /* 0F40..0F7F */
+
+#define FriBidiPropertyBlockLevel4_0F80 0x34
+
+  FriBidiPropertyBlockLevel5_0F80,  /* 0F80..0FBF */
+  FriBidiPropertyBlockLevel5_0FC0,  /* 0FC0..0FFF */
+
+#define FriBidiPropertyBlockLevel4_1000 0x36
+
+  FriBidiPropertyBlockLevel5_1000,  /* 1000..103F */
+  FriBidiPropertyBlockLevel5_1040,  /* 1040..107F */
+
+#define FriBidiPropertyBlockLevel4_1300 0x38
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1300..133F */
+  FriBidiPropertyBlockLevel5_1340,  /* 1340..137F */
+
+#define FriBidiPropertyBlockLevel4_1380 0x3A
+
+  FriBidiPropertyBlockLevel5_1380,  /* 1380..13BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 13C0..13FF */
+
+#define FriBidiPropertyBlockLevel4_1680 0x3C
+
+  FriBidiPropertyBlockLevel5_1680,  /* 1680..16BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 16C0..16FF */
+
+#define FriBidiPropertyBlockLevel4_1700 0x3E
+
+  FriBidiPropertyBlockLevel5_1700,  /* 1700..173F */
+  FriBidiPropertyBlockLevel5_1740,  /* 1740..177F */
+
+#define FriBidiPropertyBlockLevel4_1780 0x40
+
+  FriBidiPropertyBlockLevel5_1780,  /* 1780..17BF */
+  FriBidiPropertyBlockLevel5_17C0,  /* 17C0..17FF */
+
+#define FriBidiPropertyBlockLevel4_1800 0x42
+
+  FriBidiPropertyBlockLevel5_1800,  /* 1800..183F */
+  FriBidiPropertyBlockLevel5_0100,  /* 1840..187F */
+
+#define FriBidiPropertyBlockLevel4_1880 0x44
+
+  FriBidiPropertyBlockLevel5_1880,  /* 1880..18BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 18C0..18FF */
+
+#define FriBidiPropertyBlockLevel4_1900 0x46
+
+  FriBidiPropertyBlockLevel5_1900,  /* 1900..193F */
+  FriBidiPropertyBlockLevel5_1940,  /* 1940..197F */
+
+#define FriBidiPropertyBlockLevel4_1980 0x48
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1980..19BF */
+  FriBidiPropertyBlockLevel5_19C0,  /* 19C0..19FF */
+
+#define FriBidiPropertyBlockLevel4_1A00 0x4A
+
+  FriBidiPropertyBlockLevel5_1A00,  /* 1A00..1A3F */
+  FriBidiPropertyBlockLevel5_0100,  /* 1A40..1A7F */
+
+#define FriBidiPropertyBlockLevel4_1B00 0x4C
+
+  FriBidiPropertyBlockLevel5_1B00,  /* 1B00..1B3F */
+  FriBidiPropertyBlockLevel5_1B40,  /* 1B40..1B7F */
+
+#define FriBidiPropertyBlockLevel4_1D80 0x4E
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1D80..1DBF */
+  FriBidiPropertyBlockLevel5_1DC0,  /* 1DC0..1DFF */
+
+#define FriBidiPropertyBlockLevel4_1F80 0x50
+
+  FriBidiPropertyBlockLevel5_1F80,  /* 1F80..1FBF */
+  FriBidiPropertyBlockLevel5_1FC0,  /* 1FC0..1FFF */
+
+#define FriBidiPropertyBlockLevel4_2000 0x52
+
+  FriBidiPropertyBlockLevel5_2000,  /* 2000..203F */
+  FriBidiPropertyBlockLevel5_2040,  /* 2040..207F */
+
+#define FriBidiPropertyBlockLevel4_2080 0x54
+
+  FriBidiPropertyBlockLevel5_2080,  /* 2080..20BF */
+  FriBidiPropertyBlockLevel5_20C0,  /* 20C0..20FF */
+
+#define FriBidiPropertyBlockLevel4_2100 0x56
+
+  FriBidiPropertyBlockLevel5_2100,  /* 2100..213F */
+  FriBidiPropertyBlockLevel5_2140,  /* 2140..217F */
+
+#define FriBidiPropertyBlockLevel4_2180 0x58
+
+  FriBidiPropertyBlockLevel5_2180,  /* 2180..21BF */
+  FriBidiPropertyBlockLevel5_21C0,  /* 21C0..21FF */
+
+#define FriBidiPropertyBlockLevel4_2200 0x5A
+
+  FriBidiPropertyBlockLevel5_2200,  /* 2200..223F */
+  FriBidiPropertyBlockLevel5_21C0,  /* 2240..227F */
+
+#define FriBidiPropertyBlockLevel4_2280 0x5C
+
+  FriBidiPropertyBlockLevel5_21C0,  /* 2280..22BF */
+  FriBidiPropertyBlockLevel5_21C0,  /* 22C0..22FF */
+
+#define FriBidiPropertyBlockLevel4_2300 0x5E
+
+  FriBidiPropertyBlockLevel5_2300,  /* 2300..233F */
+  FriBidiPropertyBlockLevel5_2340,  /* 2340..237F */
+
+#define FriBidiPropertyBlockLevel4_2380 0x60
+
+  FriBidiPropertyBlockLevel5_2380,  /* 2380..23BF */
+  FriBidiPropertyBlockLevel5_23C0,  /* 23C0..23FF */
+
+#define FriBidiPropertyBlockLevel4_2400 0x62
+
+  FriBidiPropertyBlockLevel5_2400,  /* 2400..243F */
+  FriBidiPropertyBlockLevel5_2440,  /* 2440..247F */
+
+#define FriBidiPropertyBlockLevel4_2480 0x64
+
+  FriBidiPropertyBlockLevel5_2480,  /* 2480..24BF */
+  FriBidiPropertyBlockLevel5_24C0,  /* 24C0..24FF */
+
+#define FriBidiPropertyBlockLevel4_2680 0x66
+
+  FriBidiPropertyBlockLevel5_2680,  /* 2680..26BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 26C0..26FF */
+
+#define FriBidiPropertyBlockLevel4_2700 0x68
+
+  FriBidiPropertyBlockLevel5_2700,  /* 2700..273F */
+  FriBidiPropertyBlockLevel5_2740,  /* 2740..277F */
+
+#define FriBidiPropertyBlockLevel4_2780 0x6A
+
+  FriBidiPropertyBlockLevel5_2780,  /* 2780..27BF */
+  FriBidiPropertyBlockLevel5_27C0,  /* 27C0..27FF */
+
+#define FriBidiPropertyBlockLevel4_2B00 0x6C
+
+  FriBidiPropertyBlockLevel5_2B00,  /* 2B00..2B3F */
+  FriBidiPropertyBlockLevel5_0100,  /* 2B40..2B7F */
+
+#define FriBidiPropertyBlockLevel4_2C80 0x6E
+
+  FriBidiPropertyBlockLevel5_0100,  /* 2C80..2CBF */
+  FriBidiPropertyBlockLevel5_2CC0,  /* 2CC0..2CFF */
+
+#define FriBidiPropertyBlockLevel4_2E00 0x70
+
+  FriBidiPropertyBlockLevel5_2E00,  /* 2E00..2E3F */
+  FriBidiPropertyBlockLevel5_0100,  /* 2E40..2E7F */
+
+#define FriBidiPropertyBlockLevel4_2E80 0x72
+
+  FriBidiPropertyBlockLevel5_2E80,  /* 2E80..2EBF */
+  FriBidiPropertyBlockLevel5_2EC0,  /* 2EC0..2EFF */
+
+#define FriBidiPropertyBlockLevel4_2F80 0x74
+
+  FriBidiPropertyBlockLevel5_21C0,  /* 2F80..2FBF */
+  FriBidiPropertyBlockLevel5_2FC0,  /* 2FC0..2FFF */
+
+#define FriBidiPropertyBlockLevel4_3000 0x76
+
+  FriBidiPropertyBlockLevel5_3000,  /* 3000..303F */
+  FriBidiPropertyBlockLevel5_0100,  /* 3040..307F */
+
+#define FriBidiPropertyBlockLevel4_3080 0x78
+
+  FriBidiPropertyBlockLevel5_3080,  /* 3080..30BF */
+  FriBidiPropertyBlockLevel5_30C0,  /* 30C0..30FF */
+
+#define FriBidiPropertyBlockLevel4_3180 0x7A
+
+  FriBidiPropertyBlockLevel5_0100,  /* 3180..31BF */
+  FriBidiPropertyBlockLevel5_31C0,  /* 31C0..31FF */
+
+#define FriBidiPropertyBlockLevel4_3200 0x7C
+
+  FriBidiPropertyBlockLevel5_3200,  /* 3200..323F */
+  FriBidiPropertyBlockLevel5_3240,  /* 3240..327F */
+
+#define FriBidiPropertyBlockLevel4_3280 0x7E
+
+  FriBidiPropertyBlockLevel5_3280,  /* 3280..32BF */
+  FriBidiPropertyBlockLevel5_32C0,  /* 32C0..32FF */
+
+#define FriBidiPropertyBlockLevel4_3300 0x80
+
+  FriBidiPropertyBlockLevel5_0100,  /* 3300..333F */
+  FriBidiPropertyBlockLevel5_3340,  /* 3340..337F */
+
+#define FriBidiPropertyBlockLevel4_3380 0x82
+
+  FriBidiPropertyBlockLevel5_0100,  /* 3380..33BF */
+  FriBidiPropertyBlockLevel5_33C0,  /* 33C0..33FF */
+
+#define FriBidiPropertyBlockLevel4_4D80 0x84
+
+  FriBidiPropertyBlockLevel5_0100,  /* 4D80..4DBF */
+  FriBidiPropertyBlockLevel5_21C0,  /* 4DC0..4DFF */
+
+#define FriBidiPropertyBlockLevel4_A480 0x86
+
+  FriBidiPropertyBlockLevel5_2180,  /* A480..A4BF */
+  FriBidiPropertyBlockLevel5_A4C0,  /* A4C0..A4FF */
+
+#define FriBidiPropertyBlockLevel4_A700 0x88
+
+  FriBidiPropertyBlockLevel5_A700,  /* A700..A73F */
+  FriBidiPropertyBlockLevel5_0100,  /* A740..A77F */
+
+#define FriBidiPropertyBlockLevel4_A800 0x8A
+
+  FriBidiPropertyBlockLevel5_A800,  /* A800..A83F */
+  FriBidiPropertyBlockLevel5_A840,  /* A840..A87F */
+
+#define FriBidiPropertyBlockLevel4_FB00 0x8C
+
+  FriBidiPropertyBlockLevel5_FB00,  /* FB00..FB3F */
+  FriBidiPropertyBlockLevel5_FB40,  /* FB40..FB7F */
+
+#define FriBidiPropertyBlockLevel4_FB80 0x8E
+
+  FriBidiPropertyBlockLevel5_0680,  /* FB80..FBBF */
+  FriBidiPropertyBlockLevel5_0680,  /* FBC0..FBFF */
+
+#define FriBidiPropertyBlockLevel4_FD00 0x90
+
+  FriBidiPropertyBlockLevel5_FD00,  /* FD00..FD3F */
+  FriBidiPropertyBlockLevel5_0680,  /* FD40..FD7F */
+
+#define FriBidiPropertyBlockLevel4_FD80 0x92
+
+  FriBidiPropertyBlockLevel5_0680,  /* FD80..FDBF */
+  FriBidiPropertyBlockLevel5_FDC0,  /* FDC0..FDFF */
+
+#define FriBidiPropertyBlockLevel4_FE00 0x94
+
+  FriBidiPropertyBlockLevel5_FE00,  /* FE00..FE3F */
+  FriBidiPropertyBlockLevel5_FE40,  /* FE40..FE7F */
+
+#define FriBidiPropertyBlockLevel4_FE80 0x96
+
+  FriBidiPropertyBlockLevel5_0680,  /* FE80..FEBF */
+  FriBidiPropertyBlockLevel5_FEC0,  /* FEC0..FEFF */
+
+#define FriBidiPropertyBlockLevel4_FF00 0x98
+
+  FriBidiPropertyBlockLevel5_FF00,  /* FF00..FF3F */
+  FriBidiPropertyBlockLevel5_FF40,  /* FF40..FF7F */
+
+#define FriBidiPropertyBlockLevel4_FF80 0x9A
+
+  FriBidiPropertyBlockLevel5_0100,  /* FF80..FFBF */
+  FriBidiPropertyBlockLevel5_FFC0,  /* FFC0..FFFF */
+
+#define FriBidiPropertyBlockLevel4_10100 0x9C
+
+  FriBidiPropertyBlockLevel5_10100,  /* 10100..1013F */
+  FriBidiPropertyBlockLevel5_21C0,  /* 10140..1017F */
+
+#define FriBidiPropertyBlockLevel4_10180 0x9E
+
+  FriBidiPropertyBlockLevel5_10180,  /* 10180..101BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 101C0..101FF */
+
+#define FriBidiPropertyBlockLevel4_10900 0xA0
+
+  FriBidiPropertyBlockLevel5_10900,  /* 10900..1093F */
+  FriBidiPropertyBlockLevel5_0800,  /* 10940..1097F */
+
+#define FriBidiPropertyBlockLevel4_10A00 0xA2
+
+  FriBidiPropertyBlockLevel5_10A00,  /* 10A00..10A3F */
+  FriBidiPropertyBlockLevel5_0800,  /* 10A40..10A7F */
+
+#define FriBidiPropertyBlockLevel4_1D100 0xA4
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1D100..1D13F */
+  FriBidiPropertyBlockLevel5_1D140,  /* 1D140..1D17F */
+
+#define FriBidiPropertyBlockLevel4_1D180 0xA6
+
+  FriBidiPropertyBlockLevel5_1D180,  /* 1D180..1D1BF */
+  FriBidiPropertyBlockLevel5_0100,  /* 1D1C0..1D1FF */
+
+#define FriBidiPropertyBlockLevel4_1D200 0xA8
+
+  FriBidiPropertyBlockLevel5_21C0,  /* 1D200..1D23F */
+  FriBidiPropertyBlockLevel5_1D240,  /* 1D240..1D27F */
+
+#define FriBidiPropertyBlockLevel4_1D300 0xAA
+
+  FriBidiPropertyBlockLevel5_21C0,  /* 1D300..1D33F */
+  FriBidiPropertyBlockLevel5_1D340,  /* 1D340..1D37F */
+
+#define FriBidiPropertyBlockLevel4_1D780 0xAC
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1D780..1D7BF */
+  FriBidiPropertyBlockLevel5_1D7C0,  /* 1D7C0..1D7FF */
+
+#define FriBidiPropertyBlockLevel4_1FF80 0xAE
+
+  FriBidiPropertyBlockLevel5_0100,  /* 1FF80..1FFBF */
+  FriBidiPropertyBlockLevel5_1FFC0,  /* 1FFC0..1FFFF */
+
+#define FriBidiPropertyBlockLevel4_E0000 0xB0
+
+  FriBidiPropertyBlockLevel5_E0000,  /* E0000..E003F */
+  FriBidiPropertyBlockLevel5_E0000,  /* E0040..E007F */
+
+#define FriBidiPropertyBlockLevel4_E0100 0xB2
+
+  FriBidiPropertyBlockLevel5_0300,  /* E0100..E013F */
+  FriBidiPropertyBlockLevel5_0300,  /* E0140..E017F */
+
+#define FriBidiPropertyBlockLevel4_E0180 0xB4
+
+  FriBidiPropertyBlockLevel5_0300,  /* E0180..E01BF */
+  FriBidiPropertyBlockLevel5_E01C0,  /* E01C0..E01FF */
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel3[8*27] = {
+
+#define FriBidiPropertyBlockLevel3_0000 0x0
+
+  FriBidiPropertyBlockLevel4_0000,  /* 0000..007F */
+  FriBidiPropertyBlockLevel4_0080,  /* 0080..00FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 0100..017F */
+  FriBidiPropertyBlockLevel4_0100,  /* 0180..01FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 0200..027F */
+  FriBidiPropertyBlockLevel4_0280,  /* 0280..02FF */
+  FriBidiPropertyBlockLevel4_0300,  /* 0300..037F */
+  FriBidiPropertyBlockLevel4_0380,  /* 0380..03FF */
+
+#define FriBidiPropertyBlockLevel3_0400 0x8
+
+  FriBidiPropertyBlockLevel4_0100,  /* 0400..047F */
+  FriBidiPropertyBlockLevel4_0480,  /* 0480..04FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 0500..057F */
+  FriBidiPropertyBlockLevel4_0580,  /* 0580..05FF */
+  FriBidiPropertyBlockLevel4_0600,  /* 0600..067F */
+  FriBidiPropertyBlockLevel4_0680,  /* 0680..06FF */
+  FriBidiPropertyBlockLevel4_0700,  /* 0700..077F */
+  FriBidiPropertyBlockLevel4_0780,  /* 0780..07FF */
+
+#define FriBidiPropertyBlockLevel3_0800 0x10
+
+  FriBidiPropertyBlockLevel4_0800,  /* 0800..087F */
+  FriBidiPropertyBlockLevel4_0800,  /* 0880..08FF */
+  FriBidiPropertyBlockLevel4_0900,  /* 0900..097F */
+  FriBidiPropertyBlockLevel4_0980,  /* 0980..09FF */
+  FriBidiPropertyBlockLevel4_0A00,  /* 0A00..0A7F */
+  FriBidiPropertyBlockLevel4_0A80,  /* 0A80..0AFF */
+  FriBidiPropertyBlockLevel4_0B00,  /* 0B00..0B7F */
+  FriBidiPropertyBlockLevel4_0B80,  /* 0B80..0BFF */
+
+#define FriBidiPropertyBlockLevel3_0C00 0x18
+
+  FriBidiPropertyBlockLevel4_0C00,  /* 0C00..0C7F */
+  FriBidiPropertyBlockLevel4_0C80,  /* 0C80..0CFF */
+  FriBidiPropertyBlockLevel4_0D00,  /* 0D00..0D7F */
+  FriBidiPropertyBlockLevel4_0D80,  /* 0D80..0DFF */
+  FriBidiPropertyBlockLevel4_0E00,  /* 0E00..0E7F */
+  FriBidiPropertyBlockLevel4_0E80,  /* 0E80..0EFF */
+  FriBidiPropertyBlockLevel4_0F00,  /* 0F00..0F7F */
+  FriBidiPropertyBlockLevel4_0F80,  /* 0F80..0FFF */
+
+#define FriBidiPropertyBlockLevel3_1000 0x20
+
+  FriBidiPropertyBlockLevel4_1000,  /* 1000..107F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1080..10FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1100..117F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1180..11FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1200..127F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1280..12FF */
+  FriBidiPropertyBlockLevel4_1300,  /* 1300..137F */
+  FriBidiPropertyBlockLevel4_1380,  /* 1380..13FF */
+
+#define FriBidiPropertyBlockLevel3_1400 0x28
+
+  FriBidiPropertyBlockLevel4_0100,  /* 1400..147F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1480..14FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1500..157F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1580..15FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1600..167F */
+  FriBidiPropertyBlockLevel4_1680,  /* 1680..16FF */
+  FriBidiPropertyBlockLevel4_1700,  /* 1700..177F */
+  FriBidiPropertyBlockLevel4_1780,  /* 1780..17FF */
+
+#define FriBidiPropertyBlockLevel3_1800 0x30
+
+  FriBidiPropertyBlockLevel4_1800,  /* 1800..187F */
+  FriBidiPropertyBlockLevel4_1880,  /* 1880..18FF */
+  FriBidiPropertyBlockLevel4_1900,  /* 1900..197F */
+  FriBidiPropertyBlockLevel4_1980,  /* 1980..19FF */
+  FriBidiPropertyBlockLevel4_1A00,  /* 1A00..1A7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1A80..1AFF */
+  FriBidiPropertyBlockLevel4_1B00,  /* 1B00..1B7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1B80..1BFF */
+
+#define FriBidiPropertyBlockLevel3_1C00 0x38
+
+  FriBidiPropertyBlockLevel4_0100,  /* 1C00..1C7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1C80..1CFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D00..1D7F */
+  FriBidiPropertyBlockLevel4_1D80,  /* 1D80..1DFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1E00..1E7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1E80..1EFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1F00..1F7F */
+  FriBidiPropertyBlockLevel4_1F80,  /* 1F80..1FFF */
+
+#define FriBidiPropertyBlockLevel3_2000 0x40
+
+  FriBidiPropertyBlockLevel4_2000,  /* 2000..207F */
+  FriBidiPropertyBlockLevel4_2080,  /* 2080..20FF */
+  FriBidiPropertyBlockLevel4_2100,  /* 2100..217F */
+  FriBidiPropertyBlockLevel4_2180,  /* 2180..21FF */
+  FriBidiPropertyBlockLevel4_2200,  /* 2200..227F */
+  FriBidiPropertyBlockLevel4_2280,  /* 2280..22FF */
+  FriBidiPropertyBlockLevel4_2300,  /* 2300..237F */
+  FriBidiPropertyBlockLevel4_2380,  /* 2380..23FF */
+
+#define FriBidiPropertyBlockLevel3_2400 0x48
+
+  FriBidiPropertyBlockLevel4_2400,  /* 2400..247F */
+  FriBidiPropertyBlockLevel4_2480,  /* 2480..24FF */
+  FriBidiPropertyBlockLevel4_2280,  /* 2500..257F */
+  FriBidiPropertyBlockLevel4_2280,  /* 2580..25FF */
+  FriBidiPropertyBlockLevel4_2280,  /* 2600..267F */
+  FriBidiPropertyBlockLevel4_2680,  /* 2680..26FF */
+  FriBidiPropertyBlockLevel4_2700,  /* 2700..277F */
+  FriBidiPropertyBlockLevel4_2780,  /* 2780..27FF */
+
+#define FriBidiPropertyBlockLevel3_2800 0x50
+
+  FriBidiPropertyBlockLevel4_0100,  /* 2800..287F */
+  FriBidiPropertyBlockLevel4_0100,  /* 2880..28FF */
+  FriBidiPropertyBlockLevel4_2280,  /* 2900..297F */
+  FriBidiPropertyBlockLevel4_2280,  /* 2980..29FF */
+  FriBidiPropertyBlockLevel4_2280,  /* 2A00..2A7F */
+  FriBidiPropertyBlockLevel4_2280,  /* 2A80..2AFF */
+  FriBidiPropertyBlockLevel4_2B00,  /* 2B00..2B7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 2B80..2BFF */
+
+#define FriBidiPropertyBlockLevel3_2C00 0x58
+
+  FriBidiPropertyBlockLevel4_0100,  /* 2C00..2C7F */
+  FriBidiPropertyBlockLevel4_2C80,  /* 2C80..2CFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 2D00..2D7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 2D80..2DFF */
+  FriBidiPropertyBlockLevel4_2E00,  /* 2E00..2E7F */
+  FriBidiPropertyBlockLevel4_2E80,  /* 2E80..2EFF */
+  FriBidiPropertyBlockLevel4_2280,  /* 2F00..2F7F */
+  FriBidiPropertyBlockLevel4_2F80,  /* 2F80..2FFF */
+
+#define FriBidiPropertyBlockLevel3_3000 0x60
+
+  FriBidiPropertyBlockLevel4_3000,  /* 3000..307F */
+  FriBidiPropertyBlockLevel4_3080,  /* 3080..30FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 3100..317F */
+  FriBidiPropertyBlockLevel4_3180,  /* 3180..31FF */
+  FriBidiPropertyBlockLevel4_3200,  /* 3200..327F */
+  FriBidiPropertyBlockLevel4_3280,  /* 3280..32FF */
+  FriBidiPropertyBlockLevel4_3300,  /* 3300..337F */
+  FriBidiPropertyBlockLevel4_3380,  /* 3380..33FF */
+
+#define FriBidiPropertyBlockLevel3_3400 0x68
+
+  FriBidiPropertyBlockLevel4_0100,  /* 3400..347F */
+  FriBidiPropertyBlockLevel4_0100,  /* 3480..34FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 3500..357F */
+  FriBidiPropertyBlockLevel4_0100,  /* 3580..35FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 3600..367F */
+  FriBidiPropertyBlockLevel4_0100,  /* 3680..36FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 3700..377F */
+  FriBidiPropertyBlockLevel4_0100,  /* 3780..37FF */
+
+#define FriBidiPropertyBlockLevel3_4C00 0x70
+
+  FriBidiPropertyBlockLevel4_0100,  /* 4C00..4C7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 4C80..4CFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 4D00..4D7F */
+  FriBidiPropertyBlockLevel4_4D80,  /* 4D80..4DFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 4E00..4E7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 4E80..4EFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 4F00..4F7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 4F80..4FFF */
+
+#define FriBidiPropertyBlockLevel3_A400 0x78
+
+  FriBidiPropertyBlockLevel4_0100,  /* A400..A47F */
+  FriBidiPropertyBlockLevel4_A480,  /* A480..A4FF */
+  FriBidiPropertyBlockLevel4_0100,  /* A500..A57F */
+  FriBidiPropertyBlockLevel4_0100,  /* A580..A5FF */
+  FriBidiPropertyBlockLevel4_0100,  /* A600..A67F */
+  FriBidiPropertyBlockLevel4_0100,  /* A680..A6FF */
+  FriBidiPropertyBlockLevel4_A700,  /* A700..A77F */
+  FriBidiPropertyBlockLevel4_0100,  /* A780..A7FF */
+
+#define FriBidiPropertyBlockLevel3_A800 0x80
+
+  FriBidiPropertyBlockLevel4_A800,  /* A800..A87F */
+  FriBidiPropertyBlockLevel4_0100,  /* A880..A8FF */
+  FriBidiPropertyBlockLevel4_0100,  /* A900..A97F */
+  FriBidiPropertyBlockLevel4_0100,  /* A980..A9FF */
+  FriBidiPropertyBlockLevel4_0100,  /* AA00..AA7F */
+  FriBidiPropertyBlockLevel4_0100,  /* AA80..AAFF */
+  FriBidiPropertyBlockLevel4_0100,  /* AB00..AB7F */
+  FriBidiPropertyBlockLevel4_0100,  /* AB80..ABFF */
+
+#define FriBidiPropertyBlockLevel3_F800 0x88
+
+  FriBidiPropertyBlockLevel4_0100,  /* F800..F87F */
+  FriBidiPropertyBlockLevel4_0100,  /* F880..F8FF */
+  FriBidiPropertyBlockLevel4_0100,  /* F900..F97F */
+  FriBidiPropertyBlockLevel4_0100,  /* F980..F9FF */
+  FriBidiPropertyBlockLevel4_0100,  /* FA00..FA7F */
+  FriBidiPropertyBlockLevel4_0100,  /* FA80..FAFF */
+  FriBidiPropertyBlockLevel4_FB00,  /* FB00..FB7F */
+  FriBidiPropertyBlockLevel4_FB80,  /* FB80..FBFF */
+
+#define FriBidiPropertyBlockLevel3_FC00 0x90
+
+  FriBidiPropertyBlockLevel4_FB80,  /* FC00..FC7F */
+  FriBidiPropertyBlockLevel4_FB80,  /* FC80..FCFF */
+  FriBidiPropertyBlockLevel4_FD00,  /* FD00..FD7F */
+  FriBidiPropertyBlockLevel4_FD80,  /* FD80..FDFF */
+  FriBidiPropertyBlockLevel4_FE00,  /* FE00..FE7F */
+  FriBidiPropertyBlockLevel4_FE80,  /* FE80..FEFF */
+  FriBidiPropertyBlockLevel4_FF00,  /* FF00..FF7F */
+  FriBidiPropertyBlockLevel4_FF80,  /* FF80..FFFF */
+
+#define FriBidiPropertyBlockLevel3_10000 0x98
+
+  FriBidiPropertyBlockLevel4_0100,  /* 10000..1007F */
+  FriBidiPropertyBlockLevel4_0100,  /* 10080..100FF */
+  FriBidiPropertyBlockLevel4_10100,  /* 10100..1017F */
+  FriBidiPropertyBlockLevel4_10180,  /* 10180..101FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 10200..1027F */
+  FriBidiPropertyBlockLevel4_0100,  /* 10280..102FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 10300..1037F */
+  FriBidiPropertyBlockLevel4_0100,  /* 10380..103FF */
+
+#define FriBidiPropertyBlockLevel3_10800 0xA0
+
+  FriBidiPropertyBlockLevel4_0800,  /* 10800..1087F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10880..108FF */
+  FriBidiPropertyBlockLevel4_10900,  /* 10900..1097F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10980..109FF */
+  FriBidiPropertyBlockLevel4_10A00,  /* 10A00..10A7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10A80..10AFF */
+  FriBidiPropertyBlockLevel4_0800,  /* 10B00..10B7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10B80..10BFF */
+
+#define FriBidiPropertyBlockLevel3_10C00 0xA8
+
+  FriBidiPropertyBlockLevel4_0800,  /* 10C00..10C7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10C80..10CFF */
+  FriBidiPropertyBlockLevel4_0800,  /* 10D00..10D7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10D80..10DFF */
+  FriBidiPropertyBlockLevel4_0800,  /* 10E00..10E7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10E80..10EFF */
+  FriBidiPropertyBlockLevel4_0800,  /* 10F00..10F7F */
+  FriBidiPropertyBlockLevel4_0800,  /* 10F80..10FFF */
+
+#define FriBidiPropertyBlockLevel3_1D000 0xB0
+
+  FriBidiPropertyBlockLevel4_0100,  /* 1D000..1D07F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D080..1D0FF */
+  FriBidiPropertyBlockLevel4_1D100,  /* 1D100..1D17F */
+  FriBidiPropertyBlockLevel4_1D180,  /* 1D180..1D1FF */
+  FriBidiPropertyBlockLevel4_1D200,  /* 1D200..1D27F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D280..1D2FF */
+  FriBidiPropertyBlockLevel4_1D300,  /* 1D300..1D37F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D380..1D3FF */
+
+#define FriBidiPropertyBlockLevel3_1D400 0xB8
+
+  FriBidiPropertyBlockLevel4_0100,  /* 1D400..1D47F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D480..1D4FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D500..1D57F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D580..1D5FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D600..1D67F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D680..1D6FF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1D700..1D77F */
+  FriBidiPropertyBlockLevel4_1D780,  /* 1D780..1D7FF */
+
+#define FriBidiPropertyBlockLevel3_1FC00 0xC0
+
+  FriBidiPropertyBlockLevel4_0100,  /* 1FC00..1FC7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FC80..1FCFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FD00..1FD7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FD80..1FDFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FE00..1FE7F */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FE80..1FEFF */
+  FriBidiPropertyBlockLevel4_0100,  /* 1FF00..1FF7F */
+  FriBidiPropertyBlockLevel4_1FF80,  /* 1FF80..1FFFF */
+
+#define FriBidiPropertyBlockLevel3_E0000 0xC8
+
+  FriBidiPropertyBlockLevel4_E0000,  /* E0000..E007F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0080..E00FF */
+  FriBidiPropertyBlockLevel4_E0100,  /* E0100..E017F */
+  FriBidiPropertyBlockLevel4_E0180,  /* E0180..E01FF */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0200..E027F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0280..E02FF */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0300..E037F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0380..E03FF */
+
+#define FriBidiPropertyBlockLevel3_E0400 0xD0
+
+  FriBidiPropertyBlockLevel4_E0000,  /* E0400..E047F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0480..E04FF */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0500..E057F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0580..E05FF */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0600..E067F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0680..E06FF */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0700..E077F */
+  FriBidiPropertyBlockLevel4_E0000,  /* E0780..E07FF */
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel2[4*12] = {
+
+#define FriBidiPropertyBlockLevel2_0000 0x0
+
+  FriBidiPropertyBlockLevel3_0000,  /* 0000..03FF */
+  FriBidiPropertyBlockLevel3_0400,  /* 0400..07FF */
+  FriBidiPropertyBlockLevel3_0800,  /* 0800..0BFF */
+  FriBidiPropertyBlockLevel3_0C00,  /* 0C00..0FFF */
+
+#define FriBidiPropertyBlockLevel2_1000 0x4
+
+  FriBidiPropertyBlockLevel3_1000,  /* 1000..13FF */
+  FriBidiPropertyBlockLevel3_1400,  /* 1400..17FF */
+  FriBidiPropertyBlockLevel3_1800,  /* 1800..1BFF */
+  FriBidiPropertyBlockLevel3_1C00,  /* 1C00..1FFF */
+
+#define FriBidiPropertyBlockLevel2_2000 0x8
+
+  FriBidiPropertyBlockLevel3_2000,  /* 2000..23FF */
+  FriBidiPropertyBlockLevel3_2400,  /* 2400..27FF */
+  FriBidiPropertyBlockLevel3_2800,  /* 2800..2BFF */
+  FriBidiPropertyBlockLevel3_2C00,  /* 2C00..2FFF */
+
+#define FriBidiPropertyBlockLevel2_3000 0xC
+
+  FriBidiPropertyBlockLevel3_3000,  /* 3000..33FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 3400..37FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 3800..3BFF */
+  FriBidiPropertyBlockLevel3_3400,  /* 3C00..3FFF */
+
+#define FriBidiPropertyBlockLevel2_4000 0x10
+
+  FriBidiPropertyBlockLevel3_3400,  /* 4000..43FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 4400..47FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 4800..4BFF */
+  FriBidiPropertyBlockLevel3_4C00,  /* 4C00..4FFF */
+
+#define FriBidiPropertyBlockLevel2_5000 0x14
+
+  FriBidiPropertyBlockLevel3_3400,  /* 5000..53FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 5400..57FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 5800..5BFF */
+  FriBidiPropertyBlockLevel3_3400,  /* 5C00..5FFF */
+
+#define FriBidiPropertyBlockLevel2_A000 0x18
+
+  FriBidiPropertyBlockLevel3_3400,  /* A000..A3FF */
+  FriBidiPropertyBlockLevel3_A400,  /* A400..A7FF */
+  FriBidiPropertyBlockLevel3_A800,  /* A800..ABFF */
+  FriBidiPropertyBlockLevel3_3400,  /* AC00..AFFF */
+
+#define FriBidiPropertyBlockLevel2_F000 0x1C
+
+  FriBidiPropertyBlockLevel3_3400,  /* F000..F3FF */
+  FriBidiPropertyBlockLevel3_3400,  /* F400..F7FF */
+  FriBidiPropertyBlockLevel3_F800,  /* F800..FBFF */
+  FriBidiPropertyBlockLevel3_FC00,  /* FC00..FFFF */
+
+#define FriBidiPropertyBlockLevel2_10000 0x20
+
+  FriBidiPropertyBlockLevel3_10000,  /* 10000..103FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 10400..107FF */
+  FriBidiPropertyBlockLevel3_10800,  /* 10800..10BFF */
+  FriBidiPropertyBlockLevel3_10C00,  /* 10C00..10FFF */
+
+#define FriBidiPropertyBlockLevel2_1D000 0x24
+
+  FriBidiPropertyBlockLevel3_1D000,  /* 1D000..1D3FF */
+  FriBidiPropertyBlockLevel3_1D400,  /* 1D400..1D7FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 1D800..1DBFF */
+  FriBidiPropertyBlockLevel3_3400,  /* 1DC00..1DFFF */
+
+#define FriBidiPropertyBlockLevel2_1F000 0x28
+
+  FriBidiPropertyBlockLevel3_3400,  /* 1F000..1F3FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 1F400..1F7FF */
+  FriBidiPropertyBlockLevel3_3400,  /* 1F800..1FBFF */
+  FriBidiPropertyBlockLevel3_1FC00,  /* 1FC00..1FFFF */
+
+#define FriBidiPropertyBlockLevel2_E0000 0x2C
+
+  FriBidiPropertyBlockLevel3_E0000,  /* E0000..E03FF */
+  FriBidiPropertyBlockLevel3_E0400,  /* E0400..E07FF */
+  FriBidiPropertyBlockLevel3_E0400,  /* E0800..E0BFF */
+  FriBidiPropertyBlockLevel3_E0400,  /* E0C00..E0FFF */
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel1[16*4] = {
+
+#define FriBidiPropertyBlockLevel1_0000 0x0
+
+  FriBidiPropertyBlockLevel2_0000,  /* 0000..0FFF */
+  FriBidiPropertyBlockLevel2_1000,  /* 1000..1FFF */
+  FriBidiPropertyBlockLevel2_2000,  /* 2000..2FFF */
+  FriBidiPropertyBlockLevel2_3000,  /* 3000..3FFF */
+  FriBidiPropertyBlockLevel2_4000,  /* 4000..4FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 5000..5FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 6000..6FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 7000..7FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 8000..8FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 9000..9FFF */
+  FriBidiPropertyBlockLevel2_A000,  /* A000..AFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* B000..BFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* C000..CFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* D000..DFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E000..EFFF */
+  FriBidiPropertyBlockLevel2_F000,  /* F000..FFFF */
+
+#define FriBidiPropertyBlockLevel1_10000 0x10
+
+  FriBidiPropertyBlockLevel2_10000,  /* 10000..10FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 11000..11FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 12000..12FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 13000..13FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 14000..14FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 15000..15FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 16000..16FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 17000..17FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 18000..18FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 19000..19FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 1A000..1AFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 1B000..1BFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 1C000..1CFFF */
+  FriBidiPropertyBlockLevel2_1D000,  /* 1D000..1DFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 1E000..1EFFF */
+  FriBidiPropertyBlockLevel2_1F000,  /* 1F000..1FFFF */
+
+#define FriBidiPropertyBlockLevel1_20000 0x20
+
+  FriBidiPropertyBlockLevel2_5000,  /* 20000..20FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 21000..21FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 22000..22FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 23000..23FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 24000..24FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 25000..25FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 26000..26FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 27000..27FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 28000..28FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 29000..29FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 2A000..2AFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 2B000..2BFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 2C000..2CFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 2D000..2DFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* 2E000..2EFFF */
+  FriBidiPropertyBlockLevel2_1F000,  /* 2F000..2FFFF */
+
+#define FriBidiPropertyBlockLevel1_E0000 0x30
+
+  FriBidiPropertyBlockLevel2_E0000,  /* E0000..E0FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E1000..E1FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E2000..E2FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E3000..E3FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E4000..E4FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E5000..E5FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E6000..E6FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E7000..E7FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E8000..E8FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* E9000..E9FFF */
+  FriBidiPropertyBlockLevel2_5000,  /* EA000..EAFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* EB000..EBFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* EC000..ECFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* ED000..EDFFF */
+  FriBidiPropertyBlockLevel2_5000,  /* EE000..EEFFF */
+  FriBidiPropertyBlockLevel2_1F000,  /* EF000..EFFFF */
+};
+
+static const PACKTAB_UINT8 FriBidiPropertyBlockLevel0[17*1] = {
+
+#define FriBidiPropertyBlockLevel0_0000 0x0
+
+  FriBidiPropertyBlockLevel1_0000,  /* 0000..FFFF */
+  FriBidiPropertyBlockLevel1_10000,  /* 10000..1FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 20000..2FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 30000..3FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 40000..4FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 50000..5FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 60000..6FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 70000..7FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 80000..8FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 90000..9FFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* A0000..AFFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* B0000..BFFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* C0000..CFFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* D0000..DFFFF */
+  FriBidiPropertyBlockLevel1_E0000,  /* E0000..EFFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* F0000..FFFFF */
+  FriBidiPropertyBlockLevel1_20000,  /* 100000..10FFFF */
+};
+
+/* *INDENT-ON* */
+
+#define FRIBIDI_GET_TYPE(x)	\
+	FriBidiPropertyBlockLevel8[(x)%2 +	\
+	FriBidiPropertyBlockLevel7[(x)/2%2 +	\
+	FriBidiPropertyBlockLevel6[(x)/4%4 +	\
+	FriBidiPropertyBlockLevel5[(x)/16%4 +	\
+	FriBidiPropertyBlockLevel4[(x)/64%2 +	\
+	FriBidiPropertyBlockLevel3[(x)/128%8 +	\
+	FriBidiPropertyBlockLevel2[(x)/1024%4 +	\
+	FriBidiPropertyBlockLevel1[(x)/4096%16 +	\
+	FriBidiPropertyBlockLevel0[(x)/65536]]]]]]]]]
+
+#undef WS
+#undef SS
+#undef RLO
+#undef RLE
+#undef PDF
+#undef NSM
+#undef LRO
+#undef LRE
+#undef ET
+#undef ES
+#undef EN
+#undef CS
+#undef BS
+#undef AN
+#undef BN
+#undef ON
+#undef AL
+#undef RTL
+#undef LTR
+/*======================================================================
+ *  fribidi_get_type_internal() returns the bidi type of a character.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API FriBidiCharType
+fribidi_get_type_internal (FriBidiChar uch)
+{
+  if (uch < 0x110000)
+    return fribidi_prop_to_type[(unsigned char)FRIBIDI_GET_TYPE (uch)];
+  else
+    return FRIBIDI_TYPE_LTR;
+  /* Non-Unicode chars */
+}
+
+
+#endif /* FRIBIDI_TAB_CHAR_TYPE_9_I */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_mirroring.i Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_mirroring.i
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_tab_mirroring.i	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_tab_mirroring.i	2012-05-05 23:46:50.944763780 +0530
@@ -0,0 +1,392 @@
+/*
+  This file was automatically created from BidiMirroring.txt, version 4.1.0
+  by fribidi_create_mirroring
+*/
+
+#ifndef FRIBIDI_TAB_MIRRORING_I
+#define FRIBIDI_TAB_MIRRORING_I
+
+#include "fribidi.h"
+
+/*
+  Mirrored characters include all the characters in the Unicode list
+  that have been declared as being mirrored and that have a mirrored
+  equivalent.
+
+  There are lots of characters that are designed as being mirrored
+  but do not have any mirrored glyph, e.g. the sign for there exist.
+  Are these used in Arabic? That is are all the mathematical signs
+  that are assigned to be mirrorable actually mirrored in Arabic?
+  If that is the case, we'll change the below code to include also
+  characters that mirror to themself. It will then be the responsibility
+  of the display engine to actually mirror these.
+*/
+
+/* *INDENT-OFF* */
+
+static const struct
+{
+  FriBidiChar ch, mirrored_ch;
+}
+FriBidiMirroredChars[] =
+{
+  {0x0028, 0x0029},
+  {0x0029, 0x0028},
+  {0x003C, 0x003E},
+  {0x003E, 0x003C},
+  {0x005B, 0x005D},
+  {0x005D, 0x005B},
+  {0x007B, 0x007D},
+  {0x007D, 0x007B},
+  {0x00AB, 0x00BB},
+  {0x00BB, 0x00AB},
+  {0x0F3A, 0x0F3B},
+  {0x0F3B, 0x0F3A},
+  {0x0F3C, 0x0F3D},
+  {0x0F3D, 0x0F3C},
+  {0x169B, 0x169C},
+  {0x169C, 0x169B},
+  {0x2018, 0x2019},
+  {0x2019, 0x2018},
+  {0x201C, 0x201D},
+  {0x201D, 0x201C},
+  {0x2039, 0x203A},
+  {0x203A, 0x2039},
+  {0x2045, 0x2046},
+  {0x2046, 0x2045},
+  {0x207D, 0x207E},
+  {0x207E, 0x207D},
+  {0x208D, 0x208E},
+  {0x208E, 0x208D},
+  {0x2208, 0x220B},
+  {0x2209, 0x220C},
+  {0x220A, 0x220D},
+  {0x220B, 0x2208},
+  {0x220C, 0x2209},
+  {0x220D, 0x220A},
+  {0x2215, 0x29F5},
+  {0x223C, 0x223D},
+  {0x223D, 0x223C},
+  {0x2243, 0x22CD},
+  {0x2252, 0x2253},
+  {0x2253, 0x2252},
+  {0x2254, 0x2255},
+  {0x2255, 0x2254},
+  {0x2264, 0x2265},
+  {0x2265, 0x2264},
+  {0x2266, 0x2267},
+  {0x2267, 0x2266},
+  {0x2268, 0x2269},
+  {0x2269, 0x2268},
+  {0x226A, 0x226B},
+  {0x226B, 0x226A},
+  {0x226E, 0x226F},
+  {0x226F, 0x226E},
+  {0x2270, 0x2271},
+  {0x2271, 0x2270},
+  {0x2272, 0x2273},
+  {0x2273, 0x2272},
+  {0x2274, 0x2275},
+  {0x2275, 0x2274},
+  {0x2276, 0x2277},
+  {0x2277, 0x2276},
+  {0x2278, 0x2279},
+  {0x2279, 0x2278},
+  {0x227A, 0x227B},
+  {0x227B, 0x227A},
+  {0x227C, 0x227D},
+  {0x227D, 0x227C},
+  {0x227E, 0x227F},
+  {0x227F, 0x227E},
+  {0x2280, 0x2281},
+  {0x2281, 0x2280},
+  {0x2282, 0x2283},
+  {0x2283, 0x2282},
+  {0x2284, 0x2285},
+  {0x2285, 0x2284},
+  {0x2286, 0x2287},
+  {0x2287, 0x2286},
+  {0x2288, 0x2289},
+  {0x2289, 0x2288},
+  {0x228A, 0x228B},
+  {0x228B, 0x228A},
+  {0x228F, 0x2290},
+  {0x2290, 0x228F},
+  {0x2291, 0x2292},
+  {0x2292, 0x2291},
+  {0x2298, 0x29B8},
+  {0x22A2, 0x22A3},
+  {0x22A3, 0x22A2},
+  {0x22A6, 0x2ADE},
+  {0x22A8, 0x2AE4},
+  {0x22A9, 0x2AE3},
+  {0x22AB, 0x2AE5},
+  {0x22B0, 0x22B1},
+  {0x22B1, 0x22B0},
+  {0x22B2, 0x22B3},
+  {0x22B3, 0x22B2},
+  {0x22B4, 0x22B5},
+  {0x22B5, 0x22B4},
+  {0x22B6, 0x22B7},
+  {0x22B7, 0x22B6},
+  {0x22C9, 0x22CA},
+  {0x22CA, 0x22C9},
+  {0x22CB, 0x22CC},
+  {0x22CC, 0x22CB},
+  {0x22CD, 0x2243},
+  {0x22D0, 0x22D1},
+  {0x22D1, 0x22D0},
+  {0x22D6, 0x22D7},
+  {0x22D7, 0x22D6},
+  {0x22D8, 0x22D9},
+  {0x22D9, 0x22D8},
+  {0x22DA, 0x22DB},
+  {0x22DB, 0x22DA},
+  {0x22DC, 0x22DD},
+  {0x22DD, 0x22DC},
+  {0x22DE, 0x22DF},
+  {0x22DF, 0x22DE},
+  {0x22E0, 0x22E1},
+  {0x22E1, 0x22E0},
+  {0x22E2, 0x22E3},
+  {0x22E3, 0x22E2},
+  {0x22E4, 0x22E5},
+  {0x22E5, 0x22E4},
+  {0x22E6, 0x22E7},
+  {0x22E7, 0x22E6},
+  {0x22E8, 0x22E9},
+  {0x22E9, 0x22E8},
+  {0x22EA, 0x22EB},
+  {0x22EB, 0x22EA},
+  {0x22EC, 0x22ED},
+  {0x22ED, 0x22EC},
+  {0x22F0, 0x22F1},
+  {0x22F1, 0x22F0},
+  {0x22F2, 0x22FA},
+  {0x22F3, 0x22FB},
+  {0x22F4, 0x22FC},
+  {0x22F6, 0x22FD},
+  {0x22F7, 0x22FE},
+  {0x22FA, 0x22F2},
+  {0x22FB, 0x22F3},
+  {0x22FC, 0x22F4},
+  {0x22FD, 0x22F6},
+  {0x22FE, 0x22F7},
+  {0x2308, 0x2309},
+  {0x2309, 0x2308},
+  {0x230A, 0x230B},
+  {0x230B, 0x230A},
+  {0x2329, 0x232A},
+  {0x232A, 0x2329},
+  {0x2768, 0x2769},
+  {0x2769, 0x2768},
+  {0x276A, 0x276B},
+  {0x276B, 0x276A},
+  {0x276C, 0x276D},
+  {0x276D, 0x276C},
+  {0x276E, 0x276F},
+  {0x276F, 0x276E},
+  {0x2770, 0x2771},
+  {0x2771, 0x2770},
+  {0x2772, 0x2773},
+  {0x2773, 0x2772},
+  {0x2774, 0x2775},
+  {0x2775, 0x2774},
+  {0x27C3, 0x27C4},
+  {0x27C4, 0x27C3},
+  {0x27C5, 0x27C6},
+  {0x27C6, 0x27C5},
+  {0x27D5, 0x27D6},
+  {0x27D6, 0x27D5},
+  {0x27DD, 0x27DE},
+  {0x27DE, 0x27DD},
+  {0x27E2, 0x27E3},
+  {0x27E3, 0x27E2},
+  {0x27E4, 0x27E5},
+  {0x27E5, 0x27E4},
+  {0x27E6, 0x27E7},
+  {0x27E7, 0x27E6},
+  {0x27E8, 0x27E9},
+  {0x27E9, 0x27E8},
+  {0x27EA, 0x27EB},
+  {0x27EB, 0x27EA},
+  {0x2983, 0x2984},
+  {0x2984, 0x2983},
+  {0x2985, 0x2986},
+  {0x2986, 0x2985},
+  {0x2987, 0x2988},
+  {0x2988, 0x2987},
+  {0x2989, 0x298A},
+  {0x298A, 0x2989},
+  {0x298B, 0x298C},
+  {0x298C, 0x298B},
+  {0x298D, 0x2990},
+  {0x298E, 0x298F},
+  {0x298F, 0x298E},
+  {0x2990, 0x298D},
+  {0x2991, 0x2992},
+  {0x2992, 0x2991},
+  {0x2993, 0x2994},
+  {0x2994, 0x2993},
+  {0x2995, 0x2996},
+  {0x2996, 0x2995},
+  {0x2997, 0x2998},
+  {0x2998, 0x2997},
+  {0x29B8, 0x2298},
+  {0x29C0, 0x29C1},
+  {0x29C1, 0x29C0},
+  {0x29C4, 0x29C5},
+  {0x29C5, 0x29C4},
+  {0x29CF, 0x29D0},
+  {0x29D0, 0x29CF},
+  {0x29D1, 0x29D2},
+  {0x29D2, 0x29D1},
+  {0x29D4, 0x29D5},
+  {0x29D5, 0x29D4},
+  {0x29D8, 0x29D9},
+  {0x29D9, 0x29D8},
+  {0x29DA, 0x29DB},
+  {0x29DB, 0x29DA},
+  {0x29F5, 0x2215},
+  {0x29F8, 0x29F9},
+  {0x29F9, 0x29F8},
+  {0x29FC, 0x29FD},
+  {0x29FD, 0x29FC},
+  {0x2A2B, 0x2A2C},
+  {0x2A2C, 0x2A2B},
+  {0x2A2D, 0x2A2E},
+  {0x2A2E, 0x2A2D},
+  {0x2A34, 0x2A35},
+  {0x2A35, 0x2A34},
+  {0x2A3C, 0x2A3D},
+  {0x2A3D, 0x2A3C},
+  {0x2A64, 0x2A65},
+  {0x2A65, 0x2A64},
+  {0x2A79, 0x2A7A},
+  {0x2A7A, 0x2A79},
+  {0x2A7D, 0x2A7E},
+  {0x2A7E, 0x2A7D},
+  {0x2A7F, 0x2A80},
+  {0x2A80, 0x2A7F},
+  {0x2A81, 0x2A82},
+  {0x2A82, 0x2A81},
+  {0x2A83, 0x2A84},
+  {0x2A84, 0x2A83},
+  {0x2A8B, 0x2A8C},
+  {0x2A8C, 0x2A8B},
+  {0x2A91, 0x2A92},
+  {0x2A92, 0x2A91},
+  {0x2A93, 0x2A94},
+  {0x2A94, 0x2A93},
+  {0x2A95, 0x2A96},
+  {0x2A96, 0x2A95},
+  {0x2A97, 0x2A98},
+  {0x2A98, 0x2A97},
+  {0x2A99, 0x2A9A},
+  {0x2A9A, 0x2A99},
+  {0x2A9B, 0x2A9C},
+  {0x2A9C, 0x2A9B},
+  {0x2AA1, 0x2AA2},
+  {0x2AA2, 0x2AA1},
+  {0x2AA6, 0x2AA7},
+  {0x2AA7, 0x2AA6},
+  {0x2AA8, 0x2AA9},
+  {0x2AA9, 0x2AA8},
+  {0x2AAA, 0x2AAB},
+  {0x2AAB, 0x2AAA},
+  {0x2AAC, 0x2AAD},
+  {0x2AAD, 0x2AAC},
+  {0x2AAF, 0x2AB0},
+  {0x2AB0, 0x2AAF},
+  {0x2AB3, 0x2AB4},
+  {0x2AB4, 0x2AB3},
+  {0x2ABB, 0x2ABC},
+  {0x2ABC, 0x2ABB},
+  {0x2ABD, 0x2ABE},
+  {0x2ABE, 0x2ABD},
+  {0x2ABF, 0x2AC0},
+  {0x2AC0, 0x2ABF},
+  {0x2AC1, 0x2AC2},
+  {0x2AC2, 0x2AC1},
+  {0x2AC3, 0x2AC4},
+  {0x2AC4, 0x2AC3},
+  {0x2AC5, 0x2AC6},
+  {0x2AC6, 0x2AC5},
+  {0x2ACD, 0x2ACE},
+  {0x2ACE, 0x2ACD},
+  {0x2ACF, 0x2AD0},
+  {0x2AD0, 0x2ACF},
+  {0x2AD1, 0x2AD2},
+  {0x2AD2, 0x2AD1},
+  {0x2AD3, 0x2AD4},
+  {0x2AD4, 0x2AD3},
+  {0x2AD5, 0x2AD6},
+  {0x2AD6, 0x2AD5},
+  {0x2ADE, 0x22A6},
+  {0x2AE3, 0x22A9},
+  {0x2AE4, 0x22A8},
+  {0x2AE5, 0x22AB},
+  {0x2AEC, 0x2AED},
+  {0x2AED, 0x2AEC},
+  {0x2AF7, 0x2AF8},
+  {0x2AF8, 0x2AF7},
+  {0x2AF9, 0x2AFA},
+  {0x2AFA, 0x2AF9},
+  {0x2E02, 0x2E03},
+  {0x2E03, 0x2E02},
+  {0x2E04, 0x2E05},
+  {0x2E05, 0x2E04},
+  {0x2E09, 0x2E0A},
+  {0x2E0A, 0x2E09},
+  {0x2E0C, 0x2E0D},
+  {0x2E0D, 0x2E0C},
+  {0x2E1C, 0x2E1D},
+  {0x2E1D, 0x2E1C},
+  {0x3008, 0x3009},
+  {0x3009, 0x3008},
+  {0x300A, 0x300B},
+  {0x300B, 0x300A},
+  {0x300C, 0x300D},
+  {0x300D, 0x300C},
+  {0x300E, 0x300F},
+  {0x300F, 0x300E},
+  {0x3010, 0x3011},
+  {0x3011, 0x3010},
+  {0x3014, 0x3015},
+  {0x3015, 0x3014},
+  {0x3016, 0x3017},
+  {0x3017, 0x3016},
+  {0x3018, 0x3019},
+  {0x3019, 0x3018},
+  {0x301A, 0x301B},
+  {0x301B, 0x301A},
+  {0x301D, 0x301E},
+  {0x301E, 0x301D},
+  {0xFE59, 0xFE5A},
+  {0xFE5A, 0xFE59},
+  {0xFE5B, 0xFE5C},
+  {0xFE5C, 0xFE5B},
+  {0xFE5D, 0xFE5E},
+  {0xFE5E, 0xFE5D},
+  {0xFE64, 0xFE65},
+  {0xFE65, 0xFE64},
+  {0xFF08, 0xFF09},
+  {0xFF09, 0xFF08},
+  {0xFF1C, 0xFF1E},
+  {0xFF1E, 0xFF1C},
+  {0xFF3B, 0xFF3D},
+  {0xFF3D, 0xFF3B},
+  {0xFF5B, 0xFF5D},
+  {0xFF5D, 0xFF5B},
+  {0xFF5F, 0xFF60},
+  {0xFF60, 0xFF5F},
+  {0xFF62, 0xFF63},
+  {0xFF63, 0xFF62},
+} ;
+
+/* *INDENT-ON* */
+
+const int nFriBidiMirroredChars = 352;
+
+
+#endif /* FRIBIDI_TAB_MIRRORING_I */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.c	2012-05-05 23:46:50.944763780 +0530
@@ -0,0 +1,126 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 2001,2002 Behdad Esfahbod. 
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <fwpg@sharif.edu>. 
+ */
+
+#ifdef HAVE_CONFIG_H
+//#include <config.h>
+#endif
+#include "fribidi.h"
+
+#ifdef DEBUG
+
+char
+fribidi_char_from_type (FriBidiCharType c)
+{
+  switch (c)
+    {
+    case FRIBIDI_TYPE_LTR:
+      return 'L';
+    case FRIBIDI_TYPE_RTL:
+      return 'R';
+    case FRIBIDI_TYPE_AL:
+      return 'A';
+
+    case FRIBIDI_TYPE_EN:
+      return '1';
+    case FRIBIDI_TYPE_AN:
+      return '9';
+    case FRIBIDI_TYPE_ES:
+      return 'w';
+    case FRIBIDI_TYPE_ET:
+      return 'w';
+    case FRIBIDI_TYPE_CS:
+      return 'w';
+    case FRIBIDI_TYPE_NSM:
+      return '`';
+    case FRIBIDI_TYPE_BN:
+      return 'b';
+
+    case FRIBIDI_TYPE_BS:
+      return 'B';
+    case FRIBIDI_TYPE_SS:
+      return 'S';
+    case FRIBIDI_TYPE_WS:
+      return '_';
+    case FRIBIDI_TYPE_ON:
+      return 'n';
+
+    case FRIBIDI_TYPE_LRE:
+      return '+';
+    case FRIBIDI_TYPE_RLE:
+      return '+';
+    case FRIBIDI_TYPE_LRO:
+      return '+';
+    case FRIBIDI_TYPE_RLO:
+      return '+';
+    case FRIBIDI_TYPE_PDF:
+      return '-';
+
+    default:
+      return '?';
+    }
+};
+
+#endif
+
+char *
+fribidi_type_name (FriBidiCharType c)
+{
+#define _FRIBIDI_CASE(type)	case FRIBIDI_TYPE_##type: return #type
+  switch (c)
+    {
+      _FRIBIDI_CASE (LTR);
+      _FRIBIDI_CASE (RTL);
+      _FRIBIDI_CASE (AL);
+
+      _FRIBIDI_CASE (EN);
+      _FRIBIDI_CASE (AN);
+      _FRIBIDI_CASE (ES);
+      _FRIBIDI_CASE (ET);
+      _FRIBIDI_CASE (CS);
+      _FRIBIDI_CASE (NSM);
+      _FRIBIDI_CASE (BN);
+
+      _FRIBIDI_CASE (BS);
+      _FRIBIDI_CASE (SS);
+      _FRIBIDI_CASE (WS);
+      _FRIBIDI_CASE (ON);
+
+      _FRIBIDI_CASE (LRE);
+      _FRIBIDI_CASE (RLE);
+      _FRIBIDI_CASE (LRO);
+      _FRIBIDI_CASE (RLO);
+      _FRIBIDI_CASE (PDF);
+
+      _FRIBIDI_CASE (SOT);
+      _FRIBIDI_CASE (EOT);
+
+    default:
+      return "?";
+    }
+#undef _FRIBIDI_CASE
+}
+
+/* Map fribidi_prop_types to fribidi_types. */
+const FriBidiCharType fribidi_prop_to_type[] = {
+#define _FRIBIDI_ADD_TYPE(TYPE) FRIBIDI_TYPE_##TYPE,
+#include "fribidi_types.i"
+#undef _FRIBIDI_ADD_TYPE
+};
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.h Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.h
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.h	2012-05-05 23:46:50.940763780 +0530
@@ -0,0 +1,331 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 1999,2000 Dov Grobgeld, and
+ * Copyright (C) 2001,2002 Behdad Esfahbod. 
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <dov@imagic.weizmann.ac.il> and 
+ * <fwpg@sharif.edu>. 
+ */
+#ifndef FRIBIDI_TYPES_H
+#define FRIBIDI_TYPES_H
+
+#include "fribidi_config.h"
+
+#define FRIBIDI_INT8	char
+#if FRIBIDI_SIZEOF_INT+0 == 2
+# define FRIBIDI_INT16	int
+#elif FRIBIDI_SIZEOF_SHORT+0 == 2
+# define FRIBIDI_INT16	short
+#else
+# error cannot determine a 16-bit integer type.  check fribidi_config.h
+#endif
+#if FRIBIDI_SIZEOF_INT+0 == 4
+# define FRIBIDI_INT32	int
+#elif FRIBIDI_SIZEOF_LONG+0 == 4
+# define FRIBIDI_INT32	long
+#else
+# error cannot determine a 32-bit integer type.  check fribidi_config.h
+#endif
+
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+  typedef int fribidi_boolean;
+
+  typedef signed FRIBIDI_INT8 fribidi_int8;
+  typedef unsigned FRIBIDI_INT8 fribidi_uint8;
+  typedef signed FRIBIDI_INT16 fribidi_int16;
+  typedef unsigned FRIBIDI_INT16 fribidi_uint16;
+  typedef signed FRIBIDI_INT32 fribidi_int32;
+  typedef unsigned FRIBIDI_INT32 fribidi_uint32;
+
+  typedef signed int fribidi_int;
+  typedef unsigned int fribidi_uint;
+
+
+  typedef fribidi_int8 FriBidiLevel;
+  typedef fribidi_uint32 FriBidiChar;
+  typedef fribidi_int FriBidiStrIndex;
+  typedef fribidi_int32 FriBidiMaskType;
+  typedef FriBidiMaskType FriBidiCharType;
+
+  char *fribidi_type_name (FriBidiCharType c);
+
+/* The following type is used by fribidi_utils */
+  typedef struct
+  {
+    FriBidiStrIndex length;
+    void *attribute;
+  }
+  FriBidiRunType;
+
+/* The following type is used by fribdi_utils */
+  typedef struct _FriBidiList FriBidiList;
+  struct _FriBidiList
+  {
+    void *data;
+    FriBidiList *next;
+    FriBidiList *prev;
+  };
+
+#ifndef FRIBIDI_MAX_STRING_LENGTH
+#define FRIBIDI_MAX_STRING_LENGTH (FriBidiStrIndex) \
+				  (sizeof (FriBidiStrIndex) == 2 ?	\
+    				   0x7FFE : (sizeof (FriBidiStrIndex) == 1 ? \
+					     0x7E : 0x7FFFFFFEL))
+#endif
+
+
+/* 
+ * Define some bit masks, that character types are based on, each one has
+ * only one bit on.
+ */
+
+/* Do not use enum, because 16bit processors do not allow 32bit enum values. */
+
+#define FRIBIDI_MASK_RTL	0x00000001L	/* Is right to left */
+#define FRIBIDI_MASK_ARABIC	0x00000002L	/* Is arabic */
+
+/* Each char can be only one of the three following. */
+#define FRIBIDI_MASK_STRONG	0x00000010L	/* Is strong */
+#define FRIBIDI_MASK_WEAK	0x00000020L	/* Is weak */
+#define FRIBIDI_MASK_NEUTRAL	0x00000040L	/* Is neutral */
+#define FRIBIDI_MASK_SENTINEL	0x00000080L	/* Is sentinel: SOT, EOT */
+/* Sentinels are not valid chars, just identify the start and end of strings. */
+
+/* Each char can be only one of the five following. */
+#define FRIBIDI_MASK_LETTER	0x00000100L	/* Is letter: L, R, AL */
+#define FRIBIDI_MASK_NUMBER	0x00000200L	/* Is number: EN, AN */
+#define FRIBIDI_MASK_NUMSEPTER	0x00000400L	/* Is number separator or terminator: ES, ET, CS */
+#define FRIBIDI_MASK_SPACE	0x00000800L	/* Is space: BN, BS, SS, WS */
+#define FRIBIDI_MASK_EXPLICIT	0x00001000L	/* Is expilict mark: LRE, RLE, LRO, RLO, PDF */
+
+/* Can be on only if FRIBIDI_MASK_SPACE is also on. */
+#define FRIBIDI_MASK_SEPARATOR	0x00002000L	/* Is test separator: BS, SS */
+/* Can be on only if FRIBIDI_MASK_EXPLICIT is also on. */
+#define FRIBIDI_MASK_OVERRIDE	0x00004000L	/* Is explicit override: LRO, RLO */
+
+/* The following must be to make types pairwise different, some of them can
+   be removed but are here because of efficiency (make queries faster). */
+
+#define FRIBIDI_MASK_ES		0x00010000L
+#define FRIBIDI_MASK_ET		0x00020000L
+#define FRIBIDI_MASK_CS		0x00040000L
+
+#define FRIBIDI_MASK_NSM	0x00080000L
+#define FRIBIDI_MASK_BN		0x00100000L
+
+#define FRIBIDI_MASK_BS		0x00200000L
+#define FRIBIDI_MASK_SS		0x00400000L
+#define FRIBIDI_MASK_WS		0x00800000L
+
+/* We reserve the sign bit for user's private use: we will never use it,
+   then negative character types will be never assigned. */
+
+
+/*
+ * Define values for FriBidiCharType
+ */
+
+/* Strong left to right */
+#define FRIBIDI_TYPE_LTR	( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_LETTER )
+/* Right to left characters */
+#define FRIBIDI_TYPE_RTL	( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_LETTER \
+				+ FRIBIDI_MASK_RTL)
+/* Arabic characters */
+#define FRIBIDI_TYPE_AL		( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_LETTER \
+				+ FRIBIDI_MASK_RTL + FRIBIDI_MASK_ARABIC )
+/* Left-To-Right embedding */
+#define FRIBIDI_TYPE_LRE	(FRIBIDI_MASK_STRONG + FRIBIDI_MASK_EXPLICIT)
+/* Right-To-Left embedding */
+#define FRIBIDI_TYPE_RLE	( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_EXPLICIT \
+				+ FRIBIDI_MASK_RTL )
+/* Left-To-Right override */
+#define FRIBIDI_TYPE_LRO	( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_EXPLICIT \
+				+ FRIBIDI_MASK_OVERRIDE )
+/* Right-To-Left override */
+#define FRIBIDI_TYPE_RLO	( FRIBIDI_MASK_STRONG + FRIBIDI_MASK_EXPLICIT \
+				+ FRIBIDI_MASK_RTL + FRIBIDI_MASK_OVERRIDE )
+
+/* Pop directional override */
+#define FRIBIDI_TYPE_PDF	( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_EXPLICIT )
+/* European digit */
+#define FRIBIDI_TYPE_EN		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NUMBER )
+/* Arabic digit */
+#define FRIBIDI_TYPE_AN		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NUMBER \
+				+ FRIBIDI_MASK_ARABIC )
+/* European number separator */
+#define FRIBIDI_TYPE_ES		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NUMSEPTER \
+				+ FRIBIDI_MASK_ES )
+/* European number terminator */
+#define FRIBIDI_TYPE_ET		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NUMSEPTER \
+				+ FRIBIDI_MASK_ET )
+/* Common Separator */
+#define FRIBIDI_TYPE_CS		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NUMSEPTER \
+				+ FRIBIDI_MASK_CS )
+/* Non spacing mark */
+#define FRIBIDI_TYPE_NSM	( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_NSM )
+/* Boundary neutral */
+#define FRIBIDI_TYPE_BN		(  FRIBIDI_MASK_WEAK + FRIBIDI_MASK_SPACE \
+				+ FRIBIDI_MASK_BN )
+
+/* Block separator */
+#define FRIBIDI_TYPE_BS		( FRIBIDI_MASK_NEUTRAL + FRIBIDI_MASK_SPACE \
+				+ FRIBIDI_MASK_SEPARATOR + FRIBIDI_MASK_BS )
+/* Segment separator */
+#define FRIBIDI_TYPE_SS		( FRIBIDI_MASK_NEUTRAL + FRIBIDI_MASK_SPACE \
+				+ FRIBIDI_MASK_SEPARATOR + FRIBIDI_MASK_SS )
+/* Whitespace */
+#define FRIBIDI_TYPE_WS		( FRIBIDI_MASK_NEUTRAL + FRIBIDI_MASK_SPACE \
+				+ FRIBIDI_MASK_WS )
+/* Other Neutral */
+#define FRIBIDI_TYPE_ON		( FRIBIDI_MASK_NEUTRAL )
+
+/* The following are used to identify the paragraph direction,
+   types L, R, N are not used internally anymore, and recommended to use
+   LTR, RTL and ON instead, didn't removed because of compatability. */
+#define FRIBIDI_TYPE_L		( FRIBIDI_TYPE_LTR )
+#define FRIBIDI_TYPE_R		( FRIBIDI_TYPE_RTL )
+#define FRIBIDI_TYPE_N		( FRIBIDI_TYPE_ON )
+/* Weak left to right */
+#define FRIBIDI_TYPE_WL		( FRIBIDI_MASK_WEAK )
+/* Weak right to left */
+#define FRIBIDI_TYPE_WR		( FRIBIDI_MASK_WEAK + FRIBIDI_MASK_RTL )
+
+/* The following are only used internally */
+
+/* Start of text */
+#define FRIBIDI_TYPE_SOT	( FRIBIDI_MASK_SENTINEL )
+/* End of text */
+#define FRIBIDI_TYPE_EOT	( FRIBIDI_MASK_SENTINEL + FRIBIDI_MASK_RTL )
+
+/*
+ * End of define values for FriBidiCharType
+ */
+
+
+/*
+ * Defining macros for needed queries, It is fully dependent on the 
+ * implementation of FriBidiCharType.
+ */
+
+
+/* Is private-use value? */
+#define FRIBIDI_TYPE_PRIVATE(p)	((p) < 0)
+
+/* Return the direction of the level number, FRIBIDI_TYPE_LTR for even and
+   FRIBIDI_TYPE_RTL for odds. */
+#define FRIBIDI_LEVEL_TO_DIR(lev) (FRIBIDI_TYPE_LTR | (lev & 1))
+
+/* Return the minimum level of the direction, 0 for FRIBIDI_TYPE_LTR and
+   1 for FRIBIDI_TYPE_RTL and FRIBIDI_TYPE_AL. */
+#define FRIBIDI_DIR_TO_LEVEL(dir) ((FriBidiLevel)(dir & 1))
+
+/* Is right to left? */
+#define FRIBIDI_IS_RTL(p)      ((p) & FRIBIDI_MASK_RTL)
+/* Is arabic? */
+#define FRIBIDI_IS_ARABIC(p)   ((p) & FRIBIDI_MASK_ARABIC)
+
+/* Is strong? */
+#define FRIBIDI_IS_STRONG(p)   ((p) & FRIBIDI_MASK_STRONG)
+/* Is weak? */
+#define FRIBIDI_IS_WEAK(p)     ((p) & FRIBIDI_MASK_WEAK)
+/* Is neutral? */
+#define FRIBIDI_IS_NEUTRAL(p)  ((p) & FRIBIDI_MASK_NEUTRAL)
+/* Is sentinel? */
+#define FRIBIDI_IS_SENTINEL(p) ((p) & FRIBIDI_MASK_SENTINEL)
+
+/* Is letter: L, R, AL? */
+#define FRIBIDI_IS_LETTER(p)   ((p) & FRIBIDI_MASK_LETTER)
+/* Is number: EN, AN? */
+#define FRIBIDI_IS_NUMBER(p)   ((p) & FRIBIDI_MASK_NUMBER)
+/* Is number separator or terminator: ES, ET, CS? */
+#define FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR(p) \
+	((p) & FRIBIDI_MASK_NUMSEPTER)
+/* Is space: BN, BS, SS, WS? */
+#define FRIBIDI_IS_SPACE(p)    ((p) & FRIBIDI_MASK_SPACE)
+/* Is explicit mark: LRE, RLE, LRO, RLO, PDF? */
+#define FRIBIDI_IS_EXPLICIT(p) ((p) & FRIBIDI_MASK_EXPLICIT)
+
+/* Is test separator: BS, SS? */
+#define FRIBIDI_IS_SEPARATOR(p) ((p) & FRIBIDI_MASK_SEPARATOR)
+
+/* Is explicit override: LRO, RLO? */
+#define FRIBIDI_IS_OVERRIDE(p) ((p) & FRIBIDI_MASK_OVERRIDE)
+
+/* Some more: */
+
+/* Is left to right letter: LTR? */
+#define FRIBIDI_IS_LTR_LETTER(p) \
+	((p) & (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL) == FRIBIDI_MASK_LETTER)
+
+/* Is right to left letter: RTL, AL? */
+#define FRIBIDI_IS_RTL_LETTER(p) \
+	((p) & (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL) \
+	== (FRIBIDI_MASK_LETTER | FRIBIDI_MASK_RTL))
+
+/* Is ES or CS: ES, CS? */
+#define FRIBIDI_IS_ES_OR_CS(p) \
+	((p) & (FRIBIDI_MASK_ES | FRIBIDI_MASK_CS))
+
+/* Is explicit or BN: LRE, RLE, LRO, RLO, PDF, BN? */
+#define FRIBIDI_IS_EXPLICIT_OR_BN(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_BN))
+
+/* Is explicit or separator or BN or WS: LRE, RLE, LRO, RLO, PDF, BS, SS, BN, WS? */
+#define FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(p) \
+	((p) & (FRIBIDI_MASK_EXPLICIT | FRIBIDI_MASK_SEPARATOR \
+		| FRIBIDI_MASK_BN | FRIBIDI_MASK_WS))
+
+/* Define some conversions. */
+
+/* Change numbers: EN, AN to RTL. */
+#define FRIBIDI_CHANGE_NUMBER_TO_RTL(p) \
+	(FRIBIDI_IS_NUMBER(p) ? FRIBIDI_TYPE_RTL : (p))
+
+/* Override status of an explicit mark: LRO->LTR, RLO->RTL, otherwise->ON. */
+#define FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR(p) \
+	(FRIBIDI_IS_OVERRIDE(p) ? FRIBIDI_LEVEL_TO_DIR(FRIBIDI_DIR_TO_LEVEL(p)) \
+				: FRIBIDI_TYPE_ON)
+
+
+/*
+ * Define character types that char_type_tables use.
+ * define them to be 0, 1, 2, ... and then in fribidi_char_type.c map them
+ * to FriBidiCharTypes.
+ */
+  typedef char FriBidiPropCharType;
+
+  enum FriBidiPropEnum
+  {
+#define _FRIBIDI_ADD_TYPE(TYPE) FRIBIDI_PROP_TYPE_##TYPE,
+#include "fribidi_types.i"
+#undef _FRIBIDI_ADD_TYPE
+    FRIBIDI_TYPES_COUNT		/* Number of different character types */
+  };
+
+/* Map fribidi_prop_types to fribidi_types */
+  extern const FriBidiCharType fribidi_prop_to_type[];
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.i Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.i
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_types.i	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_types.i	2012-05-05 23:46:50.940763780 +0530
@@ -0,0 +1,21 @@
+_FRIBIDI_ADD_TYPE(LTR)		/* Strong left to right */
+_FRIBIDI_ADD_TYPE(RTL)		/* Right to left characters */
+_FRIBIDI_ADD_TYPE(AL)		/* Arabic characters */
+_FRIBIDI_ADD_TYPE(LRE)		/* Left-To-Right embedding */
+_FRIBIDI_ADD_TYPE(RLE)		/* Right-To-Left embedding */
+_FRIBIDI_ADD_TYPE(LRO)		/* Left-To-Right override */
+_FRIBIDI_ADD_TYPE(RLO)		/* Right-To-Left override */
+_FRIBIDI_ADD_TYPE(PDF)		/* Pop directional override */
+_FRIBIDI_ADD_TYPE(EN)		/* European digit */
+_FRIBIDI_ADD_TYPE(AN)		/* Arabic digit */
+_FRIBIDI_ADD_TYPE(ES)		/* European number separator */
+_FRIBIDI_ADD_TYPE(ET)		/* European number terminator */
+_FRIBIDI_ADD_TYPE(CS)		/* Common Separator */
+_FRIBIDI_ADD_TYPE(NSM)		/* Non spacing mark */
+_FRIBIDI_ADD_TYPE(BN)		/* Boundary neutral */
+_FRIBIDI_ADD_TYPE(BS)		/* Block separator */
+_FRIBIDI_ADD_TYPE(SS)		/* Segment separator */
+_FRIBIDI_ADD_TYPE(WS)		/* Whitespace */
+_FRIBIDI_ADD_TYPE(ON)		/* Other Neutral */
+_FRIBIDI_ADD_TYPE(WL)		/* Weak left to right */
+_FRIBIDI_ADD_TYPE(WR)		/* Weak right to left */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_unicode.h Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_unicode.h
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_unicode.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_unicode.h	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,74 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 2001,2002,2005 Behdad Esfahbod.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public  
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,  
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of   
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License  
+ * along with this library, in a file named COPYING; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA
+ * 
+ * For licensing issues, contact <fwpg@sharif.edu>.
+ */
+
+#ifndef FRIBIDI_UNICODE_H
+#define FRIBIDI_UNICODE_H
+
+#include "fribidi_config.h"
+#include "fribidi_types.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Unicode version */
+#define FRIBIDI_UNICODE_CHARS	(sizeof(FriBidiChar) >= 4 ? 0x110000 : 0x10000)
+#define FRIBIDI_UNICODE_VERSION	"5.0.0"
+
+/* UAX#9 Unicode BiDirectional Algorithm */
+#define UNI_MAX_BIDI_LEVEL 61
+
+/* BiDirectional marks */
+#define UNI_LRM		0x200E
+#define UNI_RLM		0x200F
+#define UNI_LRE		0x202A
+#define UNI_RLE		0x202B
+#define UNI_PDF		0x202C
+#define UNI_LRO		0x202D
+#define UNI_RLO		0x202E
+
+/* Line and Paragraph separators */
+#define UNI_LS		0x2028
+#define UNI_PS		0x2029
+
+/* Joining marks */
+#define UNI_ZWNJ	0x200C
+#define UNI_ZWJ		0x200D
+
+/* Hebrew and Arabic */
+#define UNI_HEBREW_ALEF	0x05D0
+#define UNI_ARABIC_ALEF	0x0627
+#define UNI_ARABIC_ZERO	0x0660
+#define UNI_FARSI_ZERO	0x06F0
+
+/* wcwidth functions */
+  FRIBIDI_API int fribidi_wcwidth (FriBidiChar ch);
+  FRIBIDI_API int fribidi_wcswidth (const FriBidiChar *str,
+				    FriBidiStrIndex len);
+  FRIBIDI_API int fribidi_wcswidth_cjk (const FriBidiChar *str,
+					FriBidiStrIndex len);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif				/* FRIBIDI_UNICODE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_utils.c Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_utils.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/fribidi_utils.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/fribidi_utils.c	2012-05-05 23:46:50.943763780 +0530
@@ -0,0 +1,377 @@
+/* FriBidi - Library of BiDi algorithm
+ * Copyright (C) 1999,2000 Dov Grobgeld
+ * 
+ * This library is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU Lesser General Public 
+ * License as published by the Free Software Foundation; either 
+ * version 2.1 of the License, or (at your option) any later version. 
+ * 
+ * This library is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ * Lesser General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU Lesser General Public License 
+ * along with this library, in a file named COPYING; if not, write to the 
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA  
+ * 
+ * For licensing issues, contact <dov@imagic.weizmann.ac.il>.
+ */
+
+/*======================================================================
+ *  This file contains various utility functions that are commonly
+ *  needed by programs that implement BiDi functionality. The more
+ *  code that may be put here, the easier it is for the application
+ *  writers.
+ *----------------------------------------------------------------------*/
+
+#include <stdlib.h>
+#include "fribidi.h"
+#include "fribidi_mem.h"
+
+/*======================================================================
+ *  The find_visual_ranges() function is used to convert between a
+ *  continous span in either logical or visual space to a one, two, 
+ *  three, ..., sixty-three discontinous spans in the other space.
+ *  The function outputs the number of ranges needed to display the
+ *  mapped range as well as the resolved ranges.
+ *
+ *  The variable is_v2l_map indicates whether the position map is
+ *  is in the direction of visual-to-logical. This information is
+ *  needed in order to look up the correct character from the
+ *  embedding_level_list which is assumed to be in logical order.
+ *
+ *  This function is typically used to resolve a logical range to visual
+ *  ranges e.g. to display the selection.
+ *
+ *  TBD: it does not support vis2log_map parameter yet, also it should
+ *  merge the continous intervals found to one.
+ *
+ *  Example:
+ *     The selection is between logical characters 10 to 45. Calculate
+ *     the corresponding visual selection(s):
+ *
+ *     FriBidiStrIndex sel_span[2] = {10,45};
+ *
+ *     fribidi_map_range(sel_span,
+ *                       FRIBIDI_TRUE,
+ *                       length,
+ *                       vis2log_map,
+ *                       embedding_levels,
+ *                       // output
+ *                       &num_vis_ranges, *vis_ranges);
+ **----------------------------------------------------------------------*/
+FRIBIDI_API void
+fribidi_map_range (FriBidiStrIndex in_span[2],	/* Start and end span */
+		   FriBidiStrIndex len, fribidi_boolean is_v2l_map,	/* Needed for embedding_level */
+		   FriBidiStrIndex *position_map,
+		   FriBidiLevel *embedding_level_list,
+		   /* output */
+		   int *num_mapped_spans, FriBidiStrIndex mapped_spans[63][2])
+{
+  FriBidiStrIndex ch_idx;
+  fribidi_boolean in_range = FRIBIDI_FALSE;
+  FriBidiStrIndex start_idx = in_span[0];
+  FriBidiStrIndex end_idx = in_span[1];
+
+  if (start_idx == -1)
+    start_idx = 0;
+
+  if (end_idx == -1)
+    end_idx = len;
+
+  *num_mapped_spans = 0;
+
+  /* This is a loop in the source space of the map... */
+  for (ch_idx = 0; ch_idx <= len; ch_idx++)
+    {
+      FriBidiStrIndex mapped_pos;
+
+      if (ch_idx < len)
+	mapped_pos = position_map[ch_idx];
+      else
+	mapped_pos = -1;	/* Will cause log_pos < start_idx to trigger below */
+
+      if (!in_range && mapped_pos >= start_idx && mapped_pos < end_idx)
+	{
+	  in_range = FRIBIDI_TRUE;
+	  (*num_mapped_spans)++;
+	  mapped_spans[(*num_mapped_spans) - 1][0] = ch_idx;
+	}
+      else if (in_range && (mapped_pos < start_idx || mapped_pos >= end_idx))
+	{
+	  mapped_spans[(*num_mapped_spans) - 1][1] = ch_idx;
+	  in_range = FRIBIDI_FALSE;
+	}
+    }
+}
+
+/*======================================================================
+ *  fribidi_find_string_changes() finds the bounding box of the section
+ *  of characters that need redrawing. It returns the start and the
+ *  length of the section in the new string that needs redrawing.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API void
+fribidi_find_string_changes (	/* input */
+			      FriBidiChar *old_str,
+			      FriBidiStrIndex old_len,
+			      FriBidiChar *new_str, FriBidiStrIndex new_len,
+			      /* output */
+			      FriBidiStrIndex *change_start,
+			      FriBidiStrIndex *change_len)
+{
+  FriBidiStrIndex i, num_bol, num_eol;
+
+  /* Search forwards */
+  i = 0;
+  while (i < old_len && i < new_len && old_str[i] == new_str[i])
+    i++;
+  num_bol = i;
+
+  /* Search backwards */
+  i = 0;
+  while (i < old_len
+	 && i < new_len
+	 && old_str[old_len - 1 - i] == new_str[new_len - 1 - i])
+    i++;
+  num_eol = i;
+
+  /* Assign output */
+  *change_start = num_bol;
+  *change_len = new_len - num_eol - num_bol;
+}
+
+/*======================================================================
+ *  fribidi_xpos_resolve() does the complicated translation of
+ *  an x-coordinate, e.g. as received through a mouse press event,
+ *  to the logical and the visual position the xcoordinate is closest
+ *  to. It will also resolve the direction of the cursor according
+ *  to the embedding level of the closest character.
+ *
+ *  It does this through the following logics:
+ *  Here are the different possibilities:
+ *
+ *        Pointer              =>          Log Pos         Vis pos
+ *  
+ *     Before first vis char             log_pos(vis=0)L       0
+ *     After last vis char               log_pos(vis=n-1)R     n
+ *     Within 1/2 width of vis char i    log_pos(vis=i)L       i
+ *     Within last 1/2 width of vchar i  log_pos(vis=i)R       i+1
+ *     Border between vis chars i,i+1       resolve!           i+1
+ *
+ *  Input:
+ *     x_pos        The pixel position to be resolved measured in pixels.
+ *     x_offset     The x_offset is the pixel position of the left side
+ *                  of the leftmost visual character. 
+ *     len          The length of the embedding level, the vis2log and
+ *                  the char width arrays.
+ *     base_dir     The resolved base direction of the line.
+ *     vis2log      The vis2log mapping.
+ *                  x_position and the character widths. The position
+ *                  (x_pos-x_offset) is number of pixels from the left
+ *                  of logical character 0.
+ *     char_widths  Width in pixels of each character. Note that the
+ *                  widths should be provided in logical order.
+ *
+ *  Output:
+ *     res_log_pos  Resolved logical position.
+ *     res_vis_pos  Resolved visual position
+ *     res_cursor_x_pos   The resolved pixel position to the left or
+ *                  the right of the character position x_pos.
+ *     res_cursor_dir_is_rtl   Whether the resolved dir of the character
+ *                  at position x_pos is rtl.
+ *     res_attach_before  Whether the x_pos is cutting the bounding
+ *                  box in such a way that the visual cursor should be
+ *                  be positioned before the following logical character.
+ *                  Note that in the bidi context, the positions "after
+ *                  a logical character" and "before the following logical
+ *                  character" is not necessarily the same. If x_pos is
+ *                  beyond the end of the line, res_attach_before is true.
+ *
+ *----------------------------------------------------------------------*/
+FRIBIDI_API void
+fribidi_xpos_resolve (int x_pos,
+		      int x_offset,
+		      FriBidiStrIndex len,
+		      FriBidiLevel *embedding_level_list,
+		      FriBidiCharType base_dir,
+		      FriBidiStrIndex *vis2log, int *char_widths,
+		      /* output */
+		      FriBidiStrIndex *res_log_pos,
+		      FriBidiStrIndex *res_vis_pos,
+		      int *res_cursor_x_pos,
+		      fribidi_boolean *res_cursor_dir_is_rtl,
+		      fribidi_boolean *res_attach_before)
+{
+  int char_width_sum = 0;
+  FriBidiStrIndex char_idx;
+
+  char_width_sum = 0;
+  *res_vis_pos = 0;
+
+  /* Check if we are to the left of the line bounding box */
+  if (x_pos < x_offset)
+    {
+      *res_cursor_dir_is_rtl = (base_dir == FRIBIDI_TYPE_RTL);
+      if (*res_cursor_dir_is_rtl)
+	*res_log_pos = len;
+      else
+	*res_log_pos = 0;
+
+      *res_cursor_x_pos = x_offset;
+      *res_vis_pos = 0;
+      *res_attach_before = 1;
+    }
+  else
+    {
+      /* Find the cursor pos by a linear search on the row */
+      for (char_idx = 0; char_idx < len; char_idx++)
+	{
+	  FriBidiStrIndex log_pos = vis2log[char_idx];
+	  int char_width = char_widths[log_pos];
+
+	  if (x_offset + char_width_sum + char_width > x_pos)
+	    {
+	      /* Found position */
+	      *res_cursor_dir_is_rtl =
+		fribidi_is_char_rtl (embedding_level_list, base_dir, log_pos);
+	      /* Are we in the left hand side of the clicked character? */
+	      if (x_pos - (x_offset + char_width_sum + char_width / 2) < 0)
+		{
+		  /* RTL? */
+		  if (*res_cursor_dir_is_rtl)
+		    {
+		      log_pos++;
+		      *res_attach_before = FRIBIDI_FALSE;
+		    }
+		  /* LTR */
+		  else
+		    *res_attach_before = FRIBIDI_TRUE;
+		  *res_cursor_x_pos = x_offset + char_width_sum;
+		}
+	      /* We are in the right hand side. */
+	      else
+		{
+		  /* LTR? */
+		  if (!*res_cursor_dir_is_rtl)
+		    {
+		      log_pos++;
+		      *res_attach_before = FRIBIDI_FALSE;
+		    }
+		  /* RTL */
+		  else
+		    *res_attach_before = FRIBIDI_TRUE;
+
+		  *res_cursor_x_pos = x_offset + char_width_sum + char_width;
+		  (*res_vis_pos)++;
+		}
+	      *res_log_pos = log_pos;
+	      break;
+	    }
+	  char_width_sum += char_width;
+	  (*res_vis_pos)++;
+	}
+
+      /* If we still haven't found the position we are to the left of the
+         character bounding box */
+      if (char_idx == len)
+	{
+	  *res_cursor_dir_is_rtl = (base_dir == FRIBIDI_TYPE_RTL);
+
+	  if (*res_cursor_dir_is_rtl)
+	    *res_log_pos = 0;
+	  else
+	    *res_log_pos = len;
+	  *res_cursor_x_pos = char_width_sum + x_offset;
+	  *res_vis_pos = len;
+	  *res_attach_before = FRIBIDI_TRUE;
+	}
+    }
+
+  /*  printf("x l,v = %d %d,%d\n", *res_cursor_x_pos, *res_log_pos, *res_vis_pos); */
+
+}
+
+/*======================================================================
+ *  fribidi_is_char_rtl() answers the question whether a character
+ *  was resolved in the rtl direction. This simply involves asking
+ *  if the embedding level for the character is odd.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API fribidi_boolean
+fribidi_is_char_rtl (FriBidiLevel *embedding_level_list,
+		     FriBidiCharType base_dir, FriBidiStrIndex idx)
+{
+  if (!embedding_level_list || idx < 0)
+    return FRIBIDI_IS_RTL (base_dir);
+  /* Otherwise check if the embedding level is odd */
+  else
+    return embedding_level_list[idx] % 2;
+}
+
+/*======================================================================
+ *  fribidi_runs_log2vis takes a list of logical runs and returns a
+ *  a list of visual runs. A run is defined as a sequence that has
+ *  the same attributes.
+ *----------------------------------------------------------------------*/
+FRIBIDI_API void
+fribidi_runs_log2vis (		/* input */
+		       FriBidiList *logical_runs,	/* List of FriBidiRunType */
+		       FriBidiStrIndex len, FriBidiStrIndex *log2vis, FriBidiCharType base_dir,	/* TBD: remove it, not needed */
+		       /* output */
+		       FriBidiList **visual_runs)
+{
+  void **visual_attribs = (void **) malloc (sizeof (void *) * len);
+  void *current_attrib;
+  FriBidiStrIndex pos, i;
+  FriBidiList *list, *last;
+  FriBidiStrIndex current_idx;
+
+
+  /* 1. Open up the runlength encoded list and at the same time apply
+     the log2vis map. The result is a visual array of attributes.
+   */
+  pos = 0;
+  list = logical_runs;
+  while (list)
+    {
+      FriBidiRunType *run = (FriBidiRunType *) (list->data);
+      FriBidiStrIndex length = run->length;
+      void *attrib = run->attribute;
+
+      for (i = pos; i < pos + length; i++)
+	visual_attribs[log2vis[i]] = attrib;
+      list = list->next;
+    }
+
+  /* 2. Run length encode the resulting attributes. */
+  *visual_runs = last = NULL;
+  current_attrib = visual_attribs[0];
+  current_idx = 0;
+  for (i = 0; i <= len; i++)
+    {
+      if (i == len || current_attrib != visual_attribs[i])
+	{
+	  FriBidiRunType *run =
+	    (FriBidiRunType *) malloc (sizeof (FriBidiRunType));
+	  run->length = i - current_idx;
+	  run->attribute = current_attrib;
+
+	  /* Keeping track of the last node is crucial for efficiency
+	     for long lists... */
+	  if (last == NULL)
+	    last = *visual_runs = fribidi_list_append (NULL, run);
+	  else
+	    {
+	      fribidi_list_append (last, run);
+	      last = last->next;
+	    }
+	  if (i == len)
+	    break;
+
+	  current_attrib = visual_attribs[i];
+	  current_idx = i;
+	}
+    }
+  free (visual_attribs);
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/wcwidth.c Scribus_1.5_indic/scribus/third_party/fribidi/wcwidth.c
--- Scribus_1.5_120815/scribus/third_party/fribidi/wcwidth.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/wcwidth.c	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,309 @@
+/*
+ * This is an implementation of wcwidth() and wcswidth() (defined in
+ * IEEE Std 1002.1-2001) for Unicode.
+ *
+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
+ *
+ * In fixed-width output devices, Latin characters all occupy a single
+ * "cell" position of equal width, whereas ideographic CJK characters
+ * occupy two such cells. Interoperability between terminal-line
+ * applications and (teletype-style) character terminals using the
+ * UTF-8 encoding requires agreement on which character should advance
+ * the cursor by how many cell positions. No established formal
+ * standards exist at present on which Unicode character shall occupy
+ * how many cell positions on character terminals. These routines are
+ * a first attempt of defining such behavior based on simple rules
+ * applied to data provided by the Unicode Consortium.
+ *
+ * For some graphical characters, the Unicode standard explicitly
+ * defines a character-cell width via the definition of the East Asian
+ * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.
+ * In all these cases, there is no ambiguity about which width a
+ * terminal shall use. For characters in the East Asian Ambiguous (A)
+ * class, the width choice depends purely on a preference of backward
+ * compatibility with either historic CJK or Western practice.
+ * Choosing single-width for these characters is easy to justify as
+ * the appropriate long-term solution, as the CJK practice of
+ * displaying these characters as double-width comes from historic
+ * implementation simplicity (8-bit encoded characters were displayed
+ * single-width and 16-bit ones double-width, even for Greek,
+ * Cyrillic, etc.) and not any typographic considerations.
+ *
+ * Much less clear is the choice of width for the Not East Asian
+ * (Neutral) class. Existing practice does not dictate a width for any
+ * of these characters. It would nevertheless make sense
+ * typographically to allocate two character cells to characters such
+ * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be
+ * represented adequately with a single-width glyph. The following
+ * routines at present merely assign a single-cell width to all
+ * neutral characters, in the interest of simplicity. This is not
+ * entirely satisfactory and should be reconsidered before
+ * establishing a formal standard in this area. At the moment, the
+ * decision which Not East Asian (Neutral) characters should be
+ * represented by double-width glyphs cannot yet be answered by
+ * applying a simple rule from the Unicode database content. Setting
+ * up a proper standard for the behavior of UTF-8 character terminals
+ * will require a careful analysis not only of each Unicode character,
+ * but also of each presentation form, something the author of these
+ * routines has avoided to do so far.
+ *
+ * http://www.unicode.org/unicode/reports/tr11/
+ *
+ * Markus Kuhn -- 2007-05-25 (Unicode 5.0)
+ *
+ * Permission to use, copy, modify, and distribute this software
+ * for any purpose and without fee is hereby granted. The author
+ * disclaims all warranties with regard to this software.
+ *
+ * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
+ */
+
+#include "wcwidth.i"
+
+struct interval {
+  int first;
+  int last;
+};
+
+/* auxiliary function for binary search in interval table */
+static int bisearch(wchar_t ucs, const struct interval *table, int max) {
+  int min = 0;
+  int mid;
+
+  if (ucs < table[0].first || ucs > table[max].last)
+    return 0;
+  while (max >= min) {
+    mid = (min + max) / 2;
+    if (ucs > table[mid].last)
+      min = mid + 1;
+    else if (ucs < table[mid].first)
+      max = mid - 1;
+    else
+      return 1;
+  }
+
+  return 0;
+}
+
+
+/* The following two functions define the column width of an ISO 10646
+ * character as follows:
+ *
+ *    - The null character (U+0000) has a column width of 0.
+ *
+ *    - Other C0/C1 control characters and DEL will lead to a return
+ *      value of -1.
+ *
+ *    - Non-spacing and enclosing combining characters (general
+ *      category code Mn or Me in the Unicode database) have a
+ *      column width of 0.
+ *
+ *    - SOFT HYPHEN (U+00AD) has a column width of 1.
+ *
+ *    - Other format characters (general category code Cf in the Unicode
+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
+ *
+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
+ *      have a column width of 0.
+ *
+ *    - Spacing characters in the East Asian Wide (W) or East Asian
+ *      Full-width (F) category as defined in Unicode Technical
+ *      Report #11 have a column width of 2.
+ *
+ *    - All remaining characters (including all printable
+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,
+ *      etc.) have a column width of 1.
+ *
+ * This implementation assumes that wchar_t characters are encoded
+ * in ISO 10646.
+ */
+
+int mk_wcwidth(wchar_t ucs)
+{
+  /* sorted list of non-overlapping intervals of non-spacing characters */
+  /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
+  static const struct interval combining[] = {
+    { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },
+    { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
+    { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },
+    { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },
+    { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
+    { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
+    { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },
+    { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },
+    { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },
+    { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },
+    { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },
+    { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },
+    { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },
+    { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },
+    { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },
+    { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },
+    { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },
+    { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },
+    { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },
+    { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
+    { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },
+    { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },
+    { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },
+    { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },
+    { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },
+    { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },
+    { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },
+    { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },
+    { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },
+    { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },
+    { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },
+    { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },
+    { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },
+    { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },
+    { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },
+    { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },
+    { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },
+    { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },
+    { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },
+    { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },
+    { 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },
+    { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },
+    { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },
+    { 0x10A01, 0x10A03 }, { 0x10A05, 0x10A06 }, { 0x10A0C, 0x10A0F },
+    { 0x10A38, 0x10A3A }, { 0x10A3F, 0x10A3F }, { 0x1D167, 0x1D169 },
+    { 0x1D173, 0x1D182 }, { 0x1D185, 0x1D18B }, { 0x1D1AA, 0x1D1AD },
+    { 0x1D242, 0x1D244 }, { 0xE0001, 0xE0001 }, { 0xE0020, 0xE007F },
+    { 0xE0100, 0xE01EF }
+  };
+
+  /* test for 8-bit control characters */
+  if (ucs == 0)
+    return 0;
+  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
+    return -1;
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, combining,
+	       sizeof(combining) / sizeof(struct interval) - 1))
+    return 0;
+
+  /* if we arrive here, ucs is not a combining or C0/C1 control character */
+
+  return 1 + 
+    (ucs >= 0x1100 &&
+     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
+      ucs == 0x2329 || ucs == 0x232a ||
+      (ucs >= 0x2e80 && ucs <= 0xa4cf &&
+       ucs != 0x303f) ||                  /* CJK ... Yi */
+      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
+      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
+      (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
+      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
+      (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
+      (ucs >= 0xffe0 && ucs <= 0xffe6) ||
+      (ucs >= 0x20000 && ucs <= 0x2fffd) ||
+      (ucs >= 0x30000 && ucs <= 0x3fffd)));
+}
+
+
+int mk_wcswidth(const wchar_t *pwcs, size_t n)
+{
+  int w, width = 0;
+
+  for (;*pwcs && n-- > 0; pwcs++)
+    if ((w = mk_wcwidth(*pwcs)) < 0)
+      return -1;
+    else
+      width += w;
+
+  return width;
+}
+
+
+/*
+ * The following functions are the same as mk_wcwidth() and
+ * mk_wcwidth_cjk(), except that spacing characters in the East Asian
+ * Ambiguous (A) category as defined in Unicode Technical Report #11
+ * have a column width of 2. This variant might be useful for users of
+ * CJK legacy encodings who want to migrate to UCS without changing
+ * the traditional terminal character-width behaviour. It is not
+ * otherwise recommended for general use.
+ */
+static int mk_wcwidth_cjk(wchar_t ucs)
+{
+  /* sorted list of non-overlapping intervals of East Asian Ambiguous
+   * characters, generated by "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c" */
+  static const struct interval ambiguous[] = {
+    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },
+    { 0x00AA, 0x00AA }, { 0x00AE, 0x00AE }, { 0x00B0, 0x00B4 },
+    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },
+    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },
+    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },
+    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },
+    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },
+    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },
+    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },
+    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },
+    { 0x0148, 0x014B }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },
+    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },
+    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },
+    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },
+    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },
+    { 0x02C4, 0x02C4 }, { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB },
+    { 0x02CD, 0x02CD }, { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB },
+    { 0x02DD, 0x02DD }, { 0x02DF, 0x02DF }, { 0x0391, 0x03A1 },
+    { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 }, { 0x03C3, 0x03C9 },
+    { 0x0401, 0x0401 }, { 0x0410, 0x044F }, { 0x0451, 0x0451 },
+    { 0x2010, 0x2010 }, { 0x2013, 0x2016 }, { 0x2018, 0x2019 },
+    { 0x201C, 0x201D }, { 0x2020, 0x2022 }, { 0x2024, 0x2027 },
+    { 0x2030, 0x2030 }, { 0x2032, 0x2033 }, { 0x2035, 0x2035 },
+    { 0x203B, 0x203B }, { 0x203E, 0x203E }, { 0x2074, 0x2074 },
+    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },
+    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },
+    { 0x2113, 0x2113 }, { 0x2116, 0x2116 }, { 0x2121, 0x2122 },
+    { 0x2126, 0x2126 }, { 0x212B, 0x212B }, { 0x2153, 0x2154 },
+    { 0x215B, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },
+    { 0x2190, 0x2199 }, { 0x21B8, 0x21B9 }, { 0x21D2, 0x21D2 },
+    { 0x21D4, 0x21D4 }, { 0x21E7, 0x21E7 }, { 0x2200, 0x2200 },
+    { 0x2202, 0x2203 }, { 0x2207, 0x2208 }, { 0x220B, 0x220B },
+    { 0x220F, 0x220F }, { 0x2211, 0x2211 }, { 0x2215, 0x2215 },
+    { 0x221A, 0x221A }, { 0x221D, 0x2220 }, { 0x2223, 0x2223 },
+    { 0x2225, 0x2225 }, { 0x2227, 0x222C }, { 0x222E, 0x222E },
+    { 0x2234, 0x2237 }, { 0x223C, 0x223D }, { 0x2248, 0x2248 },
+    { 0x224C, 0x224C }, { 0x2252, 0x2252 }, { 0x2260, 0x2261 },
+    { 0x2264, 0x2267 }, { 0x226A, 0x226B }, { 0x226E, 0x226F },
+    { 0x2282, 0x2283 }, { 0x2286, 0x2287 }, { 0x2295, 0x2295 },
+    { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 }, { 0x22BF, 0x22BF },
+    { 0x2312, 0x2312 }, { 0x2460, 0x24E9 }, { 0x24EB, 0x254B },
+    { 0x2550, 0x2573 }, { 0x2580, 0x258F }, { 0x2592, 0x2595 },
+    { 0x25A0, 0x25A1 }, { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 },
+    { 0x25B6, 0x25B7 }, { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 },
+    { 0x25C6, 0x25C8 }, { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 },
+    { 0x25E2, 0x25E5 }, { 0x25EF, 0x25EF }, { 0x2605, 0x2606 },
+    { 0x2609, 0x2609 }, { 0x260E, 0x260F }, { 0x2614, 0x2615 },
+    { 0x261C, 0x261C }, { 0x261E, 0x261E }, { 0x2640, 0x2640 },
+    { 0x2642, 0x2642 }, { 0x2660, 0x2661 }, { 0x2663, 0x2665 },
+    { 0x2667, 0x266A }, { 0x266C, 0x266D }, { 0x266F, 0x266F },
+    { 0x273D, 0x273D }, { 0x2776, 0x277F }, { 0xE000, 0xF8FF },
+    { 0xFFFD, 0xFFFD }, { 0xF0000, 0xFFFFD }, { 0x100000, 0x10FFFD }
+  };
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, ambiguous,
+	       sizeof(ambiguous) / sizeof(struct interval) - 1))
+    return 2;
+
+  return mk_wcwidth(ucs);
+}
+
+
+int mk_wcswidth_cjk(const wchar_t *pwcs, size_t n)
+{
+  int w, width = 0;
+
+  for (;*pwcs && n-- > 0; pwcs++)
+    if ((w = mk_wcwidth_cjk(*pwcs)) < 0)
+      return -1;
+    else
+      width += w;
+
+  return width;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/fribidi/wcwidth.i Scribus_1.5_indic/scribus/third_party/fribidi/wcwidth.i
--- Scribus_1.5_120815/scribus/third_party/fribidi/wcwidth.i	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/fribidi/wcwidth.i	2012-05-05 23:46:50.942763780 +0530
@@ -0,0 +1,9 @@
+#include "fribidi.h"
+
+#define	mk_wcwidth	FRIBIDI_API fribidi_wcwidth
+#define	mk_wcswidth	FRIBIDI_API fribidi_wcswidth
+#define	mk_wcwidth_cjk	FRIBIDI_API fribidi_wcwidth_cjk
+#define	mk_wcswidth_cjk	FRIBIDI_API fribidi_wcswidth_cjk
+
+#define wchar_t		FriBidiChar
+#define size_t		FriBidiStrIndex
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-c-linkage-decls.sh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-c-linkage-decls.sh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-c-linkage-decls.sh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-c-linkage-decls.sh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+test "x$HBHEADERS" = x && HBHEADERS=`find . -maxdepth 1 -name 'hb*.h'`
+
+
+for x in $HBHEADERS; do
+	test -f $srcdir/$x && x=$srcdir/$x
+	if ! grep -q HB_BEGIN_DECLS "$x" || ! grep -q HB_END_DECLS "$x"; then
+		echo "Ouch, file $x does not HB_BEGIN_DECLS / HB_END_DECLS"
+		stat=1
+	fi
+done
+
+exit $stat
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-header-guards.sh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-header-guards.sh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-header-guards.sh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-header-guards.sh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+test "x$HBHEADERS" = x && HBHEADERS=`find . -maxdepth 1 -name 'hb*.h'`
+test "x$HBSOURCES" = x && HBSOURCES=`find . -maxdepth 1 -name 'hb-*.cc' -or -name 'hb-*.hh'`
+
+
+for x in $HBHEADERS $HBSOURCES; do
+	test -f "$srcdir/$x" && x="$srcdir/$x"
+	echo "$x" | grep '[^h]$' -q && continue;
+	xx=`echo "$x" | sed 's@.*/@@'`
+	tag=`echo "$xx" | tr 'a-z.-' 'A-Z_'`
+	lines=`grep "\<$tag\>" "$x" | wc -l | sed 's/[ 	]*//g'`
+	if test "x$lines" != x3; then
+		echo "Ouch, header file $x does not have correct preprocessor guards"
+		stat=1
+	fi
+done
+
+exit $stat
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-includes.sh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-includes.sh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-includes.sh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-includes.sh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,42 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+test "x$HBHEADERS" = x && HBHEADERS=`find . -maxdepth 1 -name 'hb*.h'`
+test "x$HBSOURCES" = x && HBSOURCES=`find . -maxdepth 1 -name 'hb-*.cc' -or -name 'hb-*.hh'`
+
+
+cd "$srcdir"
+
+
+echo 'Checking that public header files #include "hb-common.h" or "hb.h" first (or none)'
+
+for x in $HBHEADERS; do
+	grep '#.*\<include\>' "$x" /dev/null | head -n 1
+done |
+grep -v '"hb-common[.]h"' |
+grep -v '"hb[.]h"' |
+grep -v 'hb-common[.]h:' |
+grep -v 'hb[.]h:' |
+grep . >&2 && stat=1
+
+
+echo 'Checking that source files #include "hb-*private.hh" first (or none)'
+
+for x in $HBSOURCES; do
+	grep '#.*\<include\>' "$x" /dev/null | head -n 1
+done |
+grep -v '"hb-.*private[.]hh"' |
+grep -v 'hb-private[.]hh:' |
+grep . >&2 && stat=1
+
+
+echo 'Checking that there is no #include <hb.*.h>'
+grep '#.*\<include\>.*<.*hb' $HBHEADERS $HBSOURCES >&2 && stat=1
+
+
+exit $stat
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-internal-symbols.sh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-internal-symbols.sh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-internal-symbols.sh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-internal-symbols.sh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+
+if which nm 2>/dev/null >/dev/null; then
+	:
+else
+	echo "check-internal-symbols.sh: 'nm' not found; skipping test"
+	exit 77
+fi
+
+tested=false
+for suffix in so; do
+	so=.libs/libharfbuzz.$suffix
+	if test -f "$so"; then
+		echo "Checking that we are exposing internal symbols"
+		if nm $so | grep ' T ' | grep -v ' T _fini\>\| T _init\>\| T hb_'; then
+			echo "Ouch, internal symbols exposed"
+			stat=1
+		fi
+		tested=true
+	fi
+done
+if ! $tested; then
+	echo "check-internal-symbols.sh: libharfbuzz shared library not found; skipping test"
+	exit 77
+fi
+
+exit $stat
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-libstdc++.sh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-libstdc++.sh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/check-libstdc++.sh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/check-libstdc++.sh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+LC_ALL=C
+export LC_ALL
+
+test -z "$srcdir" && srcdir=.
+stat=0
+
+
+if which ldd 2>/dev/null >/dev/null; then
+	:
+else
+	echo "check-libstdc++.sh: 'ldd' not found; skipping test"
+	exit 77
+fi
+
+tested=false
+for suffix in so dylib; do
+	so=.libs/libharfbuzz.$suffix
+	if test -f "$so"; then
+		echo "Checking that we are not linking to libstdc++"
+		if ldd $so | grep 'libstdc[+][+]'; then
+			echo "Ouch, linked to libstdc++"
+			stat=1
+		fi
+		tested=true
+	fi
+done
+if ! $tested; then
+	echo "check-internal-symbols.sh: libharfbuzz shared library not found; skipping test"
+	exit 77
+fi
+
+exit $stat
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/CMakeLists.txt Scribus_1.5_indic/scribus/third_party/harfbuzz/src/CMakeLists.txt
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/CMakeLists.txt	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/CMakeLists.txt	2012-08-14 11:52:44.308260521 +0530
@@ -0,0 +1,51 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}
+${FREETYPE_INCLUDE_DIRS}
+)
+
+SET(LIB_TYPE STATIC)
+
+add_definitions( -DHAVE_OT=1 )
+
+#No condition needed, main CMakeLists already checked for FT
+SET(HBSOURCES_FT
+hb-ft.cc
+)
+
+SET(HBSOURCES
+hb-blob.cc
+hb-buffer.cc
+hb-common.cc
+hb-font.cc
+hb-shape.cc
+hb-unicode.cc
+hb-ot-tag.cc
+hb-ot-layout.cc
+hb-fallback-shape.cc
+hb-font.cc
+hb-graphite2.cc
+hb-icu.cc
+hb-ot-layout.cc
+hb-ot-map.cc
+hb-ot-shape.cc
+hb-ot-shape-complex-arabic.cc
+hb-ot-shape-complex-indic.cc
+hb-ot-shape-complex-misc.cc
+hb-ot-shape-normalize.cc
+hb-tt-font.cc
+# hb-uniscribe.cc
+hb-warning.cc
+#hbotlayout_class.cpp
+${HBSOURCES_FT}
+)
+
+
+SET(SCRIBUS_HARFBUZZ_LIB "scribus_harfbuzz_lib")
+ADD_LIBRARY(${SCRIBUS_HARFBUZZ_LIB} STATIC ${HBSOURCES})
+
+# This is a convenience library that for linkage purposes is part of Scribus's
+# main API.
+SET_TARGET_PROPERTIES(${SCRIBUS_HARFBUZZ_LIB}
+  PROPERTIES
+  COMPILE_FLAGS -DCOMPILE_SCRIBUS_MAIN_APP
+  )
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/gen-arabic-table.py Scribus_1.5_indic/scribus/third_party/harfbuzz/src/gen-arabic-table.py
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/gen-arabic-table.py	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/gen-arabic-table.py	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,197 @@
+#!/usr/bin/python
+
+import sys
+import os.path
+
+if len (sys.argv) != 3:
+	print >>sys.stderr, "usage: ./gen-arabic-table.py ArabicShaping.txt UnicodeData.txt"
+	sys.exit (1)
+
+files = [file (x) for x in sys.argv[1:]]
+
+headers = [[files[0].readline (), files[0].readline ()]]
+headers.append (["UnicodeData.txt does not have a header."])
+while files[0].readline ().find ('##################') < 0:
+	pass
+
+
+def print_joining_table(f):
+
+	print
+	print "static const uint8_t joining_table[] ="
+	print "{"
+
+	min_u = 0x110000
+	max_u = 0
+	num = 0
+	last = -1
+	block = ''
+	for line in f:
+
+		if line[0] == '#':
+			if line.find (" characters"):
+				block = line[2:].strip ()
+			continue
+
+		fields = [x.strip () for x in line.split (';')]
+		if len (fields) == 1:
+			continue
+
+		u = int (fields[0], 16)
+		if u == 0x200C or u == 0x200D:
+			continue
+		if u < last:
+			raise Exception ("Input data character not sorted", u)
+		min_u = min (min_u, u)
+		max_u = max (max_u, u)
+		num += 1
+
+		if block:
+			print "\n  /* %s */\n" % block
+			block = ''
+
+		if last != -1:
+			last += 1
+			while last < u:
+				print "  JOINING_TYPE_X, /* %04X */" % last
+				last += 1
+		else:
+			last = u
+
+		if fields[3] in ["ALAPH", "DALATH RISH"]:
+			value = "JOINING_GROUP_" + fields[3].replace(' ', '_')
+		else:
+			value = "JOINING_TYPE_" + fields[2]
+		print "  %s, /* %s */" % (value, '; '.join(fields))
+
+	print
+	print "};"
+	print
+	print "#define JOINING_TABLE_FIRST	0x%04X" % min_u
+	print "#define JOINING_TABLE_LAST	0x%04X" % max_u
+	print
+
+	occupancy = num * 100 / (max_u - min_u + 1)
+	# Maintain at least 40% occupancy in the table */
+	if occupancy < 40:
+		raise Exception ("Table too sparse, please investigate: ", occupancy)
+
+def print_shaping_table(f):
+
+	shapes = {}
+	ligatures = {}
+	names = {}
+	for line in f:
+
+		fields = [x.strip () for x in line.split (';')]
+		if fields[5][0:1] != '<':
+			continue
+
+		items = fields[5].split (' ')
+		shape, items = items[0][1:-1], tuple (int (x, 16) for x in items[1:])
+
+		if not shape in ['initial', 'medial', 'isolated', 'final']:
+			continue
+
+		c = int (fields[0], 16)
+		if len (items) != 1:
+			# We only care about lam-alef ligatures
+			if len (items) != 2 or items[0] != 0x0644 or items[1] not in [0x0622, 0x0623, 0x0625, 0x0627]:
+				continue
+
+			# Save ligature
+			names[c] = fields[1]
+			if items not in ligatures:
+				ligatures[items] = {}
+			ligatures[items][shape] = c
+			pass
+		else:
+			# Save shape
+			if items[0] not in names:
+				names[items[0]] = fields[1]
+			else:
+				names[items[0]] = os.path.commonprefix ([names[items[0]], fields[1]]).strip ()
+			if items[0] not in shapes:
+				shapes[items[0]] = {}
+			shapes[items[0]][shape] = c
+
+	print
+	print "static const uint16_t shaping_table[][4] ="
+	print "{"
+
+	keys = shapes.keys ()
+	min_u, max_u = min (keys), max (keys)
+	for u in range (min_u, max_u + 1):
+		s = [shapes[u][shape] if u in shapes and shape in shapes[u] else u
+		     for shape in  ['initial', 'medial', 'final', 'isolated']]
+		value = ', '.join ("0x%04X" % c for c in s)
+		print "  {%s}, /* U+%04X %s */" % (value, u, names[u] if u in names else "")
+
+	print "};"
+	print
+	print "#define SHAPING_TABLE_FIRST	0x%04X" % min_u
+	print "#define SHAPING_TABLE_LAST	0x%04X" % max_u
+	print
+
+	ligas = {}
+	for pair in ligatures.keys ():
+		for shape in ligatures[pair]:
+			c = ligatures[pair][shape]
+			if shape == 'isolated':
+				liga = (shapes[pair[0]]['initial'], shapes[pair[1]]['final'])
+			elif shape == 'final':
+				liga = (shapes[pair[0]]['medial'], shapes[pair[1]]['final'])
+			else:
+				raise Exception ("Unexpected shape", shape)
+			if liga[0] not in ligas:
+				ligas[liga[0]] = []
+			ligas[liga[0]].append ((liga[1], c))
+	max_i = max (len (ligas[l]) for l in ligas)
+	print
+	print "static const struct {"
+	print " uint16_t first;"
+	print " struct {"
+	print "   uint16_t second;"
+	print "   uint16_t ligature;"
+	print " } ligatures[%d];" % max_i
+	print "} ligature_table[] ="
+	print "{"
+	keys = ligas.keys ()
+	keys.sort ()
+	for first in keys:
+
+		print "  { 0x%04X, {" % (first)
+		for liga in ligas[first]:
+			print "    { 0x%04X, 0x%04X }, /* %s */" % (liga[0], liga[1], names[liga[1]])
+		print "  }},"
+
+	print "};"
+	print
+
+
+
+print "/* == Start of generated table == */"
+print "/*"
+print " * The following table is generated by running:"
+print " *"
+print " *   ./gen-arabic-table.py ArabicShaping.txt UnicodeData.txt"
+print " *"
+print " * on files with these headers:"
+print " *"
+for h in headers:
+	for l in h:
+		print " * %s" % (l.strip())
+print " */"
+print
+print "#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH"
+print "#define HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH"
+print
+
+print_joining_table (files[0])
+print_shaping_table (files[1])
+
+print
+print "#endif /* HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH */"
+print
+print "/* == End of generated table == */"
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/gen-indic-table.py Scribus_1.5_indic/scribus/third_party/harfbuzz/src/gen-indic-table.py
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/gen-indic-table.py	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/gen-indic-table.py	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,211 @@
+#!/usr/bin/python
+
+import sys
+
+if len (sys.argv) != 4:
+	print >>sys.stderr, "usage: ./gen-indic-table.py IndicSyllabicCategory.txt IndicMatraCategory.txt Blocks.txt"
+	sys.exit (1)
+
+files = [file (x) for x in sys.argv[1:]]
+
+headers = [[f.readline () for i in range (2)] for f in files]
+
+blocks = {}
+data = [{} for f in files]
+values = [{} for f in files]
+for i, f in enumerate (files):
+	for line in f:
+
+		j = line.find ('#')
+		if j >= 0:
+			line = line[:j]
+
+		fields = [x.strip () for x in line.split (';')]
+		if len (fields) == 1:
+			continue
+
+		uu = fields[0].split ('..')
+		start = int (uu[0], 16)
+		if len (uu) == 1:
+			end = start
+		else:
+			end = int (uu[1], 16)
+
+		t = fields[1]
+
+		for u in range (start, end + 1):
+			data[i][u] = t
+		values[i][t] = values[i].get (t, 0) + 1
+
+		if i == 2:
+			blocks[t] = (start, end)
+
+# Merge data into one dict:
+defaults = ('Other', 'Not_Applicable', 'No_Block')
+for i,v in enumerate (defaults):
+	values[i][v] = values[i].get (v, 0) + 1
+combined = {}
+for i,d in enumerate (data):
+	for u,v in d.items ():
+		if i == 2 and not u in combined:
+			continue
+		if not u in combined:
+			combined[u] = list (defaults)
+		combined[u][i] = v
+data = combined
+del combined
+num = len (data)
+
+# Move the outliers NO-BREAK SPACE and DOTTED CIRCLE out
+singles = {}
+for u in [0x00A0, 0x25CC]:
+	singles[u] = data[u]
+	del data[u]
+
+print "/* == Start of generated table == */"
+print "/*"
+print " * The following table is generated by running:"
+print " *"
+print " *   ./gen-indic-table.py IndicSyllabicCategory.txt IndicMatraCategory.txt Blocks.txt"
+print " *"
+print " * on files with these headers:"
+print " *"
+for h in headers:
+	for l in h:
+		print " * %s" % (l.strip())
+print " */"
+print
+print "#ifndef HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH"
+print "#define HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH"
+print
+
+# Shorten values
+short = [{
+	"Bindu":		'Bi',
+	"Visarga":		'Vs',
+	"Vowel":		'Vo',
+	"Vowel_Dependent":	'M',
+	"Other":		'x',
+},{
+	"Not_Applicable":	'x',
+}]
+all_shorts = [[],[]]
+
+# Add some of the values, to make them more readable, and to avoid duplicates
+
+
+for i in range (2):
+	for v,s in short[i].items ():
+		all_shorts[i].append (s)
+
+what = ["INDIC_SYLLABIC_CATEGORY", "INDIC_MATRA_CATEGORY"]
+what_short = ["ISC", "IMC"]
+for i in range (2):
+	print
+	vv = values[i].keys ()
+	vv.sort ()
+	for v in vv:
+		v_no_and = v.replace ('_And_', '_')
+		if v in short[i]:
+			s = short[i][v]
+		else:
+			s = ''.join ([c for c in v_no_and if ord ('A') <= ord (c) <= ord ('Z')])
+			if s in all_shorts[i]:
+				raise Exception ("Duplicate short value alias", v, s)
+			all_shorts[i].append (s)
+			short[i][v] = s
+		print "#define %s_%s	%s_%s	%s/* %3d chars; %s */" % \
+			(what_short[i], s, what[i], v.upper (), \
+			'	'* ((48-1 - len (what[i]) - 1 - len (v)) / 8), \
+			values[i][v], v)
+print
+print "#define _(S,M) INDIC_COMBINE_CATEGORIES (ISC_##S, IMC_##M)"
+print
+print
+
+total = 0
+used = 0
+def print_block (block, start, end, data):
+	print
+	print
+	print "  /* %s  (%04X..%04X) */" % (block, start, end)
+	num = 0
+	for u in range (start, end+1):
+		if u % 8 == 0:
+			print
+			print "  /* %04X */" % u,
+		if u in data:
+			num += 1
+		d = data.get (u, defaults)
+		sys.stdout.write ("%9s" % ("_(%s,%s)," % (short[0][d[0]], short[1][d[1]])))
+
+	global total, used
+	total += end - start + 1
+	used += num
+
+uu = data.keys ()
+uu.sort ()
+
+last = -1
+num = 0
+offset = 0
+starts = []
+ends = []
+print "static const INDIC_TABLE_ELEMENT_TYPE indic_table[] = {"
+for u in uu:
+	if u <= last:
+		continue
+	block = data[u][2]
+	(start, end) = blocks[block]
+
+	if start != last + 1:
+		if start - last <= 33:
+			print_block ("FILLER", last+1, start-1, data)
+			last = start-1
+		else:
+			if last >= 0:
+				ends.append (last + 1)
+				offset += ends[-1] - starts[-1]
+			print
+			print
+			print "#define indic_offset_0x%04x %d" % (start, offset)
+			starts.append (start)
+
+	print_block (block, start, end, data)
+	last = end
+ends.append (last + 1)
+offset += ends[-1] - starts[-1]
+print
+print
+print "#define indic_offset_total %d" % offset
+print
+occupancy = used * 100. / total
+print "}; /* Table occupancy: %d%% */" % occupancy
+print
+print "static INDIC_TABLE_ELEMENT_TYPE"
+print "get_indic_categories (hb_codepoint_t u)"
+print "{"
+for (start,end) in zip (starts, ends):
+	offset = "indic_offset_0x%04x" % start
+	print "  if (0x%04X <= u && u <= 0x%04X) return indic_table[u - 0x%04X + %s];" % (start, end, start, offset)
+for u,d in singles.items ():
+	print "  if (unlikely (u == 0x%04X)) return _(%s,%s);" % (u, short[0][d[0]], short[1][d[1]])
+print "  return _(x,x);"
+print "}"
+print
+print "#undef _"
+for i in range (2):
+	print
+	vv = values[i].keys ()
+	vv.sort ()
+	for v in vv:
+		print "#undef %s_%s" % \
+			(what_short[i], short[i][v])
+print
+print "#endif /* HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH */"
+print
+print "/* == End of generated table == */"
+
+# Maintain at least 30% occupancy in the table */
+if occupancy < 30:
+	raise Exception ("Table too sparse, please investigate: ", occupancy)
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.c	2012-05-05 23:46:51.514763796 +0530
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-blob-private.h"
+
+#ifdef HAVE_SYS_MMAN_H
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#include <sys/mman.h>
+#endif /* HAVE_SYS_MMAN_H */
+
+#include <stdio.h>
+#include <errno.h>
+
+HB_BEGIN_DECLS
+
+
+#ifndef HB_DEBUG_BLOB
+#define HB_DEBUG_BLOB HB_DEBUG+0
+#endif
+
+hb_blob_t _hb_blob_nil = {
+  HB_REFERENCE_COUNT_INVALID, /* ref_count */
+
+  0, /* length */
+
+  HB_MUTEX_INIT, /* lock */
+
+  0, /* lock_count */
+  HB_MEMORY_MODE_READONLY, /* mode */
+
+  NULL, /* data */
+
+  NULL, /* destroy */
+  NULL /* user_data */
+};
+
+static void
+_hb_blob_destroy_user_data (hb_blob_t *blob)
+{
+  if (blob->destroy) {
+    blob->destroy (blob->user_data);
+    blob->destroy = NULL;
+    blob->user_data = NULL;
+  }
+}
+
+static void
+_hb_blob_unlock_and_destroy (hb_blob_t *blob)
+{
+  hb_blob_unlock (blob);
+  hb_blob_destroy (blob);
+}
+
+hb_blob_t *
+hb_blob_create (const char        *data,
+		unsigned int       length,
+		hb_memory_mode_t   mode,
+		hb_destroy_func_t  destroy,
+		void              *user_data)
+{
+  hb_blob_t *blob;
+
+  if (!length || !HB_OBJECT_DO_CREATE (hb_blob_t, blob)) {
+    if (destroy)
+      destroy (user_data);
+    return &_hb_blob_nil;
+  }
+
+  hb_mutex_init (blob->lock);
+  blob->lock_count = 0;
+
+  blob->data = data;
+  blob->length = length;
+  blob->mode = mode;
+
+  blob->destroy = destroy;
+  blob->user_data = user_data;
+
+  if (blob->mode == HB_MEMORY_MODE_DUPLICATE) {
+    blob->mode = HB_MEMORY_MODE_READONLY;
+    if (!hb_blob_try_writable (blob)) {
+      hb_blob_destroy (blob);
+      return &_hb_blob_nil;
+    }
+  }
+
+  return blob;
+}
+
+hb_blob_t *
+hb_blob_create_sub_blob (hb_blob_t    *parent,
+			 unsigned int  offset,
+			 unsigned int  length)
+{
+  hb_blob_t *blob;
+  const char *pdata;
+
+  if (!length || offset >= parent->length || !HB_OBJECT_DO_CREATE (hb_blob_t, blob))
+    return &_hb_blob_nil;
+
+  pdata = hb_blob_lock (parent);
+
+  blob->data = pdata + offset;
+  blob->length = MIN (length, parent->length - offset);
+
+  hb_mutex_lock (parent->lock);
+  blob->mode = parent->mode;
+  hb_mutex_unlock (parent->lock);
+
+  blob->destroy = (hb_destroy_func_t) _hb_blob_unlock_and_destroy;
+  blob->user_data = hb_blob_reference (parent);
+
+  return blob;
+}
+
+hb_blob_t *
+hb_blob_create_empty (void)
+{
+  return &_hb_blob_nil;
+}
+
+hb_blob_t *
+hb_blob_reference (hb_blob_t *blob)
+{
+  HB_OBJECT_DO_REFERENCE (blob);
+}
+
+unsigned int
+hb_blob_get_reference_count (hb_blob_t *blob)
+{
+  HB_OBJECT_DO_GET_REFERENCE_COUNT (blob);
+}
+
+void
+hb_blob_destroy (hb_blob_t *blob)
+{
+  HB_OBJECT_DO_DESTROY (blob);
+
+  _hb_blob_destroy_user_data (blob);
+
+  free (blob);
+}
+
+unsigned int
+hb_blob_get_length (hb_blob_t *blob)
+{
+  return blob->length;
+}
+
+const char *
+hb_blob_lock (hb_blob_t *blob)
+{
+  if (HB_OBJECT_IS_INERT (blob))
+    return NULL;
+
+  hb_mutex_lock (blob->lock);
+
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s (%d) -> %p\n", blob, __FUNCTION__,
+	     blob->lock_count, blob->data);
+
+  blob->lock_count++;
+
+  hb_mutex_unlock (blob->lock);
+
+  return blob->data;
+}
+
+void
+hb_blob_unlock (hb_blob_t *blob)
+{
+  if (HB_OBJECT_IS_INERT (blob))
+    return;
+
+  hb_mutex_lock (blob->lock);
+
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s (%d) -> %p\n", blob, __FUNCTION__,
+	     blob->lock_count, blob->data);
+
+  assert (blob->lock_count > 0);
+  blob->lock_count--;
+
+  hb_mutex_unlock (blob->lock);
+}
+
+hb_bool_t
+hb_blob_is_writable (hb_blob_t *blob)
+{
+  hb_memory_mode_t mode;
+
+  if (HB_OBJECT_IS_INERT (blob))
+    return FALSE;
+
+  hb_mutex_lock (blob->lock);
+
+  mode = blob->mode;
+
+  hb_mutex_unlock (blob->lock);
+
+  return mode == HB_MEMORY_MODE_WRITABLE;
+}
+
+
+static hb_bool_t
+_try_make_writable_inplace_unix_locked (hb_blob_t *blob)
+{
+#if defined(HAVE_SYS_MMAN_H) && defined(HAVE_MPROTECT)
+  uintptr_t pagesize = -1, mask, length;
+  const char *addr;
+
+#if defined(HAVE_SYSCONF) && defined(_SC_PAGE_SIZE)
+  pagesize = (uintptr_t) sysconf (_SC_PAGE_SIZE);
+#elif defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
+  pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);
+#elif defined(HAVE_GETPAGESIZE)
+  pagesize = (uintptr_t) getpagesize ();
+#endif
+
+  if ((uintptr_t) -1L == pagesize) {
+    if (HB_DEBUG_BLOB)
+      fprintf (stderr, "%p %s: failed to get pagesize: %s\n", blob, __FUNCTION__, strerror (errno));
+    return FALSE;
+  }
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s: pagesize is %lu\n", blob, __FUNCTION__, (unsigned long) pagesize);
+
+  mask = ~(pagesize-1);
+  addr = (const char *) (((uintptr_t) blob->data) & mask);
+  length = (const char *) (((uintptr_t) blob->data + blob->length + pagesize-1) & mask)  - addr;
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s: calling mprotect on [%p..%p] (%lu bytes)\n",
+	     blob, __FUNCTION__,
+	     addr, addr+length, (unsigned long) length);
+  if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {
+    if (HB_DEBUG_BLOB)
+      fprintf (stderr, "%p %s: %s\n", blob, __FUNCTION__, strerror (errno));
+    return FALSE;
+  }
+
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s: successfully made [%p..%p] (%lu bytes) writable\n",
+	     blob, __FUNCTION__,
+	     addr, addr+length, (unsigned long) length);
+  return TRUE;
+#else
+  return FALSE;
+#endif
+}
+
+static void
+try_writable_inplace_locked (hb_blob_t *blob)
+{
+  if (HB_DEBUG_BLOB)
+    fprintf (stderr, "%p %s: making writable\n", blob, __FUNCTION__);
+
+  if (_try_make_writable_inplace_unix_locked (blob)) {
+    if (HB_DEBUG_BLOB)
+      fprintf (stderr, "%p %s: making writable -> succeeded\n", blob, __FUNCTION__);
+    blob->mode = HB_MEMORY_MODE_WRITABLE;
+  } else {
+    if (HB_DEBUG_BLOB)
+      fprintf (stderr, "%p %s: making writable -> FAILED\n", blob, __FUNCTION__);
+    /* Failed to make writable inplace, mark that */
+    blob->mode = HB_MEMORY_MODE_READONLY;
+  }
+}
+
+hb_bool_t
+hb_blob_try_writable_inplace (hb_blob_t *blob)
+{
+  hb_memory_mode_t mode;
+
+  if (HB_OBJECT_IS_INERT (blob))
+    return FALSE;
+
+  hb_mutex_lock (blob->lock);
+
+  if (blob->mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE)
+    try_writable_inplace_locked (blob);
+
+  mode = blob->mode;
+
+  hb_mutex_unlock (blob->lock);
+
+  return mode == HB_MEMORY_MODE_WRITABLE;
+}
+
+hb_bool_t
+hb_blob_try_writable (hb_blob_t *blob)
+{
+  hb_memory_mode_t mode;
+
+  if (HB_OBJECT_IS_INERT (blob))
+    return FALSE;
+
+  hb_mutex_lock (blob->lock);
+
+  if (blob->mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE)
+    try_writable_inplace_locked (blob);
+
+  if (blob->mode == HB_MEMORY_MODE_READONLY)
+  {
+    char *new_data;
+
+    if (HB_DEBUG_BLOB)
+      fprintf (stderr, "%p %s (%d) -> %p\n", blob, __FUNCTION__,
+	       blob->lock_count, blob->data);
+
+    if (blob->lock_count)
+      goto done;
+
+    new_data = malloc (blob->length);
+    if (new_data) {
+      if (HB_DEBUG_BLOB)
+	fprintf (stderr, "%p %s: dupped successfully -> %p\n", blob, __FUNCTION__, blob->data);
+      memcpy (new_data, blob->data, blob->length);
+      _hb_blob_destroy_user_data (blob);
+      blob->mode = HB_MEMORY_MODE_WRITABLE;
+      blob->data = new_data;
+      blob->destroy = free;
+      blob->user_data = new_data;
+    }
+  }
+
+done:
+  mode = blob->mode;
+
+  hb_mutex_unlock (blob->lock);
+
+  return mode == HB_MEMORY_MODE_WRITABLE;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,324 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-blob.h"
+#include "hb-object-private.hh"
+
+#ifdef HAVE_SYS_MMAN_H
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#include <sys/mman.h>
+#endif /* HAVE_SYS_MMAN_H */
+
+#include <stdio.h>
+#include <errno.h>
+
+
+
+#ifndef HB_DEBUG_BLOB
+#define HB_DEBUG_BLOB (HB_DEBUG+0)
+#endif
+
+
+struct _hb_blob_t {
+  hb_object_header_t header;
+
+  bool immutable;
+
+  const char *data;
+  unsigned int length;
+  hb_memory_mode_t mode;
+
+  void *user_data;
+  hb_destroy_func_t destroy;
+};
+
+static hb_blob_t _hb_blob_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  NULL, /* data */
+  0, /* length */
+  HB_MEMORY_MODE_READONLY, /* mode */
+
+  NULL, /* user_data */
+  NULL  /* destroy */
+};
+
+
+static bool _try_writable (hb_blob_t *blob);
+
+static void
+_hb_blob_destroy_user_data (hb_blob_t *blob)
+{
+  if (blob->destroy) {
+    blob->destroy (blob->user_data);
+    blob->user_data = NULL;
+    blob->destroy = NULL;
+  }
+}
+
+hb_blob_t *
+hb_blob_create (const char        *data,
+		unsigned int       length,
+		hb_memory_mode_t   mode,
+		void              *user_data,
+		hb_destroy_func_t  destroy)
+{
+  hb_blob_t *blob;
+
+  if (!length || !(blob = hb_object_create<hb_blob_t> ())) {
+    if (destroy)
+      destroy (user_data);
+    return &_hb_blob_nil;
+  }
+
+  blob->data = data;
+  blob->length = length;
+  blob->mode = mode;
+
+  blob->user_data = user_data;
+  blob->destroy = destroy;
+
+  if (blob->mode == HB_MEMORY_MODE_DUPLICATE) {
+    blob->mode = HB_MEMORY_MODE_READONLY;
+    if (!_try_writable (blob)) {
+      hb_blob_destroy (blob);
+      return &_hb_blob_nil;
+    }
+  }
+
+  return blob;
+}
+
+hb_blob_t *
+hb_blob_create_sub_blob (hb_blob_t    *parent,
+			 unsigned int  offset,
+			 unsigned int  length)
+{
+  hb_blob_t *blob;
+
+  if (!length || offset >= parent->length)
+    return &_hb_blob_nil;
+
+  hb_blob_make_immutable (parent);
+
+  blob = hb_blob_create (parent->data + offset,
+			 MIN (length, parent->length - offset),
+			 parent->mode,
+			 hb_blob_reference (parent),
+			 (hb_destroy_func_t) hb_blob_destroy);
+
+  return blob;
+}
+
+hb_blob_t *
+hb_blob_get_empty (void)
+{
+  return &_hb_blob_nil;
+}
+
+hb_blob_t *
+hb_blob_reference (hb_blob_t *blob)
+{
+  return hb_object_reference (blob);
+}
+
+void
+hb_blob_destroy (hb_blob_t *blob)
+{
+  if (!hb_object_destroy (blob)) return;
+
+  _hb_blob_destroy_user_data (blob);
+
+  free (blob);
+}
+
+hb_bool_t
+hb_blob_set_user_data (hb_blob_t          *blob,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace)
+{
+  return hb_object_set_user_data (blob, key, data, destroy, replace);
+}
+
+void *
+hb_blob_get_user_data (hb_blob_t          *blob,
+		       hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (blob, key);
+}
+
+
+void
+hb_blob_make_immutable (hb_blob_t *blob)
+{
+  if (hb_object_is_inert (blob))
+    return;
+
+  blob->immutable = TRUE;
+}
+
+hb_bool_t
+hb_blob_is_immutable (hb_blob_t *blob)
+{
+  return blob->immutable;
+}
+
+
+unsigned int
+hb_blob_get_length (hb_blob_t *blob)
+{
+  return blob->length;
+}
+
+const char *
+hb_blob_get_data (hb_blob_t *blob, unsigned int *length)
+{
+  if (length)
+    *length = blob->length;
+
+  return blob->data;
+}
+
+char *
+hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length)
+{
+  if (!_try_writable (blob)) {
+    if (length)
+      *length = 0;
+
+    return NULL;
+  }
+
+  if (length)
+    *length = blob->length;
+
+  return const_cast<char *> (blob->data);
+}
+
+
+static hb_bool_t
+_try_make_writable_inplace_unix (hb_blob_t *blob)
+{
+#if defined(HAVE_SYS_MMAN_H) && defined(HAVE_MPROTECT)
+  uintptr_t pagesize = -1, mask, length;
+  const char *addr;
+
+#if defined(HAVE_SYSCONF) && defined(_SC_PAGE_SIZE)
+  pagesize = (uintptr_t) sysconf (_SC_PAGE_SIZE);
+#elif defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
+  pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);
+#elif defined(HAVE_GETPAGESIZE)
+  pagesize = (uintptr_t) getpagesize ();
+#endif
+
+  if ((uintptr_t) -1L == pagesize) {
+    DEBUG_MSG_FUNC (BLOB, blob, "failed to get pagesize: %s", strerror (errno));
+    return FALSE;
+  }
+  DEBUG_MSG_FUNC (BLOB, blob, "pagesize is %lu", (unsigned long) pagesize);
+
+  mask = ~(pagesize-1);
+  addr = (const char *) (((uintptr_t) blob->data) & mask);
+  length = (const char *) (((uintptr_t) blob->data + blob->length + pagesize-1) & mask)  - addr;
+  DEBUG_MSG_FUNC (BLOB, blob,
+		  "calling mprotect on [%p..%p] (%lu bytes)",
+		  addr, addr+length, (unsigned long) length);
+  if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {
+    DEBUG_MSG_FUNC (BLOB, blob, "mprotect failed: %s", strerror (errno));
+    return FALSE;
+  }
+
+  blob->mode = HB_MEMORY_MODE_WRITABLE;
+
+  DEBUG_MSG_FUNC (BLOB, blob,
+		  "successfully made [%p..%p] (%lu bytes) writable\n",
+		  addr, addr+length, (unsigned long) length);
+  return TRUE;
+#else
+  return FALSE;
+#endif
+}
+
+static bool
+_try_writable_inplace (hb_blob_t *blob)
+{
+  DEBUG_MSG_FUNC (BLOB, blob, "making writable inplace\n");
+
+  if (_try_make_writable_inplace_unix (blob))
+    return TRUE;
+
+  DEBUG_MSG_FUNC (BLOB, blob, "making writable -> FAILED\n");
+
+  /* Failed to make writable inplace, mark that */
+  blob->mode = HB_MEMORY_MODE_READONLY;
+  return FALSE;
+}
+
+static bool
+_try_writable (hb_blob_t *blob)
+{
+  if (blob->immutable)
+    return FALSE;
+
+  if (blob->mode == HB_MEMORY_MODE_WRITABLE)
+    return TRUE;
+
+  if (blob->mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE && _try_writable_inplace (blob))
+    return TRUE;
+
+  if (blob->mode == HB_MEMORY_MODE_WRITABLE)
+    return TRUE;
+
+
+  DEBUG_MSG_FUNC (BLOB, blob, "current data is -> %p\n", blob->data);
+
+  char *new_data;
+
+  new_data = (char *) malloc (blob->length);
+  if (unlikely (!new_data))
+    return FALSE;
+
+  DEBUG_MSG_FUNC (BLOB, blob, "dupped successfully -> %p\n", blob->data);
+
+  memcpy (new_data, blob->data, blob->length);
+  _hb_blob_destroy_user_data (blob);
+  blob->mode = HB_MEMORY_MODE_WRITABLE;
+  blob->data = new_data;
+  blob->user_data = new_data;
+  blob->destroy = free;
+
+  return TRUE;
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,101 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_BLOB_H
+#define HB_BLOB_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+typedef enum {
+  HB_MEMORY_MODE_DUPLICATE,
+  HB_MEMORY_MODE_READONLY,
+  HB_MEMORY_MODE_WRITABLE,
+  HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
+} hb_memory_mode_t;
+
+typedef struct _hb_blob_t hb_blob_t;
+
+hb_blob_t *
+hb_blob_create (const char        *data,
+		unsigned int       length,
+		hb_memory_mode_t   mode,
+		void              *user_data,
+		hb_destroy_func_t  destroy);
+
+hb_blob_t *
+hb_blob_create_sub_blob (hb_blob_t    *parent,
+			 unsigned int  offset,
+			 unsigned int  length);
+
+hb_blob_t *
+hb_blob_get_empty (void);
+
+hb_blob_t *
+hb_blob_reference (hb_blob_t *blob);
+
+void
+hb_blob_destroy (hb_blob_t *blob);
+
+hb_bool_t
+hb_blob_set_user_data (hb_blob_t          *blob,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace);
+
+
+void *
+hb_blob_get_user_data (hb_blob_t          *blob,
+		       hb_user_data_key_t *key);
+
+
+void
+hb_blob_make_immutable (hb_blob_t *blob);
+
+hb_bool_t
+hb_blob_is_immutable (hb_blob_t *blob);
+
+
+unsigned int
+hb_blob_get_length (hb_blob_t *blob);
+
+const char *
+hb_blob_get_data (hb_blob_t *blob, unsigned int *length);
+
+char *
+hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length);
+
+
+HB_END_DECLS
+
+#endif /* HB_BLOB_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob-private.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob-private.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-blob-private.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-blob-private.h	2012-05-05 23:46:51.519763796 +0530
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_BLOB_PRIVATE_H
+#define HB_BLOB_PRIVATE_H
+
+#include "hb-private.h"
+
+#include "hb-blob.h"
+
+HB_BEGIN_DECLS
+
+
+struct _hb_blob_t {
+  hb_reference_count_t ref_count;
+
+  unsigned int length;
+
+  hb_mutex_t lock;
+  /* the rest are protected by lock */
+
+  unsigned int lock_count;
+  hb_memory_mode_t mode;
+
+  const char *data;
+
+  hb_destroy_func_t destroy;
+  void *user_data;
+};
+
+extern HB_INTERNAL hb_blob_t _hb_blob_nil;
+
+
+HB_END_DECLS
+
+#endif /* HB_BLOB_PRIVATE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer.cc	2012-08-09 00:10:14.141761997 +0530
@@ -0,0 +1,890 @@
+/*
+ * Copyright  1998-2004  David Turner and Werner Lemberg
+ * Copyright  2004,2007,2009,2010  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-buffer-private.hh"
+
+#include <string.h>
+
+
+
+#ifndef HB_DEBUG_BUFFER
+#define HB_DEBUG_BUFFER (HB_DEBUG+0)
+#endif
+
+
+static hb_buffer_t _hb_buffer_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  &_hb_unicode_funcs_default,
+  {
+    HB_DIRECTION_INVALID,
+    HB_SCRIPT_INVALID,
+    NULL,
+  },
+
+  TRUE, /* in_error */
+  TRUE, /* have_output */
+  TRUE  /* have_positions */
+};
+
+/* Here is how the buffer works internally:
+ *
+ * There are two info pointers: info and out_info.  They always have
+ * the same allocated size, but different lengths.
+ *
+ * As an optimization, both info and out_info may point to the
+ * same piece of memory, which is owned by info.  This remains the
+ * case as long as out_len doesn't exceed i at any time.
+ * In that case, swap_buffers() is no-op and the glyph operations operate
+ * mostly in-place.
+ *
+ * As soon as out_info gets longer than info, out_info is moved over
+ * to an alternate buffer (which we reuse the pos buffer for!), and its
+ * current contents (out_len entries) are copied to the new place.
+ * This should all remain transparent to the user.  swap_buffers() then
+ * switches info and out_info.
+ */
+
+
+
+/* Internal API */
+
+bool
+hb_buffer_t::enlarge (unsigned int size)
+{
+  if (unlikely (in_error))
+    return FALSE;
+
+  unsigned int new_allocated = allocated;
+  hb_glyph_position_t *new_pos = NULL;
+  hb_glyph_info_t *new_info = NULL;
+  bool separate_out = out_info != info;
+
+  if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))
+    goto done;
+
+  while (size > new_allocated)
+    new_allocated += (new_allocated >> 1) + 32;
+
+  ASSERT_STATIC (sizeof (info[0]) == sizeof (pos[0]));
+  if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))
+    goto done;
+
+  new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
+  new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
+
+done:
+  if (unlikely (!new_pos || !new_info))
+    in_error = TRUE;
+
+  if (likely (new_pos))
+    pos = new_pos;
+
+  if (likely (new_info))
+    info = new_info;
+
+  out_info = separate_out ? (hb_glyph_info_t *) pos : info;
+  if (likely (!in_error))
+    allocated = new_allocated;
+
+  return likely (!in_error);
+}
+
+bool
+hb_buffer_t::make_room_for (unsigned int num_in,
+			    unsigned int num_out)
+{
+  if (unlikely (!ensure (out_len + num_out))) return FALSE;
+
+  if (out_info == info &&
+      out_len + num_out > idx + num_in)
+  {
+    assert (have_output);
+
+    out_info = (hb_glyph_info_t *) pos;
+    memcpy (out_info, info, out_len * sizeof (out_info[0]));
+  }
+
+  return TRUE;
+}
+
+void *
+hb_buffer_t::get_scratch_buffer (unsigned int *size)
+{
+  have_output = FALSE;
+  have_positions = FALSE;
+  out_len = 0;
+  *size = allocated * sizeof (pos[0]);
+  return pos;
+}
+
+
+/* HarfBuzz-Internal API */
+
+void
+hb_buffer_t::reset (void)
+{
+  if (unlikely (hb_object_is_inert (this)))
+    return;
+
+  hb_unicode_funcs_destroy (unicode);
+  unicode = _hb_buffer_nil.unicode;
+
+  props = _hb_buffer_nil.props;
+
+  in_error = FALSE;
+  have_output = FALSE;
+  have_positions = FALSE;
+
+  idx = 0;
+  len = 0;
+  out_len = 0;
+
+  serial = 0;
+  memset (allocated_var_bytes, 0, sizeof allocated_var_bytes);
+  memset (allocated_var_owner, 0, sizeof allocated_var_owner);
+
+  out_info = info;
+}
+
+void
+hb_buffer_t::add (hb_codepoint_t  codepoint,
+		  hb_mask_t       mask,
+		  unsigned int    cluster)
+{
+  hb_glyph_info_t *glyph;
+
+  if (unlikely (!ensure (len + 1))) return;
+
+  glyph = &info[len];
+
+  memset (glyph, 0, sizeof (*glyph));
+  glyph->codepoint = codepoint;
+  glyph->mask = mask;
+  glyph->cluster = cluster;
+
+  len++;
+}
+
+void
+hb_buffer_t::clear_output (void)
+{
+  if (unlikely (hb_object_is_inert (this)))
+    return;
+
+  have_output = TRUE;
+  have_positions = FALSE;
+
+  out_len = 0;
+  out_info = info;
+}
+
+void
+hb_buffer_t::clear_positions (void)
+{
+  if (unlikely (hb_object_is_inert (this)))
+    return;
+
+  have_output = FALSE;
+  have_positions = TRUE;
+
+  memset (pos, 0, sizeof (pos[0]) * len);
+}
+
+void
+hb_buffer_t::swap_buffers (void)
+{
+  if (unlikely (in_error)) return;
+
+  assert (have_output);
+  have_output = FALSE;
+
+  if (out_info != info)
+  {
+    hb_glyph_info_t *tmp_string;
+    tmp_string = info;
+    info = out_info;
+    out_info = tmp_string;
+    pos = (hb_glyph_position_t *) out_info;
+  }
+
+  unsigned int tmp;
+  tmp = len;
+  len = out_len;
+  out_len = tmp;
+
+  idx = 0;
+}
+
+void
+hb_buffer_t::replace_glyphs_be16 (unsigned int num_in,
+				  unsigned int num_out,
+				  const uint16_t *glyph_data_be)
+{
+  if (!make_room_for (num_in, num_out)) return;
+
+  hb_glyph_info_t orig_info = info[idx];
+  for (unsigned int i = 1; i < num_in; i++)
+  {
+    hb_glyph_info_t *inf = &info[idx + i];
+    orig_info.cluster = MIN (orig_info.cluster, inf->cluster);
+  }
+
+  hb_glyph_info_t *pinfo = &out_info[out_len];
+  for (unsigned int i = 0; i < num_out; i++)
+  {
+    *pinfo = orig_info;
+    pinfo->codepoint = hb_be_uint16 (glyph_data_be[i]);
+    pinfo++;
+  }
+
+  idx  += num_in;
+  out_len += num_out;
+}
+
+void
+hb_buffer_t::replace_glyphs (unsigned int num_in,
+			     unsigned int num_out,
+			     const uint32_t *glyph_data)
+{
+  if (!make_room_for (num_in, num_out)) return;
+
+  hb_glyph_info_t orig_info = info[idx];
+  for (unsigned int i = 1; i < num_in; i++)
+  {
+    hb_glyph_info_t *inf = &info[idx + i];
+    orig_info.cluster = MIN (orig_info.cluster, inf->cluster);
+  }
+
+  hb_glyph_info_t *pinfo = &out_info[out_len];
+  for (unsigned int i = 0; i < num_out; i++)
+  {
+    *pinfo = orig_info;
+    pinfo->codepoint = glyph_data[i];
+    pinfo++;
+  }
+
+  idx  += num_in;
+  out_len += num_out;
+}
+
+void
+hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)
+{
+  if (!make_room_for (0, 1)) return;
+
+  out_info[out_len] = info[idx];
+  out_info[out_len].codepoint = glyph_index;
+
+  out_len++;
+}
+
+void
+hb_buffer_t::copy_glyph (void)
+{
+  if (!make_room_for (0, 1)) return;
+
+  out_info[out_len] = info[idx];
+
+  out_len++;
+}
+
+void
+hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)
+{
+  if (!make_room_for (1, 1)) return;
+
+  out_info[out_len] = info[idx];
+  out_info[out_len].codepoint = glyph_index;
+
+  idx++;
+  out_len++;
+}
+
+void
+hb_buffer_t::next_glyph (void)
+{
+  if (have_output)
+  {
+    if (out_info != info)
+    {
+      if (unlikely (!ensure (out_len + 1))) return;
+      out_info[out_len] = info[idx];
+    }
+    else if (out_len != idx)
+      out_info[out_len] = info[idx];
+
+    out_len++;
+  }
+
+  idx++;
+}
+
+void
+hb_buffer_t::set_masks (hb_mask_t    value,
+			hb_mask_t    mask,
+			unsigned int cluster_start,
+			unsigned int cluster_end)
+{
+  hb_mask_t not_mask = ~mask;
+  value &= mask;
+
+  if (!mask)
+    return;
+
+  if (cluster_start == 0 && cluster_end == (unsigned int)-1) {
+    unsigned int count = len;
+    for (unsigned int i = 0; i < count; i++)
+      info[i].mask = (info[i].mask & not_mask) | value;
+    return;
+  }
+
+  unsigned int count = len;
+  for (unsigned int i = 0; i < count; i++)
+    if (cluster_start <= info[i].cluster && info[i].cluster < cluster_end)
+      info[i].mask = (info[i].mask & not_mask) | value;
+}
+
+void
+hb_buffer_t::reverse_range (unsigned int start,
+			    unsigned int end)
+{
+  unsigned int i, j;
+
+  if (start == end - 1)
+    return;
+
+  for (i = start, j = end - 1; i < j; i++, j--) {
+    hb_glyph_info_t t;
+
+    t = info[i];
+    info[i] = info[j];
+    info[j] = t;
+  }
+
+  if (pos) {
+    for (i = start, j = end - 1; i < j; i++, j--) {
+      hb_glyph_position_t t;
+
+      t = pos[i];
+      pos[i] = pos[j];
+      pos[j] = t;
+    }
+  }
+}
+
+void
+hb_buffer_t::reverse (void)
+{
+  if (unlikely (!len))
+    return;
+
+  reverse_range (0, len);
+}
+
+void
+hb_buffer_t::reverse_clusters (void)
+{
+  unsigned int i, start, count, last_cluster;
+
+  if (unlikely (!len))
+    return;
+
+  reverse ();
+
+  count = len;
+  start = 0;
+  last_cluster = info[0].cluster;
+  for (i = 1; i < count; i++) {
+    if (last_cluster != info[i].cluster) {
+      reverse_range (start, i);
+      start = i;
+      last_cluster = info[i].cluster;
+    }
+  }
+  reverse_range (start, i);
+}
+
+void
+hb_buffer_t::merge_clusters (unsigned int start,
+			     unsigned int end)
+{
+  unsigned int cluster = this->info[start].cluster;
+
+  for (unsigned int i = start + 1; i < end; i++)
+    cluster = MIN (cluster, this->info[i].cluster);
+  for (unsigned int i = start; i < end; i++)
+    this->info[i].cluster = cluster;
+}
+void
+hb_buffer_t::merge_out_clusters (unsigned int start,
+				 unsigned int end)
+{
+  unsigned int cluster = this->out_info[start].cluster;
+
+  for (unsigned int i = start + 1; i < end; i++)
+    cluster = MIN (cluster, this->out_info[i].cluster);
+  for (unsigned int i = start; i < end; i++)
+    this->out_info[i].cluster = cluster;
+}
+
+void
+hb_buffer_t::guess_properties (void)
+{
+  /* If script is set to INVALID, guess from buffer contents */
+//printf ( "(%s)(%d)(%s) -(%d)  \n", __FILE__, __LINE__, __func__, props.script ) ;
+  if (props.script == HB_SCRIPT_INVALID) {
+    for (unsigned int i = 0; i < len; i++) {
+      hb_script_t script = hb_unicode_script (unicode, info[i].codepoint);
+      if (likely (script != HB_SCRIPT_COMMON &&
+		  script != HB_SCRIPT_INHERITED &&
+		  script != HB_SCRIPT_UNKNOWN)) {
+        props.script = script;
+        break;
+      }
+    }
+  }
+
+  /* If direction is set to INVALID, guess from script */
+  if (props.direction == HB_DIRECTION_INVALID) {
+    props.direction = hb_script_get_horizontal_direction (props.script);
+  }
+
+  /* If language is not set, use default language from locale */
+  if (props.language == HB_LANGUAGE_INVALID) {
+    /* TODO get_default_for_script? using $LANGUAGE */
+    props.language = hb_language_get_default ();
+  }
+}
+
+
+static inline void
+dump_var_allocation (const hb_buffer_t *buffer)
+{
+  char buf[80];
+  for (unsigned int i = 0; i < 8; i++)
+    buf[i] = '0' + buffer->allocated_var_bytes[7 - i];
+  buf[8] = '\0';
+  DEBUG_MSG (BUFFER, buffer,
+	     "Current var allocation: %s",
+	     buf);
+}
+
+void hb_buffer_t::allocate_var (unsigned int byte_i, unsigned int count, const char *owner)
+{
+  assert (byte_i < 8 && byte_i + count <= 8);
+
+  if (DEBUG (BUFFER))
+    dump_var_allocation (this);
+  DEBUG_MSG (BUFFER, this,
+	     "Allocating var bytes %d..%d for %s",
+	     byte_i, byte_i + count - 1, owner);
+
+  for (unsigned int i = byte_i; i < byte_i + count; i++) {
+    assert (!allocated_var_bytes[i]);
+    allocated_var_bytes[i]++;
+    allocated_var_owner[i] = owner;
+  }
+}
+
+void hb_buffer_t::deallocate_var (unsigned int byte_i, unsigned int count, const char *owner)
+{
+  if (DEBUG (BUFFER))
+    dump_var_allocation (this);
+
+  DEBUG_MSG (BUFFER, this,
+	     "Deallocating var bytes %d..%d for %s",
+	     byte_i, byte_i + count - 1, owner);
+
+  assert (byte_i < 8 && byte_i + count <= 8);
+  for (unsigned int i = byte_i; i < byte_i + count; i++) {
+    assert (allocated_var_bytes[i]);
+    assert (0 == strcmp (allocated_var_owner[i], owner));
+    allocated_var_bytes[i]--;
+  }
+}
+
+void hb_buffer_t::deallocate_var_all (void)
+{
+  memset (allocated_var_bytes, 0, sizeof (allocated_var_bytes));
+  memset (allocated_var_owner, 0, sizeof (allocated_var_owner));
+}
+
+/* Public API */
+
+hb_buffer_t *
+hb_buffer_create ()
+{
+  hb_buffer_t *buffer;
+
+  if (!(buffer = hb_object_create<hb_buffer_t> ()))
+    return &_hb_buffer_nil;
+
+  buffer->reset ();
+
+  return buffer;
+}
+
+hb_buffer_t *
+hb_buffer_get_empty (void)
+{
+  return &_hb_buffer_nil;
+}
+
+hb_buffer_t *
+hb_buffer_reference (hb_buffer_t *buffer)
+{
+  return hb_object_reference (buffer);
+}
+
+void
+hb_buffer_destroy (hb_buffer_t *buffer)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  if (!hb_object_destroy (buffer)) return;
+
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__) ;
+  hb_unicode_funcs_destroy (buffer->unicode);
+
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__) ;
+  free (buffer->info);
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__) ;
+//  free (buffer->pos);
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__) ;
+
+  free (buffer);
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__) ;
+}
+
+hb_bool_t
+hb_buffer_set_user_data (hb_buffer_t        *buffer,
+			 hb_user_data_key_t *key,
+			 void *              data,
+			 hb_destroy_func_t   destroy,
+			 hb_bool_t           replace)
+{
+  return hb_object_set_user_data (buffer, key, data, destroy, replace);
+}
+
+void *
+hb_buffer_get_user_data (hb_buffer_t        *buffer,
+			 hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (buffer, key);
+}
+
+
+void
+hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
+			     hb_unicode_funcs_t *unicode)
+{
+  if (unlikely (hb_object_is_inert (buffer)))
+    return;
+
+  if (!unicode)
+    unicode = _hb_buffer_nil.unicode;
+
+  hb_unicode_funcs_reference (unicode);
+  hb_unicode_funcs_destroy (buffer->unicode);
+  buffer->unicode = unicode;
+}
+
+hb_unicode_funcs_t *
+hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)
+{
+  return buffer->unicode;
+}
+
+void
+hb_buffer_set_direction (hb_buffer_t    *buffer,
+			 hb_direction_t  direction)
+
+{
+  if (unlikely (hb_object_is_inert (buffer)))
+    return;
+
+  buffer->props.direction = direction;
+}
+
+hb_direction_t
+hb_buffer_get_direction (hb_buffer_t    *buffer)
+{
+  return buffer->props.direction;
+}
+
+void
+hb_buffer_set_script (hb_buffer_t *buffer,
+		      hb_script_t  script)
+{
+  if (unlikely (hb_object_is_inert (buffer)))
+    return;
+
+  buffer->props.script = script;
+}
+
+hb_script_t
+hb_buffer_get_script (hb_buffer_t *buffer)
+{
+  return buffer->props.script;
+}
+
+void
+hb_buffer_set_language (hb_buffer_t   *buffer,
+			hb_language_t  language)
+{
+  if (unlikely (hb_object_is_inert (buffer)))
+    return;
+
+  buffer->props.language = language;
+}
+
+hb_language_t
+hb_buffer_get_language (hb_buffer_t *buffer)
+{
+  return buffer->props.language;
+}
+
+
+void
+hb_buffer_reset (hb_buffer_t *buffer)
+{
+  buffer->reset ();
+}
+
+hb_bool_t
+hb_buffer_pre_allocate (hb_buffer_t *buffer, unsigned int size)
+{
+  return buffer->ensure (size);
+}
+
+hb_bool_t
+hb_buffer_allocation_successful (hb_buffer_t  *buffer)
+{
+  return !buffer->in_error;
+}
+
+void
+hb_buffer_add (hb_buffer_t    *buffer,
+	       hb_codepoint_t  codepoint,
+	       hb_mask_t       mask,
+	       unsigned int    cluster)
+{
+  buffer->add (codepoint, mask, cluster);
+}
+
+hb_bool_t
+hb_buffer_set_length (hb_buffer_t  *buffer,
+		      unsigned int  length)
+{
+  if (!buffer->ensure (length))
+    return FALSE;
+
+  /* Wipe the new space */
+  if (length > buffer->len) {
+    memset (buffer->info + buffer->len, 0, sizeof (buffer->info[0]) * (length - buffer->len));
+    if (buffer->have_positions)
+      memset (buffer->pos + buffer->len, 0, sizeof (buffer->pos[0]) * (length - buffer->len));
+  }
+
+  buffer->len = length;
+  return TRUE;
+}
+
+unsigned int
+hb_buffer_get_length (hb_buffer_t *buffer)
+{
+  return buffer->len;
+}
+
+/* Return value valid as long as buffer not modified */
+hb_glyph_info_t *
+hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,
+                           unsigned int *length)
+{
+  if (length)
+    *length = buffer->len;
+
+  return (hb_glyph_info_t *) buffer->info;
+}
+
+/* Return value valid as long as buffer not modified */
+hb_glyph_position_t *
+hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,
+                               unsigned int *length)
+{
+  if (!buffer->have_positions)
+    buffer->clear_positions ();
+
+  if (length)
+    *length = buffer->len;
+
+  return (hb_glyph_position_t *) buffer->pos;
+}
+
+void
+hb_buffer_reverse (hb_buffer_t *buffer)
+{
+  buffer->reverse ();
+}
+
+void
+hb_buffer_reverse_clusters (hb_buffer_t *buffer)
+{
+  buffer->reverse_clusters ();
+}
+
+void
+hb_buffer_guess_properties (hb_buffer_t *buffer)
+{
+  buffer->guess_properties ();
+}
+
+#define ADD_UTF(T) \
+	HB_STMT_START { \
+	  if (text_length == -1) { \
+	    text_length = 0; \
+	    const T *p = (const T *) text; \
+	    while (*p) { \
+	      text_length++; \
+	      p++; \
+	    } \
+	  } \
+	  if (item_length == -1) \
+	    item_length = text_length - item_offset; \
+	  buffer->ensure (buffer->len + item_length * sizeof (T) / 4); \
+	  const T *next = (const T *) text + item_offset; \
+	  const T *end = next + item_length; \
+	  while (next < end) { \
+	    hb_codepoint_t u; \
+	    const T *old_next = next; \
+	    next = UTF_NEXT (next, end, u); \
+	    hb_buffer_add (buffer, u, 1,  old_next - (const T *) text); \
+	  } \
+	} HB_STMT_END
+
+
+#define UTF8_COMPUTE(Char, Mask, Len) \
+  if (Char < 128) { Len = 1; Mask = 0x7f; } \
+  else if ((Char & 0xe0) == 0xc0) { Len = 2; Mask = 0x1f; } \
+  else if ((Char & 0xf0) == 0xe0) { Len = 3; Mask = 0x0f; } \
+  else if ((Char & 0xf8) == 0xf0) { Len = 4; Mask = 0x07; } \
+  else Len = 0;
+
+static inline const uint8_t *
+hb_utf8_next (const uint8_t *text,
+	      const uint8_t *end,
+	      hb_codepoint_t *unicode)
+{
+  uint8_t c = *text;
+  unsigned int mask, len;
+
+  /* TODO check for overlong sequences? */
+
+  UTF8_COMPUTE (c, mask, len);
+  if (unlikely (!len || (unsigned int) (end - text) < len)) {
+    *unicode = -1;
+    return text + 1;
+  } else {
+    hb_codepoint_t result;
+    unsigned int i;
+    result = c & mask;
+    for (i = 1; i < len; i++)
+      {
+	if (unlikely ((text[i] & 0xc0) != 0x80))
+	  {
+	    *unicode = -1;
+	    return text + 1;
+	  }
+	result <<= 6;
+	result |= (text[i] & 0x3f);
+      }
+    *unicode = result;
+    return text + len;
+  }
+}
+
+void
+hb_buffer_add_utf8 (hb_buffer_t  *buffer,
+		    const char   *text,
+		    int           text_length,
+		    unsigned int  item_offset,
+		    int           item_length)
+{
+#define UTF_NEXT(S, E, U)	hb_utf8_next (S, E, &(U))
+  ADD_UTF (uint8_t);
+#undef UTF_NEXT
+}
+
+static inline const uint16_t *
+hb_utf16_next (const uint16_t *text,
+	       const uint16_t *end,
+	       hb_codepoint_t *unicode)
+{
+  uint16_t c = *text++;
+
+  if (unlikely (c >= 0xd800 && c < 0xdc00)) {
+    /* high surrogate */
+    uint16_t l;
+    if (text < end && ((l = *text), likely (l >= 0xdc00 && l < 0xe000))) {
+      /* low surrogate */
+      *unicode = ((hb_codepoint_t) ((c) - 0xd800) * 0x400 + (l) - 0xdc00 + 0x10000);
+       text++;
+    } else
+      *unicode = -1;
+  } else
+    *unicode = c;
+
+  return text;
+}
+
+void
+hb_buffer_add_utf16 (hb_buffer_t    *buffer,
+		     const uint16_t *text,
+		     int             text_length,
+		     unsigned int    item_offset,
+		     int            item_length)
+{
+#define UTF_NEXT(S, E, U)	hb_utf16_next (S, E, &(U))
+  ADD_UTF (uint16_t);
+#undef UTF_NEXT
+}
+
+void
+hb_buffer_add_utf32 (hb_buffer_t    *buffer,
+		     const uint32_t *text,
+		     int             text_length,
+		     unsigned int    item_offset,
+		     int             item_length)
+{
+#define UTF_NEXT(S, E, U)	((U) = *(S), (S)+1)
+  ADD_UTF (uint32_t);
+#undef UTF_NEXT
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,198 @@
+/*
+ * Copyright  1998-2004  David Turner and Werner Lemberg
+ * Copyright  2004,2007,2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_BUFFER_H
+#define HB_BUFFER_H
+
+#include "hb-common.h"
+#include "hb-unicode.h"
+
+HB_BEGIN_DECLS
+
+
+typedef struct _hb_buffer_t hb_buffer_t;
+
+typedef struct _hb_glyph_info_t {
+  hb_codepoint_t codepoint;
+  hb_mask_t      mask;
+  uint32_t       cluster;
+
+  /*< private >*/
+  hb_var_int_t   var1;
+  hb_var_int_t   var2;
+} hb_glyph_info_t;
+
+typedef struct _hb_glyph_position_t {
+  hb_position_t  x_advance;
+  hb_position_t  y_advance;
+  hb_position_t  x_offset;
+  hb_position_t  y_offset;
+
+  /*< private >*/
+  hb_var_int_t   var;
+} hb_glyph_position_t;
+
+
+hb_buffer_t *
+hb_buffer_create (void);
+
+hb_buffer_t *
+hb_buffer_get_empty (void);
+
+hb_buffer_t *
+hb_buffer_reference (hb_buffer_t *buffer);
+
+void
+hb_buffer_destroy (hb_buffer_t *buffer);
+
+hb_bool_t
+hb_buffer_set_user_data (hb_buffer_t        *buffer,
+			 hb_user_data_key_t *key,
+			 void *              data,
+			 hb_destroy_func_t   destroy,
+			 hb_bool_t           replace);
+
+void *
+hb_buffer_get_user_data (hb_buffer_t        *buffer,
+			 hb_user_data_key_t *key);
+
+
+void
+hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
+			     hb_unicode_funcs_t *unicode_funcs);
+
+hb_unicode_funcs_t *
+hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer);
+
+void
+hb_buffer_set_direction (hb_buffer_t    *buffer,
+			 hb_direction_t  direction);
+
+hb_direction_t
+hb_buffer_get_direction (hb_buffer_t *buffer);
+
+void
+hb_buffer_set_script (hb_buffer_t *buffer,
+		      hb_script_t  script);
+
+hb_script_t
+hb_buffer_get_script (hb_buffer_t *buffer);
+
+void
+hb_buffer_set_language (hb_buffer_t   *buffer,
+			hb_language_t  language);
+
+hb_language_t
+hb_buffer_get_language (hb_buffer_t *buffer);
+
+
+/* Resets the buffer.  Afterwards it's as if it was just created,
+ * except that it has a larger buffer allocated perhaps... */
+void
+hb_buffer_reset (hb_buffer_t *buffer);
+
+/* Returns FALSE if allocation failed */
+hb_bool_t
+hb_buffer_pre_allocate (hb_buffer_t  *buffer,
+		        unsigned int  size);
+
+
+/* Returns FALSE if allocation has failed before */
+hb_bool_t
+hb_buffer_allocation_successful (hb_buffer_t  *buffer);
+
+void
+hb_buffer_reverse (hb_buffer_t *buffer);
+
+void
+hb_buffer_reverse_clusters (hb_buffer_t *buffer);
+
+void
+hb_buffer_guess_properties (hb_buffer_t *buffer);
+
+
+/* Filling the buffer in */
+
+void
+hb_buffer_add (hb_buffer_t    *buffer,
+	       hb_codepoint_t  codepoint,
+	       hb_mask_t       mask,
+	       unsigned int    cluster);
+
+void
+hb_buffer_add_utf8 (hb_buffer_t  *buffer,
+		    const char   *text,
+		    int           text_length,
+		    unsigned int  item_offset,
+		    int           item_length);
+
+void
+hb_buffer_add_utf16 (hb_buffer_t    *buffer,
+		     const uint16_t *text,
+		     int             text_length,
+		     unsigned int    item_offset,
+		     int             item_length);
+
+void
+hb_buffer_add_utf32 (hb_buffer_t    *buffer,
+		     const uint32_t *text,
+		     int             text_length,
+		     unsigned int    item_offset,
+		     int             item_length);
+
+
+/* Clears any new items added at the end */
+hb_bool_t
+hb_buffer_set_length (hb_buffer_t  *buffer,
+		      unsigned int  length);
+
+/* Return value valid as long as buffer not modified */
+unsigned int
+hb_buffer_get_length (hb_buffer_t *buffer);
+
+/* Getting glyphs out of the buffer */
+
+/* Return value valid as long as buffer not modified */
+hb_glyph_info_t *
+hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,
+                           unsigned int *length);
+
+/* Return value valid as long as buffer not modified */
+hb_glyph_position_t *
+hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,
+                               unsigned int *length);
+
+
+HB_END_DECLS
+
+#endif /* HB_BUFFER_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-buffer-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-buffer-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,161 @@
+/*
+ * Copyright  1998-2004  David Turner and Werner Lemberg
+ * Copyright  2004,2007,2009,2010  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_BUFFER_PRIVATE_HH
+#define HB_BUFFER_PRIVATE_HH
+
+#include "hb-private.hh"
+#include "hb-buffer.h"
+#include "hb-object-private.hh"
+#include "hb-unicode-private.hh"
+
+
+
+ASSERT_STATIC (sizeof (hb_glyph_info_t) == 20);
+ASSERT_STATIC (sizeof (hb_glyph_info_t) == sizeof (hb_glyph_position_t));
+
+typedef struct _hb_segment_properties_t {
+    hb_direction_t      direction;
+    hb_script_t         script;
+    hb_language_t       language;
+} hb_segment_properties_t;
+
+
+struct _hb_buffer_t {
+  hb_object_header_t header;
+
+  /* Information about how the text in the buffer should be treated */
+
+  hb_unicode_funcs_t *unicode; /* Unicode functions */
+  hb_segment_properties_t props; /* Script, language, direction */
+
+  /* Buffer contents */
+
+  bool in_error; /* Allocation failed */
+  bool have_output; /* Whether we have an output buffer going on */
+  bool have_positions; /* Whether we have positions */
+
+  unsigned int idx; /* Cursor into ->info and ->pos arrays */
+  unsigned int len; /* Length of ->info and ->pos arrays */
+  unsigned int out_len; /* Length of ->out array if have_output */
+
+  unsigned int allocated; /* Length of allocated arrays */
+  hb_glyph_info_t     *info;
+  hb_glyph_info_t     *out_info;
+  hb_glyph_position_t *pos;
+
+  unsigned int serial;
+  uint8_t allocated_var_bytes[8];
+  const char *allocated_var_owner[8];
+
+
+  /* Methods */
+
+  HB_INTERNAL void reset (void);
+
+  inline unsigned int backtrack_len (void) const
+  { return have_output? out_len : idx; }
+  inline unsigned int next_serial (void) { return serial++; }
+
+  HB_INTERNAL void allocate_var (unsigned int byte_i, unsigned int count, const char *owner);
+  HB_INTERNAL void deallocate_var (unsigned int byte_i, unsigned int count, const char *owner);
+  HB_INTERNAL void deallocate_var_all (void);
+
+  HB_INTERNAL void add (hb_codepoint_t  codepoint,
+			hb_mask_t       mask,
+			unsigned int    cluster);
+
+  HB_INTERNAL void reverse_range (unsigned int start, unsigned int end);
+  HB_INTERNAL void reverse (void);
+  HB_INTERNAL void reverse_clusters (void);
+  HB_INTERNAL void guess_properties (void);
+
+  HB_INTERNAL void swap_buffers (void);
+  HB_INTERNAL void clear_output (void);
+  HB_INTERNAL void clear_positions (void);
+  HB_INTERNAL void replace_glyphs_be16 (unsigned int num_in,
+					unsigned int num_out,
+					const uint16_t *glyph_data_be);
+  HB_INTERNAL void replace_glyphs (unsigned int num_in,
+				   unsigned int num_out,
+				   const hb_codepoint_t *glyph_data);
+  HB_INTERNAL void replace_glyph (hb_codepoint_t glyph_index);
+  /* Makes a copy of the glyph at idx to output and replace glyph_index */
+  HB_INTERNAL void output_glyph (hb_codepoint_t glyph_index);
+  /* Copies glyph at idx to output but doesn't advance idx */
+  HB_INTERNAL void copy_glyph (void);
+  /* Copies glyph at idx to output and advance idx.
+   * If there's no output, just advance idx. */
+  HB_INTERNAL void next_glyph (void);
+  /* Advance idx without copying to output. */
+  inline void skip_glyph (void) { idx++; }
+
+  inline void reset_masks (hb_mask_t mask)
+  {
+    for (unsigned int j = 0; j < len; j++)
+      info[j].mask = mask;
+  }
+  inline void add_masks (hb_mask_t mask)
+  {
+    for (unsigned int j = 0; j < len; j++)
+      info[j].mask |= mask;
+  }
+  HB_INTERNAL void set_masks (hb_mask_t value,
+			      hb_mask_t mask,
+			      unsigned int cluster_start,
+			      unsigned int cluster_end);
+
+  HB_INTERNAL void merge_clusters (unsigned int start,
+				   unsigned int end);
+  HB_INTERNAL void merge_out_clusters (unsigned int start,
+				       unsigned int end);
+
+  /* Internal methods */
+  HB_INTERNAL bool enlarge (unsigned int size);
+
+  inline bool ensure (unsigned int size)
+  { return likely (size <= allocated) ? TRUE : enlarge (size); }
+
+  HB_INTERNAL bool make_room_for (unsigned int num_in, unsigned int num_out);
+
+  HB_INTERNAL void *get_scratch_buffer (unsigned int *size);
+};
+
+
+#define HB_BUFFER_XALLOCATE_VAR(b, func, var, owner) \
+  b->func (offsetof (hb_glyph_info_t, var) - offsetof(hb_glyph_info_t, var1), \
+	   sizeof (b->info[0].var), owner)
+#define HB_BUFFER_ALLOCATE_VAR(b, var) \
+	HB_BUFFER_XALLOCATE_VAR (b, allocate_var, var (), #var)
+#define HB_BUFFER_DEALLOCATE_VAR(b, var) \
+	HB_BUFFER_XALLOCATE_VAR (b, deallocate_var, var (), #var)
+
+
+
+#endif /* HB_BUFFER_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.c	2012-05-05 23:46:51.529763796 +0530
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+HB_BEGIN_DECLS
+
+
+hb_tag_t
+hb_tag_from_string (const char *s)
+{
+  char tag[4];
+  unsigned int i;
+
+  for (i = 0; i < 4 && s[i]; i++)
+    tag[i] = s[i];
+  for (; i < 4; i++)
+    tag[i] = ' ';
+
+  return HB_TAG_STR (tag);
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,387 @@
+/*
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2011,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-version.h"
+
+#include "hb-mutex-private.hh"
+#include "hb-object-private.hh"
+
+#include <locale.h>
+
+
+
+/* hb_tag_t */
+
+hb_tag_t
+hb_tag_from_string (const char *s, int len)
+{
+  char tag[4];
+  unsigned int i;
+
+  if (!s || !len || !*s)
+    return HB_TAG_NONE;
+
+  if (len < 0 || len > 4)
+    len = 4;
+  for (i = 0; i < (unsigned) len && s[i]; i++)
+    tag[i] = s[i];
+  for (; i < 4; i++)
+    tag[i] = ' ';
+
+  return HB_TAG_CHAR4 (tag);
+}
+
+
+/* hb_direction_t */
+
+const char direction_strings[][4] = {
+  "ltr",
+  "rtl",
+  "ttb",
+  "btt"
+};
+
+hb_direction_t
+hb_direction_from_string (const char *str, int len)
+{
+  if (unlikely (!str || !len || !*str))
+    return HB_DIRECTION_INVALID;
+
+  /* Lets match loosely: just match the first letter, such that
+   * all of "ltr", "left-to-right", etc work!
+   */
+  char c = TOLOWER (str[0]);
+  for (unsigned int i = 0; i < ARRAY_LENGTH (direction_strings); i++)
+    if (c == direction_strings[i][0])
+      return (hb_direction_t) (HB_DIRECTION_LTR + i);
+
+  return HB_DIRECTION_INVALID;
+}
+
+const char *
+hb_direction_to_string (hb_direction_t direction)
+{
+  if (likely ((unsigned int) (direction - HB_DIRECTION_LTR)
+	      < ARRAY_LENGTH (direction_strings)))
+    return direction_strings[direction - HB_DIRECTION_LTR];
+
+  return "invalid";
+}
+
+
+/* hb_language_t */
+
+struct _hb_language_t {
+  const char s[1];
+};
+
+static const char canon_map[256] = {
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,  '-',  0,   0,
+  '0', '1', '2', '3', '4', '5', '6', '7',  '8', '9',  0,   0,   0,   0,   0,   0,
+  '-', 'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,  '-',
+   0,  'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,   0
+};
+
+static hb_bool_t
+lang_equal (const void *v1,
+	    const void *v2)
+{
+  const unsigned char *p1 = (const unsigned char *) v1;
+  const unsigned char *p2 = (const unsigned char *) v2;
+
+  while (canon_map[*p1] && canon_map[*p1] == canon_map[*p2])
+    {
+      p1++, p2++;
+    }
+
+  return (canon_map[*p1] == canon_map[*p2]);
+}
+
+#if 0
+static unsigned int
+lang_hash (const void *key)
+{
+  const unsigned char *p = key;
+  unsigned int h = 0;
+  while (canon_map[*p])
+    {
+      h = (h << 5) - h + canon_map[*p];
+      p++;
+    }
+
+  return h;
+}
+#endif
+
+
+struct hb_language_item_t {
+
+  hb_language_t lang;
+
+  inline bool operator == (const char *s) const {
+    return lang_equal (lang, s);
+  }
+
+  inline hb_language_item_t & operator = (const char *s) {
+    lang = (hb_language_t) strdup (s);
+    for (unsigned char *p = (unsigned char *) lang; *p; p++)
+      *p = canon_map[*p];
+
+    return *this;
+  }
+
+  void finish (void) { free (lang); }
+};
+
+static struct hb_static_lang_set_t : hb_lockable_set_t<hb_language_item_t, hb_static_mutex_t> {
+  ~hb_static_lang_set_t (void) { this->finish (lock); }
+  hb_static_mutex_t lock;
+} langs;
+
+hb_language_t
+hb_language_from_string (const char *str, int len)
+{
+  if (!str || !len || !*str)
+    return HB_LANGUAGE_INVALID;
+
+  char strbuf[32];
+  if (len >= 0) {
+    len = MIN (len, (int) sizeof (strbuf) - 1);
+    str = (char *) memcpy (strbuf, str, len);
+    strbuf[len] = '\0';
+  }
+
+  hb_language_item_t *item = langs.find_or_insert (str, langs.lock);
+
+  return likely (item) ? item->lang : HB_LANGUAGE_INVALID;
+}
+
+const char *
+hb_language_to_string (hb_language_t language)
+{
+  /* This is actually NULL-safe! */
+  return language->s;
+}
+
+hb_language_t
+hb_language_get_default (void)
+{
+  static hb_language_t default_language;
+
+  if (!default_language) {
+    /* This block is not quite threadsafe, but is not as bad as
+     * it looks since it's idempotent.  As long as pointer ops
+     * are atomic, we are safe. */
+
+    /* I hear that setlocale() doesn't honor env vars on Windows,
+     * but for now we ignore that. */
+
+    default_language = hb_language_from_string (setlocale (LC_CTYPE, NULL), -1);
+  }
+
+  return default_language;
+}
+
+
+/* hb_script_t */
+
+hb_script_t
+hb_script_from_iso15924_tag (hb_tag_t tag)
+{
+  if (unlikely (tag == HB_TAG_NONE))
+    return HB_SCRIPT_INVALID;
+
+  /* Be lenient, adjust case (one capital letter followed by three small letters) */
+  tag = (tag & 0xDFDFDFDF) | 0x00202020;
+
+  switch (tag) {
+
+    /* These graduated from the 'Q' private-area codes, but
+     * the old code is still aliased by Unicode, and the Qaai
+     * one in use by ICU. */
+    case HB_TAG('Q','a','a','i'): return HB_SCRIPT_INHERITED;
+    case HB_TAG('Q','a','a','c'): return HB_SCRIPT_COPTIC;
+
+    /* Script variants from http://unicode.org/iso15924/ */
+    case HB_TAG('C','y','r','s'): return HB_SCRIPT_CYRILLIC;
+    case HB_TAG('L','a','t','f'): return HB_SCRIPT_LATIN;
+    case HB_TAG('L','a','t','g'): return HB_SCRIPT_LATIN;
+    case HB_TAG('S','y','r','e'): return HB_SCRIPT_SYRIAC;
+    case HB_TAG('S','y','r','j'): return HB_SCRIPT_SYRIAC;
+    case HB_TAG('S','y','r','n'): return HB_SCRIPT_SYRIAC;
+  }
+
+  /* If it looks right, just use the tag as a script */
+  if (((uint32_t) tag & 0xE0E0E0E0) == 0x40606060)
+    return (hb_script_t) tag;
+
+  /* Otherwise, return unknown */
+  return HB_SCRIPT_UNKNOWN;
+}
+
+hb_script_t
+hb_script_from_string (const char *s, int len)
+{
+  return hb_script_from_iso15924_tag (hb_tag_from_string (s, len));
+}
+
+hb_tag_t
+hb_script_to_iso15924_tag (hb_script_t script)
+{
+  return (hb_tag_t) script;
+}
+
+hb_direction_t
+hb_script_get_horizontal_direction (hb_script_t script)
+{
+  /* http://goo.gl/x9ilM */
+  switch ((hb_tag_t) script)
+  {
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_ARABIC:
+    case HB_SCRIPT_HEBREW:
+
+    /* Unicode-3.0 additions */
+    case HB_SCRIPT_SYRIAC:
+    case HB_SCRIPT_THAANA:
+
+    /* Unicode-4.0 additions */
+    case HB_SCRIPT_CYPRIOT:
+
+    /* Unicode-4.1 additions */
+    case HB_SCRIPT_KHAROSHTHI:
+
+    /* Unicode-5.0 additions */
+    case HB_SCRIPT_PHOENICIAN:
+    case HB_SCRIPT_NKO:
+
+    /* Unicode-5.1 additions */
+    case HB_SCRIPT_LYDIAN:
+
+    /* Unicode-5.2 additions */
+    case HB_SCRIPT_AVESTAN:
+    case HB_SCRIPT_IMPERIAL_ARAMAIC:
+    case HB_SCRIPT_INSCRIPTIONAL_PAHLAVI:
+    case HB_SCRIPT_INSCRIPTIONAL_PARTHIAN:
+    case HB_SCRIPT_OLD_SOUTH_ARABIAN:
+    case HB_SCRIPT_OLD_TURKIC:
+    case HB_SCRIPT_SAMARITAN:
+
+    /* Unicode-6.0 additions */
+    case HB_SCRIPT_MANDAIC:
+
+    /* Unicode-6.1 additions */
+    case HB_SCRIPT_MEROITIC_CURSIVE:
+    case HB_SCRIPT_MEROITIC_HIEROGLYPHS:
+
+      return HB_DIRECTION_RTL;
+  }
+
+  return HB_DIRECTION_LTR;
+}
+
+
+/* hb_user_data_array_t */
+
+
+/* NOTE: Currently we use a global lock for user_data access
+ * threadsafety.  If one day we add a mutex to any object, we
+ * should switch to using that insted for these too.
+ */
+
+static hb_static_mutex_t user_data_lock;
+
+bool
+hb_user_data_array_t::set (hb_user_data_key_t *key,
+			   void *              data,
+			   hb_destroy_func_t   destroy,
+			   hb_bool_t           replace)
+{
+  if (!key)
+    return false;
+
+  if (replace) {
+    if (!data && !destroy) {
+      items.remove (key, user_data_lock);
+      return true;
+    }
+  }
+  hb_user_data_item_t item = {key, data, destroy};
+  bool ret = !!items.replace_or_insert (item, user_data_lock, replace);
+
+  return ret;
+}
+
+void *
+hb_user_data_array_t::get (hb_user_data_key_t *key)
+{
+  hb_user_data_item_t item = {NULL };
+
+  return items.find (key, &item, user_data_lock) ? item.data : NULL;
+}
+
+void
+hb_user_data_array_t::finish (void)
+{
+  items.finish (user_data_lock);
+}
+
+
+/* hb_version */
+
+void
+hb_version (unsigned int *major,
+	    unsigned int *minor,
+	    unsigned int *micro)
+{
+  *major = HB_VERSION_MAJOR;
+  *minor = HB_VERSION_MINOR;
+  *micro = HB_VERSION_MICRO;
+}
+
+const char *
+hb_version_string (void)
+{
+  return HB_VERSION_STRING;
+}
+
+hb_bool_t
+hb_version_check (unsigned int major,
+		  unsigned int minor,
+		  unsigned int micro)
+{
+  return HB_VERSION_CHECK (major, minor, micro);
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-common.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-common.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,346 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ * Copyright  2011,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_COMMON_H
+#define HB_COMMON_H
+
+# ifdef __cplusplus
+#  define HB_BEGIN_DECLS	extern "C" {
+#  define HB_END_DECLS		}
+# else /* !__cplusplus */
+#  define HB_BEGIN_DECLS
+#  define HB_END_DECLS
+# endif /* !__cplusplus */
+
+HB_BEGIN_DECLS
+
+#if !defined (HB_DONT_DEFINE_STDINT)
+
+#if defined (_SVR4) || defined (SVR4) || defined (__OpenBSD__) || \
+    defined (_sgi) || defined (__sun) || defined (sun) || \
+    defined (__digital__) || defined (__HP_cc)
+#  include <inttypes.h>
+#elif defined (_AIX)
+#  include <sys/inttypes.h>
+/* VS 2010 (_MSC_VER 1600) has stdint.h */
+#elif defined (_MSC_VER) && _MSC_VER < 1600
+typedef __int8 int8_t;
+typedef unsigned __int8 uint8_t;
+typedef __int16 int16_t;
+typedef unsigned __int16 uint16_t;
+typedef __int32 int32_t;
+typedef unsigned __int32 uint32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#else
+#  include <stdint.h>
+#endif
+
+#endif
+
+
+typedef int hb_bool_t;
+
+typedef uint32_t hb_codepoint_t;
+typedef int32_t hb_position_t;
+typedef uint32_t hb_mask_t;
+
+typedef union _hb_var_int_t {
+  uint32_t u32;
+  int32_t i32;
+  uint16_t u16[2];
+  int16_t i16[2];
+  uint8_t u8[4];
+  int8_t i8[4];
+} hb_var_int_t;
+
+
+/* hb_tag_t */
+
+typedef uint32_t hb_tag_t;
+
+#define HB_TAG(a,b,c,d) ((hb_tag_t)((((uint8_t)(a))<<24)|(((uint8_t)(b))<<16)|(((uint8_t)(c))<<8)|((uint8_t)(d))))
+#define HB_UNTAG(tag)   ((uint8_t)((tag)>>24)), ((uint8_t)((tag)>>16)), ((uint8_t)((tag)>>8)), ((uint8_t)(tag))
+
+#define HB_TAG_NONE HB_TAG(0,0,0,0)
+
+/* len=-1 means str is NUL-terminated */
+hb_tag_t hb_tag_from_string (const char *str, int len);
+
+
+/* hb_direction_t */
+
+typedef enum {
+  HB_DIRECTION_INVALID = 0,
+  HB_DIRECTION_LTR = 4,
+  HB_DIRECTION_RTL,
+  HB_DIRECTION_TTB,
+  HB_DIRECTION_BTT
+} hb_direction_t;
+
+/* len=-1 means str is NUL-terminated */
+hb_direction_t
+hb_direction_from_string (const char *str, int len);
+
+const char *
+hb_direction_to_string (hb_direction_t direction);
+
+#define HB_DIRECTION_IS_HORIZONTAL(dir)	((((unsigned int) (dir)) & ~1U) == 4)
+#define HB_DIRECTION_IS_VERTICAL(dir)	((((unsigned int) (dir)) & ~1U) == 6)
+#define HB_DIRECTION_IS_FORWARD(dir)	((((unsigned int) (dir)) & ~2U) == 4)
+#define HB_DIRECTION_IS_BACKWARD(dir)	((((unsigned int) (dir)) & ~2U) == 5)
+#define HB_DIRECTION_IS_VALID(dir)	((((unsigned int) (dir)) & ~3U) == 4)
+#define HB_DIRECTION_REVERSE(dir)	((hb_direction_t) (((unsigned int) (dir)) ^ 1)) /* Direction must be valid */
+
+
+/* hb_language_t */
+
+typedef struct _hb_language_t *hb_language_t;
+
+/* len=-1 means str is NUL-terminated */
+hb_language_t
+hb_language_from_string (const char *str, int len);
+
+const char *
+hb_language_to_string (hb_language_t language);
+
+#define HB_LANGUAGE_INVALID ((hb_language_t) NULL)
+
+hb_language_t
+hb_language_get_default (void);
+
+
+/* hb_unicode_general_category_t */
+
+typedef enum
+{
+  HB_UNICODE_GENERAL_CATEGORY_CONTROL,			/* Cc */
+  HB_UNICODE_GENERAL_CATEGORY_FORMAT,			/* Cf */
+  HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED,		/* Cn */
+  HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE,		/* Co */
+  HB_UNICODE_GENERAL_CATEGORY_SURROGATE,		/* Cs */
+  HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER,		/* Ll */
+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER,		/* Lm */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER,		/* Lo */
+  HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER,		/* Lt */
+  HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER,		/* Lu */
+  HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK,		/* Mc */
+  HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK,		/* Me */
+  HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK,		/* Mn */
+  HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER,		/* Nd */
+  HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER,		/* Nl */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER,		/* No */
+  HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION,	/* Pc */
+  HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION,		/* Pd */
+  HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION,	/* Pe */
+  HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION,	/* Pf */
+  HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION,	/* Pi */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION,	/* Po */
+  HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION,		/* Ps */
+  HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL,		/* Sc */
+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL,		/* Sk */
+  HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL,		/* Sm */
+  HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL,		/* So */
+  HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR,		/* Zl */
+  HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR,	/* Zp */
+  HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR		/* Zs */
+} hb_unicode_general_category_t;
+
+
+/* hb_script_t */
+
+/* http://unicode.org/iso15924/ */
+/* http://goo.gl/x9ilM */
+typedef enum
+{
+  /* Unicode-1.1 additions */
+  HB_SCRIPT_COMMON			= HB_TAG ('Z','y','y','y'),
+  HB_SCRIPT_ARABIC			= HB_TAG ('A','r','a','b'),
+  HB_SCRIPT_ARMENIAN			= HB_TAG ('A','r','m','n'),
+  HB_SCRIPT_BENGALI			= HB_TAG ('B','e','n','g'),
+  HB_SCRIPT_BOPOMOFO			= HB_TAG ('B','o','p','o'),
+  HB_SCRIPT_CANADIAN_ABORIGINAL		= HB_TAG ('C','a','n','s'),
+  HB_SCRIPT_CHEROKEE			= HB_TAG ('C','h','e','r'),
+  HB_SCRIPT_COPTIC			= HB_TAG ('C','o','p','t'),
+  HB_SCRIPT_CYRILLIC			= HB_TAG ('C','y','r','l'),
+  HB_SCRIPT_DEVANAGARI			= HB_TAG ('D','e','v','a'),
+  HB_SCRIPT_GEORGIAN			= HB_TAG ('G','e','o','r'),
+  HB_SCRIPT_GREEK			= HB_TAG ('G','r','e','k'),
+  HB_SCRIPT_GUJARATI			= HB_TAG ('G','u','j','r'),
+  HB_SCRIPT_GURMUKHI			= HB_TAG ('G','u','r','u'),
+  HB_SCRIPT_HANGUL			= HB_TAG ('H','a','n','g'),
+  HB_SCRIPT_HAN				= HB_TAG ('H','a','n','i'),
+  HB_SCRIPT_HEBREW			= HB_TAG ('H','e','b','r'),
+  HB_SCRIPT_HIRAGANA			= HB_TAG ('H','i','r','a'),
+  HB_SCRIPT_INHERITED			= HB_TAG ('Z','i','n','h'),
+  HB_SCRIPT_KANNADA			= HB_TAG ('K','n','d','a'),
+  HB_SCRIPT_KATAKANA			= HB_TAG ('K','a','n','a'),
+  HB_SCRIPT_LAO				= HB_TAG ('L','a','o','o'),
+  HB_SCRIPT_LATIN			= HB_TAG ('L','a','t','n'),
+  HB_SCRIPT_MALAYALAM			= HB_TAG ('M','l','y','m'),
+  HB_SCRIPT_MONGOLIAN			= HB_TAG ('M','o','n','g'),
+  HB_SCRIPT_OGHAM			= HB_TAG ('O','g','a','m'),
+  HB_SCRIPT_ORIYA			= HB_TAG ('O','r','y','a'),
+  HB_SCRIPT_RUNIC			= HB_TAG ('R','u','n','r'),
+  HB_SCRIPT_SYRIAC			= HB_TAG ('S','y','r','c'),
+  HB_SCRIPT_TAMIL			= HB_TAG ('T','a','m','l'),
+  HB_SCRIPT_TELUGU			= HB_TAG ('T','e','l','u'),
+  HB_SCRIPT_THAI			= HB_TAG ('T','h','a','i'),
+  HB_SCRIPT_YI				= HB_TAG ('Y','i','i','i'),
+
+  /* Unicode-2.0 additions */
+  HB_SCRIPT_TIBETAN			= HB_TAG ('T','i','b','t'),
+
+  /* Unicode-3.0 additions */
+  HB_SCRIPT_ETHIOPIC			= HB_TAG ('E','t','h','i'),
+  HB_SCRIPT_KHMER			= HB_TAG ('K','h','m','r'),
+  HB_SCRIPT_MYANMAR			= HB_TAG ('M','y','m','r'),
+  HB_SCRIPT_SINHALA			= HB_TAG ('S','i','n','h'),
+  HB_SCRIPT_THAANA			= HB_TAG ('T','h','a','a'),
+
+  /* Unicode-3.1 additions */
+  HB_SCRIPT_DESERET			= HB_TAG ('D','s','r','t'),
+  HB_SCRIPT_GOTHIC			= HB_TAG ('G','o','t','h'),
+  HB_SCRIPT_OLD_ITALIC			= HB_TAG ('I','t','a','l'),
+
+  /* Unicode-3.2 additions */
+  HB_SCRIPT_BUHID			= HB_TAG ('B','u','h','d'),
+  HB_SCRIPT_HANUNOO			= HB_TAG ('H','a','n','o'),
+  HB_SCRIPT_TAGALOG			= HB_TAG ('T','g','l','g'),
+  HB_SCRIPT_TAGBANWA			= HB_TAG ('T','a','g','b'),
+
+  /* Unicode-4.0 additions */
+  HB_SCRIPT_BRAILLE			= HB_TAG ('B','r','a','i'),
+  HB_SCRIPT_CYPRIOT			= HB_TAG ('C','p','r','t'),
+  HB_SCRIPT_LIMBU			= HB_TAG ('L','i','m','b'),
+  HB_SCRIPT_LINEAR_B			= HB_TAG ('L','i','n','b'),
+  HB_SCRIPT_OSMANYA			= HB_TAG ('O','s','m','a'),
+  HB_SCRIPT_SHAVIAN			= HB_TAG ('S','h','a','w'),
+  HB_SCRIPT_TAI_LE			= HB_TAG ('T','a','l','e'),
+  HB_SCRIPT_UGARITIC			= HB_TAG ('U','g','a','r'),
+
+  /* Unicode-4.1 additions */
+  HB_SCRIPT_BUGINESE			= HB_TAG ('B','u','g','i'),
+  HB_SCRIPT_GLAGOLITIC			= HB_TAG ('G','l','a','g'),
+  HB_SCRIPT_KHAROSHTHI			= HB_TAG ('K','h','a','r'),
+  HB_SCRIPT_NEW_TAI_LUE			= HB_TAG ('T','a','l','u'),
+  HB_SCRIPT_OLD_PERSIAN			= HB_TAG ('X','p','e','o'),
+  HB_SCRIPT_SYLOTI_NAGRI		= HB_TAG ('S','y','l','o'),
+  HB_SCRIPT_TIFINAGH			= HB_TAG ('T','f','n','g'),
+
+  /* Unicode-5.0 additions */
+  HB_SCRIPT_BALINESE			= HB_TAG ('B','a','l','i'),
+  HB_SCRIPT_CUNEIFORM			= HB_TAG ('X','s','u','x'),
+  HB_SCRIPT_NKO				= HB_TAG ('N','k','o','o'),
+  HB_SCRIPT_PHAGS_PA			= HB_TAG ('P','h','a','g'),
+  HB_SCRIPT_PHOENICIAN			= HB_TAG ('P','h','n','x'),
+  HB_SCRIPT_UNKNOWN			= HB_TAG ('Z','z','z','z'),
+
+  /* Unicode-5.1 additions */
+  HB_SCRIPT_CARIAN			= HB_TAG ('C','a','r','i'),
+  HB_SCRIPT_CHAM			= HB_TAG ('C','h','a','m'),
+  HB_SCRIPT_KAYAH_LI			= HB_TAG ('K','a','l','i'),
+  HB_SCRIPT_LEPCHA			= HB_TAG ('L','e','p','c'),
+  HB_SCRIPT_LYCIAN			= HB_TAG ('L','y','c','i'),
+  HB_SCRIPT_LYDIAN			= HB_TAG ('L','y','d','i'),
+  HB_SCRIPT_OL_CHIKI			= HB_TAG ('O','l','c','k'),
+  HB_SCRIPT_REJANG			= HB_TAG ('R','j','n','g'),
+  HB_SCRIPT_SAURASHTRA			= HB_TAG ('S','a','u','r'),
+  HB_SCRIPT_SUNDANESE			= HB_TAG ('S','u','n','d'),
+  HB_SCRIPT_VAI				= HB_TAG ('V','a','i','i'),
+
+  /* Unicode-5.2 additions */
+  HB_SCRIPT_AVESTAN			= HB_TAG ('A','v','s','t'),
+  HB_SCRIPT_BAMUM			= HB_TAG ('B','a','m','u'),
+  HB_SCRIPT_EGYPTIAN_HIEROGLYPHS	= HB_TAG ('E','g','y','p'),
+  HB_SCRIPT_IMPERIAL_ARAMAIC		= HB_TAG ('A','r','m','i'),
+  HB_SCRIPT_INSCRIPTIONAL_PAHLAVI	= HB_TAG ('P','h','l','i'),
+  HB_SCRIPT_INSCRIPTIONAL_PARTHIAN	= HB_TAG ('P','r','t','i'),
+  HB_SCRIPT_JAVANESE			= HB_TAG ('J','a','v','a'),
+  HB_SCRIPT_KAITHI			= HB_TAG ('K','t','h','i'),
+  HB_SCRIPT_LISU			= HB_TAG ('L','i','s','u'),
+  HB_SCRIPT_MEETEI_MAYEK		= HB_TAG ('M','t','e','i'),
+  HB_SCRIPT_OLD_SOUTH_ARABIAN		= HB_TAG ('S','a','r','b'),
+  HB_SCRIPT_OLD_TURKIC			= HB_TAG ('O','r','k','h'),
+  HB_SCRIPT_SAMARITAN			= HB_TAG ('S','a','m','r'),
+  HB_SCRIPT_TAI_THAM			= HB_TAG ('L','a','n','a'),
+  HB_SCRIPT_TAI_VIET			= HB_TAG ('T','a','v','t'),
+
+  /* Unicode-6.0 additions */
+  HB_SCRIPT_BATAK			= HB_TAG ('B','a','t','k'),
+  HB_SCRIPT_BRAHMI			= HB_TAG ('B','r','a','h'),
+  HB_SCRIPT_MANDAIC			= HB_TAG ('M','a','n','d'),
+
+  /* Unicode-6.1 additions */
+  HB_SCRIPT_CHAKMA			= HB_TAG ('C','a','k','m'),
+  HB_SCRIPT_MEROITIC_CURSIVE		= HB_TAG ('M','e','r','c'),
+  HB_SCRIPT_MEROITIC_HIEROGLYPHS	= HB_TAG ('M','e','r','o'),
+  HB_SCRIPT_MIAO			= HB_TAG ('P','l','r','d'),
+  HB_SCRIPT_SHARADA			= HB_TAG ('S','h','r','d'),
+  HB_SCRIPT_SORA_SOMPENG		= HB_TAG ('S','o','r','a'),
+  HB_SCRIPT_TAKRI			= HB_TAG ('T','a','k','r'),
+
+  /* No script set */
+  HB_SCRIPT_INVALID			= HB_TAG_NONE
+} hb_script_t;
+
+
+/* Script functions */
+
+hb_script_t
+hb_script_from_iso15924_tag (hb_tag_t tag);
+
+/* suger for tag_from_string() then script_from_iso15924_tag */
+/* len=-1 means s is NUL-terminated */
+hb_script_t
+hb_script_from_string (const char *s, int len);
+
+hb_tag_t
+hb_script_to_iso15924_tag (hb_script_t script);
+
+hb_direction_t
+hb_script_get_horizontal_direction (hb_script_t script);
+
+
+/* User data */
+
+typedef struct _hb_user_data_key_t {
+  /*< private >*/
+  char unused;
+} hb_user_data_key_t;
+
+typedef void (*hb_destroy_func_t) (void *user_data);
+
+
+HB_END_DECLS
+
+#endif /* HB_COMMON_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-fallback-shape.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-fallback-shape.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-fallback-shape.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-fallback-shape.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,61 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-fallback-shape-private.hh"
+
+#include "hb-buffer-private.hh"
+
+hb_bool_t
+_hb_fallback_shape (hb_font_t          *font,
+		    hb_buffer_t        *buffer,
+		    const hb_feature_t *features,
+		    unsigned int        num_features)
+{
+  buffer->guess_properties ();
+
+  unsigned int count = buffer->len;
+
+  for (unsigned int i = 0; i < count; i++)
+    hb_font_get_glyph (font, buffer->info[i].codepoint, 0, &buffer->info[i].codepoint);
+
+  buffer->clear_positions ();
+
+  for (unsigned int i = 0; i < count; i++) {
+    hb_font_get_glyph_advance_for_direction (font, buffer->info[i].codepoint,
+					     buffer->props.direction,
+					     &buffer->pos[i].x_advance,
+					     &buffer->pos[i].y_advance);
+    hb_font_subtract_glyph_origin_for_direction (font, buffer->info[i].codepoint,
+						 buffer->props.direction,
+						 &buffer->pos[i].x_offset,
+						 &buffer->pos[i].y_offset);
+  }
+
+  if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))
+    hb_buffer_reverse (buffer);
+
+  return TRUE;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-fallback-shape-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-fallback-shape-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-fallback-shape-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-fallback-shape-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,47 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_FALLBACK_SHAPE_PRIVATE_HH
+#define HB_FALLBACK_SHAPE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-shape.h"
+
+
+HB_BEGIN_DECLS
+
+
+HB_INTERNAL hb_bool_t
+_hb_fallback_shape (hb_font_t          *font,
+		    hb_buffer_t        *buffer,
+		    const hb_feature_t *features,
+		    unsigned int        num_features);
+
+
+HB_END_DECLS
+
+#endif /* HB_FALLBACK_SHAPE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,988 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-ot-layout-private.hh"
+
+#include "hb-font-private.hh"
+#include "hb-blob.h"
+#include "hb-open-file-private.hh"
+#include "hb-ot-head-table.hh"
+
+#include <string.h>
+
+
+
+/*
+ * hb_font_funcs_t
+ */
+
+static hb_bool_t
+hb_font_get_glyph_nil (hb_font_t *font HB_UNUSED,
+		       void *font_data HB_UNUSED,
+		       hb_codepoint_t unicode,
+		       hb_codepoint_t variation_selector,
+		       hb_codepoint_t *glyph,
+		       void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return hb_font_get_glyph (font->parent, unicode, variation_selector, glyph);
+
+  *glyph = 0;
+  return FALSE;
+}
+
+static hb_position_t
+hb_font_get_glyph_h_advance_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_x_distance (hb_font_get_glyph_h_advance (font->parent, glyph));
+
+  return font->x_scale;
+}
+
+static hb_position_t
+hb_font_get_glyph_v_advance_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_y_distance (hb_font_get_glyph_v_advance (font->parent, glyph));
+
+  return font->y_scale;
+}
+
+static hb_bool_t
+hb_font_get_glyph_h_origin_nil (hb_font_t *font HB_UNUSED,
+				void *font_data HB_UNUSED,
+				hb_codepoint_t glyph,
+				hb_position_t *x,
+				hb_position_t *y,
+				void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_h_origin (font->parent,
+						glyph,
+						x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+static hb_bool_t
+hb_font_get_glyph_v_origin_nil (hb_font_t *font HB_UNUSED,
+				void *font_data HB_UNUSED,
+				hb_codepoint_t glyph,
+				hb_position_t *x,
+				hb_position_t *y,
+				void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_v_origin (font->parent,
+						glyph,
+						x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+static hb_position_t
+hb_font_get_glyph_h_kerning_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t left_glyph,
+				 hb_codepoint_t right_glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_x_distance (hb_font_get_glyph_h_kerning (font->parent, left_glyph, right_glyph));
+
+  return 0;
+}
+
+static hb_position_t
+hb_font_get_glyph_v_kerning_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t top_glyph,
+				 hb_codepoint_t bottom_glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_y_distance (hb_font_get_glyph_v_kerning (font->parent, top_glyph, bottom_glyph));
+
+  return 0;
+}
+
+static hb_bool_t
+hb_font_get_glyph_extents_nil (hb_font_t *font HB_UNUSED,
+			       void *font_data HB_UNUSED,
+			       hb_codepoint_t glyph,
+			       hb_glyph_extents_t *extents,
+			       void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_extents (font->parent,
+					       glyph,
+					       extents);
+    if (ret) {
+      font->parent_scale_position (&extents->x_bearing, &extents->y_bearing);
+      font->parent_scale_distance (&extents->width, &extents->height);
+    }
+    return ret;
+  }
+
+  memset (extents, 0, sizeof (*extents));
+  return FALSE;
+}
+
+static hb_bool_t
+hb_font_get_glyph_contour_point_nil (hb_font_t *font HB_UNUSED,
+				     void *font_data HB_UNUSED,
+				     hb_codepoint_t glyph,
+				     unsigned int point_index,
+				     hb_position_t *x,
+				     hb_position_t *y,
+				     void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_contour_point (font->parent,
+						     glyph, point_index,
+						     x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+
+static hb_font_funcs_t _hb_font_funcs_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  {
+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,
+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+  }
+};
+
+
+hb_font_funcs_t *
+hb_font_funcs_create (void)
+{
+  hb_font_funcs_t *ffuncs;
+
+  if (!(ffuncs = hb_object_create<hb_font_funcs_t> ()))
+    return &_hb_font_funcs_nil;
+
+  ffuncs->get = _hb_font_funcs_nil.get;
+
+  return ffuncs;
+}
+
+hb_font_funcs_t *
+hb_font_funcs_get_empty (void)
+{
+  return &_hb_font_funcs_nil;
+}
+
+hb_font_funcs_t *
+hb_font_funcs_reference (hb_font_funcs_t *ffuncs)
+{
+  return hb_object_reference (ffuncs);
+}
+
+void
+hb_font_funcs_destroy (hb_font_funcs_t *ffuncs)
+{
+  if (!hb_object_destroy (ffuncs)) return;
+
+#define HB_FONT_FUNC_IMPLEMENT(name) if (ffuncs->destroy.name) \
+  ffuncs->destroy.name (ffuncs->user_data.name);
+  HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+
+  free (ffuncs);
+}
+
+hb_bool_t
+hb_font_funcs_set_user_data (hb_font_funcs_t    *ffuncs,
+			     hb_user_data_key_t *key,
+			     void *              data,
+			     hb_destroy_func_t   destroy,
+			     hb_bool_t           replace)
+{
+  return hb_object_set_user_data (ffuncs, key, data, destroy, replace);
+}
+
+void *
+hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,
+			     hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (ffuncs, key);
+}
+
+
+void
+hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs)
+{
+  if (hb_object_is_inert (ffuncs))
+    return;
+
+  ffuncs->immutable = TRUE;
+}
+
+hb_bool_t
+hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs)
+{
+  return ffuncs->immutable;
+}
+
+
+#define HB_FONT_FUNC_IMPLEMENT(name) \
+                                                                         \
+void                                                                     \
+hb_font_funcs_set_##name##_func (hb_font_funcs_t             *ffuncs,    \
+                                 hb_font_get_##name##_func_t  func,      \
+                                 void                        *user_data, \
+                                 hb_destroy_func_t            destroy)   \
+{                                                                        \
+  if (ffuncs->immutable) {                                               \
+    if (destroy)                                                         \
+      destroy (user_data);                                               \
+    return;                                                              \
+  }                                                                      \
+                                                                         \
+  if (ffuncs->destroy.name)                                              \
+    ffuncs->destroy.name (ffuncs->user_data.name);                       \
+                                                                         \
+  if (func) {                                                            \
+    ffuncs->get.name = func;                                             \
+    ffuncs->user_data.name = user_data;                                  \
+    ffuncs->destroy.name = destroy;                                      \
+  } else {                                                               \
+    ffuncs->get.name = hb_font_get_##name##_nil;                         \
+    ffuncs->user_data.name = NULL;                                       \
+    ffuncs->destroy.name = NULL;                                         \
+  }                                                                      \
+}
+
+HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+
+
+hb_bool_t
+hb_font_get_glyph (hb_font_t *font,
+		   hb_codepoint_t unicode, hb_codepoint_t variation_selector,
+		   hb_codepoint_t *glyph)
+{
+  *glyph = 0;
+  return font->klass->get.glyph (font, font->user_data,
+				 unicode, variation_selector, glyph,
+				 font->klass->user_data.glyph);
+}
+
+hb_position_t
+hb_font_get_glyph_h_advance (hb_font_t *font,
+			     hb_codepoint_t glyph)
+{
+  return font->klass->get.glyph_h_advance (font, font->user_data,
+					   glyph,
+					   font->klass->user_data.glyph_h_advance);
+}
+
+hb_position_t
+hb_font_get_glyph_v_advance (hb_font_t *font,
+			     hb_codepoint_t glyph)
+{
+  return font->klass->get.glyph_v_advance (font, font->user_data,
+					   glyph,
+					   font->klass->user_data.glyph_v_advance);
+}
+
+hb_bool_t
+hb_font_get_glyph_h_origin (hb_font_t *font,
+			    hb_codepoint_t glyph,
+			    hb_position_t *x, hb_position_t *y)
+{
+  *x = *y = 0;
+  return font->klass->get.glyph_h_origin (font, font->user_data,
+					   glyph, x, y,
+					   font->klass->user_data.glyph_h_origin);
+}
+
+hb_bool_t
+hb_font_get_glyph_v_origin (hb_font_t *font,
+			    hb_codepoint_t glyph,
+			    hb_position_t *x, hb_position_t *y)
+{
+  *x = *y = 0;
+  return font->klass->get.glyph_v_origin (font, font->user_data,
+					   glyph, x, y,
+					   font->klass->user_data.glyph_v_origin);
+}
+
+hb_position_t
+hb_font_get_glyph_h_kerning (hb_font_t *font,
+			     hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
+{
+  return font->klass->get.glyph_h_kerning (font, font->user_data,
+					   left_glyph, right_glyph,
+					   font->klass->user_data.glyph_h_kerning);
+}
+
+hb_position_t
+hb_font_get_glyph_v_kerning (hb_font_t *font,
+			     hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)
+{
+  return font->klass->get.glyph_v_kerning (font, font->user_data,
+				     left_glyph, right_glyph,
+				     font->klass->user_data.glyph_v_kerning);
+}
+
+hb_bool_t
+hb_font_get_glyph_extents (hb_font_t *font,
+			   hb_codepoint_t glyph,
+			   hb_glyph_extents_t *extents)
+{
+  memset (extents, 0, sizeof (*extents));
+  return font->klass->get.glyph_extents (font, font->user_data,
+					 glyph,
+					 extents,
+					 font->klass->user_data.glyph_extents);
+}
+
+hb_bool_t
+hb_font_get_glyph_contour_point (hb_font_t *font,
+				 hb_codepoint_t glyph, unsigned int point_index,
+				 hb_position_t *x, hb_position_t *y)
+{
+  *x = *y = 0;
+  return font->klass->get.glyph_contour_point (font, font->user_data,
+					       glyph, point_index,
+					       x, y,
+					       font->klass->user_data.glyph_contour_point);
+}
+
+
+/* A bit higher-level, and with fallback */
+
+void
+hb_font_get_glyph_advance_for_direction (hb_font_t *font,
+					 hb_codepoint_t glyph,
+					 hb_direction_t direction,
+					 hb_position_t *x, hb_position_t *y)
+{
+  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+    *x = hb_font_get_glyph_h_advance (font, glyph);
+    *y = 0;
+  } else {
+    *x = 0;
+    *y = hb_font_get_glyph_v_advance (font, glyph);
+  }
+}
+
+static void
+guess_v_origin_minus_h_origin (hb_font_t *font,
+			       hb_codepoint_t glyph,
+			       hb_position_t *x, hb_position_t *y)
+{
+  *x = hb_font_get_glyph_h_advance (font, glyph) / 2;
+
+  /* TODO use font_metics.ascent */
+  *y = font->y_scale;
+}
+
+
+void
+hb_font_get_glyph_origin_for_direction (hb_font_t *font,
+					hb_codepoint_t glyph,
+					hb_direction_t direction,
+					hb_position_t *x, hb_position_t *y)
+{
+  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+    hb_bool_t ret = hb_font_get_glyph_h_origin (font, glyph, x, y);
+    if (!ret && (ret = hb_font_get_glyph_v_origin (font, glyph, x, y))) {
+      hb_position_t dx, dy;
+      guess_v_origin_minus_h_origin (font, glyph, &dx, &dy);
+      *x -= dx; *y -= dy;
+    }
+  } else {
+    hb_bool_t ret = hb_font_get_glyph_v_origin (font, glyph, x, y);
+    if (!ret && (ret = hb_font_get_glyph_h_origin (font, glyph, x, y))) {
+      hb_position_t dx, dy;
+      guess_v_origin_minus_h_origin (font, glyph, &dx, &dy);
+      *x += dx; *y += dy;
+    }
+  }
+}
+
+void
+hb_font_add_glyph_origin_for_direction (hb_font_t *font,
+					hb_codepoint_t glyph,
+					hb_direction_t direction,
+					hb_position_t *x, hb_position_t *y)
+{
+  hb_position_t origin_x, origin_y;
+
+  hb_font_get_glyph_origin_for_direction (font, glyph, direction, &origin_x, &origin_y);
+
+  *x += origin_x;
+  *y += origin_y;
+}
+
+void
+hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,
+					     hb_codepoint_t glyph,
+					     hb_direction_t direction,
+					     hb_position_t *x, hb_position_t *y)
+{
+  hb_position_t origin_x, origin_y;
+
+  hb_font_get_glyph_origin_for_direction (font, glyph, direction, &origin_x, &origin_y);
+
+  *x -= origin_x;
+  *y -= origin_y;
+}
+
+void
+hb_font_get_glyph_kerning_for_direction (hb_font_t *font,
+					 hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
+					 hb_direction_t direction,
+					 hb_position_t *x, hb_position_t *y)
+{
+  if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {
+    *x = hb_font_get_glyph_h_kerning (font, first_glyph, second_glyph);
+    *y = 0;
+  } else {
+    *x = 0;
+    *y = hb_font_get_glyph_v_kerning (font, first_glyph, second_glyph);
+  }
+}
+
+hb_bool_t
+hb_font_get_glyph_extents_for_origin (hb_font_t *font,
+				      hb_codepoint_t glyph,
+				      hb_direction_t direction,
+				      hb_glyph_extents_t *extents)
+{
+  hb_bool_t ret = hb_font_get_glyph_extents (font, glyph, extents);
+
+  if (ret)
+    hb_font_subtract_glyph_origin_for_direction (font, glyph, direction, &extents->x_bearing, &extents->y_bearing);
+
+  return ret;
+}
+
+hb_bool_t
+hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,
+					    hb_codepoint_t glyph, unsigned int point_index,
+					    hb_direction_t direction,
+					    hb_position_t *x, hb_position_t *y)
+{
+  hb_bool_t ret = hb_font_get_glyph_contour_point (font, glyph, point_index, x, y);
+
+  if (ret)
+    hb_font_subtract_glyph_origin_for_direction (font, glyph, direction, x, y);
+
+  return ret;
+}
+
+
+/*
+ * hb_face_t
+ */
+
+static hb_face_t _hb_face_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  NULL, /* reference_table */
+  NULL, /* user_data */
+  NULL, /* destroy */
+
+  NULL, /* ot_layout */
+
+  0,    /* index */
+  1000  /* upem */
+};
+
+
+hb_face_t *
+hb_face_create_for_tables (hb_reference_table_func_t  reference_table,
+			   void                      *user_data,
+			   hb_destroy_func_t          destroy)
+{
+  hb_face_t *face;
+
+  if (!reference_table || !(face = hb_object_create<hb_face_t> ())) {
+    if (destroy)
+      destroy (user_data);
+    return &_hb_face_nil;
+  }
+
+  face->reference_table = reference_table;
+  face->user_data = user_data;
+  face->destroy = destroy;
+
+  face->ot_layout = _hb_ot_layout_create (face);
+
+  face->upem = 0;
+
+  return face;
+}
+
+
+typedef struct _hb_face_for_data_closure_t {
+  hb_blob_t *blob;
+  unsigned int  index;
+} hb_face_for_data_closure_t;
+
+static hb_face_for_data_closure_t *
+_hb_face_for_data_closure_create (hb_blob_t *blob, unsigned int index)
+{
+  hb_face_for_data_closure_t *closure;
+
+  closure = (hb_face_for_data_closure_t *) malloc (sizeof (hb_face_for_data_closure_t));
+  if (unlikely (!closure))
+    return NULL;
+
+  closure->blob = blob;
+  closure->index = index;
+
+  return closure;
+}
+
+static void
+_hb_face_for_data_closure_destroy (hb_face_for_data_closure_t *closure)
+{
+  hb_blob_destroy (closure->blob);
+  free (closure);
+}
+
+static hb_blob_t *
+_hb_face_for_data_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
+{
+  hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) user_data;
+
+  if (tag == HB_TAG_NONE)
+    return hb_blob_reference (data->blob);
+
+  const OpenTypeFontFile &ot_file = *Sanitizer<OpenTypeFontFile>::lock_instance (data->blob);
+  const OpenTypeFontFace &ot_face = ot_file.get_face (data->index);
+
+  const OpenTypeTable &table = ot_face.get_table_by_tag (tag);
+
+  hb_blob_t *blob = hb_blob_create_sub_blob (data->blob, table.offset, table.length);
+
+  return blob;
+}
+
+hb_face_t *
+hb_face_create (hb_blob_t    *blob,
+		unsigned int  index)
+{
+  hb_face_t *face;
+
+  if (unlikely (!blob || !hb_blob_get_length (blob)))
+    return &_hb_face_nil;
+
+  hb_face_for_data_closure_t *closure = _hb_face_for_data_closure_create (Sanitizer<OpenTypeFontFile>::sanitize (hb_blob_reference (blob)), index);
+
+  if (unlikely (!closure))
+    return &_hb_face_nil;
+
+  face = hb_face_create_for_tables (_hb_face_for_data_reference_table,
+				    closure,
+				    (hb_destroy_func_t) _hb_face_for_data_closure_destroy);
+
+  hb_face_set_index (face, index);
+
+  return face;
+}
+
+hb_face_t *
+hb_face_get_empty (void)
+{
+  return &_hb_face_nil;
+}
+
+
+hb_face_t *
+hb_face_reference (hb_face_t *face)
+{
+  return hb_object_reference (face);
+}
+
+void
+hb_face_destroy (hb_face_t *face)
+{
+  if (!hb_object_destroy (face)) return;
+
+  _hb_ot_layout_destroy (face->ot_layout);
+
+  if (face->destroy)
+    face->destroy (face->user_data);
+
+  free (face);
+}
+
+hb_bool_t
+hb_face_set_user_data (hb_face_t          *face,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace)
+{
+  return hb_object_set_user_data (face, key, data, destroy, replace);
+}
+
+void *
+hb_face_get_user_data (hb_face_t          *face,
+		       hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (face, key);
+}
+
+void
+hb_face_make_immutable (hb_face_t *face)
+{
+  if (hb_object_is_inert (face))
+    return;
+
+  face->immutable = true;
+}
+
+hb_bool_t
+hb_face_is_immutable (hb_face_t *face)
+{
+  return face->immutable;
+}
+
+
+hb_blob_t *
+hb_face_reference_table (hb_face_t *face,
+			 hb_tag_t   tag)
+{
+  hb_blob_t *blob;
+
+  if (unlikely (!face || !face->reference_table))
+    return hb_blob_get_empty ();
+
+  blob = face->reference_table (face, tag, face->user_data);
+  if (unlikely (!blob))
+    return hb_blob_get_empty ();
+
+  return blob;
+}
+
+hb_blob_t *
+hb_face_reference_blob (hb_face_t *face)
+{
+  return hb_face_reference_table (face, HB_TAG_NONE);
+}
+
+void
+hb_face_set_index (hb_face_t    *face,
+		   unsigned int  index)
+{
+  if (hb_object_is_inert (face))
+    return;
+
+  face->index = 0;
+}
+
+unsigned int
+hb_face_get_index (hb_face_t    *face)
+{
+  return face->index;
+}
+
+void
+hb_face_set_upem (hb_face_t    *face,
+		  unsigned int  upem)
+{
+  if (hb_object_is_inert (face))
+    return;
+
+  face->upem = upem;
+}
+
+unsigned int
+hb_face_get_upem (hb_face_t *face)
+{
+  if (unlikely (!face->upem)) {
+    hb_blob_t *head_blob = Sanitizer<head>::sanitize (hb_face_reference_table (face, HB_OT_TAG_head));
+    const head *head_table = Sanitizer<head>::lock_instance (head_blob);
+    face->upem = head_table->get_upem ();
+    hb_blob_destroy (head_blob);
+  }
+  return face->upem;
+}
+
+
+/*
+ * hb_font_t
+ */
+
+static hb_font_t _hb_font_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  NULL, /* parent */
+  &_hb_face_nil,
+
+  0, /* x_scale */
+  0, /* y_scale */
+
+  0, /* x_ppem */
+  0, /* y_ppem */
+
+  &_hb_font_funcs_nil, /* klass */
+  NULL, /* user_data */
+  NULL  /* destroy */
+};
+
+hb_font_t *
+hb_font_create (hb_face_t *face)
+{
+  hb_font_t *font;
+
+  if (unlikely (!face))
+    face = &_hb_face_nil;
+  if (unlikely (hb_object_is_inert (face)))
+    return &_hb_font_nil;
+  if (!(font = hb_object_create<hb_font_t> ()))
+    return &_hb_font_nil;
+
+  hb_face_make_immutable (face);
+  font->face = hb_face_reference (face);
+  font->klass = &_hb_font_funcs_nil;
+
+  return font;
+}
+
+hb_font_t *
+hb_font_create_sub_font (hb_font_t *parent)
+{
+  if (unlikely (!parent))
+    return &_hb_font_nil;
+
+  hb_font_t *font = hb_font_create (parent->face);
+
+  if (unlikely (hb_object_is_inert (font)))
+    return font;
+
+  hb_font_make_immutable (parent);
+  font->parent = hb_font_reference (parent);
+
+  font->x_scale = parent->x_scale;
+  font->y_scale = parent->y_scale;
+  font->x_ppem = parent->x_ppem;
+  font->y_ppem = parent->y_ppem;
+
+  font->klass = &_hb_font_funcs_nil;
+
+  return font;
+}
+
+hb_font_t *
+hb_font_get_empty (void)
+{
+  return &_hb_font_nil;
+}
+
+hb_font_t *
+hb_font_reference (hb_font_t *font)
+{
+  return hb_object_reference (font);
+}
+
+void
+hb_font_destroy (hb_font_t *font)
+{
+  if (!hb_object_destroy (font)) return;
+
+  hb_font_destroy (font->parent);
+  hb_face_destroy (font->face);
+  hb_font_funcs_destroy (font->klass);
+  if (font->destroy)
+    font->destroy (font->user_data);
+
+  free (font);
+}
+
+hb_bool_t
+hb_font_set_user_data (hb_font_t          *font,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace)
+{
+  return hb_object_set_user_data (font, key, data, destroy, replace);
+}
+
+void *
+hb_font_get_user_data (hb_font_t          *font,
+		       hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (font, key);
+}
+
+void
+hb_font_make_immutable (hb_font_t *font)
+{
+  if (hb_object_is_inert (font))
+    return;
+
+  font->immutable = true;
+}
+
+hb_bool_t
+hb_font_is_immutable (hb_font_t *font)
+{
+  return font->immutable;
+}
+
+hb_font_t *
+hb_font_get_parent (hb_font_t *font)
+{
+  return font->parent;
+}
+
+hb_face_t *
+hb_font_get_face (hb_font_t *font)
+{
+  return font->face;
+}
+
+
+void
+hb_font_set_funcs (hb_font_t         *font,
+		   hb_font_funcs_t   *klass,
+		   void              *user_data,
+		   hb_destroy_func_t  destroy)
+{
+  if (font->immutable) {
+    if (destroy)
+      destroy (user_data);
+    return;
+  }
+
+  if (font->destroy)
+    font->destroy (font->user_data);
+
+  if (!klass)
+    klass = &_hb_font_funcs_nil;
+
+  hb_font_funcs_reference (klass);
+  hb_font_funcs_destroy (font->klass);
+  font->klass = klass;
+  font->user_data = user_data;
+  font->destroy = destroy;
+}
+
+void
+hb_font_set_funcs_data (hb_font_t         *font,
+		        void              *user_data,
+		        hb_destroy_func_t  destroy)
+{
+  /* Destroy user_data? */
+  if (font->immutable) {
+    if (destroy)
+      destroy (user_data);
+    return;
+  }
+
+  if (font->destroy)
+    font->destroy (font->user_data);
+
+  font->user_data = user_data;
+  font->destroy = destroy;
+}
+
+
+void
+hb_font_set_scale (hb_font_t *font,
+		   int x_scale,
+		   int y_scale)
+{
+  if (font->immutable)
+    return;
+
+  font->x_scale = x_scale;
+  font->y_scale = y_scale;
+}
+
+void
+hb_font_get_scale (hb_font_t *font,
+		   int *x_scale,
+		   int *y_scale)
+{
+  if (x_scale) *x_scale = font->x_scale;
+  if (y_scale) *y_scale = font->y_scale;
+}
+
+void
+hb_font_set_ppem (hb_font_t *font,
+		  unsigned int x_ppem,
+		  unsigned int y_ppem)
+{
+  if (font->immutable)
+    return;
+
+  font->x_ppem = x_ppem;
+  font->y_ppem = y_ppem;
+}
+
+void
+hb_font_get_ppem (hb_font_t *font,
+		  unsigned int *x_ppem,
+		  unsigned int *y_ppem)
+{
+  if (x_ppem) *x_ppem = font->x_ppem;
+  if (y_ppem) *y_ppem = font->y_ppem;
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,407 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_FONT_H
+#define HB_FONT_H
+
+#include "hb-common.h"
+#include "hb-blob.h"
+
+HB_BEGIN_DECLS
+
+
+typedef struct _hb_face_t hb_face_t;
+typedef struct _hb_font_t hb_font_t;
+
+/*
+ * hb_face_t
+ */
+
+hb_face_t *
+hb_face_create (hb_blob_t    *blob,
+		unsigned int  index);
+
+typedef hb_blob_t * (*hb_reference_table_func_t)  (hb_face_t *face, hb_tag_t tag, void *user_data);
+
+/* calls destroy() when not needing user_data anymore */
+hb_face_t *
+hb_face_create_for_tables (hb_reference_table_func_t  reference_table,
+			   void                      *user_data,
+			   hb_destroy_func_t          destroy);
+
+hb_face_t *
+hb_face_get_empty (void);
+
+hb_face_t *
+hb_face_reference (hb_face_t *face);
+
+void
+hb_face_destroy (hb_face_t *face);
+
+hb_bool_t
+hb_face_set_user_data (hb_face_t          *face,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace);
+
+
+void *
+hb_face_get_user_data (hb_face_t          *face,
+		       hb_user_data_key_t *key);
+
+void
+hb_face_make_immutable (hb_face_t *face);
+
+hb_bool_t
+hb_face_is_immutable (hb_face_t *face);
+
+
+hb_blob_t *
+hb_face_reference_table (hb_face_t *face,
+			 hb_tag_t   tag);
+
+hb_blob_t *
+hb_face_reference_blob (hb_face_t *face);
+
+void
+hb_face_set_index (hb_face_t    *face,
+		   unsigned int  index);
+
+unsigned int
+hb_face_get_index (hb_face_t    *face);
+
+void
+hb_face_set_upem (hb_face_t    *face,
+		  unsigned int  upem);
+
+unsigned int
+hb_face_get_upem (hb_face_t *face);
+
+
+/*
+ * hb_font_funcs_t
+ */
+
+typedef struct _hb_font_funcs_t hb_font_funcs_t;
+
+hb_font_funcs_t *
+hb_font_funcs_create (void);
+
+hb_font_funcs_t *
+hb_font_funcs_get_empty (void);
+
+hb_font_funcs_t *
+hb_font_funcs_reference (hb_font_funcs_t *ffuncs);
+
+void
+hb_font_funcs_destroy (hb_font_funcs_t *ffuncs);
+
+hb_bool_t
+hb_font_funcs_set_user_data (hb_font_funcs_t    *ffuncs,
+			     hb_user_data_key_t *key,
+			     void *              data,
+			     hb_destroy_func_t   destroy,
+			     hb_bool_t           replace);
+
+
+void *
+hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,
+			     hb_user_data_key_t *key);
+
+
+void
+hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs);
+
+hb_bool_t
+hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs);
+
+/* funcs */
+
+typedef struct _hb_glyph_extents_t
+{
+  hb_position_t x_bearing;
+  hb_position_t y_bearing;
+  hb_position_t width;
+  hb_position_t height;
+} hb_glyph_extents_t;
+
+
+/* func types */
+
+typedef hb_bool_t (*hb_font_get_glyph_func_t) (hb_font_t *font, void *font_data,
+					       hb_codepoint_t unicode, hb_codepoint_t variation_selector,
+					       hb_codepoint_t *glyph,
+					       void *user_data);
+
+
+typedef hb_position_t (*hb_font_get_glyph_advance_func_t) (hb_font_t *font, void *font_data,
+							   hb_codepoint_t glyph,
+							   void *user_data);
+typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_h_advance_func_t;
+typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_v_advance_func_t;
+
+typedef hb_bool_t (*hb_font_get_glyph_origin_func_t) (hb_font_t *font, void *font_data,
+						      hb_codepoint_t glyph,
+						      hb_position_t *x, hb_position_t *y,
+						      void *user_data);
+typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_h_origin_func_t;
+typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_v_origin_func_t;
+
+typedef hb_position_t (*hb_font_get_glyph_kerning_func_t) (hb_font_t *font, void *font_data,
+							   hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
+							   void *user_data);
+typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_h_kerning_func_t;
+typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_v_kerning_func_t;
+
+
+typedef hb_bool_t (*hb_font_get_glyph_extents_func_t) (hb_font_t *font, void *font_data,
+						       hb_codepoint_t glyph,
+						       hb_glyph_extents_t *extents,
+						       void *user_data);
+typedef hb_bool_t (*hb_font_get_glyph_contour_point_func_t) (hb_font_t *font, void *font_data,
+							     hb_codepoint_t glyph, unsigned int point_index,
+							     hb_position_t *x, hb_position_t *y,
+							     void *user_data);
+
+
+/* func setters */
+
+void
+hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,
+			      hb_font_get_glyph_func_t glyph_func,
+			      void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_font_funcs_set_glyph_h_advance_func (hb_font_funcs_t *ffuncs,
+					hb_font_get_glyph_h_advance_func_t func,
+					void *user_data, hb_destroy_func_t destroy);
+void
+hb_font_funcs_set_glyph_v_advance_func (hb_font_funcs_t *ffuncs,
+					hb_font_get_glyph_v_advance_func_t func,
+					void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_font_funcs_set_glyph_h_origin_func (hb_font_funcs_t *ffuncs,
+				       hb_font_get_glyph_h_origin_func_t func,
+				       void *user_data, hb_destroy_func_t destroy);
+void
+hb_font_funcs_set_glyph_v_origin_func (hb_font_funcs_t *ffuncs,
+				       hb_font_get_glyph_v_origin_func_t func,
+				       void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_font_funcs_set_glyph_h_kerning_func (hb_font_funcs_t *ffuncs,
+					hb_font_get_glyph_h_kerning_func_t func,
+					void *user_data, hb_destroy_func_t destroy);
+void
+hb_font_funcs_set_glyph_v_kerning_func (hb_font_funcs_t *ffuncs,
+					hb_font_get_glyph_v_kerning_func_t func,
+					void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_font_funcs_set_glyph_extents_func (hb_font_funcs_t *ffuncs,
+				      hb_font_get_glyph_extents_func_t func,
+				      void *user_data, hb_destroy_func_t destroy);
+void
+hb_font_funcs_set_glyph_contour_point_func (hb_font_funcs_t *ffuncs,
+					    hb_font_get_glyph_contour_point_func_t func,
+					    void *user_data, hb_destroy_func_t destroy);
+
+
+/* func dispatch */
+
+hb_bool_t
+hb_font_get_glyph (hb_font_t *font,
+		   hb_codepoint_t unicode, hb_codepoint_t variation_selector,
+		   hb_codepoint_t *glyph);
+
+hb_position_t
+hb_font_get_glyph_h_advance (hb_font_t *font,
+			     hb_codepoint_t glyph);
+hb_position_t
+hb_font_get_glyph_v_advance (hb_font_t *font,
+			     hb_codepoint_t glyph);
+
+hb_bool_t
+hb_font_get_glyph_h_origin (hb_font_t *font,
+			    hb_codepoint_t glyph,
+			    hb_position_t *x, hb_position_t *y);
+hb_bool_t
+hb_font_get_glyph_v_origin (hb_font_t *font,
+			    hb_codepoint_t glyph,
+			    hb_position_t *x, hb_position_t *y);
+
+hb_position_t
+hb_font_get_glyph_h_kerning (hb_font_t *font,
+			     hb_codepoint_t left_glyph, hb_codepoint_t right_glyph);
+hb_position_t
+hb_font_get_glyph_v_kerning (hb_font_t *font,
+			     hb_codepoint_t top_glyph, hb_codepoint_t bottom_glyph);
+
+hb_bool_t
+hb_font_get_glyph_extents (hb_font_t *font,
+			   hb_codepoint_t glyph,
+			   hb_glyph_extents_t *extents);
+
+hb_bool_t
+hb_font_get_glyph_contour_point (hb_font_t *font,
+				 hb_codepoint_t glyph, unsigned int point_index,
+				 hb_position_t *x, hb_position_t *y);
+
+
+/* high-level funcs, with fallback */
+
+void
+hb_font_get_glyph_advance_for_direction (hb_font_t *font,
+					 hb_codepoint_t glyph,
+					 hb_direction_t direction,
+					 hb_position_t *x, hb_position_t *y);
+void
+hb_font_get_glyph_origin_for_direction (hb_font_t *font,
+					hb_codepoint_t glyph,
+					hb_direction_t direction,
+					hb_position_t *x, hb_position_t *y);
+void
+hb_font_add_glyph_origin_for_direction (hb_font_t *font,
+					hb_codepoint_t glyph,
+					hb_direction_t direction,
+					hb_position_t *x, hb_position_t *y);
+void
+hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,
+					     hb_codepoint_t glyph,
+					     hb_direction_t direction,
+					     hb_position_t *x, hb_position_t *y);
+
+void
+hb_font_get_glyph_kerning_for_direction (hb_font_t *font,
+					 hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
+					 hb_direction_t direction,
+					 hb_position_t *x, hb_position_t *y);
+
+hb_bool_t
+hb_font_get_glyph_extents_for_origin (hb_font_t *font,
+				      hb_codepoint_t glyph,
+				      hb_direction_t direction,
+				      hb_glyph_extents_t *extents);
+
+hb_bool_t
+hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,
+					    hb_codepoint_t glyph, unsigned int point_index,
+					    hb_direction_t direction,
+					    hb_position_t *x, hb_position_t *y);
+
+
+/*
+ * hb_font_t
+ */
+
+/* Fonts are very light-weight objects */
+
+hb_font_t *
+hb_font_create (hb_face_t *face);
+
+hb_font_t *
+hb_font_create_sub_font (hb_font_t *parent);
+
+hb_font_t *
+hb_font_get_empty (void);
+
+hb_font_t *
+hb_font_reference (hb_font_t *font);
+
+void
+hb_font_destroy (hb_font_t *font);
+
+hb_bool_t
+hb_font_set_user_data (hb_font_t          *font,
+		       hb_user_data_key_t *key,
+		       void *              data,
+		       hb_destroy_func_t   destroy,
+		       hb_bool_t           replace);
+
+
+void *
+hb_font_get_user_data (hb_font_t          *font,
+		       hb_user_data_key_t *key);
+
+void
+hb_font_make_immutable (hb_font_t *font);
+
+hb_bool_t
+hb_font_is_immutable (hb_font_t *font);
+
+hb_font_t *
+hb_font_get_parent (hb_font_t *font);
+
+hb_face_t *
+hb_font_get_face (hb_font_t *font);
+
+
+void
+hb_font_set_funcs (hb_font_t         *font,
+		   hb_font_funcs_t   *klass,
+		   void              *font_data,
+		   hb_destroy_func_t  destroy);
+
+/* Be *very* careful with this function! */
+void
+hb_font_set_funcs_data (hb_font_t         *font,
+		        void              *font_data,
+		        hb_destroy_func_t  destroy);
+
+
+void
+hb_font_set_scale (hb_font_t *font,
+		   int x_scale,
+		   int y_scale);
+
+void
+hb_font_get_scale (hb_font_t *font,
+		   int *x_scale,
+		   int *y_scale);
+
+/*
+ * A zero value means "no hinting in that direction"
+ */
+void
+hb_font_set_ppem (hb_font_t *font,
+		  unsigned int x_ppem,
+		  unsigned int y_ppem);
+
+void
+hb_font_get_ppem (hb_font_t *font,
+		  unsigned int *x_ppem,
+		  unsigned int *y_ppem);
+
+
+HB_END_DECLS
+
+#endif /* HB_FONT_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font-private.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font-private.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font-private.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font-private.h	2012-05-05 23:46:51.518763796 +0530
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_FONT_PRIVATE_H
+#define HB_FONT_PRIVATE_H
+
+#include "hb-private.h"
+
+#include "hb-font.h"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * hb_font_funcs_t
+ */
+
+struct _hb_font_funcs_t {
+  hb_reference_count_t ref_count;
+
+  hb_bool_t immutable;
+
+  struct {
+    hb_font_get_glyph_func_t		get_glyph;
+    hb_font_get_contour_point_func_t	get_contour_point;
+    hb_font_get_glyph_metrics_func_t	get_glyph_metrics;
+    hb_font_get_kerning_func_t		get_kerning;
+  } v;
+};
+
+extern HB_INTERNAL hb_font_funcs_t _hb_font_funcs_nil;
+
+
+/*
+ * hb_face_t
+ */
+
+struct _hb_face_t {
+  hb_reference_count_t ref_count;
+
+  hb_get_table_func_t  get_table;
+  hb_destroy_func_t    destroy;
+  void                *user_data;
+
+  hb_blob_t *head_blob;
+  const struct head *head_table;
+
+  struct hb_ot_layout_t *ot_layout;
+};
+
+
+/*
+ * hb_font_t
+ */
+
+struct _hb_font_t {
+  hb_reference_count_t ref_count;
+
+  unsigned int x_scale;
+  unsigned int y_scale;
+
+  unsigned int x_ppem;
+  unsigned int y_ppem;
+
+  hb_font_funcs_t   *klass;
+  hb_destroy_func_t  destroy;
+  void              *user_data;
+};
+
+
+HB_END_DECLS
+
+#endif /* HB_FONT_PRIVATE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-font-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-font-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,163 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_FONT_PRIVATE_HH
+#define HB_FONT_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-font.h"
+#include "hb-object-private.hh"
+
+
+
+/*
+ * hb_font_funcs_t
+ */
+
+#define HB_FONT_FUNCS_IMPLEMENT_CALLBACKS \
+  HB_FONT_FUNC_IMPLEMENT (glyph) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_h_advance) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_v_advance) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_h_origin) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_v_origin) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_h_kerning) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_v_kerning) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_extents) \
+  HB_FONT_FUNC_IMPLEMENT (glyph_contour_point) \
+  /* ^--- Add new callbacks here */
+
+struct _hb_font_funcs_t {
+  hb_object_header_t header;
+
+  hb_bool_t immutable;
+
+  /* Don't access these directly.  Call hb_font_get_*() instead. */
+
+  struct {
+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_func_t name;
+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+  } get;
+
+  struct {
+#define HB_FONT_FUNC_IMPLEMENT(name) void *name;
+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+  } user_data;
+
+  struct {
+#define HB_FONT_FUNC_IMPLEMENT(name) hb_destroy_func_t name;
+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+  } destroy;
+};
+
+
+/*
+ * hb_face_t
+ */
+
+struct _hb_face_t {
+  hb_object_header_t header;
+
+  hb_bool_t immutable;
+
+  hb_reference_table_func_t  reference_table;
+  void                      *user_data;
+  hb_destroy_func_t          destroy;
+
+  struct hb_ot_layout_t *ot_layout;
+
+  unsigned int index;
+  unsigned int upem;
+};
+
+
+/*
+ * hb_font_t
+ */
+
+struct _hb_font_t {
+  hb_object_header_t header;
+
+  hb_bool_t immutable;
+
+  hb_font_t *parent;
+  hb_face_t *face;
+
+  int x_scale;
+  int y_scale;
+
+  unsigned int x_ppem;
+  unsigned int y_ppem;
+
+  hb_font_funcs_t   *klass;
+  void              *user_data;
+  hb_destroy_func_t  destroy;
+
+
+  /* Convert from font-space to user-space */
+  inline hb_position_t em_scale_x (int16_t v) { return em_scale (v, this->x_scale); }
+  inline hb_position_t em_scale_y (int16_t v) { return em_scale (v, this->y_scale); }
+
+  /* Convert from parent-font user-space to our user-space */
+  inline hb_position_t parent_scale_x_distance (hb_position_t v) {
+    if (unlikely (parent && parent->x_scale != x_scale))
+      return v * (int64_t) this->x_scale / this->parent->x_scale;
+    return v;
+  }
+  inline hb_position_t parent_scale_y_distance (hb_position_t v) {
+    if (unlikely (parent && parent->y_scale != y_scale))
+      return v * (int64_t) this->y_scale / this->parent->y_scale;
+    return v;
+  }
+  inline hb_position_t parent_scale_x_position (hb_position_t v) {
+    return parent_scale_x_distance (v);
+  }
+  inline hb_position_t parent_scale_y_position (hb_position_t v) {
+    return parent_scale_y_distance (v);
+  }
+
+  inline void parent_scale_distance (hb_position_t *x, hb_position_t *y) {
+    *x = parent_scale_x_distance (*x);
+    *y = parent_scale_y_distance (*y);
+  }
+  inline void parent_scale_position (hb_position_t *x, hb_position_t *y) {
+    *x = parent_scale_x_position (*x);
+    *y = parent_scale_y_position (*y);
+  }
+
+
+  private:
+  inline hb_position_t em_scale (int16_t v, int scale) { return v * (int64_t) scale / hb_face_get_upem (this->face); }
+};
+
+
+
+#endif /* HB_FONT_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.c	2012-05-05 23:46:51.523763796 +0530
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ * Copyright (C) 2009  Keith Stribley <devel@thanlwinsoft.org>
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-ft.h"
+
+#include "hb-font-private.h"
+
+#include FT_TRUETYPE_TABLES_H
+
+HB_BEGIN_DECLS
+
+
+static hb_codepoint_t
+hb_ft_get_glyph (hb_font_t *font HB_UNUSED,
+		 hb_face_t *face HB_UNUSED,
+		 const void *user_data,
+		 hb_codepoint_t unicode,
+		 hb_codepoint_t variation_selector)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+
+#ifdef HAVE_FT_FACE_GETCHARVARIANTINDEX
+  if (unlikely (variation_selector)) {
+    hb_codepoint_t glyph = FT_Face_GetCharVariantIndex (ft_face, unicode, variation_selector);
+    if (glyph)
+      return glyph;
+  }
+#endif
+
+  return FT_Get_Char_Index (ft_face, unicode);
+}
+
+static hb_bool_t
+hb_ft_get_contour_point (hb_font_t *font HB_UNUSED,
+			 hb_face_t *face HB_UNUSED,
+			 const void *user_data,
+			 unsigned int point_index,
+			 hb_codepoint_t glyph,
+			 hb_position_t *x,
+			 hb_position_t *y)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+  int load_flags = FT_LOAD_DEFAULT;
+
+  /* TODO: load_flags, embolden, etc */
+
+  if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
+      return FALSE;
+
+  if (unlikely (ft_face->glyph->format != FT_GLYPH_FORMAT_OUTLINE))
+      return FALSE;
+
+  if (unlikely (point_index >= (unsigned int) ft_face->glyph->outline.n_points))
+      return FALSE;
+
+  *x = ft_face->glyph->outline.points[point_index].x;
+  *y = ft_face->glyph->outline.points[point_index].y;
+
+  return TRUE;
+}
+
+static void
+hb_ft_get_glyph_metrics (hb_font_t *font HB_UNUSED,
+			 hb_face_t *face HB_UNUSED,
+			 const void *user_data,
+			 hb_codepoint_t glyph,
+			 hb_glyph_metrics_t *metrics)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+  int load_flags = FT_LOAD_DEFAULT;
+
+  /* TODO: load_flags, embolden, etc */
+
+  metrics->x_advance = metrics->y_advance = 0;
+  metrics->x_offset = metrics->y_offset = 0;
+  metrics->width = metrics->height = 0;
+  if (likely (!FT_Load_Glyph (ft_face, glyph, load_flags)))
+  {
+    /* TODO: A few negations should be in order here, not sure. */
+    metrics->x_advance = ft_face->glyph->advance.x;
+    metrics->y_advance = ft_face->glyph->advance.y;
+    metrics->x_offset = ft_face->glyph->metrics.horiBearingX;
+    metrics->y_offset = ft_face->glyph->metrics.horiBearingY;
+    metrics->width = ft_face->glyph->metrics.width;
+    metrics->height = ft_face->glyph->metrics.height;
+  }
+}
+
+static hb_position_t
+hb_ft_get_kerning (hb_font_t *font HB_UNUSED,
+		   hb_face_t *face HB_UNUSED,
+		   const void *user_data,
+		   hb_codepoint_t first_glyph,
+		   hb_codepoint_t second_glyph)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+  FT_Vector kerning;
+
+  /* TODO: Kern type? */
+  if (FT_Get_Kerning (ft_face, first_glyph, second_glyph, FT_KERNING_DEFAULT, &kerning))
+      return 0;
+
+  return kerning.x;
+}
+
+static hb_font_funcs_t ft_ffuncs = {
+  HB_REFERENCE_COUNT_INVALID, /* ref_count */
+  TRUE, /* immutable */
+  {
+    hb_ft_get_glyph,
+    hb_ft_get_contour_point,
+    hb_ft_get_glyph_metrics,
+    hb_ft_get_kerning
+  }
+};
+
+hb_font_funcs_t *
+hb_ft_get_font_funcs (void)
+{
+  return &ft_ffuncs;
+}
+
+
+static hb_blob_t *
+get_table  (hb_tag_t tag, void *user_data)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+  FT_Byte *buffer;
+  FT_ULong  length = 0;
+  FT_Error error;
+
+  if (unlikely (tag == HB_TAG_NONE))
+    return NULL;
+
+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, NULL, &length);
+  if (error)
+    return NULL;
+
+  /* TODO Use FT_Memory? */
+  buffer = (FT_Byte *) malloc (length);
+  if (buffer == NULL)
+    return NULL;
+
+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, buffer, &length);
+  if (error)
+    return NULL;
+
+  return hb_blob_create ((const char *) buffer, length,
+			 HB_MEMORY_MODE_WRITABLE,
+			 free, buffer);
+}
+
+
+hb_face_t *
+hb_ft_face_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy)
+{
+  hb_face_t *face;
+
+  if (ft_face->stream->read == NULL) {
+    hb_blob_t *blob;
+
+    blob = hb_blob_create ((const char *) ft_face->stream->base,
+			   (unsigned int) ft_face->stream->size,
+			   /* TODO: Check FT_FACE_FLAG_EXTERNAL_STREAM? */
+			   HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE,
+			   destroy, ft_face);
+    face = hb_face_create_for_data (blob, ft_face->face_index);
+    hb_blob_destroy (blob);
+  } else {
+    face = hb_face_create_for_tables (get_table, destroy, ft_face);
+  }
+
+  return face;
+}
+
+static void
+hb_ft_face_finalize (FT_Face ft_face)
+{
+  hb_face_destroy ((hb_face_t *) ft_face->generic.data);
+}
+
+hb_face_t *
+hb_ft_face_create_cached (FT_Face ft_face)
+{
+  if (unlikely (!ft_face->generic.data || ft_face->generic.finalizer != (FT_Generic_Finalizer) hb_ft_face_finalize))
+  {
+    if (ft_face->generic.finalizer)
+      ft_face->generic.finalizer (ft_face);
+
+    ft_face->generic.data = hb_ft_face_create (ft_face, NULL);
+    ft_face->generic.finalizer = (FT_Generic_Finalizer) hb_ft_face_finalize;
+  }
+
+  return hb_face_reference ((hb_face_t *) ft_face->generic.data);
+}
+
+
+hb_font_t *
+hb_ft_font_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy)
+{
+  hb_font_t *font;
+
+  font = hb_font_create ();
+  hb_font_set_funcs (font,
+		     hb_ft_get_font_funcs (),
+		     destroy, ft_face);
+  hb_font_set_scale (font,
+		     ((uint64_t) ft_face->size->metrics.x_scale * (uint64_t) ft_face->units_per_EM) >> 16,
+		     ((uint64_t) ft_face->size->metrics.y_scale * (uint64_t) ft_face->units_per_EM) >> 16);
+  hb_font_set_ppem (font,
+		    ft_face->size->metrics.x_ppem,
+		    ft_face->size->metrics.y_ppem);
+
+  return font;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,441 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2009  Keith Stribley
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-ft.h"
+
+#include "hb-font-private.hh"
+
+#include FT_ADVANCES_H
+#include FT_TRUETYPE_TABLES_H
+
+
+
+#ifndef HB_DEBUG_FT
+#define HB_DEBUG_FT (HB_DEBUG+0)
+#endif
+
+
+/* TODO:
+ *
+ * In general, this file does a fine job of what it's supposed to do.
+ * There are, however, things that need more work:
+ *
+ *   - We don't handle any load_flags.  That definitely has API implications. :(
+ *     I believe hb_ft_font_create() should take load_flags input.
+ *     In particular, FT_Get_Advance() without the NO_HINTING flag seems to be
+ *     buggy.
+ *
+ *   - We don't handle / allow for emboldening / obliqueing.
+ *
+ *   - Rounding, etc?
+ *
+ *   - In the future, we should add constructors to create fonts in font space.
+ *
+ *   - I believe transforms are not correctly implemented.  FreeType does not
+ *     provide any API to get to the transform/delta set on the face. :(
+ *
+ *   - Always use FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH?
+ *
+ *   - FT_Load_Glyph() is exteremely costly.  Do something about it?
+ */
+
+
+static hb_bool_t
+hb_ft_get_glyph (hb_font_t *font HB_UNUSED,
+		 void *font_data,
+		 hb_codepoint_t unicode,
+		 hb_codepoint_t variation_selector,
+		 hb_codepoint_t *glyph,
+		 void *user_data HB_UNUSED)
+
+{
+  FT_Face ft_face = (FT_Face) font_data;
+
+#ifdef HAVE_FT_FACE_GETCHARVARIANTINDEX
+  if (unlikely (variation_selector)) {
+    *glyph = FT_Face_GetCharVariantIndex (ft_face, unicode, variation_selector);
+    if (*glyph)
+      return TRUE;
+  }
+#endif
+
+  *glyph = FT_Get_Char_Index (ft_face, unicode);
+  return *glyph != 0;
+}
+
+static hb_position_t
+hb_ft_get_glyph_h_advance (hb_font_t *font HB_UNUSED,
+			   void *font_data,
+			   hb_codepoint_t glyph,
+			   void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  int load_flags = FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING;
+  FT_Fixed v;
+
+  if (unlikely (FT_Get_Advance (ft_face, glyph, load_flags, &v)))
+    return 0;
+
+  return v >> 10;
+}
+
+static hb_position_t
+hb_ft_get_glyph_v_advance (hb_font_t *font HB_UNUSED,
+			   void *font_data,
+			   hb_codepoint_t glyph,
+			   void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  int load_flags = FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING | FT_LOAD_VERTICAL_LAYOUT;
+  FT_Fixed v;
+
+  if (unlikely (FT_Get_Advance (ft_face, glyph, load_flags, &v)))
+    return 0;
+
+  /* Note: FreeType's vertical metrics grows downward while other FreeType coordinates
+   * have a Y growing upward.  Hence the extra negation. */
+  return -v >> 10;
+}
+
+static hb_bool_t
+hb_ft_get_glyph_h_origin (hb_font_t *font HB_UNUSED,
+			  void *font_data HB_UNUSED,
+			  hb_codepoint_t glyph HB_UNUSED,
+			  hb_position_t *x HB_UNUSED,
+			  hb_position_t *y HB_UNUSED,
+			  void *user_data HB_UNUSED)
+{
+  /* We always work in the horizontal coordinates. */
+  return TRUE;
+}
+
+static hb_bool_t
+hb_ft_get_glyph_v_origin (hb_font_t *font HB_UNUSED,
+			  void *font_data,
+			  hb_codepoint_t glyph,
+			  hb_position_t *x,
+			  hb_position_t *y,
+			  void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  int load_flags = FT_LOAD_DEFAULT;
+
+  if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
+    return FALSE;
+
+  /* Note: FreeType's vertical metrics grows downward while other FreeType coordinates
+   * have a Y growing upward.  Hence the extra negation. */
+  *x = ft_face->glyph->metrics.horiBearingX -   ft_face->glyph->metrics.vertBearingX;
+  *y = ft_face->glyph->metrics.horiBearingY - (-ft_face->glyph->metrics.vertBearingY);
+
+  return TRUE;
+}
+
+static hb_position_t
+hb_ft_get_glyph_h_kerning (hb_font_t *font HB_UNUSED,
+			   void *font_data,
+			   hb_codepoint_t left_glyph,
+			   hb_codepoint_t right_glyph,
+			   void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  FT_Vector kerningv;
+
+  if (FT_Get_Kerning (ft_face, left_glyph, right_glyph, FT_KERNING_DEFAULT, &kerningv))
+    return 0;
+
+  return kerningv.x;
+}
+
+static hb_position_t
+hb_ft_get_glyph_v_kerning (hb_font_t *font HB_UNUSED,
+			   void *font_data HB_UNUSED,
+			   hb_codepoint_t top_glyph HB_UNUSED,
+			   hb_codepoint_t bottom_glyph HB_UNUSED,
+			   void *user_data HB_UNUSED)
+{
+  /* FreeType API doesn't support vertical kerning */
+  return 0;
+}
+
+static hb_bool_t
+hb_ft_get_glyph_extents (hb_font_t *font HB_UNUSED,
+			 void *font_data,
+			 hb_codepoint_t glyph,
+			 hb_glyph_extents_t *extents,
+			 void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  int load_flags = FT_LOAD_DEFAULT;
+
+  if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
+    return FALSE;
+
+  extents->x_bearing = ft_face->glyph->metrics.horiBearingX;
+  extents->y_bearing = ft_face->glyph->metrics.horiBearingY;
+  extents->width = ft_face->glyph->metrics.width;
+  extents->height = ft_face->glyph->metrics.height;
+  return TRUE;
+}
+
+static hb_bool_t
+hb_ft_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
+			       void *font_data,
+			       hb_codepoint_t glyph,
+			       unsigned int point_index,
+			       hb_position_t *x,
+			       hb_position_t *y,
+			       void *user_data HB_UNUSED)
+{
+  FT_Face ft_face = (FT_Face) font_data;
+  int load_flags = FT_LOAD_DEFAULT;
+
+  if (unlikely (FT_Load_Glyph (ft_face, glyph, load_flags)))
+      return FALSE;
+
+  if (unlikely (ft_face->glyph->format != FT_GLYPH_FORMAT_OUTLINE))
+      return FALSE;
+
+  if (unlikely (point_index >= (unsigned int) ft_face->glyph->outline.n_points))
+      return FALSE;
+
+  *x = ft_face->glyph->outline.points[point_index].x;
+  *y = ft_face->glyph->outline.points[point_index].y;
+
+  return TRUE;
+}
+
+static hb_font_funcs_t ft_ffuncs = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  {
+    hb_ft_get_glyph,
+    hb_ft_get_glyph_h_advance,
+    hb_ft_get_glyph_v_advance,
+    hb_ft_get_glyph_h_origin,
+    hb_ft_get_glyph_v_origin,
+    hb_ft_get_glyph_h_kerning,
+    hb_ft_get_glyph_v_kerning,
+    hb_ft_get_glyph_extents,
+    hb_ft_get_glyph_contour_point,
+  }
+};
+
+static hb_font_funcs_t *
+_hb_ft_get_font_funcs (void)
+{
+  return &ft_ffuncs;
+}
+
+
+static hb_blob_t *
+reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
+{
+  FT_Face ft_face = (FT_Face) user_data;
+  FT_Byte *buffer;
+  FT_ULong  length = 0;
+  FT_Error error;
+
+  /* Note: FreeType like HarfBuzz uses the NONE tag for fetching the entire blob */
+
+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, NULL, &length);
+  if (error)
+    return NULL;
+
+  buffer = (FT_Byte *) malloc (length);
+  if (buffer == NULL)
+    return NULL;
+
+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, buffer, &length);
+  if (error)
+    return NULL;
+
+  return hb_blob_create ((const char *) buffer, length,
+			 HB_MEMORY_MODE_WRITABLE,
+			 buffer, free);
+}
+
+
+hb_face_t *
+hb_ft_face_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy)
+{
+  hb_face_t *face;
+
+  if (ft_face->stream->read == NULL) {
+    hb_blob_t *blob;
+
+    blob = hb_blob_create ((const char *) ft_face->stream->base,
+			   (unsigned int) ft_face->stream->size,
+			   /* TODO: We assume that it's mmap()'ed, but FreeType code
+			    * suggests that there are cases we reach here but font is
+			    * not mmapped.  For example, when mmap() fails.  No idea
+			    * how to deal with it better here. */
+			   HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE,
+			   ft_face, destroy);
+    face = hb_face_create (blob, ft_face->face_index);
+    hb_blob_destroy (blob);
+  } else {
+    face = hb_face_create_for_tables (reference_table, ft_face, destroy);
+  }
+
+  hb_face_set_index (face, ft_face->face_index);
+  hb_face_set_upem (face, ft_face->units_per_EM);
+
+  return face;
+}
+
+static void
+hb_ft_face_finalize (FT_Face ft_face)
+{
+  hb_face_destroy ((hb_face_t *) ft_face->generic.data);
+}
+
+hb_face_t *
+hb_ft_face_create_cached (FT_Face ft_face)
+{
+  if (unlikely (!ft_face->generic.data || ft_face->generic.finalizer != (FT_Generic_Finalizer) hb_ft_face_finalize))
+  {
+    if (ft_face->generic.finalizer)
+      ft_face->generic.finalizer (ft_face);
+
+    ft_face->generic.data = hb_ft_face_create (ft_face, NULL);
+    ft_face->generic.finalizer = (FT_Generic_Finalizer) hb_ft_face_finalize;
+  }
+
+  return hb_face_reference ((hb_face_t *) ft_face->generic.data);
+}
+
+static void
+_do_nothing (void)
+{
+}
+
+
+hb_font_t *
+hb_ft_font_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy)
+{
+  hb_font_t *font;
+  hb_face_t *face;
+
+  face = hb_ft_face_create (ft_face, destroy);
+  font = hb_font_create (face);
+  hb_face_destroy (face);
+  hb_font_set_funcs (font,
+		     _hb_ft_get_font_funcs (),
+		     ft_face, (hb_destroy_func_t) _do_nothing);
+  hb_font_set_scale (font,
+		     ((uint64_t) ft_face->size->metrics.x_scale * (uint64_t) ft_face->units_per_EM) >> 16,
+		     ((uint64_t) ft_face->size->metrics.y_scale * (uint64_t) ft_face->units_per_EM) >> 16);
+  hb_font_set_ppem (font,
+		    ft_face->size->metrics.x_ppem,
+		    ft_face->size->metrics.y_ppem);
+
+  return font;
+}
+
+
+
+
+static FT_Library ft_library;
+static hb_bool_t ft_library_initialized;
+static struct ft_library_destructor {
+  ~ft_library_destructor (void) {
+    if (ft_library)
+      FT_Done_FreeType (ft_library);
+  }
+} static_ft_library_destructor;
+
+static FT_Library
+_get_ft_library (void)
+{
+  if (unlikely (!ft_library_initialized)) {
+    FT_Init_FreeType (&ft_library);
+    ft_library_initialized = TRUE;
+  }
+
+  return ft_library;
+}
+
+static void
+_release_blob (FT_Face ft_face)
+{
+  hb_blob_destroy ((hb_blob_t *) ft_face->generic.data);
+}
+
+void
+hb_ft_font_set_funcs (hb_font_t *font)
+{
+  hb_blob_t *blob = hb_face_reference_blob (font->face);
+  unsigned int blob_length;
+  const char *blob_data = hb_blob_get_data (blob, &blob_length);
+  if (unlikely (!blob_length))
+    DEBUG_MSG (FT, font, "Font face has empty blob");
+
+  FT_Face ft_face = NULL;
+  FT_Error err = FT_New_Memory_Face (_get_ft_library (),
+				     (const FT_Byte *) blob_data,
+				     blob_length,
+				     hb_face_get_index (font->face),
+				     &ft_face);
+
+  if (unlikely (err)) {
+    hb_blob_destroy (blob);
+    DEBUG_MSG (FT, font, "Font face FT_New_Memory_Face() failed");
+    return;
+  }
+
+  FT_Select_Charmap (ft_face, FT_ENCODING_UNICODE);
+
+  FT_Set_Char_Size (ft_face,
+		    font->x_scale, font->y_scale,
+		    font->x_ppem * 72 * 64 / font->x_scale,
+		    font->y_ppem * 72 * 64 / font->y_scale);
+
+  ft_face->generic.data = blob;
+  ft_face->generic.finalizer = (FT_Generic_Finalizer) _release_blob;
+
+  hb_font_set_funcs (font,
+		     _hb_ft_get_font_funcs (),
+		     ft_face,
+		     (hb_destroy_func_t) FT_Done_Face);
+}
+
+FT_Face
+hb_ft_font_get_face (hb_font_t *font)
+{
+  if (font->destroy == (hb_destroy_func_t) FT_Done_Face ||
+      font->destroy == (hb_destroy_func_t) _do_nothing)
+    return (FT_Face) font->user_data;
+
+  return NULL;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ft.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ft.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,62 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_FT_H
+#define HB_FT_H
+
+#include "hb.h"
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+HB_BEGIN_DECLS
+
+/* Note: FreeType is not thread-safe.  Hence, these functions are not either. */
+
+hb_face_t *
+hb_ft_face_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy);
+
+hb_face_t *
+hb_ft_face_create_cached (FT_Face ft_face);
+
+hb_font_t *
+hb_ft_font_create (FT_Face           ft_face,
+		   hb_destroy_func_t destroy);
+
+
+
+/* Makes an hb_font_t use FreeType internally to implement font functions. */
+void
+hb_ft_font_set_funcs (hb_font_t *font);
+
+FT_Face
+hb_ft_font_get_face (hb_font_t *font);
+
+
+HB_END_DECLS
+
+#endif /* HB_FT_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.c	2012-05-05 23:46:51.523763796 +0530
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-glib.h"
+
+#include "hb-unicode-private.h"
+
+#include <glib.h>
+
+HB_BEGIN_DECLS
+
+
+static hb_codepoint_t hb_glib_get_mirroring (hb_codepoint_t unicode) { g_unichar_get_mirror_char (unicode, &unicode); return unicode; }
+static hb_category_t hb_glib_get_general_category (hb_codepoint_t unicode) { return g_unichar_type (unicode); }
+static hb_script_t hb_glib_get_script (hb_codepoint_t unicode) { return g_unichar_get_script (unicode); }
+static unsigned int hb_glib_get_combining_class (hb_codepoint_t unicode) { return g_unichar_combining_class (unicode); }
+static unsigned int hb_glib_get_eastasian_width (hb_codepoint_t unicode) { return g_unichar_iswide (unicode); }
+
+
+static hb_unicode_funcs_t glib_ufuncs = {
+  HB_REFERENCE_COUNT_INVALID, /* ref_count */
+  TRUE, /* immutable */
+  {
+    hb_glib_get_general_category,
+    hb_glib_get_combining_class,
+    hb_glib_get_mirroring,
+    hb_glib_get_script,
+    hb_glib_get_eastasian_width
+  }
+};
+
+hb_unicode_funcs_t *
+hb_glib_get_unicode_funcs (void)
+{
+  return &glib_ufuncs;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,358 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-glib.h"
+
+#include "hb-unicode-private.hh"
+
+
+#if !GLIB_CHECK_VERSION(2,29,14)
+static const hb_script_t
+glib_script_to_script[] =
+{
+  HB_SCRIPT_COMMON,
+  HB_SCRIPT_INHERITED,
+  HB_SCRIPT_ARABIC,
+  HB_SCRIPT_ARMENIAN,
+  HB_SCRIPT_BENGALI,
+  HB_SCRIPT_BOPOMOFO,
+  HB_SCRIPT_CHEROKEE,
+  HB_SCRIPT_COPTIC,
+  HB_SCRIPT_CYRILLIC,
+  HB_SCRIPT_DESERET,
+  HB_SCRIPT_DEVANAGARI,
+  HB_SCRIPT_ETHIOPIC,
+  HB_SCRIPT_GEORGIAN,
+  HB_SCRIPT_GOTHIC,
+  HB_SCRIPT_GREEK,
+  HB_SCRIPT_GUJARATI,
+  HB_SCRIPT_GURMUKHI,
+  HB_SCRIPT_HAN,
+  HB_SCRIPT_HANGUL,
+  HB_SCRIPT_HEBREW,
+  HB_SCRIPT_HIRAGANA,
+  HB_SCRIPT_KANNADA,
+  HB_SCRIPT_KATAKANA,
+  HB_SCRIPT_KHMER,
+  HB_SCRIPT_LAO,
+  HB_SCRIPT_LATIN,
+  HB_SCRIPT_MALAYALAM,
+  HB_SCRIPT_MONGOLIAN,
+  HB_SCRIPT_MYANMAR,
+  HB_SCRIPT_OGHAM,
+  HB_SCRIPT_OLD_ITALIC,
+  HB_SCRIPT_ORIYA,
+  HB_SCRIPT_RUNIC,
+  HB_SCRIPT_SINHALA,
+  HB_SCRIPT_SYRIAC,
+  HB_SCRIPT_TAMIL,
+  HB_SCRIPT_TELUGU,
+  HB_SCRIPT_THAANA,
+  HB_SCRIPT_THAI,
+  HB_SCRIPT_TIBETAN,
+  HB_SCRIPT_CANADIAN_ABORIGINAL,
+  HB_SCRIPT_YI,
+  HB_SCRIPT_TAGALOG,
+  HB_SCRIPT_HANUNOO,
+  HB_SCRIPT_BUHID,
+  HB_SCRIPT_TAGBANWA,
+
+  /* Unicode-4.0 additions */
+  HB_SCRIPT_BRAILLE,
+  HB_SCRIPT_CYPRIOT,
+  HB_SCRIPT_LIMBU,
+  HB_SCRIPT_OSMANYA,
+  HB_SCRIPT_SHAVIAN,
+  HB_SCRIPT_LINEAR_B,
+  HB_SCRIPT_TAI_LE,
+  HB_SCRIPT_UGARITIC,
+
+  /* Unicode-4.1 additions */
+  HB_SCRIPT_NEW_TAI_LUE,
+  HB_SCRIPT_BUGINESE,
+  HB_SCRIPT_GLAGOLITIC,
+  HB_SCRIPT_TIFINAGH,
+  HB_SCRIPT_SYLOTI_NAGRI,
+  HB_SCRIPT_OLD_PERSIAN,
+  HB_SCRIPT_KHAROSHTHI,
+
+  /* Unicode-5.0 additions */
+  HB_SCRIPT_UNKNOWN,
+  HB_SCRIPT_BALINESE,
+  HB_SCRIPT_CUNEIFORM,
+  HB_SCRIPT_PHOENICIAN,
+  HB_SCRIPT_PHAGS_PA,
+  HB_SCRIPT_NKO,
+
+  /* Unicode-5.1 additions */
+  HB_SCRIPT_KAYAH_LI,
+  HB_SCRIPT_LEPCHA,
+  HB_SCRIPT_REJANG,
+  HB_SCRIPT_SUNDANESE,
+  HB_SCRIPT_SAURASHTRA,
+  HB_SCRIPT_CHAM,
+  HB_SCRIPT_OL_CHIKI,
+  HB_SCRIPT_VAI,
+  HB_SCRIPT_CARIAN,
+  HB_SCRIPT_LYCIAN,
+  HB_SCRIPT_LYDIAN,
+
+  /* Unicode-5.2 additions */
+  HB_SCRIPT_AVESTAN,
+  HB_SCRIPT_BAMUM,
+  HB_SCRIPT_EGYPTIAN_HIEROGLYPHS,
+  HB_SCRIPT_IMPERIAL_ARAMAIC,
+  HB_SCRIPT_INSCRIPTIONAL_PAHLAVI,
+  HB_SCRIPT_INSCRIPTIONAL_PARTHIAN,
+  HB_SCRIPT_JAVANESE,
+  HB_SCRIPT_KAITHI,
+  HB_SCRIPT_TAI_THAM,
+  HB_SCRIPT_LISU,
+  HB_SCRIPT_MEETEI_MAYEK,
+  HB_SCRIPT_OLD_SOUTH_ARABIAN,
+  HB_SCRIPT_OLD_TURKIC,
+  HB_SCRIPT_SAMARITAN,
+  HB_SCRIPT_TAI_VIET,
+
+  /* Unicode-6.0 additions */
+  HB_SCRIPT_BATAK,
+  HB_SCRIPT_BRAHMI,
+  HB_SCRIPT_MANDAIC,
+
+  /* Unicode-6.1 additions */
+  HB_SCRIPT_CHAKMA,
+  HB_SCRIPT_MEROITIC_CURSIVE,
+  HB_SCRIPT_MEROITIC_HIEROGLYPHS,
+  HB_SCRIPT_MIAO,
+  HB_SCRIPT_SHARADA,
+  HB_SCRIPT_SORA_SOMPENG,
+  HB_SCRIPT_TAKRI
+};
+#endif
+
+hb_script_t
+hb_glib_script_to_script (GUnicodeScript script)
+{
+#if GLIB_CHECK_VERSION(2,29,14)
+  return (hb_script_t) g_unicode_script_to_iso15924 (script);
+#else
+  if (likely ((unsigned int) script < ARRAY_LENGTH (glib_script_to_script)))
+    return glib_script_to_script[script];
+
+  if (unlikely (script == G_UNICODE_SCRIPT_INVALID_CODE))
+    return HB_SCRIPT_INVALID;
+
+  return HB_SCRIPT_UNKNOWN;
+#endif
+}
+
+GUnicodeScript
+hb_glib_script_from_script (hb_script_t script)
+{
+#if GLIB_CHECK_VERSION(2,29,14)
+  return g_unicode_script_from_iso15924 (script);
+#else
+  unsigned int count = ARRAY_LENGTH (glib_script_to_script);
+  for (unsigned int i = 0; i < count; i++)
+    if (glib_script_to_script[i] == script)
+      return (GUnicodeScript) i;
+
+  if (unlikely (script == HB_SCRIPT_INVALID))
+    return G_UNICODE_SCRIPT_INVALID_CODE;
+
+  return G_UNICODE_SCRIPT_UNKNOWN;
+#endif
+}
+
+
+static unsigned int
+hb_glib_unicode_combining_class (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				 hb_codepoint_t      unicode,
+				 void               *user_data HB_UNUSED)
+
+{
+  return g_unichar_combining_class (unicode);
+}
+
+static unsigned int
+hb_glib_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				 hb_codepoint_t      unicode,
+				 void               *user_data HB_UNUSED)
+{
+  return g_unichar_iswide (unicode) ? 2 : 1;
+}
+
+static hb_unicode_general_category_t
+hb_glib_unicode_general_category (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				  hb_codepoint_t      unicode,
+				  void               *user_data HB_UNUSED)
+
+{
+  /* hb_unicode_general_category_t and GUnicodeType are identical */
+  return (hb_unicode_general_category_t) g_unichar_type (unicode);
+}
+
+static hb_codepoint_t
+hb_glib_unicode_mirroring (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			   hb_codepoint_t      unicode,
+			   void               *user_data HB_UNUSED)
+{
+  g_unichar_get_mirror_char (unicode, &unicode);
+  return unicode;
+}
+
+static hb_script_t
+hb_glib_unicode_script (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			hb_codepoint_t      unicode,
+			void               *user_data HB_UNUSED)
+{
+  return hb_glib_script_to_script (g_unichar_get_script (unicode));
+}
+
+static hb_bool_t
+hb_glib_unicode_compose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			 hb_codepoint_t      a,
+			 hb_codepoint_t      b,
+			 hb_codepoint_t     *ab,
+			 void               *user_data HB_UNUSED)
+{
+#if GLIB_CHECK_VERSION(2,29,12)
+  return g_unichar_compose (a, b, ab);
+#endif
+
+  /* We don't ifdef-out the fallback code such that compiler always
+   * sees it and makes sure it's compilable. */
+
+  if (!a || !b)
+    return FALSE;
+
+  gchar utf8[12];
+  gchar *normalized;
+  gint len;
+  hb_bool_t ret;
+
+  len = g_unichar_to_utf8 (a, utf8);
+  len += g_unichar_to_utf8 (b, utf8 + len);
+  normalized = g_utf8_normalize (utf8, len, G_NORMALIZE_NFC);
+  len = g_utf8_strlen (normalized, -1);
+  if (unlikely (!len))
+    return FALSE;
+
+  if (len == 1) {
+    *ab = g_utf8_get_char (normalized);
+    ret = TRUE;
+  } else {
+    ret = FALSE;
+  }
+
+  g_free (normalized);
+  return ret;
+}
+
+static hb_bool_t
+hb_glib_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			   hb_codepoint_t      ab,
+			   hb_codepoint_t     *a,
+			   hb_codepoint_t     *b,
+			   void               *user_data HB_UNUSED)
+{
+#if GLIB_CHECK_VERSION(2,29,12)
+  return g_unichar_decompose (ab, a, b);
+#endif
+
+  /* We don't ifdef-out the fallback code such that compiler always
+   * sees it and makes sure it's compilable. */
+
+  gchar utf8[6];
+  gchar *normalized;
+  gint len;
+  hb_bool_t ret;
+
+  len = g_unichar_to_utf8 (ab, utf8);
+  normalized = g_utf8_normalize (utf8, len, G_NORMALIZE_NFD);
+  len = g_utf8_strlen (normalized, -1);
+  if (unlikely (!len))
+    return FALSE;
+
+  if (len == 1) {
+    *a = g_utf8_get_char (normalized);
+    *b = 0;
+    ret = *a != ab;
+  } else if (len == 2) {
+    *a = g_utf8_get_char (normalized);
+    *b = g_utf8_get_char (g_utf8_next_char (normalized));
+    /* Here's the ugly part: if ab decomposes to a single character and
+     * that character decomposes again, we have to detect that and undo
+     * the second part :-(. */
+    gchar *recomposed = g_utf8_normalize (normalized, -1, G_NORMALIZE_NFC);
+    hb_codepoint_t c = g_utf8_get_char (recomposed);
+    if (c != ab && c != *a) {
+      *a = c;
+      *b = 0;
+    }
+    g_free (recomposed);
+    ret = TRUE;
+  } else {
+    /* If decomposed to more than two characters, take the last one,
+     * and recompose the rest to get the first component. */
+    gchar *end = g_utf8_offset_to_pointer (normalized, len - 1);
+    gchar *recomposed;
+    *b = g_utf8_get_char (end);
+    recomposed = g_utf8_normalize (normalized, end - normalized, G_NORMALIZE_NFC);
+    /* We expect that recomposed has exactly one character now. */
+    *a = g_utf8_get_char (recomposed);
+    g_free (recomposed);
+    ret = TRUE;
+  }
+
+  g_free (normalized);
+  return ret;
+}
+
+
+extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_glib;
+hb_unicode_funcs_t _hb_glib_unicode_funcs = {
+  HB_OBJECT_HEADER_STATIC,
+
+  NULL, /* parent */
+  TRUE, /* immutable */
+  {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_glib_unicode_##name,
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  }
+};
+
+hb_unicode_funcs_t *
+hb_glib_get_unicode_funcs (void)
+{
+  return &_hb_glib_unicode_funcs;
+}
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-glib.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-glib.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,52 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_GLIB_H
+#define HB_GLIB_H
+
+#include "hb.h"
+
+#include <glib.h>
+
+HB_BEGIN_DECLS
+
+
+hb_script_t
+hb_glib_script_to_script (GUnicodeScript script);
+
+GUnicodeScript
+hb_glib_script_from_script (hb_script_t script);
+
+
+hb_unicode_funcs_t *
+hb_glib_get_unicode_funcs (void);
+
+
+HB_END_DECLS
+
+#endif /* HB_GLIB_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject-enums.cc.tmpl Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject-enums.cc.tmpl
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject-enums.cc.tmpl	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject-enums.cc.tmpl	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,74 @@
+/*** BEGIN file-header ***/
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+/* g++ didn't like older gtype.h gcc-only code path. */
+#include <glib.h>
+#if !GLIB_CHECK_VERSION(2,29,16)
+#undef __GNUC__
+#undef __GNUC_MINOR__
+#define __GNUC__ 2
+#define __GNUC_MINOR__ 6
+#endif
+
+#include "hb-gobject.h"
+
+/*** END file-header ***/
+
+/*** BEGIN file-production ***/
+/* enumerations from "@filename@" */
+/*** END file-production ***/
+
+/*** BEGIN value-header ***/
+inline static /* TODO(behdad) disable these for now until we fix them... */
+GType
+@enum_name@_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      static const G@Type@Value values[] = {
+/*** END value-header ***/
+
+/*** BEGIN value-production ***/
+        { @VALUENAME@, "@VALUENAME@", "@valuenick@" },
+/*** END value-production ***/
+
+/*** BEGIN value-tail ***/
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_@type@_register_static (g_intern_static_string ("@EnumName@"), values);
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
+
+/*** END value-tail ***/
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,69 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_GOBJECT_H
+#define HB_GOBJECT_H
+
+#include "hb.h"
+
+#include <glib-object.h>
+
+HB_BEGIN_DECLS
+
+
+/* Objects */
+
+#define HB_GOBJECT_TYPE_BLOB hb_gobject_blob_get_type ()
+GType
+hb_gobject_blob_get_type (void);
+
+#define HB_GOBJECT_TYPE_BUFFER hb_gobject_buffer_get_type ()
+GType
+hb_gobject_buffer_get_type (void);
+
+#define HB_GOBJECT_TYPE_FACE hb_gobject_face_get_type ()
+GType
+hb_gobject_face_get_type (void);
+
+#define HB_GOBJECT_TYPE_FONT hb_gobject_font_get_type ()
+GType
+hb_gobject_font_get_type (void);
+
+#define HB_GOBJECT_TYPE_FONT_FUNCS hb_gobject_font_funcs_get_type ()
+GType
+hb_gobject_font_funcs_get_type (void);
+
+#define HB_GOBJECT_TYPE_UNICODE_FUNCS hb_gobject_unicode_funcs_get_type ()
+GType
+hb_gobject_unicode_funcs_get_type (void);
+
+
+/* Enums */
+
+
+HB_END_DECLS
+
+#endif /* HB_GOBJECT_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject-structs.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject-structs.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-gobject-structs.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-gobject-structs.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,63 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+/* g++ didn't like older gtype.h gcc-only code path. */
+#include <glib.h>
+#if !GLIB_CHECK_VERSION(2,29,16)
+#undef __GNUC__
+#undef __GNUC_MINOR__
+#define __GNUC__ 2
+#define __GNUC_MINOR__ 6
+#endif
+
+#include "hb-gobject.h"
+
+#define _HB_DEFINE_BOXED_TYPE(Name,underscore_name,copy_func,free_func) \
+GType \
+underscore_name##_get_type (void) \
+{ \
+   static volatile gsize type = 0; \
+   if (g_once_init_enter (&type)) { \
+      GType t = g_boxed_type_register_static (g_intern_static_string (#Name), \
+					      (GBoxedCopyFunc) copy_func, \
+					      (GBoxedFreeFunc) free_func); \
+      g_once_init_leave (&type, t); \
+   } \
+   return type; \
+}
+
+#define HB_DEFINE_BOXED_TYPE(name) \
+	_HB_DEFINE_BOXED_TYPE (hb_##name, hb_gobject_##name, hb_##name##_reference, hb_##name##_destroy);
+
+HB_DEFINE_BOXED_TYPE (buffer)
+HB_DEFINE_BOXED_TYPE (blob)
+HB_DEFINE_BOXED_TYPE (face)
+HB_DEFINE_BOXED_TYPE (font)
+HB_DEFINE_BOXED_TYPE (font_funcs)
+HB_DEFINE_BOXED_TYPE (unicode_funcs)
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2.cc	2012-05-05 20:32:25.000000000 +0530
@@ -0,0 +1,350 @@
+/*
+ * Copyright  2011  Martin Hosken
+ * Copyright  2011  SIL International
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-graphite2.h"
+
+#include "hb-buffer-private.hh"
+#include "hb-font-private.hh"
+#include "hb-ot.h"
+
+#include <graphite2/Font.h>
+#include <graphite2/Segment.h>
+
+
+struct hb_gr_cluster_t {
+  unsigned int base_char;
+  unsigned int num_chars;
+  unsigned int base_glyph;
+  unsigned int num_glyphs;
+};
+
+
+typedef struct hb_gr_tablelist_t {
+  hb_blob_t   *blob;
+  struct hb_gr_tablelist_t *next;
+  unsigned int tag;
+} hb_gr_tablelist_t;
+
+static struct hb_gr_face_data_t {
+  hb_face_t         *face;
+  gr_face           *grface;
+  hb_gr_tablelist_t *tlist;
+} _hb_gr_face_data_nil = {NULL, NULL};
+
+static struct hb_gr_font_data_t {
+  gr_font   *grfont;
+  gr_face   *grface;
+} _hb_gr_font_data_nil = {NULL, NULL};
+
+
+static const void *hb_gr_get_table (const void *data, unsigned int tag, size_t *len)
+{
+  hb_gr_tablelist_t *pl = NULL, *p;
+  hb_gr_face_data_t *face = (hb_gr_face_data_t *) data;
+  hb_gr_tablelist_t *tlist = face->tlist;
+
+  for (p = tlist; p; p = p->next)
+    if (p->tag == tag ) {
+      unsigned int tlen;
+      const char *d = hb_blob_get_data (p->blob, &tlen);
+      *len = tlen;
+      return d;
+    } else
+      pl = p;
+
+  if (!face->face)
+    return NULL;
+  hb_blob_t *blob = hb_face_reference_table (face->face, tag);
+
+  if (!pl || pl->blob)
+  {
+    p = (hb_gr_tablelist_t *) malloc (sizeof (hb_gr_tablelist_t));
+    if (!p) {
+      hb_blob_destroy (blob);
+      return NULL;
+    }
+    p->next = NULL;
+    if (pl)
+      pl->next = p;
+    else
+      face->tlist = p;
+    pl = p;
+  }
+  pl->blob = blob;
+  pl->tag = tag;
+
+  unsigned int tlen;
+  const char *d = hb_blob_get_data (blob, &tlen);
+  *len = tlen;
+  return d;
+}
+
+static float hb_gr_get_advance (const void *hb_font, unsigned short gid)
+{
+  return hb_font_get_glyph_h_advance ((hb_font_t *) hb_font, gid);
+}
+
+static void _hb_gr_face_data_destroy (void *data)
+{
+  hb_gr_face_data_t *f = (hb_gr_face_data_t *) data;
+  hb_gr_tablelist_t *tlist = f->tlist;
+  while (tlist)
+  {
+    hb_gr_tablelist_t *old = tlist;
+    hb_blob_destroy (tlist->blob);
+    tlist = tlist->next;
+    free (old);
+  }
+  gr_face_destroy (f->grface);
+}
+
+static void _hb_gr_font_data_destroy (void *data)
+{
+  hb_gr_font_data_t *f = (hb_gr_font_data_t *) data;
+
+  gr_font_destroy (f->grfont);
+  free (f);
+}
+
+static hb_user_data_key_t hb_gr_data_key;
+
+static hb_gr_face_data_t *
+_hb_gr_face_get_data (hb_face_t *face)
+{
+  hb_gr_face_data_t *data = (hb_gr_face_data_t *) hb_face_get_user_data (face, &hb_gr_data_key);
+  if (likely (data)) return data;
+
+  data = (hb_gr_face_data_t *) calloc (1, sizeof (hb_gr_face_data_t));
+  if (unlikely (!data))
+    return &_hb_gr_face_data_nil;
+
+
+  hb_blob_t *silf_blob = hb_face_reference_table (face, HB_GRAPHITE_TAG_Silf);
+  if (!hb_blob_get_length (silf_blob))
+  {
+    hb_blob_destroy (silf_blob);
+    return &_hb_gr_face_data_nil;
+  }
+
+  data->face = face;
+  data->grface = gr_make_face (data, &hb_gr_get_table, gr_face_default);
+
+
+  if (unlikely (!hb_face_set_user_data (face, &hb_gr_data_key, data,
+					(hb_destroy_func_t) _hb_gr_face_data_destroy,
+					FALSE)))
+  {
+    _hb_gr_face_data_destroy (data);
+    data = (hb_gr_face_data_t *) hb_face_get_user_data (face, &hb_gr_data_key);
+    if (data)
+      return data;
+    else
+      return &_hb_gr_face_data_nil;
+  }
+
+  return data;
+}
+
+static hb_gr_font_data_t *
+_hb_gr_font_get_data (hb_font_t *font)
+{
+  hb_gr_font_data_t *data = (hb_gr_font_data_t *) hb_font_get_user_data (font, &hb_gr_data_key);
+  if (likely (data)) return data;
+
+  data = (hb_gr_font_data_t *) calloc (1, sizeof (hb_gr_font_data_t));
+  if (unlikely (!data))
+    return &_hb_gr_font_data_nil;
+
+
+  hb_blob_t *silf_blob = hb_face_reference_table (font->face, HB_GRAPHITE_TAG_Silf);
+  if (!hb_blob_get_length (silf_blob))
+  {
+    hb_blob_destroy (silf_blob);
+    return &_hb_gr_font_data_nil;
+  }
+
+  data->grface = _hb_gr_face_get_data (font->face)->grface;
+  int scale;
+  hb_font_get_scale (font, &scale, NULL);
+  data->grfont = gr_make_font_with_advance_fn (scale, font, &hb_gr_get_advance, data->grface);
+
+
+  if (unlikely (!hb_font_set_user_data (font, &hb_gr_data_key, data,
+					(hb_destroy_func_t) _hb_gr_font_data_destroy,
+					FALSE)))
+  {
+    _hb_gr_font_data_destroy (data);
+    data = (hb_gr_font_data_t *) hb_font_get_user_data (font, &hb_gr_data_key);
+    if (data)
+      return data;
+    else
+      return &_hb_gr_font_data_nil;
+  }
+
+  return data;
+}
+
+
+hb_bool_t
+_hb_graphite_shape (hb_font_t          *font,
+		   hb_buffer_t        *buffer,
+		   const hb_feature_t *features,
+		   unsigned int        num_features)
+{
+
+  buffer->guess_properties ();
+
+  /* XXX We do a hell of a lot of stuff just to figure out this font
+   * is not graphite!  Shouldn't do. */
+
+  hb_gr_font_data_t *data = _hb_gr_font_get_data (font);
+  if (!data->grface) return FALSE;
+
+  unsigned int charlen;
+  hb_glyph_info_t *bufferi = hb_buffer_get_glyph_infos (buffer, &charlen);
+
+  int success = 0;
+
+  if (!charlen) return TRUE;
+
+  const char *lang = hb_language_to_string (hb_buffer_get_language (buffer));
+  const char *lang_end = strchr (lang, '-');
+  int lang_len = lang_end ? lang_end - lang : -1;
+  gr_feature_val *feats = gr_face_featureval_for_lang (data->grface, lang ? hb_tag_from_string (lang, lang_len) : 0);
+
+  while (num_features--)
+  {
+    const gr_feature_ref *fref = gr_face_find_fref (data->grface, features->tag);
+    if (fref)
+      gr_fref_set_feature_value (fref, features->value, feats);
+    features++;
+  }
+
+  hb_codepoint_t *gids = NULL, *pg;
+  hb_gr_cluster_t *clusters = NULL;
+  gr_segment *seg = NULL;
+  uint32_t *text = NULL;
+  const gr_slot *is;
+  unsigned int ci = 0, ic = 0;
+  float curradvx = 0., curradvy = 0.;
+  unsigned int glyphlen = 0;
+  unsigned int *p;
+
+  text = (uint32_t *) malloc ((charlen + 1) * sizeof (uint32_t));
+  if (!text) goto dieout;
+
+  p = text;
+  for (unsigned int i = 0; i < charlen; ++i)
+    *p++ = bufferi++->codepoint;
+  *p = 0;
+
+  hb_tag_t script_tag[2];
+  hb_ot_tags_from_script (hb_buffer_get_script (buffer), &script_tag[0], &script_tag[1]);
+
+  seg = gr_make_seg (data->grfont, data->grface,
+		     script_tag[1] == HB_TAG_NONE ? script_tag[0] : script_tag[1],
+		     feats,
+		     gr_utf32, text, charlen,
+		     2 | (hb_buffer_get_direction (buffer) == HB_DIRECTION_RTL ? 1 : 0));
+  if (!seg) goto dieout;
+
+  glyphlen = gr_seg_n_slots (seg);
+  clusters = (hb_gr_cluster_t *) calloc (charlen, sizeof (hb_gr_cluster_t));
+  if (!glyphlen || !clusters) goto dieout;
+
+  gids = (hb_codepoint_t *) malloc (glyphlen * sizeof (hb_codepoint_t));
+  if (!gids) goto dieout;
+
+  pg = gids;
+  for (is = gr_seg_first_slot (seg), ic = 0; is; is = gr_slot_next_in_segment (is), ic++)
+  {
+    unsigned int before = gr_slot_before (is);
+    unsigned int after = gr_slot_after (is);
+    *pg = gr_slot_gid (is);
+    pg++;
+    while (clusters[ci].base_char > before && ci)
+    {
+      clusters[ci-1].num_chars += clusters[ci].num_chars;
+      clusters[ci-1].num_glyphs += clusters[ci].num_glyphs;
+      ci--;
+    }
+
+    if (gr_slot_can_insert_before (is) && clusters[ci].num_chars && before >= clusters[ci].base_char + clusters[ci].num_chars)
+    {
+      hb_gr_cluster_t *c = clusters + ci + 1;
+      c->base_char = clusters[ci].base_char + clusters[ci].num_chars;
+      c->num_chars = before - c->base_char;
+      c->base_glyph = ic;
+      c->num_glyphs = 0;
+      ci++;
+    }
+    clusters[ci].num_glyphs++;
+
+    if (clusters[ci].base_char + clusters[ci].num_chars < after + 1)
+	clusters[ci].num_chars = after + 1 - clusters[ci].base_char;
+  }
+  ci++;
+
+  buffer->clear_output ();
+  for (unsigned int i = 0; i < ci; ++i)
+    buffer->replace_glyphs (clusters[i].num_chars, clusters[i].num_glyphs, gids + clusters[i].base_glyph);
+  buffer->swap_buffers ();
+
+  hb_glyph_position_t *pPos;
+  for (pPos = hb_buffer_get_glyph_positions (buffer, NULL), is = gr_seg_first_slot (seg);
+       is; pPos++, is = gr_slot_next_in_segment (is))
+  {
+    pPos->x_offset = gr_slot_origin_X(is) - curradvx;
+    pPos->y_offset = gr_slot_origin_Y(is) - curradvy;
+    pPos->x_advance = gr_slot_advance_X(is, data->grface, data->grfont);
+    pPos->y_advance = gr_slot_advance_Y(is, data->grface, data->grfont);
+//    if (pPos->x_advance < 0 && gr_slot_attached_to(is))
+//      pPos->x_advance = 0;
+    curradvx += pPos->x_advance;
+    curradvy += pPos->y_advance;
+  }
+  pPos[-1].x_advance += gr_seg_advance_X(seg) - curradvx;
+
+  /* TODO(behdad):
+   * This shaper is badly broken with RTL text.  It returns glyphs
+   * in the logical order!
+   */
+//  if (HB_DIRECTION_IS_BACKWARD (buffer->props.direction))
+//    hb_buffer_reverse (buffer);
+
+  success = 1;
+
+dieout:
+  if (gids) free (gids);
+  if (clusters) free (clusters);
+  if (seg) gr_seg_destroy (seg);
+  if (text) free (text);
+  return success;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011  Martin Hosken
+ * Copyright (C) 2011  SIL International
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#ifndef HB_GRAPHITE2_H
+#define HB_GRAPHITE2_H
+
+#include "hb.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_GRAPHITE_TAG_Silf HB_TAG('S','i','l','f')
+
+/* TODO add gr_font/face etc getters and other glue API */
+
+HB_END_DECLS
+
+#endif /* HB_GRAPHITE2_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite2-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite2-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,42 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_GRAPHITE2_PRIVATE_HH
+#define HB_GRAPHITE2_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-graphite2.h"
+
+
+HB_INTERNAL hb_bool_t
+_hb_graphite2_shape (hb_font_t          *font,
+		     hb_buffer_t        *buffer,
+		     const hb_feature_t *features,
+		     unsigned int        num_features);
+
+
+#endif /* HB_GRAPHITE2_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite.cc	2012-05-05 23:46:51.532763797 +0530
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2009, Martin Hosken
+ * Copyright (C) 2009, SIL International
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include <graphite/GrClient.h>
+#include <graphite/ITextSource.h>
+#include <graphite/GrData.h>
+#include <graphite/GrConstants.h>
+#include <graphite/Segment.h>
+#include "hb-buffer-private.hh"
+#include "hb-font-private.h"
+#include "hb-graphite.h"
+#include <map>
+
+HB_BEGIN_DECLS
+
+
+namespace TtfUtil
+{
+extern int FontAscent(const void *pOS2);
+extern int FontDescent(const void *pOS2);
+extern int DesignUnits(const void *pHead);
+extern bool FontOs2Style(const void *pOS2, bool &fBold, bool &fItalic);
+}
+
+typedef struct _featureSetting {
+    unsigned int id;
+    int value;
+} featureSetting;
+
+class HbGrBufferTextSrc : public gr::ITextSource
+{
+public:
+  HbGrBufferTextSrc(hb_buffer_t *buff, hb_feature_t *feats, unsigned int num_features)
+  {
+    hb_feature_t *aFeat = feats;
+    featureSetting *aNewFeat;
+
+    buffer = hb_buffer_reference(buff);
+    features = new featureSetting[num_features];
+    nFeatures = num_features;
+    aNewFeat = features;
+    for (unsigned int i = 0; i < num_features; i++, aFeat++, aNewFeat++)
+    {
+        aNewFeat->id = aFeat->tag;
+        aNewFeat->value = aFeat->value;
+    }
+  };
+  ~HbGrBufferTextSrc() { hb_buffer_destroy(buffer); delete[] features; };
+  virtual gr::UtfType utfEncodingForm() { return gr::kutf32; };
+  virtual size_t getLength() { return buffer->len; };
+  virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf32 * prgchBuffer)
+  {
+    assert(cch <= buffer->len);
+    if (cch > buffer->len)
+      return 0;
+    for (unsigned int i = ichMin; i < ichMin + cch; i++)
+      prgchBuffer[i - ichMin] = buffer->info[i].codepoint;
+    return (cch - ichMin);
+  };
+  virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf16 * prgchBuffer) { return 0 ;};
+  virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf8 * prgchBuffer) { return 0; };
+  virtual bool getRightToLeft(gr::toffset ich)
+  { return hb_buffer_get_direction(buffer) == HB_DIRECTION_RTL; };
+  virtual unsigned int getDirectionDepth(gr::toffset ich)
+  { return hb_buffer_get_direction(buffer) == HB_DIRECTION_RTL ? 1 : 0; };
+  virtual float getVerticalOffset(gr::toffset ich) { return 0; };
+  virtual gr::isocode getLanguage(gr::toffset ich)
+  {
+    gr::isocode aLang;
+    char *p = (char *)(buffer->language);
+    int i;
+    for (i = 0; i < 4; i++)
+    {
+      if (p != NULL)
+        aLang.rgch[i] = *p;
+      else
+        aLang.rgch[i] = 0;
+      if (p && *p)
+        p++;
+    }
+    return aLang;
+  }
+
+  virtual std::pair<gr::toffset, gr::toffset> propertyRange(gr::toffset ich)
+  { return std::pair<gr::toffset, gr::toffset>(0, buffer->len); };
+  virtual size_t getFontFeatures(gr::toffset ich, gr::FeatureSetting * prgfset)
+  {
+    featureSetting *aFeat = features;
+    for (unsigned int i = 0; i < nFeatures; i++, aFeat++, prgfset++)
+    {
+      prgfset->id = aFeat->id;
+      prgfset->value = aFeat->value;
+    }
+    return nFeatures;
+  }
+  virtual bool sameSegment(gr::toffset ich1, gr::toffset ich2) {return true; };
+
+private:
+  hb_buffer_t   *buffer;
+  featureSetting   *features;
+  unsigned int nFeatures;
+};
+
+class HbGrFont : public gr::Font
+{
+public:
+  HbGrFont(hb_font_t *font, hb_face_t *face) : gr::Font()
+  { m_font = hb_font_reference(font); m_face = hb_face_reference(face); initfont(); };
+  ~HbGrFont()
+  {
+    std::map<hb_tag_t,hb_blob_t *>::iterator p = m_blobs.begin();
+    while (p != m_blobs.end())
+    { hb_blob_destroy((p++)->second); }
+    hb_font_destroy(m_font);
+    hb_face_destroy(m_face);
+  };
+  HbGrFont (const HbGrFont &font) : gr::Font(font)
+  {
+    *this = font;
+    m_blobs = std::map<hb_tag_t, hb_blob_t *>(font.m_blobs);
+    std::map<hb_tag_t,hb_blob_t *>::iterator p=m_blobs.begin();
+    while (p != m_blobs.end()) { hb_blob_reference((*p++).second); }
+    hb_font_reference(m_font);
+    hb_face_reference(m_face);
+  };
+  virtual HbGrFont *copyThis() { return new HbGrFont(*this); };
+  virtual bool bold() { return m_bold; };
+  virtual bool italic() { return m_italic; };
+  virtual float ascent() { float asc; getFontMetrics(&asc, NULL, NULL); return asc; };
+  virtual float descent() { float desc; getFontMetrics(NULL, &desc, NULL); return desc; };
+  virtual float height()
+  { float asc, desc; getFontMetrics(&asc, &desc, NULL); return (asc + desc); };
+  virtual unsigned int getDPIx() { return m_font->x_ppem; };
+  virtual unsigned int getDPIy() { return m_font->y_ppem; };
+  virtual const void *getTable(gr::fontTableId32 tableID, size_t *pcbsize)
+  {
+    hb_blob_t *blob;
+    std::map<hb_tag_t,hb_blob_t *>::iterator p=m_blobs.find((hb_tag_t)tableID);
+    if (p == m_blobs.end())
+    {
+      blob = hb_face_get_table(m_face, (hb_tag_t)tableID);
+      m_blobs[(hb_tag_t)tableID] = blob;
+    }
+    else
+    { blob = p->second; }
+
+    const char *res = hb_blob_lock(blob);
+    if (pcbsize)
+      *pcbsize = hb_blob_get_length(blob);
+    hb_blob_unlock(blob);
+    return (const void *)res;
+  }
+
+  virtual void getFontMetrics(float *pAscent, float *pDescent, float *pEmSquare)
+  {
+    if (pAscent) *pAscent = 1. * m_ascent * m_font->y_ppem / m_emsquare;
+    if (pDescent) *pDescent = 1. * m_descent * m_font->y_ppem / m_emsquare;
+    if (pEmSquare) *pEmSquare = m_font->x_scale;
+  }
+  virtual void getGlyphPoint(gr::gid16 glyphID, unsigned int pointNum, gr::Point &pointReturn)
+  {
+    hb_position_t x, y;
+    hb_font_get_contour_point(m_font, m_face, pointNum, glyphID, &x, &y);
+    pointReturn.x = (float)x;
+    pointReturn.y = (float)y;
+  }
+
+  virtual void getGlyphMetrics(gr::gid16 glyphID, gr::Rect &boundingBox, gr::Point &advances)
+  {
+    hb_glyph_metrics_t metrics;
+    hb_font_get_glyph_metrics(m_font, m_face, glyphID, &metrics);
+    boundingBox.top = (metrics.y_offset + metrics.height);
+    boundingBox.bottom = metrics.y_offset;
+    boundingBox.left = metrics.x_offset;
+    boundingBox.right = (metrics.x_offset + metrics.width);
+    advances.x = metrics.x_advance;
+    advances.y = metrics.y_advance;
+//    fprintf (stderr, "%d: (%d, %d, %d, %d)+(%d, %d)\n", glyphID, metrics.x_offset, metrics.y_offset, metrics.width, metrics.height, metrics.x_advance, metrics.y_advance);
+  }
+
+private:
+  HB_INTERNAL void initfont();
+
+  hb_font_t *m_font;
+  hb_face_t *m_face;
+  float m_ascent;
+  float m_descent;
+  float m_emsquare;
+  bool m_bold;
+  bool m_italic;
+  std::map<hb_tag_t, hb_blob_t *> m_blobs;
+};
+
+void HbGrFont::initfont()
+{
+  const void *pOS2 = getTable(gr::kttiOs2, NULL);
+  const void *pHead = getTable(gr::kttiHead, NULL);
+  TtfUtil::FontOs2Style(pOS2, m_bold, m_italic);
+  m_ascent = static_cast<float>(TtfUtil::FontAscent(pOS2));
+  m_descent = static_cast<float>(TtfUtil::FontDescent(pOS2));
+  m_emsquare = static_cast<float>(TtfUtil::DesignUnits(pHead));
+}
+
+void
+hb_graphite_shape (hb_font_t    *font,
+		   hb_face_t    *face,
+		   hb_buffer_t  *buffer,
+		   hb_feature_t *features,
+		   unsigned int  num_features)
+{
+  /* create text source */
+  HbGrBufferTextSrc   textSrc(buffer, features, num_features);
+
+  /* create grfont */
+  HbGrFont          grfont(font, face);
+
+  /* create segment */
+  int *firsts;
+  bool *flags;
+  int numChars;
+  int numGlyphs;
+  gr::LayoutEnvironment layout;
+  std::pair<gr::GlyphIterator, gr::GlyphIterator>glyph_range;
+  gr::GlyphIterator iGlyph;
+  hb_codepoint_t *glyph_infos, *pGlyph;
+  hb_glyph_position_t *pPosition;
+  int cGlyph = 0;
+  int cChar = 0;
+
+  layout.setStartOfLine(0);
+  layout.setEndOfLine(0);
+  layout.setDumbFallback(true);
+  layout.setJustifier(NULL);
+  layout.setRightToLeft(false);
+
+  gr::RangeSegment pSegment(&grfont, &textSrc, &layout, (gr::toffset)0,
+        static_cast<gr::toffset>(buffer->len), (gr::Segment *)NULL);
+
+  /* fill in buffer from segment */
+  _hb_buffer_clear_output(buffer);
+  pSegment.getUniscribeClusters(NULL, 0, &numChars, NULL, 0, &numGlyphs);
+  firsts = new int[numChars];
+  flags = new bool[numGlyphs];
+  glyph_infos = new hb_codepoint_t[numGlyphs];
+  hb_buffer_ensure(buffer, numGlyphs);
+  pSegment.getUniscribeClusters(firsts, numChars, NULL, flags, numGlyphs, NULL);
+  glyph_range = pSegment.glyphs();
+  for (pGlyph = glyph_infos, iGlyph = glyph_range.first; iGlyph != glyph_range.second;
+        iGlyph++, pGlyph++)
+  { *pGlyph = iGlyph->glyphID(); }
+
+  while (cGlyph < numGlyphs)
+  {
+    if (flags[cGlyph])
+    {
+        int oldcChar = cChar++;
+        int oldcGlyph = cGlyph++;
+        while (cChar < numChars && firsts[cChar] == firsts[oldcChar]) cChar++;
+        while (cGlyph < numGlyphs && !flags[cGlyph]) cGlyph++;
+        _hb_buffer_add_output_glyphs(buffer, cChar - oldcChar, cGlyph - oldcGlyph,
+                glyph_infos + oldcGlyph, 0xFFFF, 0xFFFF);
+    }
+    else
+    { cGlyph++; }   /* This should never happen */
+  }
+
+  float curradvx = 0., curradvy = 0.;
+  for (pPosition = hb_buffer_get_glyph_positions(buffer), iGlyph = glyph_range.first;
+        iGlyph != glyph_range.second; pPosition++, iGlyph++)
+  {
+    pPosition->x_offset = iGlyph->origin() - curradvx;
+    pPosition->y_offset = iGlyph->yOffset() - curradvy;
+    pPosition->x_advance = pPosition->x_offset + iGlyph->advanceWidth();
+    pPosition->y_advance = pPosition->y_offset + iGlyph->advanceHeight();
+    if (pPosition->x_advance < 0 && iGlyph->logicalIndex() != iGlyph->attachedClusterBase()->logicalIndex())
+        pPosition->x_advance = 0;
+    curradvx += pPosition->x_advance;
+    curradvy += pPosition->y_advance;
+//    fprintf(stderr, "%d@(%f, %f)+(%f, %f)\n", iGlyph->glyphID(), iGlyph->origin(), iGlyph->yOffset(), iGlyph->advanceWidth(), iGlyph->advanceHeight());
+  }
+
+  delete[] glyph_infos;
+  delete[] firsts;
+  delete[] flags;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-graphite.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-graphite.h	2012-05-05 23:46:51.522763796 +0530
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2009, Martin Hosken
+ * Copyright (C) 2009, SIL International
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_GRAPHITE_H
+#define HB_GRAPHITE_H
+
+#include "hb-shape.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_GRAPHITE_TAG_Silf HB_TAG('S','i','l','f')
+
+void hb_graphite_shape (hb_font_t    *font,
+			hb_face_t    *face,
+			hb_buffer_t  *buffer,
+			hb_feature_t *features,
+			unsigned int  num_features);
+
+
+HB_END_DECLS
+
+#endif /* HB_GRAPHITE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,44 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H
+#define HB_H
+#define HB_H_IN
+
+#include "hb-blob.h"
+#include "hb-buffer.h"
+#include "hb-common.h"
+#include "hb-font.h"
+#include "hb-set.h"
+#include "hb-shape.h"
+#include "hb-unicode.h"
+#include "hb-version.h"
+
+HB_BEGIN_DECLS
+HB_END_DECLS
+
+#undef HB_H_IN
+#endif /* HB_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.c	2012-05-05 23:46:51.515763796 +0530
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ * Copyright (C) 2009  Keith Stribley <devel@thanlwinsoft.org>
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-icu.h"
+
+#include "hb-unicode-private.h"
+
+#include <unicode/uversion.h>
+#include <unicode/uchar.h>
+#include <unicode/uscript.h>
+
+HB_BEGIN_DECLS
+
+
+static hb_codepoint_t hb_icu_get_mirroring (hb_codepoint_t unicode) { return u_charMirror(unicode); }
+static unsigned int hb_icu_get_combining_class (hb_codepoint_t unicode) { return u_getCombiningClass (unicode); }
+
+static unsigned int
+hb_icu_get_eastasian_width (hb_codepoint_t unicode)
+{
+  switch (u_getIntPropertyValue(unicode, UCHAR_EAST_ASIAN_WIDTH))
+  {
+  case U_EA_WIDE:
+  case U_EA_FULLWIDTH:
+    return 2;
+  case U_EA_NEUTRAL:
+  case U_EA_AMBIGUOUS:
+  case U_EA_HALFWIDTH:
+  case U_EA_NARROW:
+    return 1;
+  }
+  return 1;
+}
+
+static hb_category_t
+hb_icu_get_general_category (hb_codepoint_t unicode)
+{
+  switch (u_getIntPropertyValue(unicode, UCHAR_GENERAL_CATEGORY))
+  {
+  case U_UNASSIGNED:			return HB_CATEGORY_UNASSIGNED;
+
+  case U_UPPERCASE_LETTER:		return HB_CATEGORY_UPPERCASE_LETTER;	/* Lu */
+  case U_LOWERCASE_LETTER:		return HB_CATEGORY_LOWERCASE_LETTER;	/* Ll */
+  case U_TITLECASE_LETTER:		return HB_CATEGORY_TITLECASE_LETTER;	/* Lt */
+  case U_MODIFIER_LETTER:		return HB_CATEGORY_MODIFIER_LETTER;	/* Lm */
+  case U_OTHER_LETTER:			return HB_CATEGORY_OTHER_LETTER;	/* Lo */
+
+  case U_NON_SPACING_MARK:		return HB_CATEGORY_NON_SPACING_MARK;	/* Mn */
+  case U_ENCLOSING_MARK:		return HB_CATEGORY_ENCLOSING_MARK;	/* Me */
+  case U_COMBINING_SPACING_MARK:	return HB_CATEGORY_COMBINING_MARK;	/* Mc */
+
+  case U_DECIMAL_DIGIT_NUMBER:		return HB_CATEGORY_DECIMAL_NUMBER;	/* Nd */
+  case U_LETTER_NUMBER:			return HB_CATEGORY_LETTER_NUMBER;	/* Nl */
+  case U_OTHER_NUMBER:			return HB_CATEGORY_OTHER_NUMBER;	/* No */
+
+  case U_SPACE_SEPARATOR:		return HB_CATEGORY_SPACE_SEPARATOR;	/* Zs */
+  case U_LINE_SEPARATOR:		return HB_CATEGORY_LINE_SEPARATOR;	/* Zl */
+  case U_PARAGRAPH_SEPARATOR:		return HB_CATEGORY_PARAGRAPH_SEPARATOR;	/* Zp */
+
+  case U_CONTROL_CHAR:			return HB_CATEGORY_CONTROL;		/* Cc */
+  case U_FORMAT_CHAR:			return HB_CATEGORY_FORMAT;		/* Cf */
+  case U_PRIVATE_USE_CHAR:		return HB_CATEGORY_PRIVATE_USE;		/* Co */
+  case U_SURROGATE:			return HB_CATEGORY_SURROGATE;		/* Cs */
+
+
+  case U_DASH_PUNCTUATION:		return HB_CATEGORY_DASH_PUNCTUATION;	/* Pd */
+  case U_START_PUNCTUATION:		return HB_CATEGORY_OPEN_PUNCTUATION;	/* Ps */
+  case U_END_PUNCTUATION:		return HB_CATEGORY_CLOSE_PUNCTUATION;	/* Pe */
+  case U_CONNECTOR_PUNCTUATION:		return HB_CATEGORY_CONNECT_PUNCTUATION;	/* Pc */
+  case U_OTHER_PUNCTUATION:		return HB_CATEGORY_OTHER_PUNCTUATION;	/* Po */
+
+  case U_MATH_SYMBOL:			return HB_CATEGORY_MATH_SYMBOL;		/* Sm */
+  case U_CURRENCY_SYMBOL:		return HB_CATEGORY_CURRENCY_SYMBOL;	/* Sc */
+  case U_MODIFIER_SYMBOL:		return HB_CATEGORY_MODIFIER_SYMBOL;	/* Sk */
+  case U_OTHER_SYMBOL:			return HB_CATEGORY_OTHER_SYMBOL;	/* So */
+
+  case U_INITIAL_PUNCTUATION:		return HB_CATEGORY_INITIAL_PUNCTUATION;	/* Pi */
+  case U_FINAL_PUNCTUATION:		return HB_CATEGORY_FINAL_PUNCTUATION;	/* Pf */
+  }
+
+  return HB_CATEGORY_UNASSIGNED;
+}
+
+static hb_script_t
+hb_icu_get_script (hb_codepoint_t unicode)
+{
+  UErrorCode status = U_ZERO_ERROR;
+  UScriptCode scriptCode = uscript_getScript(unicode, &status);
+  switch ((int) scriptCode)
+  {
+#define CHECK_ICU_VERSION(major, minor) \
+	U_ICU_VERSION_MAJOR_NUM > (major) || (U_ICU_VERSION_MAJOR_NUM == (major) && U_ICU_VERSION_MINOR_NUM >= (minor))
+#define MATCH_SCRIPT(C) case USCRIPT_##C: return HB_SCRIPT_##C
+#define MATCH_SCRIPT2(C1, C2) case USCRIPT_##C1: return HB_SCRIPT_##C2
+  MATCH_SCRIPT (INVALID_CODE);
+  MATCH_SCRIPT (COMMON);             /* Zyyy */
+  MATCH_SCRIPT (INHERITED);          /* Qaai */
+  MATCH_SCRIPT (ARABIC);             /* Arab */
+  MATCH_SCRIPT (ARMENIAN);           /* Armn */
+  MATCH_SCRIPT (BENGALI);            /* Beng */
+  MATCH_SCRIPT (BOPOMOFO);           /* Bopo */
+  MATCH_SCRIPT (CHEROKEE);           /* Cher */
+  MATCH_SCRIPT (COPTIC);             /* Qaac */
+  MATCH_SCRIPT (CYRILLIC);           /* Cyrl (Cyrs) */
+  MATCH_SCRIPT (DESERET);            /* Dsrt */
+  MATCH_SCRIPT (DEVANAGARI);         /* Deva */
+  MATCH_SCRIPT (ETHIOPIC);           /* Ethi */
+  MATCH_SCRIPT (GEORGIAN);           /* Geor (Geon); Geoa) */
+  MATCH_SCRIPT (GOTHIC);             /* Goth */
+  MATCH_SCRIPT (GREEK);              /* Grek */
+  MATCH_SCRIPT (GUJARATI);           /* Gujr */
+  MATCH_SCRIPT (GURMUKHI);           /* Guru */
+  MATCH_SCRIPT (HAN);                /* Hani */
+  MATCH_SCRIPT (HANGUL);             /* Hang */
+  MATCH_SCRIPT (HEBREW);             /* Hebr */
+  MATCH_SCRIPT (HIRAGANA);           /* Hira */
+  MATCH_SCRIPT (KANNADA);            /* Knda */
+  MATCH_SCRIPT (KATAKANA);           /* Kana */
+  MATCH_SCRIPT (KHMER);              /* Khmr */
+  MATCH_SCRIPT (LAO);                /* Laoo */
+  MATCH_SCRIPT (LATIN);              /* Latn (Latf); Latg) */
+  MATCH_SCRIPT (MALAYALAM);          /* Mlym */
+  MATCH_SCRIPT (MONGOLIAN);          /* Mong */
+  MATCH_SCRIPT (MYANMAR);            /* Mymr */
+  MATCH_SCRIPT (OGHAM);              /* Ogam */
+  MATCH_SCRIPT (OLD_ITALIC);         /* Ital */
+  MATCH_SCRIPT (ORIYA);              /* Orya */
+  MATCH_SCRIPT (RUNIC);              /* Runr */
+  MATCH_SCRIPT (SINHALA);            /* Sinh */
+  MATCH_SCRIPT (SYRIAC);             /* Syrc (Syrj, Syrn); Syre) */
+  MATCH_SCRIPT (TAMIL);              /* Taml */
+  MATCH_SCRIPT (TELUGU);             /* Telu */
+  MATCH_SCRIPT (THAANA);             /* Thaa */
+  MATCH_SCRIPT (THAI);               /* Thai */
+  MATCH_SCRIPT (TIBETAN);            /* Tibt */
+  MATCH_SCRIPT (CANADIAN_ABORIGINAL);/* Cans */
+  MATCH_SCRIPT (YI);                 /* Yiii */
+  MATCH_SCRIPT (TAGALOG);            /* Tglg */
+  MATCH_SCRIPT (HANUNOO);            /* Hano */
+  MATCH_SCRIPT (BUHID);              /* Buhd */
+  MATCH_SCRIPT (TAGBANWA);           /* Tagb */
+
+  /* Unicode-4.0 additions */
+  MATCH_SCRIPT (BRAILLE);            /* Brai */
+  MATCH_SCRIPT (CYPRIOT);            /* Cprt */
+  MATCH_SCRIPT (LIMBU);              /* Limb */
+  MATCH_SCRIPT (OSMANYA);            /* Osma */
+  MATCH_SCRIPT (SHAVIAN);            /* Shaw */
+  MATCH_SCRIPT (LINEAR_B);           /* Linb */
+  MATCH_SCRIPT (TAI_LE);             /* Tale */
+  MATCH_SCRIPT (UGARITIC);           /* Ugar */
+
+  /* Unicode-4.1 additions */
+  MATCH_SCRIPT (NEW_TAI_LUE);        /* Talu */
+  MATCH_SCRIPT (BUGINESE);           /* Bugi */
+  MATCH_SCRIPT (GLAGOLITIC);         /* Glag */
+  MATCH_SCRIPT (TIFINAGH);           /* Tfng */
+  MATCH_SCRIPT (SYLOTI_NAGRI);       /* Sylo */
+  MATCH_SCRIPT (OLD_PERSIAN);        /* Xpeo */
+  MATCH_SCRIPT (KHAROSHTHI);         /* Khar */
+
+  /* Unicode-5.0 additions */
+  MATCH_SCRIPT (UNKNOWN);            /* Zzzz */
+  MATCH_SCRIPT (BALINESE);           /* Bali */
+  MATCH_SCRIPT (CUNEIFORM);          /* Xsux */
+  MATCH_SCRIPT (PHOENICIAN);         /* Phnx */
+  MATCH_SCRIPT (PHAGS_PA);           /* Phag */
+  MATCH_SCRIPT (NKO);                /* Nkoo */
+
+  /* Unicode-5.1 additions */
+  MATCH_SCRIPT (KAYAH_LI);           /* Kali */
+  MATCH_SCRIPT (LEPCHA);             /* Lepc */
+  MATCH_SCRIPT (REJANG);             /* Rjng */
+  MATCH_SCRIPT (SUNDANESE);          /* Sund */
+  MATCH_SCRIPT (SAURASHTRA);         /* Saur */
+  MATCH_SCRIPT (CHAM);               /* Cham */
+  MATCH_SCRIPT (OL_CHIKI);           /* Olck */
+  MATCH_SCRIPT (VAI);                /* Vaii */
+  MATCH_SCRIPT (CARIAN);             /* Cari */
+  MATCH_SCRIPT (LYCIAN);             /* Lyci */
+  MATCH_SCRIPT (LYDIAN);             /* Lydi */
+
+  /* Unicode-5.2 additions */
+  MATCH_SCRIPT (AVESTAN);                /* Avst */
+#if CHECK_ICU_VERSION (4, 4)
+  MATCH_SCRIPT (BAMUM);                  /* Bamu */
+#endif
+  MATCH_SCRIPT (EGYPTIAN_HIEROGLYPHS);   /* Egyp */
+  MATCH_SCRIPT (IMPERIAL_ARAMAIC);       /* Armi */
+  MATCH_SCRIPT (INSCRIPTIONAL_PAHLAVI);  /* Phli */
+  MATCH_SCRIPT (INSCRIPTIONAL_PARTHIAN); /* Prti */
+  MATCH_SCRIPT (JAVANESE);               /* Java */
+  MATCH_SCRIPT (KAITHI);                 /* Kthi */
+  MATCH_SCRIPT2(LANNA, TAI_THAM);        /* Lana */
+#if CHECK_ICU_VERSION (4, 4)
+  MATCH_SCRIPT (LISU);                   /* Lisu */
+#endif
+  MATCH_SCRIPT (MEITEI_MAYEK);           /* Mtei */
+#if CHECK_ICU_VERSION (4, 4)
+  MATCH_SCRIPT (OLD_SOUTH_ARABIAN);      /* Sarb */
+#endif
+  MATCH_SCRIPT2(ORKHON, OLD_TURKIC);     /* Orkh */
+  MATCH_SCRIPT (SAMARITAN);              /* Samr */
+  MATCH_SCRIPT (TAI_VIET);               /* Tavt */
+  }
+  return HB_SCRIPT_UNKNOWN;
+}
+
+static hb_unicode_funcs_t icu_ufuncs = {
+  HB_REFERENCE_COUNT_INVALID, /* ref_count */
+  TRUE, /* immutable */
+  {
+    hb_icu_get_general_category,
+    hb_icu_get_combining_class,
+    hb_icu_get_mirroring,
+    hb_icu_get_script,
+    hb_icu_get_eastasian_width
+  }
+};
+
+hb_unicode_funcs_t *
+hb_icu_get_unicode_funcs (void)
+{
+  return &icu_ufuncs;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,291 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2009  Keith Stribley
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-icu.h"
+
+#include "hb-unicode-private.hh"
+
+#include <unicode/uversion.h>
+#include <unicode/uchar.h>
+#include <unicode/unorm.h>
+#include <unicode/ustring.h>
+
+
+
+hb_script_t
+hb_icu_script_to_script (UScriptCode script)
+{
+  if (unlikely (script == USCRIPT_INVALID_CODE))
+    return HB_SCRIPT_INVALID;
+
+  return hb_script_from_string (uscript_getShortName (script), -1);
+}
+
+UScriptCode
+hb_icu_script_from_script (hb_script_t script)
+{
+  if (unlikely (script == HB_SCRIPT_INVALID))
+    return USCRIPT_INVALID_CODE;
+
+  for (unsigned int i = 0; i < USCRIPT_CODE_LIMIT; i++)
+    if (unlikely (hb_icu_script_to_script ((UScriptCode) i) == script))
+      return (UScriptCode) i;
+
+  return USCRIPT_UNKNOWN;
+}
+
+
+static unsigned int
+hb_icu_unicode_combining_class (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				hb_codepoint_t      unicode,
+				void               *user_data HB_UNUSED)
+
+{
+  return u_getCombiningClass (unicode);
+}
+
+static unsigned int
+hb_icu_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				hb_codepoint_t      unicode,
+				void               *user_data HB_UNUSED)
+{
+  switch (u_getIntPropertyValue(unicode, UCHAR_EAST_ASIAN_WIDTH))
+  {
+  case U_EA_WIDE:
+  case U_EA_FULLWIDTH:
+    return 2;
+  case U_EA_NEUTRAL:
+  case U_EA_AMBIGUOUS:
+  case U_EA_HALFWIDTH:
+  case U_EA_NARROW:
+    return 1;
+  }
+  return 1;
+}
+
+static hb_unicode_general_category_t
+hb_icu_unicode_general_category (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+				 hb_codepoint_t      unicode,
+				 void               *user_data HB_UNUSED)
+{
+  switch (u_getIntPropertyValue(unicode, UCHAR_GENERAL_CATEGORY))
+  {
+  case U_UNASSIGNED:			return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;
+
+  case U_UPPERCASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER;
+  case U_LOWERCASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER;
+  case U_TITLECASE_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER;
+  case U_MODIFIER_LETTER:		return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER;
+  case U_OTHER_LETTER:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER;
+
+  case U_NON_SPACING_MARK:		return HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK;
+  case U_ENCLOSING_MARK:		return HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK;
+  case U_COMBINING_SPACING_MARK:	return HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK;
+
+  case U_DECIMAL_DIGIT_NUMBER:		return HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER;
+  case U_LETTER_NUMBER:			return HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER;
+  case U_OTHER_NUMBER:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER;
+
+  case U_SPACE_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR;
+  case U_LINE_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR;
+  case U_PARAGRAPH_SEPARATOR:		return HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR;
+
+  case U_CONTROL_CHAR:			return HB_UNICODE_GENERAL_CATEGORY_CONTROL;
+  case U_FORMAT_CHAR:			return HB_UNICODE_GENERAL_CATEGORY_FORMAT;
+  case U_PRIVATE_USE_CHAR:		return HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE;
+  case U_SURROGATE:			return HB_UNICODE_GENERAL_CATEGORY_SURROGATE;
+
+
+  case U_DASH_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION;
+  case U_START_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION;
+  case U_END_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION;
+  case U_CONNECTOR_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION;
+  case U_OTHER_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION;
+
+  case U_MATH_SYMBOL:			return HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL;
+  case U_CURRENCY_SYMBOL:		return HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL;
+  case U_MODIFIER_SYMBOL:		return HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL;
+  case U_OTHER_SYMBOL:			return HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL;
+
+  case U_INITIAL_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION;
+  case U_FINAL_PUNCTUATION:		return HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION;
+  }
+
+  return HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED;
+}
+
+static hb_codepoint_t
+hb_icu_unicode_mirroring (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			  hb_codepoint_t      unicode,
+			  void               *user_data HB_UNUSED)
+{
+  return u_charMirror(unicode);
+}
+
+static hb_script_t
+hb_icu_unicode_script (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+		       hb_codepoint_t      unicode,
+		       void               *user_data HB_UNUSED)
+{
+  UErrorCode status = U_ZERO_ERROR;
+  UScriptCode scriptCode = uscript_getScript(unicode, &status);
+
+  if (unlikely (U_FAILURE (status)))
+    return HB_SCRIPT_UNKNOWN;
+
+  return hb_icu_script_to_script (scriptCode);
+}
+
+static hb_bool_t
+hb_icu_unicode_compose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			hb_codepoint_t      a,
+			hb_codepoint_t      b,
+			hb_codepoint_t     *ab,
+			void               *user_data HB_UNUSED)
+{
+  if (!a || !b)
+    return FALSE;
+
+  UChar utf16[4], normalized[5];
+  int len;
+  hb_bool_t ret, err;
+  UErrorCode icu_err;
+
+  len = 0;
+  err = FALSE;
+  U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), a, err);
+  if (err) return FALSE;
+  U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), b, err);
+  if (err) return FALSE;
+
+  icu_err = U_ZERO_ERROR;
+  len = unorm_normalize (utf16, len, UNORM_NFC, 0, normalized, ARRAY_LENGTH (normalized), &icu_err);
+  if (U_FAILURE (icu_err))
+    return FALSE;
+  if (u_countChar32 (normalized, len) == 1) {
+    U16_GET_UNSAFE (normalized, 0, *ab);
+    ret = TRUE;
+  } else {
+    ret = FALSE;
+  }
+
+  return ret;
+}
+
+static hb_bool_t
+hb_icu_unicode_decompose (hb_unicode_funcs_t *ufuncs HB_UNUSED,
+			  hb_codepoint_t      ab,
+			  hb_codepoint_t     *a,
+			  hb_codepoint_t     *b,
+			  void               *user_data HB_UNUSED)
+{
+  UChar utf16[2], normalized[20];
+  int len;
+  hb_bool_t ret, err;
+  UErrorCode icu_err;
+
+  /* This function is a monster! Maybe it wasn't a good idea adding a
+   * pairwise decompose API... */
+  /* Watchout for the dragons.  Err, watchout for macros changing len. */
+
+  len = 0;
+  err = FALSE;
+  U16_APPEND (utf16, len, ARRAY_LENGTH (utf16), ab, err);
+  if (err) return FALSE;
+
+  icu_err = U_ZERO_ERROR;
+  len = unorm_normalize (utf16, len, UNORM_NFD, 0, normalized, ARRAY_LENGTH (normalized), &icu_err);
+  if (U_FAILURE (icu_err))
+    return FALSE;
+
+  len = u_countChar32 (normalized, len);
+
+  if (len == 1) {
+    U16_GET_UNSAFE (normalized, 0, *a);
+    *b = 0;
+    ret = *a != ab;
+  } else if (len == 2) {
+    len =0;
+    U16_NEXT_UNSAFE (normalized, len, *a);
+    U16_NEXT_UNSAFE (normalized, len, *b);
+
+    /* Here's the ugly part: if ab decomposes to a single character and
+     * that character decomposes again, we have to detect that and undo
+     * the second part :-(. */
+    UChar recomposed[20];
+    icu_err = U_ZERO_ERROR;
+    unorm_normalize (normalized, len, UNORM_NFC, 0, recomposed, ARRAY_LENGTH (recomposed), &icu_err);
+    if (U_FAILURE (icu_err))
+      return FALSE;
+    hb_codepoint_t c;
+    U16_GET_UNSAFE (recomposed, 0, c);
+    if (c != *a && c != ab) {
+      *a = c;
+      *b = 0;
+    }
+    ret = TRUE;
+  } else {
+    /* If decomposed to more than two characters, take the last one,
+     * and recompose the rest to get the first component. */
+    U16_PREV_UNSAFE (normalized, len, *b);
+    UChar recomposed[20];
+    icu_err = U_ZERO_ERROR;
+    len = unorm_normalize (normalized, len, UNORM_NFC, 0, recomposed, ARRAY_LENGTH (recomposed), &icu_err);
+    if (U_FAILURE (icu_err))
+      return FALSE;
+    /* We expect that recomposed has exactly one character now. */
+    U16_GET_UNSAFE (recomposed, 0, *a);
+    ret = TRUE;
+  }
+
+  return ret;
+}
+
+extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_icu;
+hb_unicode_funcs_t _hb_icu_unicode_funcs = {
+  HB_OBJECT_HEADER_STATIC,
+
+  NULL, /* parent */
+  TRUE, /* immutable */
+  {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_icu_unicode_##name,
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  }
+};
+
+hb_unicode_funcs_t *
+hb_icu_get_unicode_funcs (void)
+{
+  return &_hb_icu_unicode_funcs;
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-icu.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-icu.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,53 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_ICU_H
+#define HB_ICU_H
+
+#include "hb.h"
+
+#include <unicode/uscript.h>
+
+
+HB_BEGIN_DECLS
+
+
+hb_script_t
+hb_icu_script_to_script (UScriptCode script);
+
+UScriptCode
+hb_icu_script_from_script (hb_script_t script);
+
+
+hb_unicode_funcs_t *
+hb_icu_get_unicode_funcs (void);
+
+
+HB_END_DECLS
+
+#endif /* HB_ICU_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-language.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-language.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-language.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-language.c	2012-05-05 23:46:51.517763796 +0530
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-language.h"
+
+HB_BEGIN_DECLS
+
+
+static const char canon_map[256] = {
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,
+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,  '-',  0,   0,
+  '0', '1', '2', '3', '4', '5', '6', '7',  '8', '9',  0,   0,   0,   0,   0,   0,
+  '-', 'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,  '-',
+   0,  'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,   0
+};
+
+static hb_bool_t
+lang_equal (const void *v1,
+	    const void *v2)
+{
+  const unsigned char *p1 = v1;
+  const unsigned char *p2 = v2;
+
+  while (canon_map[*p1] && canon_map[*p1] == canon_map[*p2])
+    {
+      p1++, p2++;
+    }
+
+  return (canon_map[*p1] == canon_map[*p2]);
+}
+
+#if 0
+static unsigned int
+lang_hash (const void *key)
+{
+  const unsigned char *p = key;
+  unsigned int h = 0;
+  while (canon_map[*p])
+    {
+      h = (h << 5) - h + canon_map[*p];
+      p++;
+    }
+
+  return h;
+}
+#endif
+
+
+hb_language_t
+hb_language_from_string (const char *str)
+{
+  static unsigned int num_langs;
+  static unsigned int num_alloced;
+  static const char **langs;
+  unsigned int i;
+  unsigned char *p;
+
+  /* TODO Use a hash table or something */
+
+  if (!str)
+    return NULL;
+
+  for (i = 0; i < num_langs; i++)
+    if (lang_equal (str, langs[i]))
+      return langs[i];
+
+  if (unlikely (num_langs == num_alloced)) {
+    unsigned int new_alloced = 2 * (8 + num_alloced);
+    const char **new_langs = realloc (langs, new_alloced * sizeof (langs[0]));
+    if (!new_langs)
+      return NULL;
+    num_alloced = new_alloced;
+    langs = new_langs;
+  }
+
+  langs[i] = strdup (str);
+  for (p = (unsigned char *) langs[i]; *p; p++)
+    *p = canon_map[*p];
+
+  num_langs++;
+
+  return (hb_language_t) langs[i];
+}
+
+const char *
+hb_language_to_string (hb_language_t language)
+{
+  return (const char *) language;
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-language.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-language.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-language.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-language.h	2012-05-05 23:46:51.519763796 +0530
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_LANGUAGE_H
+#define HB_LANGUAGE_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+typedef const void *hb_language_t;
+
+hb_language_t
+hb_language_from_string (const char *str);
+
+const char *
+hb_language_to_string (hb_language_t language);
+
+
+HB_END_DECLS
+
+#endif /* HB_LANGUAGE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-mutex-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-mutex-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-mutex-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-mutex-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,114 @@
+/*
+ * Copyright  2007  Chris Wilson
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_MUTEX_PRIVATE_HH
+#define HB_MUTEX_PRIVATE_HH
+
+#include "hb-private.hh"
+
+
+
+/* mutex */
+
+/* We need external help for these */
+
+#if !defined(HB_NO_MT) && defined(HAVE_GLIB)
+
+#include <glib.h>
+typedef GStaticMutex hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	G_STATIC_MUTEX_INIT
+#define hb_mutex_impl_init(M)	g_static_mutex_init (M)
+#define hb_mutex_impl_lock(M)	g_static_mutex_lock (M)
+#define hb_mutex_impl_unlock(M)	g_static_mutex_unlock (M)
+#define hb_mutex_impl_free(M)	g_static_mutex_free (M)
+
+#elif !defined(HB_NO_MT) && defined(_MSC_VER) || defined(__MINGW32__)
+
+#include <windows.h>
+typedef CRITICAL_SECTION hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	{ NULL, 0, 0, NULL, NULL, 0 }
+#define hb_mutex_impl_init(M)	InitializeCriticalSection (M)
+#define hb_mutex_impl_lock(M)	EnterCriticalSection (M)
+#define hb_mutex_impl_unlock(M)	LeaveCriticalSection (M)
+#define hb_mutex_impl_free(M)	DeleteCriticalSection (M)
+
+#elif !defined(HB_NO_MT) && defined(__APPLE__)
+
+#include <pthread.h>
+typedef pthread_mutex_t hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	PTHREAD_MUTEX_INITIALIZER
+#define hb_mutex_impl_init(M)	pthread_mutex_init (M, NULL)
+#define hb_mutex_impl_lock(M)	pthread_mutex_lock (M)
+#define hb_mutex_impl_unlock(M)	pthread_mutex_unlock (M)
+#define hb_mutex_impl_free(M)	pthread_mutex_destroy (M)
+
+#else
+
+#define HB_MUTEX_IMPL_NIL 1
+typedef volatile int hb_mutex_impl_t;
+#define HB_MUTEX_IMPL_INIT	0
+#define hb_mutex_impl_init(M)	((void) (*(M) = 0))
+#define hb_mutex_impl_lock(M)	((void) (*(M) = 1))
+#define hb_mutex_impl_unlock(M)	((void) (*(M) = 0))
+#define hb_mutex_impl_free(M)	((void) (*(M) = 2))
+
+#endif
+
+
+struct hb_mutex_t
+{
+  hb_mutex_impl_t m;
+
+  inline void init   (void) { hb_mutex_impl_init   (&m); }
+  inline void lock   (void) { hb_mutex_impl_lock   (&m); }
+  inline void unlock (void) { hb_mutex_impl_unlock (&m); }
+  inline void free   (void) { hb_mutex_impl_free   (&m); }
+};
+
+#define HB_MUTEX_INIT		{HB_MUTEX_IMPL_INIT}
+#define hb_mutex_init(M)	(M)->init ()
+#define hb_mutex_lock(M)	(M)->lock ()
+#define hb_mutex_unlock(M)	(M)->unlock ()
+#define hb_mutex_free(M)	(M)->free ()
+
+
+struct hb_static_mutex_t : hb_mutex_t
+{
+  hb_static_mutex_t (void)  { this->init (); }
+  ~hb_static_mutex_t (void) { this->free (); }
+
+  private:
+  NO_COPY (hb_static_mutex_t);
+};
+
+
+
+#endif /* HB_MUTEX_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-object-private.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-object-private.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-object-private.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-object-private.h	2012-05-05 23:46:51.516763796 +0530
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2007 Chris Wilson
+ * Copyright (C) 2009,2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OBJECT_PRIVATE_H
+#define HB_OBJECT_PRIVATE_H
+
+#include "hb-private.h"
+
+HB_BEGIN_DECLS
+
+
+/* Encapsulate operations on the object's reference count */
+typedef struct {
+  hb_atomic_int_t ref_count;
+} hb_reference_count_t;
+
+#define hb_reference_count_inc(RC) hb_atomic_int_fetch_and_add ((RC).ref_count, 1)
+#define hb_reference_count_dec(RC) hb_atomic_int_fetch_and_add ((RC).ref_count, -1)
+
+#define HB_REFERENCE_COUNT_INIT(RC, VALUE) ((RC).ref_count = (VALUE))
+
+#define HB_REFERENCE_COUNT_GET_VALUE(RC) hb_atomic_int_get ((RC).ref_count)
+#define HB_REFERENCE_COUNT_SET_VALUE(RC, VALUE) hb_atomic_int_set ((RC).ref_count, (VALUE))
+
+#define HB_REFERENCE_COUNT_INVALID_VALUE ((hb_atomic_int_t) -1)
+#define HB_REFERENCE_COUNT_INVALID {HB_REFERENCE_COUNT_INVALID_VALUE}
+
+#define HB_REFERENCE_COUNT_IS_INVALID(RC) (HB_REFERENCE_COUNT_GET_VALUE (RC) == HB_REFERENCE_COUNT_INVALID_VALUE)
+
+#define HB_REFERENCE_COUNT_HAS_REFERENCE(RC) (HB_REFERENCE_COUNT_GET_VALUE (RC) > 0)
+
+
+
+/* Debug */
+
+#ifndef HB_DEBUG_OBJECT
+#define HB_DEBUG_OBJECT HB_DEBUG+0
+#endif
+
+static inline void
+_hb_trace_object (const void *obj,
+		  hb_reference_count_t *ref_count,
+		  const char *function)
+{
+  if (HB_DEBUG_OBJECT)
+    fprintf (stderr, "OBJECT(%p) refcount=%d %s\n",
+	     obj,
+	     HB_REFERENCE_COUNT_GET_VALUE (*ref_count),
+	     function);
+}
+
+#define TRACE_OBJECT(obj) _hb_trace_object (obj, &obj->ref_count, __FUNCTION__)
+
+
+
+/* Object allocation and lifecycle manamgement macros */
+
+#define HB_OBJECT_IS_INERT(obj) \
+    (unlikely (HB_REFERENCE_COUNT_IS_INVALID ((obj)->ref_count)))
+
+#define HB_OBJECT_DO_INIT_EXPR(obj) \
+    HB_REFERENCE_COUNT_INIT (obj->ref_count, 1)
+
+#define HB_OBJECT_DO_INIT(obj) \
+  HB_STMT_START { \
+    HB_OBJECT_DO_INIT_EXPR (obj); \
+  } HB_STMT_END
+
+#define HB_OBJECT_DO_CREATE(Type, obj) \
+  likely (( \
+	       (void) ( \
+		 ((obj) = (Type *) calloc (1, sizeof (Type))) && \
+		 ( \
+		  HB_OBJECT_DO_INIT_EXPR (obj), \
+		  TRACE_OBJECT (obj), \
+		  TRUE \
+		 ) \
+	       ), \
+	       (obj) \
+	     ))
+
+#define HB_OBJECT_DO_REFERENCE(obj) \
+  HB_STMT_START { \
+    int old_count; \
+    if (unlikely (!(obj) || HB_OBJECT_IS_INERT (obj))) \
+      return obj; \
+    TRACE_OBJECT (obj); \
+    old_count = hb_reference_count_inc (obj->ref_count); \
+    assert (old_count > 0); \
+    return obj; \
+  } HB_STMT_END
+
+#define HB_OBJECT_DO_GET_REFERENCE_COUNT(obj) \
+  HB_STMT_START { \
+    if (unlikely (!(obj) || HB_OBJECT_IS_INERT (obj))) \
+      return 0; \
+    return HB_REFERENCE_COUNT_GET_VALUE (obj->ref_count); \
+  } HB_STMT_END
+
+#define HB_OBJECT_DO_DESTROY(obj) \
+  HB_STMT_START { \
+    int old_count; \
+    if (unlikely (!(obj) || HB_OBJECT_IS_INERT (obj))) \
+      return; \
+    TRACE_OBJECT (obj); \
+    old_count = hb_reference_count_dec (obj->ref_count); \
+    assert (old_count > 0); \
+    if (old_count != 1) \
+      return; \
+  } HB_STMT_END
+
+
+HB_END_DECLS
+
+#endif /* HB_OBJECT_PRIVATE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-object-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-object-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-object-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-object-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,263 @@
+/*
+ * Copyright  2007  Chris Wilson
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Contributor(s):
+ *	Chris Wilson <chris@chris-wilson.co.uk>
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OBJECT_PRIVATE_HH
+#define HB_OBJECT_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-mutex-private.hh"
+
+
+
+/* Debug */
+
+#ifndef HB_DEBUG_OBJECT
+#define HB_DEBUG_OBJECT (HB_DEBUG+0)
+#endif
+
+
+/* atomic_int */
+
+/* We need external help for these */
+
+#if !defined(HB_NO_MT) && defined(HAVE_GLIB)
+
+#include <glib.h>
+typedef volatile int hb_atomic_int_t;
+#if GLIB_CHECK_VERSION(2,29,5)
+#define hb_atomic_int_add(AI, V)	g_atomic_int_add (&(AI), V)
+#else
+#define hb_atomic_int_add(AI, V)	g_atomic_int_exchange_and_add (&(AI), V)
+#endif
+#define hb_atomic_int_get(AI)		g_atomic_int_get (&(AI))
+
+
+#elif !defined(HB_NO_MT) && defined(_MSC_VER) && _MSC_VER >= 1600
+
+#include <intrin.h>
+typedef long hb_atomic_int_t;
+#define hb_atomic_int_add(AI, V)	_InterlockedExchangeAdd (&(AI), V)
+#define hb_atomic_int_get(AI)		(_ReadBarrier (), (AI))
+
+#elif !defined(HB_NO_MT) && defined(__APPLE__)
+
+#include <libkern/OSAtomic.h>
+typedef int32_t hb_atomic_int_t;
+#define hb_atomic_int_add(AI, V)	(OSAtomicAdd32Barrier((V), &(AI)), (AI) - (V))
+#define hb_atomic_int_get(AI)		OSAtomicAdd32Barrier(0, &(AI))
+
+#else
+
+#define HB_ATOMIC_INT_NIL 1
+
+typedef volatile int hb_atomic_int_t;
+#define hb_atomic_int_add(AI, V)	((AI) += (V), (AI) - (V))
+#define hb_atomic_int_get(AI)		(AI)
+
+#endif
+
+
+
+
+/* reference_count */
+
+typedef struct {
+  hb_atomic_int_t ref_count;
+
+#define HB_REFERENCE_COUNT_INVALID_VALUE ((hb_atomic_int_t) -1)
+#define HB_REFERENCE_COUNT_INVALID {HB_REFERENCE_COUNT_INVALID_VALUE}
+
+  inline void init (int v) { ref_count = v; /* non-atomic is fine */ }
+  inline int inc (void) { return hb_atomic_int_add (ref_count,  1); }
+  inline int dec (void) { return hb_atomic_int_add (ref_count, -1); }
+
+  inline int get (void) { return hb_atomic_int_get (ref_count); }
+  inline int get_unsafe (void) const { return ref_count; }
+  inline bool is_invalid (void) const { return ref_count == HB_REFERENCE_COUNT_INVALID_VALUE; }
+
+} hb_reference_count_t;
+
+
+/* user_data */
+
+struct hb_user_data_array_t {
+
+  struct hb_user_data_item_t {
+    hb_user_data_key_t *key;
+    void *data;
+    hb_destroy_func_t destroy;
+
+    inline bool operator == (hb_user_data_key_t *other_key) const { return key == other_key; }
+    inline bool operator == (hb_user_data_item_t &other) const { return key == other.key; }
+
+    void finish (void) { if (destroy) destroy (data); }
+  };
+
+  hb_lockable_set_t<hb_user_data_item_t, hb_static_mutex_t> items;
+
+  HB_INTERNAL bool set (hb_user_data_key_t *key,
+			void *              data,
+			hb_destroy_func_t   destroy,
+			hb_bool_t           replace);
+
+  HB_INTERNAL void *get (hb_user_data_key_t *key);
+
+  HB_INTERNAL void finish (void);
+};
+
+
+/* object_header */
+
+typedef struct _hb_object_header_t hb_object_header_t;
+
+struct _hb_object_header_t {
+  hb_reference_count_t ref_count;
+  hb_user_data_array_t user_data;
+
+#define HB_OBJECT_HEADER_STATIC {HB_REFERENCE_COUNT_INVALID}
+
+  static inline void *create (unsigned int size) {
+    hb_object_header_t *obj = (hb_object_header_t *) calloc (1, size);
+
+    if (likely (obj))
+      obj->init ();
+
+    return obj;
+  }
+
+  inline void init (void) {
+    ref_count.init (1);
+  }
+
+  inline bool is_inert (void) const {
+    return unlikely (ref_count.is_invalid ());
+  }
+
+  inline void reference (void) {
+    if (unlikely (!this || this->is_inert ()))
+      return;
+    ref_count.inc ();
+  }
+
+  inline bool destroy (void) {
+    if (unlikely (!this || this->is_inert ()))
+      return false;
+    if (ref_count.dec () != 1)
+      return false;
+
+    ref_count.init (HB_REFERENCE_COUNT_INVALID_VALUE);
+
+    user_data.finish ();
+
+    return true;
+  }
+
+  inline bool set_user_data (hb_user_data_key_t *key,
+			     void *              data,
+			     hb_destroy_func_t   destroy_func,
+			     hb_bool_t           replace) {
+    if (unlikely (!this || this->is_inert ()))
+      return false;
+
+    return user_data.set (key, data, destroy_func, replace);
+  }
+
+  inline void *get_user_data (hb_user_data_key_t *key) {
+    return user_data.get (key);
+  }
+
+  inline void trace (const char *function) const {
+    DEBUG_MSG (OBJECT, (void *) this,
+	       "refcount=%d %s",
+	       this ? ref_count.get_unsafe () : 0,
+	       function);
+  }
+
+};
+
+
+
+
+/* object */
+
+template <typename Type>
+static inline void hb_object_trace (const Type *obj, const char *function)
+{
+  obj->header.trace (function);
+}
+template <typename Type>
+static inline Type *hb_object_create (void)
+{
+  Type *obj = (Type *) hb_object_header_t::create (sizeof (Type));
+  hb_object_trace (obj, HB_FUNC);
+  return obj;
+}
+template <typename Type>
+static inline bool hb_object_is_inert (const Type *obj)
+{
+  return unlikely (obj->header.is_inert ());
+}
+template <typename Type>
+static inline Type *hb_object_reference (Type *obj)
+{
+  hb_object_trace (obj, HB_FUNC);
+  obj->header.reference ();
+  return obj;
+}
+template <typename Type>
+static inline bool hb_object_destroy (Type *obj)
+{
+  hb_object_trace (obj, HB_FUNC);
+  return obj->header.destroy ();
+}
+template <typename Type>
+static inline bool hb_object_set_user_data (Type               *obj,
+					    hb_user_data_key_t *key,
+					    void *              data,
+					    hb_destroy_func_t   destroy,
+					    hb_bool_t           replace)
+{
+  return obj->header.set_user_data (key, data, destroy, replace);
+}
+
+template <typename Type>
+static inline void *hb_object_get_user_data (Type               *obj,
+					     hb_user_data_key_t *key)
+{
+  return obj->header.get_user_data (key);
+}
+
+
+
+
+
+#endif /* HB_OBJECT_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-open-file-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-open-file-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-open-file-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-open-file-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,256 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OPEN_FILE_PRIVATE_HH
+#define HB_OPEN_FILE_PRIVATE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ *
+ * The OpenType Font File
+ *
+ */
+
+
+/*
+ * Organization of an OpenType Font
+ */
+
+struct OpenTypeFontFile;
+struct OffsetTable;
+struct TTCHeader;
+
+
+typedef struct TableRecord
+{
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  Tag		tag;		/* 4-byte identifier. */
+  CheckSum	checkSum;	/* CheckSum for this table. */
+  ULONG		offset;		/* Offset from beginning of TrueType font
+				 * file. */
+  ULONG		length;		/* Length of this table. */
+  public:
+  DEFINE_SIZE_STATIC (16);
+} OpenTypeTable;
+
+typedef struct OffsetTable
+{
+  friend struct OpenTypeFontFile;
+
+  inline unsigned int get_table_count (void) const
+  { return numTables; }
+  inline const TableRecord& get_table (unsigned int i) const
+  {
+    if (unlikely (i >= numTables)) return Null(TableRecord);
+    return tables[i];
+  }
+  inline bool find_table_index (hb_tag_t tag, unsigned int *table_index) const
+  {
+    Tag t;
+    t.set (tag);
+    unsigned int count = numTables;
+    for (unsigned int i = 0; i < count; i++)
+    {
+      if (t == tables[i].tag)
+      {
+        if (table_index) *table_index = i;
+        return true;
+      }
+    }
+    if (table_index) *table_index = Index::NOT_FOUND_INDEX;
+    return false;
+  }
+  inline const TableRecord& get_table_by_tag (hb_tag_t tag) const
+  {
+    unsigned int table_index;
+    find_table_index (tag, &table_index);
+    return get_table (table_index);
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& c->check_array (tables, TableRecord::static_size, numTables);
+  }
+
+  private:
+  Tag		sfnt_version;	/* '\0\001\0\00' if TrueType / 'OTTO' if CFF */
+  USHORT	numTables;	/* Number of tables. */
+  USHORT	searchRange;	/* (Maximum power of 2 <= numTables) x 16 */
+  USHORT	entrySelector;	/* Log2(maximum power of 2 <= numTables). */
+  USHORT	rangeShift;	/* NumTables x 16-searchRange. */
+  TableRecord	tables[VAR];	/* TableRecord entries. numTables items */
+  public:
+  DEFINE_SIZE_ARRAY (12, tables);
+} OpenTypeFontFace;
+
+
+/*
+ * TrueType Collections
+ */
+
+struct TTCHeaderVersion1
+{
+  friend struct TTCHeader;
+
+  inline unsigned int get_face_count (void) const { return table.len; }
+  inline const OpenTypeFontFace& get_face (unsigned int i) const { return this+table[i]; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return table.sanitize (c, this);
+  }
+
+  private:
+  Tag		ttcTag;		/* TrueType Collection ID string: 'ttcf' */
+  FixedVersion	version;	/* Version of the TTC Header (1.0),
+				 * 0x00010000 */
+  LongOffsetLongArrayOf<OffsetTable>
+		table;		/* Array of offsets to the OffsetTable for each font
+				 * from the beginning of the file */
+  public:
+  DEFINE_SIZE_ARRAY (12, table);
+};
+
+struct TTCHeader
+{
+  friend struct OpenTypeFontFile;
+
+  private:
+
+  inline unsigned int get_face_count (void) const
+  {
+    switch (u.header.version.major) {
+    case 2: /* version 2 is compatible with version 1 */
+    case 1: return u.version1.get_face_count ();
+    default:return 0;
+    }
+  }
+  inline const OpenTypeFontFace& get_face (unsigned int i) const
+  {
+    switch (u.header.version.major) {
+    case 2: /* version 2 is compatible with version 1 */
+    case 1: return u.version1.get_face (i);
+    default:return Null(OpenTypeFontFace);
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!u.header.version.sanitize (c))) return false;
+    switch (u.header.version.major) {
+    case 2: /* version 2 is compatible with version 1 */
+    case 1: return u.version1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  struct {
+  Tag		ttcTag;		/* TrueType Collection ID string: 'ttcf' */
+  FixedVersion	version;	/* Version of the TTC Header (1.0 or 2.0),
+				 * 0x00010000 or 0x00020000 */
+  }			header;
+  TTCHeaderVersion1	version1;
+  } u;
+};
+
+
+/*
+ * OpenType Font File
+ */
+
+struct OpenTypeFontFile
+{
+  static const hb_tag_t CFFTag		= HB_TAG ('O','T','T','O'); /* OpenType with Postscript outlines */
+  static const hb_tag_t TrueTypeTag	= HB_TAG ( 0 , 1 , 0 , 0 ); /* OpenType with TrueType outlines */
+  static const hb_tag_t TTCTag		= HB_TAG ('t','t','c','f'); /* TrueType Collection */
+  static const hb_tag_t TrueTag		= HB_TAG ('t','r','u','e'); /* Obsolete Apple TrueType */
+  static const hb_tag_t Typ1Tag		= HB_TAG ('t','y','p','1'); /* Obsolete Apple Type1 font in SFNT container */
+
+  inline hb_tag_t get_tag (void) const { return u.tag; }
+
+  inline unsigned int get_face_count (void) const
+  {
+    switch (u.tag) {
+    case CFFTag:	/* All the non-collection tags */
+    case TrueTag:
+    case Typ1Tag:
+    case TrueTypeTag:	return 1;
+    case TTCTag:	return u.ttcHeader.get_face_count ();
+    default:		return 0;
+    }
+  }
+  inline const OpenTypeFontFace& get_face (unsigned int i) const
+  {
+    switch (u.tag) {
+    /* Note: for non-collection SFNT data we ignore index.  This is because
+     * Apple dfont container is a container of SFNT's.  So each SFNT is a
+     * non-TTC, but the index is more than zero. */
+    case CFFTag:	/* All the non-collection tags */
+    case TrueTag:
+    case Typ1Tag:
+    case TrueTypeTag:	return u.fontFace;
+    case TTCTag:	return u.ttcHeader.get_face (i);
+    default:		return Null(OpenTypeFontFace);
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!u.tag.sanitize (c))) return false;
+    switch (u.tag) {
+    case CFFTag:	/* All the non-collection tags */
+    case TrueTag:
+    case Typ1Tag:
+    case TrueTypeTag:	return u.fontFace.sanitize (c);
+    case TTCTag:	return u.ttcHeader.sanitize (c);
+    default:		return true;
+    }
+  }
+
+  private:
+  union {
+  Tag			tag;		/* 4-byte identifier. */
+  OpenTypeFontFace	fontFace;
+  TTCHeader		ttcHeader;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (4, tag);
+};
+
+
+
+#endif /* HB_OPEN_FILE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-open-type-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-open-type-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-open-type-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-open-type-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,710 @@
+/*
+ * Copyright  2007,2008,2009,2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OPEN_TYPE_PRIVATE_HH
+#define HB_OPEN_TYPE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-blob.h"
+
+
+
+/*
+ * Casts
+ */
+
+/* Cast to struct T, reference to reference */
+template<typename Type, typename TObject>
+inline const Type& CastR(const TObject &X)
+{ return reinterpret_cast<const Type&> (X); }
+template<typename Type, typename TObject>
+inline Type& CastR(TObject &X)
+{ return reinterpret_cast<Type&> (X); }
+
+/* Cast to struct T, pointer to pointer */
+template<typename Type, typename TObject>
+inline const Type* CastP(const TObject *X)
+{ return reinterpret_cast<const Type*> (X); }
+template<typename Type, typename TObject>
+inline Type* CastP(TObject *X)
+{ return reinterpret_cast<Type*> (X); }
+
+/* StructAtOffset<T>(P,Ofs) returns the struct T& that is placed at memory
+ * location pointed to by P plus Ofs bytes. */
+template<typename Type>
+inline const Type& StructAtOffset(const void *P, unsigned int offset)
+{ return * reinterpret_cast<const Type*> ((const char *) P + offset); }
+template<typename Type>
+inline Type& StructAtOffset(void *P, unsigned int offset)
+{ return * reinterpret_cast<Type*> ((char *) P + offset); }
+
+/* StructAfter<T>(X) returns the struct T& that is placed after X.
+ * Works with X of variable size also.  X must implement get_size() */
+template<typename Type, typename TObject>
+inline const Type& StructAfter(const TObject &X)
+{ return StructAtOffset<Type>(&X, X.get_size()); }
+template<typename Type, typename TObject>
+inline Type& StructAfter(TObject &X)
+{ return StructAtOffset<Type>(&X, X.get_size()); }
+
+
+
+/*
+ * Size checking
+ */
+
+/* Check _assertion in a method environment */
+#define _DEFINE_SIZE_ASSERTION(_assertion) \
+  inline void _size_assertion (void) const \
+  { ASSERT_STATIC (_assertion); }
+/* Check that _code compiles in a method environment */
+#define _DEFINE_COMPILES_ASSERTION(_code) \
+  inline void _compiles_assertion (void) const \
+  { _code; }
+
+
+#define DEFINE_SIZE_STATIC(size) \
+  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size)); \
+  static const unsigned int static_size = (size); \
+  static const unsigned int min_size = (size)
+
+/* Size signifying variable-sized array */
+#define VAR 1
+
+#define DEFINE_SIZE_UNION(size, _member) \
+  _DEFINE_SIZE_ASSERTION (this->u._member.static_size == (size)); \
+  static const unsigned int min_size = (size)
+
+#define DEFINE_SIZE_MIN(size) \
+  _DEFINE_SIZE_ASSERTION (sizeof (*this) >= (size)); \
+  static const unsigned int min_size = (size)
+
+#define DEFINE_SIZE_ARRAY(size, array) \
+  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size) + sizeof (array[0])); \
+  _DEFINE_COMPILES_ASSERTION ((void) array[0].static_size) \
+  static const unsigned int min_size = (size)
+
+#define DEFINE_SIZE_ARRAY2(size, array1, array2) \
+  _DEFINE_SIZE_ASSERTION (sizeof (*this) == (size) + sizeof (this->array1[0]) + sizeof (this->array2[0])); \
+  _DEFINE_COMPILES_ASSERTION ((void) array1[0].static_size; (void) array2[0].static_size) \
+  static const unsigned int min_size = (size)
+
+
+
+/*
+ * Null objects
+ */
+
+/* Global nul-content Null pool.  Enlarge as necessary. */
+static const void *_NullPool[64 / sizeof (void *)];
+
+/* Generic nul-content Null objects. */
+template <typename Type>
+static inline const Type& Null (void) {
+  ASSERT_STATIC (Type::min_size <= sizeof (_NullPool));
+  return *CastP<Type> (_NullPool);
+}
+
+/* Specializaiton for arbitrary-content arbitrary-sized Null objects. */
+#define DEFINE_NULL_DATA(Type, data) \
+static const char _Null##Type[Type::min_size + 1] = data; /* +1 is for nul-termination in data */ \
+template <> \
+inline const Type& Null<Type> (void) { \
+  return *CastP<Type> (_Null##Type); \
+} /* The following line really exists such that we end in a place needing semicolon */ \
+ASSERT_STATIC (Type::min_size + 1 <= sizeof (_Null##Type))
+
+/* Accessor macro. */
+#define Null(Type) Null<Type>()
+
+
+
+/*
+ * Sanitize
+ */
+
+#ifndef HB_DEBUG_SANITIZE
+#define HB_DEBUG_SANITIZE (HB_DEBUG+0)
+#endif
+
+
+#define TRACE_SANITIZE() \
+	hb_auto_trace_t<HB_DEBUG_SANITIZE> trace (&c->debug_depth, "SANITIZE", this, NULL, HB_FUNC);
+
+
+struct hb_sanitize_context_t
+{
+  inline void init (hb_blob_t *b)
+  {
+    this->blob = hb_blob_reference (b);
+    this->writable = false;
+  }
+
+  inline void setup (void)
+  {
+    this->start = hb_blob_get_data (this->blob, NULL);
+    this->end = this->start + hb_blob_get_length (this->blob);
+    this->edit_count = 0;
+    this->debug_depth = 0;
+
+    DEBUG_MSG (SANITIZE, this->blob,
+	       "init [%p..%p] (%lu bytes)",
+	       this->start, this->end,
+	       (unsigned long) (this->end - this->start));
+  }
+
+  inline void finish (void)
+  {
+    DEBUG_MSG (SANITIZE, this->blob,
+	       "fini [%p..%p] %u edit requests",
+	       this->start, this->end, this->edit_count);
+
+    hb_blob_destroy (this->blob);
+    this->blob = NULL;
+    this->start = this->end = NULL;
+  }
+
+  inline bool check_range (const void *base, unsigned int len) const
+  {
+    const char *p = (const char *) base;
+    bool ret = this->start <= p &&
+	       p <= this->end &&
+	       (unsigned int) (this->end - p) >= len;
+
+    DEBUG_MSG_LEVEL (SANITIZE, this->blob, this->debug_depth,
+		     "%-*d-> range [%p..%p] (%d bytes) in [%p..%p] -> %s",
+		     this->debug_depth, this->debug_depth,
+		     p, p + len, len,
+		     this->start, this->end,
+		     ret ? "pass" : "FAIL");
+
+    return likely (ret);
+  }
+
+  inline bool check_array (const void *base, unsigned int record_size, unsigned int len) const
+  {
+    const char *p = (const char *) base;
+    bool overflows = _hb_unsigned_int_mul_overflows (len, record_size);
+
+    DEBUG_MSG_LEVEL (SANITIZE, this->blob, this->debug_depth,
+		     "%-*d-> array [%p..%p] (%d*%d=%ld bytes) in [%p..%p] -> %s",
+		     this->debug_depth, this->debug_depth,
+		     p, p + (record_size * len), record_size, len, (unsigned long) record_size * len,
+		     this->start, this->end,
+		     !overflows ? "does not overflow" : "OVERFLOWS FAIL");
+
+    return likely (!overflows && this->check_range (base, record_size * len));
+  }
+
+  template <typename Type>
+  inline bool check_struct (const Type *obj) const
+  {
+    return likely (this->check_range (obj, obj->min_size));
+  }
+
+  inline bool can_edit (const void *base HB_UNUSED, unsigned int len HB_UNUSED)
+  {
+    const char *p = (const char *) base;
+    this->edit_count++;
+
+    DEBUG_MSG_LEVEL (SANITIZE, this->blob, this->debug_depth,
+		     "%-*d-> edit(%u) [%p..%p] (%d bytes) in [%p..%p] -> %s",
+		     this->debug_depth, this->debug_depth,
+		     this->edit_count,
+		     p, p + len, len,
+		     this->start, this->end,
+		     this->writable ? "granted" : "REJECTED");
+
+    return this->writable;
+  }
+
+  unsigned int debug_depth;
+  const char *start, *end;
+  bool writable;
+  unsigned int edit_count;
+  hb_blob_t *blob;
+};
+
+
+
+/* Template to sanitize an object. */
+template <typename Type>
+struct Sanitizer
+{
+  static hb_blob_t *sanitize (hb_blob_t *blob) {
+    hb_sanitize_context_t c[1] = {{0}};
+    bool sane;
+
+    /* TODO is_sane() stuff */
+
+    c->init (blob);
+
+  retry:
+    DEBUG_MSG_FUNC (SANITIZE, blob, "start");
+
+    c->setup ();
+
+    if (unlikely (!c->start)) {
+      c->finish ();
+      return blob;
+    }
+
+    Type *t = CastP<Type> (const_cast<char *> (c->start));
+
+    sane = t->sanitize (c);
+    if (sane) {
+      if (c->edit_count) {
+	DEBUG_MSG_FUNC (SANITIZE, blob, "passed first round with %d edits; going for second round", c->edit_count);
+
+        /* sanitize again to ensure no toe-stepping */
+        c->edit_count = 0;
+	sane = t->sanitize (c);
+	if (c->edit_count) {
+	  DEBUG_MSG_FUNC (SANITIZE, blob, "requested %d edits in second round; FAILLING", c->edit_count);
+	  sane = false;
+	}
+      }
+    } else {
+      unsigned int edit_count = c->edit_count;
+      if (edit_count && !c->writable) {
+        c->start = hb_blob_get_data_writable (blob, NULL);
+	c->end = c->start + hb_blob_get_length (blob);
+
+	if (c->start) {
+	  c->writable = true;
+	  /* ok, we made it writable by relocating.  try again */
+	  DEBUG_MSG_FUNC (SANITIZE, blob, "retry");
+	  goto retry;
+	}
+      }
+    }
+
+    c->finish ();
+
+    DEBUG_MSG_FUNC (SANITIZE, blob, sane ? "PASSED" : "FAILED");
+    if (sane)
+      return blob;
+    else {
+      hb_blob_destroy (blob);
+      return hb_blob_get_empty ();
+    }
+  }
+
+  static const Type* lock_instance (hb_blob_t *blob) {
+    hb_blob_make_immutable (blob);
+    const char *base = hb_blob_get_data (blob, NULL);
+    return unlikely (!base) ? &Null(Type) : CastP<Type> (base);
+  }
+};
+
+
+
+
+/*
+ *
+ * The OpenType Font File: Data Types
+ */
+
+
+/* "The following data types are used in the OpenType font file.
+ *  All OpenType fonts use Motorola-style byte ordering (Big Endian):" */
+
+/*
+ * Int types
+ */
+
+
+template <typename Type, int Bytes> struct BEInt;
+
+/* LONGTERMTODO: On machines allowing unaligned access, we can make the
+ * following tighter by using byteswap instructions on ints directly. */
+template <typename Type>
+struct BEInt<Type, 2>
+{
+  public:
+  inline void set (Type i) { hb_be_uint16_put (v,i); }
+  inline operator Type (void) const { return hb_be_uint16_get (v); }
+  inline bool operator == (const BEInt<Type, 2>& o) const { return hb_be_uint16_eq (v, o.v); }
+  inline bool operator != (const BEInt<Type, 2>& o) const { return !(*this == o); }
+  private: uint8_t v[2];
+};
+template <typename Type>
+struct BEInt<Type, 4>
+{
+  public:
+  inline void set (Type i) { hb_be_uint32_put (v,i); }
+  inline operator Type (void) const { return hb_be_uint32_get (v); }
+  inline bool operator == (const BEInt<Type, 4>& o) const { return hb_be_uint32_eq (v, o.v); }
+  inline bool operator != (const BEInt<Type, 4>& o) const { return !(*this == o); }
+  private: uint8_t v[4];
+};
+
+/* Integer types in big-endian order and no alignment requirement */
+template <typename Type>
+struct IntType
+{
+  inline void set (Type i) { v.set (i); }
+  inline operator Type(void) const { return v; }
+  inline bool operator == (const IntType<Type> &o) const { return v == o.v; }
+  inline bool operator != (const IntType<Type> &o) const { return v != o.v; }
+  inline int cmp (Type a) const { Type b = v; return a < b ? -1 : a == b ? 0 : +1; }
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return likely (c->check_struct (this));
+  }
+  protected:
+  BEInt<Type, sizeof (Type)> v;
+  public:
+  DEFINE_SIZE_STATIC (sizeof (Type));
+};
+
+/* Typedef these to avoid clash with windows.h */
+#define USHORT	HB_USHORT
+#define SHORT	HB_SHORT
+#define ULONG	HB_ULONG
+#define LONG	HB_LONG
+typedef IntType<uint16_t> USHORT;	/* 16-bit unsigned integer. */
+typedef IntType<int16_t>  SHORT;	/* 16-bit signed integer. */
+typedef IntType<uint32_t> ULONG;	/* 32-bit unsigned integer. */
+typedef IntType<int32_t>  LONG;		/* 32-bit signed integer. */
+
+/* 16-bit signed integer (SHORT) that describes a quantity in FUnits. */
+typedef SHORT FWORD;
+
+/* 16-bit unsigned integer (USHORT) that describes a quantity in FUnits. */
+typedef USHORT UFWORD;
+
+/* Date represented in number of seconds since 12:00 midnight, January 1,
+ * 1904. The value is represented as a signed 64-bit integer. */
+struct LONGDATETIME
+{
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return likely (c->check_struct (this));
+  }
+  private:
+  LONG major;
+  ULONG minor;
+  public:
+  DEFINE_SIZE_STATIC (8);
+};
+
+/* Array of four uint8s (length = 32 bits) used to identify a script, language
+ * system, feature, or baseline */
+struct Tag : ULONG
+{
+  /* What the char* converters return is NOT nul-terminated.  Print using "%.4s" */
+  inline operator const char* (void) const { return reinterpret_cast<const char *> (&this->v); }
+  inline operator char* (void) { return reinterpret_cast<char *> (&this->v); }
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+DEFINE_NULL_DATA (Tag, "    ");
+
+/* Glyph index number, same as uint16 (length = 16 bits) */
+typedef USHORT GlyphID;
+
+/* Script/language-system/feature index */
+struct Index : USHORT {
+  static const unsigned int NOT_FOUND_INDEX = 0xFFFF;
+};
+DEFINE_NULL_DATA (Index, "\xff\xff");
+
+/* Offset to a table, same as uint16 (length = 16 bits), Null offset = 0x0000 */
+typedef USHORT Offset;
+
+/* LongOffset to a table, same as uint32 (length = 32 bits), Null offset = 0x00000000 */
+typedef ULONG LongOffset;
+
+
+/* CheckSum */
+struct CheckSum : ULONG
+{
+  static uint32_t CalcTableChecksum (ULONG *Table, uint32_t Length)
+  {
+    uint32_t Sum = 0L;
+    ULONG *EndPtr = Table+((Length+3) & ~3) / ULONG::static_size;
+
+    while (Table < EndPtr)
+      Sum += *Table++;
+    return Sum;
+  }
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+
+/*
+ * Version Numbers
+ */
+
+struct FixedVersion
+{
+  inline uint32_t to_int (void) const { return (major << 16) + minor; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  USHORT major;
+  USHORT minor;
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+
+
+/*
+ * Template subclasses of Offset and LongOffset that do the dereferencing.
+ * Use: (base+offset)
+ */
+
+template <typename OffsetType, typename Type>
+struct GenericOffsetTo : OffsetType
+{
+  inline const Type& operator () (const void *base) const
+  {
+    unsigned int offset = *this;
+    if (unlikely (!offset)) return Null(Type);
+    return StructAtOffset<Type> (base, offset);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    if (unlikely (!c->check_struct (this))) return false;
+    unsigned int offset = *this;
+    if (unlikely (!offset)) return true;
+    Type &obj = StructAtOffset<Type> (base, offset);
+    return likely (obj.sanitize (c)) || neuter (c);
+  }
+  template <typename T>
+  inline bool sanitize (hb_sanitize_context_t *c, void *base, T user_data) {
+    TRACE_SANITIZE ();
+    if (unlikely (!c->check_struct (this))) return false;
+    unsigned int offset = *this;
+    if (unlikely (!offset)) return true;
+    Type &obj = StructAtOffset<Type> (base, offset);
+    return likely (obj.sanitize (c, user_data)) || neuter (c);
+  }
+
+  private:
+  /* Set the offset to Null */
+  inline bool neuter (hb_sanitize_context_t *c) {
+    if (c->can_edit (this, this->static_size)) {
+      this->set (0); /* 0 is Null offset */
+      return true;
+    }
+    return false;
+  }
+};
+template <typename Base, typename OffsetType, typename Type>
+inline const Type& operator + (const Base &base, GenericOffsetTo<OffsetType, Type> offset) { return offset (base); }
+
+template <typename Type>
+struct OffsetTo : GenericOffsetTo<Offset, Type> {};
+
+template <typename Type>
+struct LongOffsetTo : GenericOffsetTo<LongOffset, Type> {};
+
+
+/*
+ * Array Types
+ */
+
+template <typename LenType, typename Type>
+struct GenericArrayOf
+{
+  const Type *sub_array (unsigned int start_offset, unsigned int *pcount /* IN/OUT */) const
+  {
+    unsigned int count = len;
+    if (unlikely (start_offset > count))
+      count = 0;
+    else
+      count -= start_offset;
+    count = MIN (count, *pcount);
+    *pcount = count;
+    return array + start_offset;
+  }
+
+  inline const Type& operator [] (unsigned int i) const
+  {
+    if (unlikely (i >= len)) return Null(Type);
+    return array[i];
+  }
+  inline unsigned int get_size (void) const
+  { return len.static_size + len * Type::static_size; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!sanitize_shallow (c))) return false;
+
+    /* Note: for structs that do not reference other structs,
+     * we do not need to call their sanitize() as we already did
+     * a bound check on the aggregate array size.  We just include
+     * a small unreachable expression to make sure the structs
+     * pointed to do have a simple sanitize(), ie. they do not
+     * reference other structs via offsets.
+     */
+    (void) (false && array[0].sanitize (c));
+
+    return true;
+  }
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    if (unlikely (!sanitize_shallow (c))) return false;
+    unsigned int count = len;
+    for (unsigned int i = 0; i < count; i++)
+      if (unlikely (!array[i].sanitize (c, base)))
+        return false;
+    return true;
+  }
+  template <typename T>
+  inline bool sanitize (hb_sanitize_context_t *c, void *base, T user_data) {
+    TRACE_SANITIZE ();
+    if (unlikely (!sanitize_shallow (c))) return false;
+    unsigned int count = len;
+    for (unsigned int i = 0; i < count; i++)
+      if (unlikely (!array[i].sanitize (c, base, user_data)))
+        return false;
+    return true;
+  }
+
+  private:
+  inline bool sanitize_shallow (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& c->check_array (this, Type::static_size, len);
+  }
+
+  public:
+  LenType len;
+  Type array[VAR];
+  public:
+  DEFINE_SIZE_ARRAY (sizeof (LenType), array);
+};
+
+/* An array with a USHORT number of elements. */
+template <typename Type>
+struct ArrayOf : GenericArrayOf<USHORT, Type> {};
+
+/* An array with a ULONG number of elements. */
+template <typename Type>
+struct LongArrayOf : GenericArrayOf<ULONG, Type> {};
+
+/* Array of Offset's */
+template <typename Type>
+struct OffsetArrayOf : ArrayOf<OffsetTo<Type> > {};
+
+/* Array of LongOffset's */
+template <typename Type>
+struct LongOffsetArrayOf : ArrayOf<LongOffsetTo<Type> > {};
+
+/* LongArray of LongOffset's */
+template <typename Type>
+struct LongOffsetLongArrayOf : LongArrayOf<LongOffsetTo<Type> > {};
+
+/* Array of offsets relative to the beginning of the array itself. */
+template <typename Type>
+struct OffsetListOf : OffsetArrayOf<Type>
+{
+  inline const Type& operator [] (unsigned int i) const
+  {
+    if (unlikely (i >= this->len)) return Null(Type);
+    return this+this->array[i];
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return OffsetArrayOf<Type>::sanitize (c, this);
+  }
+  template <typename T>
+  inline bool sanitize (hb_sanitize_context_t *c, T user_data) {
+    TRACE_SANITIZE ();
+    return OffsetArrayOf<Type>::sanitize (c, this, user_data);
+  }
+};
+
+
+/* An array with a USHORT number of elements,
+ * starting at second element. */
+template <typename Type>
+struct HeadlessArrayOf
+{
+  inline const Type& operator [] (unsigned int i) const
+  {
+    if (unlikely (i >= len || !i)) return Null(Type);
+    return array[i-1];
+  }
+  inline unsigned int get_size (void) const
+  { return len.static_size + (len ? len - 1 : 0) * Type::static_size; }
+
+  inline bool sanitize_shallow (hb_sanitize_context_t *c) {
+    return c->check_struct (this)
+	&& c->check_array (this, Type::static_size, len);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!sanitize_shallow (c))) return false;
+
+    /* Note: for structs that do not reference other structs,
+     * we do not need to call their sanitize() as we already did
+     * a bound check on the aggregate array size.  We just include
+     * a small unreachable expression to make sure the structs
+     * pointed to do have a simple sanitize(), ie. they do not
+     * reference other structs via offsets.
+     */
+    (void) (false && array[0].sanitize (c));
+
+    return true;
+  }
+
+  USHORT len;
+  Type array[VAR];
+  public:
+  DEFINE_SIZE_ARRAY (sizeof (USHORT), array);
+};
+
+
+/* An array with sorted elements.  Supports binary searching. */
+template <typename Type>
+struct SortedArrayOf : ArrayOf<Type> {
+
+  template <typename SearchType>
+  inline int search (const SearchType &x) const {
+    struct Cmp {
+      static int cmp (const SearchType *a, const Type *b) { return b->cmp (*a); }
+    };
+    const Type *p = (const Type *) bsearch (&x, this->array, this->len, sizeof (this->array[0]), (hb_compare_func_t) Cmp::cmp);
+    return p ? p - this->array : -1;
+  }
+};
+
+
+
+#endif /* HB_OPEN_TYPE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,40 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_H
+#define HB_OT_H
+#define HB_OT_H_IN
+
+#include "hb.h"
+
+#include "hb-ot-layout.h"
+#include "hb-ot-tag.h"
+
+HB_BEGIN_DECLS
+HB_END_DECLS
+
+#undef HB_OT_H_IN
+#endif /* HB_OT_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-head-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-head-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-head-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-head-private.hh	2012-05-05 23:46:51.532763797 +0530
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_HEAD_PRIVATE_HH
+#define HB_OT_HEAD_PRIVATE_HH
+
+#include "hb-open-type-private.hh"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * head
+ */
+
+#define HB_OT_TAG_head HB_TAG('h','e','a','d')
+
+struct head
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_head;
+
+  inline unsigned int get_upem (void) const {
+    unsigned int upem = unitsPerEm;
+    /* If no valid head table found, assume 1000, which matches typicaly Type1 usage. */
+    return 16 <= upem && upem <= 16384 ? upem : 1000;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    /* Shall we check for magicNumber here?  Who cares? */
+    return c->check_struct (this) && likely (version.major == 1);
+  }
+
+  private:
+  FixedVersion	version;		/* Version of the head table--currently
+					 * 0x00010000 for version 1.0. */
+  FixedVersion	fontRevision;		/* Set by font manufacturer. */
+  ULONG		checkSumAdjustment;	/* To compute: set it to 0, sum the
+					 * entire font as ULONG, then store
+					 * 0xB1B0AFBA - sum. */
+  ULONG		magicNumber;		/* Set to 0x5F0F3CF5. */
+  USHORT	flags;			/* Bit 0: Baseline for font at y=0;
+					 * Bit 1: Left sidebearing point at x=0;
+					 * Bit 2: Instructions may depend on point size;
+					 * Bit 3: Force ppem to integer values for all
+					 *   internal scaler math; may use fractional
+					 *   ppem sizes if this bit is clear;
+					 * Bit 4: Instructions may alter advance width
+					 *   (the advance widths might not scale linearly);
+
+					 * Bits 5-10: These should be set according to
+					 *   Apple's specification. However, they are not
+					 *   implemented in OpenType.
+					 * Bit 5: This bit should be set in fonts that are
+					 *   intended to e laid out vertically, and in
+					 *   which the glyphs have been drawn such that an
+					 *   x-coordinate of 0 corresponds to the desired
+					 *   vertical baseline.
+					 * Bit 6: This bit must be set to zero.
+					 * Bit 7: This bit should be set if the font
+					 *   requires layout for correct linguistic
+					 *   rendering (e.g. Arabic fonts).
+					 * Bit 8: This bit should be set for a GX font
+					 *   which has one or more metamorphosis effects
+					 *   designated as happening by default.
+					 * Bit 9: This bit should be set if the font
+					 *   contains any strong right-to-left glyphs.
+					 * Bit 10: This bit should be set if the font
+					 *   contains Indic-style rearrangement effects.
+
+					 * Bit 11: Font data is 'lossless,' as a result
+					 *   of having been compressed and decompressed
+					 *   with the Agfa MicroType Express engine.
+					 * Bit 12: Font converted (produce compatible metrics)
+					 * Bit 13: Font optimized for ClearType.
+					 *   Note, fonts that rely on embedded bitmaps (EBDT)
+					 *   for rendering should not be considered optimized
+					 *   for ClearType, and therefore should keep this bit
+					 *   cleared.
+					 * Bit 14: Reserved, set to 0
+					 * Bit 15: Reserved, set to 0. */
+  USHORT	unitsPerEm;		/* Valid range is from 16 to 16384. This value
+					 * should be a power of 2 for fonts that have
+					 * TrueType outlines. */
+  LONGDATETIME	created;		/* Number of seconds since 12:00 midnight,
+					   January 1, 1904. 64-bit integer */
+  LONGDATETIME	modified;		/* Number of seconds since 12:00 midnight,
+					   January 1, 1904. 64-bit integer */
+  SHORT		xMin;			/* For all glyph bounding boxes. */
+  SHORT		yMin;			/* For all glyph bounding boxes. */
+  SHORT		xMax;			/* For all glyph bounding boxes. */
+  SHORT		yMax;			/* For all glyph bounding boxes. */
+  USHORT	macStyle;		/* Bit 0: Bold (if set to 1);
+					 * Bit 1: Italic (if set to 1)
+					 * Bit 2: Underline (if set to 1)
+					 * Bit 3: Outline (if set to 1)
+					 * Bit 4: Shadow (if set to 1)
+					 * Bit 5: Condensed (if set to 1)
+					 * Bit 6: Extended (if set to 1)
+					 * Bits 7-15: Reserved (set to 0). */
+  USHORT	lowestRecPPEM;		/* Smallest readable size in pixels. */
+  SHORT		fontDirectionHint;	/* Deprecated (Set to 2).
+					 * 0: Fully mixed directional glyphs;
+					 * 1: Only strongly left to right;
+					 * 2: Like 1 but also contains neutrals;
+					 * -1: Only strongly right to left;
+					 * -2: Like -1 but also contains neutrals. */
+  SHORT		indexToLocFormat;	/* 0 for short offsets, 1 for long. */
+  SHORT		glyphDataFormat;	/* 0 for current format. */
+  public:
+  DEFINE_SIZE_STATIC (54);
+};
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_HEAD_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-head-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-head-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-head-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-head-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,143 @@
+/*
+ * Copyright  2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_HEAD_TABLE_HH
+#define HB_OT_HEAD_TABLE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ * head -- Font Header
+ */
+
+#define HB_OT_TAG_head HB_TAG('h','e','a','d')
+
+struct head
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_head;
+
+  inline unsigned int get_upem (void) const {
+    unsigned int upem = unitsPerEm;
+    /* If no valid head table found, assume 1000, which matches typicaly Type1 usage. */
+    return 16 <= upem && upem <= 16384 ? upem : 1000;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this) && likely (version.major == 1);
+  }
+
+  private:
+  FixedVersion	version;		/* Version of the head table--currently
+					 * 0x00010000 for version 1.0. */
+  FixedVersion	fontRevision;		/* Set by font manufacturer. */
+  ULONG		checkSumAdjustment;	/* To compute: set it to 0, sum the
+					 * entire font as ULONG, then store
+					 * 0xB1B0AFBA - sum. */
+  ULONG		magicNumber;		/* Set to 0x5F0F3CF5. */
+  USHORT	flags;			/* Bit 0: Baseline for font at y=0;
+					 * Bit 1: Left sidebearing point at x=0;
+					 * Bit 2: Instructions may depend on point size;
+					 * Bit 3: Force ppem to integer values for all
+					 *   internal scaler math; may use fractional
+					 *   ppem sizes if this bit is clear;
+					 * Bit 4: Instructions may alter advance width
+					 *   (the advance widths might not scale linearly);
+
+					 * Bits 5-10: These should be set according to
+					 *   Apple's specification. However, they are not
+					 *   implemented in OpenType.
+					 * Bit 5: This bit should be set in fonts that are
+					 *   intended to e laid out vertically, and in
+					 *   which the glyphs have been drawn such that an
+					 *   x-coordinate of 0 corresponds to the desired
+					 *   vertical baseline.
+					 * Bit 6: This bit must be set to zero.
+					 * Bit 7: This bit should be set if the font
+					 *   requires layout for correct linguistic
+					 *   rendering (e.g. Arabic fonts).
+					 * Bit 8: This bit should be set for a GX font
+					 *   which has one or more metamorphosis effects
+					 *   designated as happening by default.
+					 * Bit 9: This bit should be set if the font
+					 *   contains any strong right-to-left glyphs.
+					 * Bit 10: This bit should be set if the font
+					 *   contains Indic-style rearrangement effects.
+
+					 * Bit 11: Font data is 'lossless,' as a result
+					 *   of having been compressed and decompressed
+					 *   with the Agfa MicroType Express engine.
+					 * Bit 12: Font converted (produce compatible metrics)
+					 * Bit 13: Font optimized for ClearType.
+					 *   Note, fonts that rely on embedded bitmaps (EBDT)
+					 *   for rendering should not be considered optimized
+					 *   for ClearType, and therefore should keep this bit
+					 *   cleared.
+					 * Bit 14: Last Resort font. If set, indicates that
+					 * the glyphs encoded in the cmap subtables are simply
+					 * generic symbolic representations of code point
+					 * ranges and dont truly represent support for those
+					 * code points. If unset, indicates that the glyphs
+					 * encoded in the cmap subtables represent proper
+					 * support for those code points.
+					 * Bit 15: Reserved, set to 0. */
+  USHORT	unitsPerEm;		/* Valid range is from 16 to 16384. This value
+					 * should be a power of 2 for fonts that have
+					 * TrueType outlines. */
+  LONGDATETIME	created;		/* Number of seconds since 12:00 midnight,
+					   January 1, 1904. 64-bit integer */
+  LONGDATETIME	modified;		/* Number of seconds since 12:00 midnight,
+					   January 1, 1904. 64-bit integer */
+  SHORT		xMin;			/* For all glyph bounding boxes. */
+  SHORT		yMin;			/* For all glyph bounding boxes. */
+  SHORT		xMax;			/* For all glyph bounding boxes. */
+  SHORT		yMax;			/* For all glyph bounding boxes. */
+  USHORT	macStyle;		/* Bit 0: Bold (if set to 1);
+					 * Bit 1: Italic (if set to 1)
+					 * Bit 2: Underline (if set to 1)
+					 * Bit 3: Outline (if set to 1)
+					 * Bit 4: Shadow (if set to 1)
+					 * Bit 5: Condensed (if set to 1)
+					 * Bit 6: Extended (if set to 1)
+					 * Bits 7-15: Reserved (set to 0). */
+  USHORT	lowestRecPPEM;		/* Smallest readable size in pixels. */
+  SHORT		fontDirectionHint;	/* Deprecated (Set to 2).
+					 * 0: Fully mixed directional glyphs;
+					 * 1: Only strongly left to right;
+					 * 2: Like 1 but also contains neutrals;
+					 * -1: Only strongly right to left;
+					 * -2: Like -1 but also contains neutrals. */
+  SHORT		indexToLocFormat;	/* 0 for short offsets, 1 for long. */
+  SHORT		glyphDataFormat;	/* 0 for current format. */
+  public:
+  DEFINE_SIZE_STATIC (54);
+};
+
+
+
+#endif /* HB_OT_HEAD_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-hhea-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-hhea-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-hhea-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-hhea-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,92 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_HHEA_TABLE_HH
+#define HB_OT_HHEA_TABLE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ * hhea -- The Horizontal Header Table
+ */
+
+#define HB_OT_TAG_hhea HB_TAG('h','h','e','a')
+
+
+struct hhea
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_hhea;
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this) && likely (version.major == 1);
+  }
+
+  private:
+  FixedVersion	version;		/* 0x00010000 for version 1.0. */
+  FWORD		ascender;		/* Typographic ascent. <a
+					 * href="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html">
+					 * (Distance from baseline of highest
+					 * ascender)</a> */
+  FWORD		descender;		/* Typographic descent. <a
+					 * href="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html">
+					 * (Distance from baseline of lowest
+					 * descender)</a> */
+  FWORD		lineGap;		/* Typographic line gap. Negative
+					 * LineGap values are treated as zero
+					 * in Windows 3.1, System 6, and
+					 * System 7. */
+  UFWORD	advanceWidthMax;	/* Maximum advance width value in
+					 * 'hmtx' table. */
+  FWORD		minLeftSideBearing;	/* Minimum left sidebearing value in
+					 * 'hmtx' table. */
+  FWORD		minRightSideBearing;	/* Minimum right sidebearing value;
+					 * calculated as Min(aw - lsb -
+					 * (xMax - xMin)). */
+  FWORD		xMaxExtent;		/* Max(lsb + (xMax - xMin)). */
+  SHORT		caretSlopeRise;		/* Used to calculate the slope of the
+					 * cursor (rise/run); 1 for vertical. */
+  SHORT		caretSlopeRun;		/* 0 for vertical. */
+  SHORT		caretOffset;		/* The amount by which a slanted
+					 * highlight on a glyph needs
+					 * to be shifted to produce the
+					 * best appearance. Set to 0 for
+					 * non--slanted fonts */
+  SHORT		reserved1;		/* set to 0 */
+  SHORT		reserved2;		/* set to 0 */
+  SHORT		reserved3;		/* set to 0 */
+  SHORT		reserved4;		/* set to 0 */
+  SHORT		metricDataFormat;	/* 0 for current format. */
+  USHORT	numberOfHMetrics;	/* Number of hMetric entries in 'hmtx'
+					 * table */
+  public:
+  DEFINE_SIZE_STATIC (36);
+};
+
+
+#endif /* HB_OT_HHEA_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-hmtx-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-hmtx-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-hmtx-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-hmtx-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,86 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_HMTX_TABLE_HH
+#define HB_OT_HMTX_TABLE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ * hmtx -- The Horizontal Metrics Table
+ */
+
+#define HB_OT_TAG_hmtx HB_TAG('h','m','t','x')
+
+
+struct LongHorMetric
+{
+  USHORT	advanceWidth;
+  SHORT		lsb;
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct hmtx
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_hmtx;
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    /* We don't check for anything specific here.  The users of the
+     * struct do all the hard work... */
+    return true;
+  }
+
+  private:
+  LongHorMetric	longHorMetric[VAR];	/* Paired advance width and left side
+					 * bearing values for each glyph. The
+					 * value numOfHMetrics comes from
+					 * the 'hhea' table. If the font is
+					 * monospaced, only one entry need
+					 * be in the array, but that entry is
+					 * required. The last entry applies to
+					 * all subsequent glyphs. */
+  SHORT		leftSideBearingX[VAR];	/* Here the advanceWidth is assumed
+					 * to be the same as the advanceWidth
+					 * for the last entry above. The
+					 * number of entries in this array is
+					 * derived from numGlyphs (from 'maxp'
+					 * table) minus numberOfHMetrics. This
+					 * generally is used with a run of
+					 * monospaced glyphs (e.g., Kanji
+					 * fonts or Courier fonts). Only one
+					 * run is allowed and it must be at
+					 * the end. This allows a monospaced
+					 * font to vary the left side bearing
+					 * values for each glyph. */
+  public:
+  DEFINE_SIZE_ARRAY2 (0, longHorMetric, leftSideBearingX);
+};
+
+#endif /* HB_OT_HMTX_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout.cc	2012-08-08 23:47:15.115723531 +0530
@@ -0,0 +1,554 @@
+/*
+ * Copyright  1998-2004  David Turner and Werner Lemberg
+ * Copyright  2006  Behdad Esfahbod
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-layout-private.hh"
+
+#include "hb-ot-layout-gdef-table.hh"
+#include "hb-ot-layout-gsub-table.hh"
+#include "hb-ot-layout-gpos-table.hh"
+#include "hb-ot-maxp-table.hh"
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+
+hb_ot_layout_t *
+_hb_ot_layout_create (hb_face_t *face)
+{
+  /* TODO Remove this object altogether */
+  hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));
+
+  layout->gdef_blob = Sanitizer<GDEF>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GDEF));
+  layout->gdef = Sanitizer<GDEF>::lock_instance (layout->gdef_blob);
+
+  layout->gsub_blob = Sanitizer<GSUB>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GSUB));
+  layout->gsub = Sanitizer<GSUB>::lock_instance (layout->gsub_blob);
+
+  layout->gpos_blob = Sanitizer<GPOS>::sanitize (hb_face_reference_table (face, HB_OT_TAG_GPOS));
+  layout->gpos = Sanitizer<GPOS>::lock_instance (layout->gpos_blob);
+
+  return layout;
+}
+
+void
+_hb_ot_layout_destroy (hb_ot_layout_t *layout)
+{
+  hb_blob_destroy (layout->gdef_blob);
+  hb_blob_destroy (layout->gsub_blob);
+  hb_blob_destroy (layout->gpos_blob);
+
+  free (layout);
+}
+
+static inline const GDEF&
+_get_gdef (hb_face_t *face)
+{
+  return likely (face->ot_layout && face->ot_layout->gdef) ? *face->ot_layout->gdef : Null(GDEF);
+}
+static inline const GSUB&
+_get_gsub (hb_face_t *face)
+{
+  return likely (face->ot_layout && face->ot_layout->gsub) ? *face->ot_layout->gsub : Null(GSUB);
+}
+static inline const GPOS&
+_get_gpos (hb_face_t *face)
+{
+  return likely (face->ot_layout && face->ot_layout->gpos) ? *face->ot_layout->gpos : Null(GPOS);
+}
+
+
+/*
+ * GDEF
+ */
+
+hb_bool_t
+hb_ot_layout_has_glyph_classes (hb_face_t *face)
+{
+  return _get_gdef (face).has_glyph_classes ();
+}
+
+unsigned int
+_hb_ot_layout_get_glyph_property (hb_face_t       *face,
+				  hb_glyph_info_t *info)
+{
+  if (!info->props_cache())
+  {
+    const GDEF &gdef = _get_gdef (face);
+    info->props_cache() = gdef.get_glyph_props (info->codepoint);
+  }
+
+  return info->props_cache();
+}
+
+static hb_bool_t
+_hb_ot_layout_match_properties (hb_face_t      *face,
+				hb_codepoint_t  codepoint,
+				unsigned int    glyph_props,
+				unsigned int    lookup_props)
+{
+  /* Not covered, if, for example, glyph class is ligature and
+   * lookup_props includes LookupFlags::IgnoreLigatures
+   */
+  if (glyph_props & lookup_props & LookupFlag::IgnoreFlags)
+    return false;
+
+  if (glyph_props & HB_OT_LAYOUT_GLYPH_CLASS_MARK)
+  {
+    /* If using mark filtering sets, the high short of
+     * lookup_props has the set index.
+     */
+    if (lookup_props & LookupFlag::UseMarkFilteringSet)
+      return _get_gdef (face).mark_set_covers (lookup_props >> 16, codepoint);
+
+    /* The second byte of lookup_props has the meaning
+     * "ignore marks of attachment type different than
+     * the attachment type specified."
+     */
+    if (lookup_props & LookupFlag::MarkAttachmentType && glyph_props & LookupFlag::MarkAttachmentType)
+      return (lookup_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);
+  }
+
+  return true;
+}
+
+hb_bool_t
+_hb_ot_layout_check_glyph_property (hb_face_t    *face,
+				    hb_glyph_info_t *ginfo,
+				    unsigned int  lookup_props,
+				    unsigned int *property_out)
+{
+  unsigned int property;
+
+  property = _hb_ot_layout_get_glyph_property (face, ginfo);
+  (void) (property_out && (*property_out = property));
+
+  return _hb_ot_layout_match_properties (face, ginfo->codepoint, property, lookup_props);
+}
+
+hb_bool_t
+_hb_ot_layout_skip_mark (hb_face_t    *face,
+			 hb_glyph_info_t *ginfo,
+			 unsigned int  lookup_props,
+			 unsigned int *property_out)
+{
+  unsigned int property;
+
+  property = _hb_ot_layout_get_glyph_property (face, ginfo);
+  (void) (property_out && (*property_out = property));
+
+  /* If it's a mark, skip it we don't accept it. */
+  if (unlikely (property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+    return !_hb_ot_layout_match_properties (face, ginfo->codepoint, property, lookup_props);
+
+  /* If not a mark, don't skip. */
+  return false;
+}
+
+
+
+unsigned int
+hb_ot_layout_get_attach_points (hb_face_t      *face,
+				hb_codepoint_t  glyph,
+				unsigned int    start_offset,
+				unsigned int   *point_count /* IN/OUT */,
+				unsigned int   *point_array /* OUT */)
+{
+  return _get_gdef (face).get_attach_points (glyph, start_offset, point_count, point_array);
+}
+
+unsigned int
+hb_ot_layout_get_ligature_carets (hb_font_t      *font,
+				  hb_direction_t  direction,
+				  hb_codepoint_t  glyph,
+				  unsigned int    start_offset,
+				  unsigned int   *caret_count /* IN/OUT */,
+				  int            *caret_array /* OUT */)
+{
+  return _get_gdef (font->face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);
+}
+
+/*
+ * GSUB/GPOS
+ */
+
+static const GSUBGPOS&
+get_gsubgpos_table (hb_face_t *face,
+		    hb_tag_t   table_tag)
+{
+  switch (table_tag) {
+    case HB_OT_TAG_GSUB: return _get_gsub (face);
+    case HB_OT_TAG_GPOS: return _get_gpos (face);
+    default:             return Null(GSUBGPOS);
+  }
+}
+
+
+unsigned int
+hb_ot_layout_table_get_script_tags (hb_face_t    *face,
+				    hb_tag_t      table_tag,
+				    unsigned int  start_offset,
+				    unsigned int *script_count /* IN/OUT */,
+				    hb_tag_t     *script_tags /* OUT */)
+{
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+
+  return g.get_script_tags (start_offset, script_count, script_tags);
+}
+
+/************/
+unsigned int
+hb_ot_layout_table_get_script_count(hb_face_t    *face,
+                                    hb_tag_t      table_tag)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+    const GSUBGPOS &g = get_gsubgpos_table(face, table_tag);
+    return g.get_script_count();
+}
+
+unsigned int
+hb_ot_layout_script_get_language_count(hb_face_t    *face,
+                                    hb_tag_t      table_tag,
+                                    unsigned int  script_index)
+{
+//printf ( "(%s)(%d)(%s)(%d)  \n", __FILE__, __LINE__, __func__, script_index  ) ;
+     const GSUBGPOS &g = get_gsubgpos_table(face, table_tag);
+     const Script &s = g.get_script(script_index);
+     if(s.has_default_lang_sys())
+             return s.get_lang_sys_count() + 1;
+     return s.get_lang_sys_count();
+}
+
+unsigned int
+hb_ot_layout_language_get_feature_count(hb_face_t    *face,
+                                            hb_tag_t      table_tag,
+                                            unsigned int   script_index,
+                                            unsigned int   language_index)
+{
+printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+    const GSUBGPOS &g = get_gsubgpos_table(face, table_tag);
+    const Script &s = g.get_script(script_index);
+    const LangSys &l = (HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX == language_index) ? s.get_default_lang_sys() : s.get_lang_sys(language_index);
+    return l.get_feature_count();
+}
+/************/
+hb_bool_t
+hb_ot_layout_table_find_script (hb_face_t    *face,
+				hb_tag_t      table_tag,
+				hb_tag_t      script_tag,
+				unsigned int *script_index)
+{
+  ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX);
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+
+  if (g.find_script_index (script_tag, script_index))
+    return TRUE;
+
+  /* try finding 'DFLT' */
+  if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))
+    return FALSE;
+
+  /* try with 'dflt'; MS site has had typos and many fonts use it now :(.
+   * including many versions of DejaVu Sans Mono! */
+  if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
+    return FALSE;
+
+  if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
+  return FALSE;
+}
+
+hb_bool_t
+hb_ot_layout_table_choose_script (hb_face_t      *face,
+				  hb_tag_t        table_tag,
+				  const hb_tag_t *script_tags,
+				  unsigned int   *script_index,
+				  hb_tag_t       *chosen_script)
+{
+  ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX);
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+
+  while (*script_tags)
+  {
+    if (g.find_script_index (*script_tags, script_index)) {
+      if (chosen_script)
+        *chosen_script = *script_tags;
+      return TRUE;
+    }
+    script_tags++;
+  }
+
+  /* try finding 'DFLT' */
+  if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
+    if (chosen_script)
+      *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
+    return FALSE;
+  }
+
+  /* try with 'dflt'; MS site has had typos and many fonts use it now :( */
+  if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
+    if (chosen_script)
+      *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
+    return FALSE;
+  }
+
+  /* try with 'latn'; some old fonts put their features there even though
+     they're really trying to support Thai, for example :( */
+#define HB_OT_TAG_LATIN_SCRIPT		HB_TAG ('l', 'a', 't', 'n')
+  if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
+    if (chosen_script)
+      *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
+    return FALSE;
+  }
+
+  if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
+  if (chosen_script)
+    *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
+  return FALSE;
+}
+
+unsigned int
+hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
+				     hb_tag_t      table_tag,
+				     unsigned int  start_offset,
+				     unsigned int *feature_count /* IN/OUT */,
+				     hb_tag_t     *feature_tags /* OUT */)
+{
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+
+  return g.get_feature_tags (start_offset, feature_count, feature_tags);
+}
+
+
+unsigned int
+hb_ot_layout_script_get_language_tags (hb_face_t    *face,
+				       hb_tag_t      table_tag,
+				       unsigned int  script_index,
+				       unsigned int  start_offset,
+				       unsigned int *language_count /* IN/OUT */,
+				       hb_tag_t     *language_tags /* OUT */)
+{
+  const Script &s = get_gsubgpos_table (face, table_tag).get_script (script_index);
+
+  return s.get_lang_sys_tags (start_offset, language_count, language_tags);
+}
+
+hb_bool_t
+hb_ot_layout_script_find_language (hb_face_t    *face,
+				   hb_tag_t      table_tag,
+				   unsigned int  script_index,
+				   hb_tag_t      language_tag,
+				   unsigned int *language_index)
+{
+  ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX);
+  const Script &s = get_gsubgpos_table (face, table_tag).get_script (script_index);
+
+  if (s.find_lang_sys_index (language_tag, language_index))
+    return TRUE;
+
+  /* try with 'dflt'; MS site has had typos and many fonts use it now :( */
+  if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
+    return FALSE;
+
+  if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
+  return FALSE;
+}
+
+hb_bool_t
+hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
+						  hb_tag_t      table_tag,
+						  unsigned int  script_index,
+						  unsigned int  language_index,
+						  unsigned int *feature_index)
+{
+  const LangSys &l = get_gsubgpos_table (face, table_tag).get_script (script_index).get_lang_sys (language_index);
+
+  if (feature_index) *feature_index = l.get_required_feature_index ();
+
+  return l.has_required_feature ();
+}
+
+unsigned int
+hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
+					   hb_tag_t      table_tag,
+					   unsigned int  script_index,
+					   unsigned int  language_index,
+					   unsigned int  start_offset,
+					   unsigned int *feature_count /* IN/OUT */,
+					   unsigned int *feature_indexes /* OUT */)
+{
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+  const LangSys &l = g.get_script (script_index).get_lang_sys (language_index);
+
+  return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
+}
+
+unsigned int
+hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
+					hb_tag_t      table_tag,
+					unsigned int  script_index,
+					unsigned int  language_index,
+					unsigned int  start_offset,
+					unsigned int *feature_count /* IN/OUT */,
+					hb_tag_t     *feature_tags /* OUT */)
+{
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+  const LangSys &l = g.get_script (script_index).get_lang_sys (language_index);
+
+  ASSERT_STATIC (sizeof (unsigned int) == sizeof (hb_tag_t));
+  unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
+
+  if (feature_tags) {
+    unsigned int count = *feature_count;
+    for (unsigned int i = 0; i < count; i++)
+      feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
+  }
+
+  return ret;
+}
+
+
+hb_bool_t
+hb_ot_layout_language_find_feature (hb_face_t    *face,
+				    hb_tag_t      table_tag,
+				    unsigned int  script_index,
+				    unsigned int  language_index,
+				    hb_tag_t      feature_tag,
+				    unsigned int *feature_index)
+{
+  ASSERT_STATIC (Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX);
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+  const LangSys &l = g.get_script (script_index).get_lang_sys (language_index);
+
+  unsigned int num_features = l.get_feature_count ();
+  for (unsigned int i = 0; i < num_features; i++) {
+    unsigned int f_index = l.get_feature_index (i);
+
+    if (feature_tag == g.get_feature_tag (f_index)) {
+      if (feature_index) *feature_index = f_index;
+      return TRUE;
+    }
+  }
+
+  if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
+  return FALSE;
+}
+
+unsigned int
+hb_ot_layout_feature_get_lookup_indexes (hb_face_t    *face,
+					 hb_tag_t      table_tag,
+					 unsigned int  feature_index,
+					 unsigned int  start_offset,
+					 unsigned int *lookup_count /* IN/OUT */,
+					 unsigned int *lookup_indexes /* OUT */)
+{
+  const GSUBGPOS &g = get_gsubgpos_table (face, table_tag);
+  const Feature &f = g.get_feature (feature_index);
+
+  return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
+}
+
+
+/*
+ * GSUB
+ */
+
+hb_bool_t
+hb_ot_layout_has_substitution (hb_face_t *face)
+{
+//printf ( "(%s)(%d)(%s) \n", __FILE__, __LINE__, __func__) ;
+  return &_get_gsub (face) != &Null(GSUB);
+}
+
+void
+hb_ot_layout_substitute_start (hb_buffer_t  *buffer)
+{
+//printf ( "(%s)(%d)(%s) \n", __FILE__, __LINE__, __func__) ;
+  GSUB::substitute_start (buffer);
+}
+
+hb_bool_t
+hb_ot_layout_substitute_lookup (hb_face_t    *face,
+				hb_buffer_t  *buffer,
+				unsigned int  lookup_index,
+				hb_mask_t     mask)
+{
+  hb_apply_context_t c (NULL, face, buffer, mask);
+  return _get_gsub (face).substitute_lookup (&c, lookup_index);
+}
+
+void
+hb_ot_layout_substitute_finish (hb_buffer_t  *buffer HB_UNUSED)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  GSUB::substitute_finish (buffer);
+}
+
+void
+hb_ot_layout_substitute_closure_lookup (hb_face_t    *face,
+				        hb_set_t     *glyphs,
+				        unsigned int  lookup_index)
+{
+printf ( "(%s)(%d)(%s)   \n", __FILE__, __LINE__, __func__) ;
+  hb_closure_context_t c (face, glyphs);
+  _get_gsub (face).closure_lookup (&c, lookup_index);
+}
+
+/*
+ * GPOS
+ */
+
+hb_bool_t
+hb_ot_layout_has_positioning (hb_face_t *face)
+{
+  return &_get_gpos (face) != &Null(GPOS);
+}
+
+void
+hb_ot_layout_position_start (hb_buffer_t  *buffer)
+{
+  GPOS::position_start (buffer);
+}
+
+hb_bool_t
+hb_ot_layout_position_lookup   (hb_font_t    *font,
+				hb_buffer_t  *buffer,
+				unsigned int  lookup_index,
+				hb_mask_t     mask)
+{
+  hb_apply_context_t c (font, font->face, buffer, mask);
+  return _get_gpos (font->face).position_lookup (&c, lookup_index);
+}
+
+void
+hb_ot_layout_position_finish (hb_buffer_t  *buffer)
+{
+  GPOS::position_finish (buffer);
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hbotlayout_class.cpp Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hbotlayout_class.cpp
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hbotlayout_class.cpp	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hbotlayout_class.cpp	2012-05-05 23:46:51.519763796 +0530
@@ -0,0 +1,164 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "hbotlayout_class.h"
+
+
+#include "hb-ot-layout-private.hh"
+
+#include "hb-ot-layout-gdef-private.hh"
+#include "hb-ot-layout-gsub-private.hh"
+#include "hb-ot-layout-gpos-private.hh"
+
+
+HBOtLayout::HBOtLayout(hb_face_t *face)
+	:m_face(face)
+{
+
+}
+
+HBOtLayout::~HBOtLayout()
+{
+	if(scriptTags) delete scriptTags;
+	if(languageTags) delete languageTags;
+	if(featureTags) delete featureTags;
+
+	if(scriptIndexes) delete scriptIndexes;
+	if(languageIndexes) delete languageIndexes;
+	if(featureIndexes) delete featureIndexes;
+}
+
+bool HBOtLayout::set(HBOtLayout::Hierarchy h, const hb_tag_t &tag)
+{
+	if(h == Table)
+	{
+		if((tag == HB_OT_TAG_GSUB)
+			&& (&_get_gsub (m_face) != &Null(GSUB)))
+		{
+			currentTable = tag;
+			return true;
+		}
+		else if((tag == HB_OT_TAG_GPOS)
+			&& (&_get_gpos (m_face) != &Null(GPOS)))
+		{
+			currentTable == tag;
+			return true;
+		}
+		return false;
+	}
+	else if(h == Script)
+	{
+		if(currentTable == 0)
+			return false;
+		const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+		if (g.find_script_index(tag, currentScriptIndex))
+		{
+			currentScript = tag;
+			return true;
+		}
+		return false;
+	}
+	else if(h == Language)
+	{
+		if((currentTable == 0)
+			|| (currentScript == 0))
+			return false;
+		const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+		const Script &s = g.get_script(currentScriptIndex);
+		if (s.find_lang_sys_index (tag, currentLanguageIndex))
+		{
+			currentLanguage = tag;
+			return true;
+		}
+		return false;
+
+	}
+	return false;
+}
+
+unsigned int HBOtLayout::count(HBOtLayout::Hierarchy h) const
+{
+	if(h == Script)
+	{
+		if(currentTable == 0)
+			return 0;
+		const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+		return g.get_script_count();
+	}
+	else if(h == Language)
+	{
+		if((currentTable == 0)
+			|| (currentScript == 0))
+			return 0;
+		const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+		const Script &s = g.get_script(currentScriptIndex);
+		return s.get_lang_sys_count();
+	}
+	else if(h == Feature)
+	{
+		if((currentTable == 0)
+			|| (currentScript == 0)
+			|| (currentLanguage == 0))
+			return 0;
+		const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+		const Script &s = g.get_script(currentScriptIndex);
+		const LangSys &l = s.get_lang_sys(currentLanguageIndex);
+		return l.get_feature_count();
+	}
+	return 0;
+}
+
+hb_tag_t * HBOtLayout::getTags(HBOtLayout::Hierarchy h) const
+{
+	if(h == Script)
+	{
+		if(currentTable == 0)
+			return 0;
+		unsigned int scriptCount(count(Script));
+		if(scriptTags)
+		{
+			delete scriptTags;
+			scriptTags = 0;
+		}
+		if(scriptCount > 0)
+		{
+			scriptTags = new hb_tag_t[scriptCount];
+			const GSUBGPOS &g = get_gsubgpos_table(m_face, currentTable);
+			g.get_script_tags(0, scriptCount, scriptTags);
+		}
+		return scriptTags;
+	}
+	else if(h == Language)
+	{
+		if((currentTable == 0)
+			|| (currentScript == 0))
+			return 0;
+
+	}
+	else if(h == Feature)
+	{
+		if((currentTable == 0)
+			|| (currentScript == 0)
+			|| (currentLanguage == 0))
+			return 0;
+
+	}
+	return 0;
+}
\ No newline at end of file
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hbotlayout_class.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hbotlayout_class.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hbotlayout_class.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hbotlayout_class.h	2012-05-05 23:46:51.529763796 +0530
@@ -0,0 +1,68 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Pierre Marchand   *
+ *   pierre@oep-h.com   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef HBOTLAYOUT_H
+#define HBOTLAYOUT_H
+
+#include "hb-common.h"
+#include "hb-buffer.h"
+#include "hb-font.h"
+
+#include "hb-ot-tag.h"
+
+class HBOtLayout
+{
+	hb_face_t * m_face;
+
+	hb_tag_t * scriptTags;
+	hb_tag_t * languageTags;
+	hb_tag_t * featureTags;
+
+	unsigned int * scriptIndexes;
+	unsigned int * languageIndexes;
+	unsigned int * featureIndexes;
+
+	hb_tag_t currentTable;
+	hb_tag_t currentScript;
+	hb_tag_t currentLanguage;
+
+	unsigned int currentScriptIndex;
+	unsigned int currentLanguageIndex;
+
+public:
+	enum Hierarchy{
+		Table,
+		Script,
+		Language,
+		Feature
+	};
+
+	HBOtLayout(hb_face_t * face);
+	~HBOtLayout();
+
+	bool set(Hierarchy h, const hb_tag_t& tag);
+	unsigned int count(Hierarchy) const;
+	// a pity we don't have std++
+	hb_tag_t * getTags(Hierarchy h) const;
+	unsigned int * getIndexes(Hierarchy h) const;
+
+};
+
+#endif // HBOTLAYOUT_H
\ No newline at end of file
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-common-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-common-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-common-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-common-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,746 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ * Copyright  2010,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_COMMON_PRIVATE_HH
+#define HB_OT_LAYOUT_COMMON_PRIVATE_HH
+
+#include "hb-ot-layout-private.hh"
+#include "hb-open-type-private.hh"
+#include "hb-set-private.hh"
+
+
+#define NO_CONTEXT		((unsigned int) 0x110000)
+#define NOT_COVERED		((unsigned int) 0x110000)
+#define MAX_NESTING_LEVEL	8
+
+
+
+/*
+ *
+ * OpenType Layout Common Table Formats
+ *
+ */
+
+
+/*
+ * Script, ScriptList, LangSys, Feature, FeatureList, Lookup, LookupList
+ */
+
+template <typename Type>
+struct Record
+{
+  inline int cmp (hb_tag_t a) const {
+    return tag.cmp (a);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& offset.sanitize (c, base);
+  }
+
+  Tag		tag;		/* 4-byte Tag identifier */
+  OffsetTo<Type>
+		offset;		/* Offset from beginning of object holding
+				 * the Record */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+template <typename Type>
+struct RecordArrayOf : SortedArrayOf<Record<Type> > {
+  inline const Tag& get_tag (unsigned int i) const
+  {
+    /* We cheat slightly and don't define separate Null objects
+     * for Record types.  Instead, we return the correct Null(Tag)
+     * here. */
+    if (unlikely (i >= this->len)) return Null(Tag);
+    return (*this)[i].tag;
+  }
+  inline unsigned int get_tags (unsigned int start_offset,
+				unsigned int *record_count /* IN/OUT */,
+				hb_tag_t     *record_tags /* OUT */) const
+  {
+    if (record_count) {
+      const Record<Type> *arr = this->sub_array (start_offset, record_count);
+      unsigned int count = *record_count;
+      for (unsigned int i = 0; i < count; i++)
+	record_tags[i] = arr[i].tag;
+    }
+    return this->len;
+  }
+  inline bool find_index (hb_tag_t tag, unsigned int *index) const
+  {
+    int i = this->search (tag);
+    if (i != -1) {
+        if (index) *index = i;
+        return true;
+    } else {
+      if (index) *index = Index::NOT_FOUND_INDEX;
+      return false;
+    }
+  }
+};
+
+template <typename Type>
+struct RecordListOf : RecordArrayOf<Type>
+{
+  inline const Type& operator [] (unsigned int i) const
+  { return this+RecordArrayOf<Type>::operator [](i).offset; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return RecordArrayOf<Type>::sanitize (c, this);
+  }
+};
+
+
+struct RangeRecord
+{
+  inline int cmp (hb_codepoint_t g) const {
+    hb_codepoint_t a = start, b = end;
+    return g < a ? -1 : g <= b ? 0 : +1 ;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  inline bool intersects (const hb_set_t *glyphs) const {
+    return glyphs->intersects (start, end);
+  }
+
+  GlyphID	start;		/* First GlyphID in the range */
+  GlyphID	end;		/* Last GlyphID in the range */
+  USHORT	value;		/* Value */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+DEFINE_NULL_DATA (RangeRecord, "\000\001");
+
+
+struct IndexArray : ArrayOf<Index>
+{
+  inline unsigned int get_indexes (unsigned int start_offset,
+				   unsigned int *_count /* IN/OUT */,
+				   unsigned int *_indexes /* OUT */) const
+  {
+    if (_count) {
+      const USHORT *arr = this->sub_array (start_offset, _count);
+      unsigned int count = *_count;
+      for (unsigned int i = 0; i < count; i++)
+	_indexes[i] = arr[i];
+    }
+    return this->len;
+  }
+};
+
+
+struct Script;
+struct LangSys;
+struct Feature;
+
+
+struct LangSys
+{
+  inline unsigned int get_feature_count (void) const
+  { return featureIndex.len; }
+  inline hb_tag_t get_feature_index (unsigned int i) const
+  { return featureIndex[i]; }
+  inline unsigned int get_feature_indexes (unsigned int start_offset,
+					   unsigned int *feature_count /* IN/OUT */,
+					   unsigned int *feature_indexes /* OUT */) const
+  { return featureIndex.get_indexes (start_offset, feature_count, feature_indexes); }
+
+  inline bool has_required_feature (void) const { return reqFeatureIndex != 0xffff; }
+  inline unsigned int get_required_feature_index (void) const
+  {
+    if (reqFeatureIndex == 0xffff)
+      return Index::NOT_FOUND_INDEX;
+   return reqFeatureIndex;;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& featureIndex.sanitize (c);
+  }
+
+  Offset	lookupOrder;	/* = Null (reserved for an offset to a
+				 * reordering table) */
+  USHORT	reqFeatureIndex;/* Index of a feature required for this
+				 * language system--if no required features
+				 * = 0xFFFF */
+  IndexArray	featureIndex;	/* Array of indices into the FeatureList */
+  public:
+  DEFINE_SIZE_ARRAY (6, featureIndex);
+};
+DEFINE_NULL_DATA (LangSys, "\0\0\xFF\xFF");
+
+
+struct Script
+{
+  inline unsigned int get_lang_sys_count (void) const
+  { return langSys.len; }
+  inline const Tag& get_lang_sys_tag (unsigned int i) const
+  { return langSys.get_tag (i); }
+  inline unsigned int get_lang_sys_tags (unsigned int start_offset,
+					 unsigned int *lang_sys_count /* IN/OUT */,
+					 hb_tag_t     *lang_sys_tags /* OUT */) const
+  { return langSys.get_tags (start_offset, lang_sys_count, lang_sys_tags); }
+  inline const LangSys& get_lang_sys (unsigned int i) const
+  {
+    if (i == Index::NOT_FOUND_INDEX) return get_default_lang_sys ();
+    return this+langSys[i].offset;
+  }
+  inline bool find_lang_sys_index (hb_tag_t tag, unsigned int *index) const
+  { return langSys.find_index (tag, index); }
+
+  inline bool has_default_lang_sys (void) const { return defaultLangSys != 0; }
+  inline const LangSys& get_default_lang_sys (void) const { return this+defaultLangSys; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return defaultLangSys.sanitize (c, this)
+	&& langSys.sanitize (c, this);
+  }
+
+  private:
+  OffsetTo<LangSys>
+		defaultLangSys;	/* Offset to DefaultLangSys table--from
+				 * beginning of Script table--may be Null */
+  RecordArrayOf<LangSys>
+		langSys;	/* Array of LangSysRecords--listed
+				 * alphabetically by LangSysTag */
+  public:
+  DEFINE_SIZE_ARRAY (4, langSys);
+};
+
+typedef RecordListOf<Script> ScriptList;
+
+
+struct Feature
+{
+  inline unsigned int get_lookup_count (void) const
+  { return lookupIndex.len; }
+  inline hb_tag_t get_lookup_index (unsigned int i) const
+  { return lookupIndex[i]; }
+  inline unsigned int get_lookup_indexes (unsigned int start_index,
+					  unsigned int *lookup_count /* IN/OUT */,
+					  unsigned int *lookup_tags /* OUT */) const
+  { return lookupIndex.get_indexes (start_index, lookup_count, lookup_tags); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& lookupIndex.sanitize (c);
+  }
+
+  Offset	featureParams;	/* Offset to Feature Parameters table (if one
+				 * has been defined for the feature), relative
+				 * to the beginning of the Feature Table; = Null
+				 * if not required */
+  IndexArray	 lookupIndex;	/* Array of LookupList indices */
+  public:
+  DEFINE_SIZE_ARRAY (4, lookupIndex);
+};
+
+typedef RecordListOf<Feature> FeatureList;
+
+
+struct LookupFlag : USHORT
+{
+  enum Flags {
+    RightToLeft		= 0x0001u,
+    IgnoreBaseGlyphs	= 0x0002u,
+    IgnoreLigatures	= 0x0004u,
+    IgnoreMarks		= 0x0008u,
+    IgnoreFlags		= 0x000Eu,
+    UseMarkFilteringSet	= 0x0010u,
+    Reserved		= 0x00E0u,
+    MarkAttachmentType	= 0xFF00u
+  };
+  public:
+  DEFINE_SIZE_STATIC (2);
+};
+
+struct Lookup
+{
+  inline unsigned int get_subtable_count (void) const { return subTable.len; }
+
+  inline unsigned int get_type (void) const { return lookupType; }
+
+  /* lookup_props is a 32-bit integer where the lower 16-bit is LookupFlag and
+   * higher 16-bit is mark-filtering-set if the lookup uses one.
+   * Not to be confused with glyph_props which is very similar. */
+  inline uint32_t get_props (void) const
+  {
+    unsigned int flag = lookupFlag;
+    if (unlikely (flag & LookupFlag::UseMarkFilteringSet))
+    {
+      const USHORT &markFilteringSet = StructAfter<USHORT> (subTable);
+      flag += (markFilteringSet << 16);
+    }
+    return flag;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    /* Real sanitize of the subtables is done by GSUB/GPOS/... */
+    if (!(c->check_struct (this)
+       && subTable.sanitize (c))) return false;
+    if (unlikely (lookupFlag & LookupFlag::UseMarkFilteringSet))
+    {
+      USHORT &markFilteringSet = StructAfter<USHORT> (subTable);
+      if (!markFilteringSet.sanitize (c)) return false;
+    }
+    return true;
+  }
+
+  USHORT	lookupType;		/* Different enumerations for GSUB and GPOS */
+  USHORT	lookupFlag;		/* Lookup qualifiers */
+  ArrayOf<Offset>
+		subTable;		/* Array of SubTables */
+  USHORT	markFilteringSetX[VAR];	/* Index (base 0) into GDEF mark glyph sets
+					 * structure. This field is only present if bit
+					 * UseMarkFilteringSet of lookup flags is set. */
+  public:
+  DEFINE_SIZE_ARRAY2 (6, subTable, markFilteringSetX);
+};
+
+typedef OffsetListOf<Lookup> LookupList;
+
+
+/*
+ * Coverage Table
+ */
+
+struct CoverageFormat1
+{
+  friend struct Coverage;
+
+  private:
+  inline unsigned int get_coverage (hb_codepoint_t glyph_id) const
+  {
+    int i = glyphArray.search (glyph_id);
+    if (i != -1)
+        return i;
+    return NOT_COVERED;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return glyphArray.sanitize (c);
+  }
+
+  inline bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const {
+    return glyphs->has (glyphArray[index]);
+  }
+
+  struct Iter {
+    inline void init (const struct CoverageFormat1 &c_) { c = &c_; i = 0; };
+    inline bool more (void) { return i < c->glyphArray.len; }
+    inline void next (void) { i++; }
+    inline uint16_t get_glyph (void) { return c->glyphArray[i]; }
+    inline uint16_t get_coverage (void) { return i; }
+
+    private:
+    const struct CoverageFormat1 *c;
+    unsigned int i;
+  };
+
+  private:
+  USHORT	coverageFormat;	/* Format identifier--format = 1 */
+  SortedArrayOf<GlyphID>
+		glyphArray;	/* Array of GlyphIDs--in numerical order */
+  public:
+  DEFINE_SIZE_ARRAY (4, glyphArray);
+};
+
+struct CoverageFormat2
+{
+  friend struct Coverage;
+
+  private:
+  inline unsigned int get_coverage (hb_codepoint_t glyph_id) const
+  {
+    int i = rangeRecord.search (glyph_id);
+    if (i != -1) {
+      const RangeRecord &range = rangeRecord[i];
+      return (unsigned int) range.value + (glyph_id - range.start);
+    }
+    return NOT_COVERED;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return rangeRecord.sanitize (c);
+  }
+
+  inline bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const {
+    unsigned int i;
+    unsigned int count = rangeRecord.len;
+    for (i = 0; i < count; i++) {
+      const RangeRecord &range = rangeRecord[i];
+      if (range.value <= index &&
+	  index < range.value + (range.end - range.start) &&
+	  range.intersects (glyphs))
+        return true;
+      else if (index < range.value)
+        return false;
+    }
+    return false;
+  }
+
+  struct Iter {
+    inline void init (const CoverageFormat2 &c_) {
+      c = &c_;
+      coverage = 0;
+      i = 0;
+      j = c->rangeRecord.len ? c_.rangeRecord[0].start : 0;
+    }
+    inline bool more (void) { return i < c->rangeRecord.len; }
+    inline void next (void) {
+      coverage++;
+      if (j == c->rangeRecord[i].end) {
+        i++;
+	if (more ())
+	  j = c->rangeRecord[i].start;
+	return;
+      }
+      j++;
+    }
+    inline uint16_t get_glyph (void) { return j; }
+    inline uint16_t get_coverage (void) { return coverage; }
+
+    private:
+    const struct CoverageFormat2 *c;
+    unsigned int i, j, coverage;
+  };
+
+  private:
+  USHORT	coverageFormat;	/* Format identifier--format = 2 */
+  SortedArrayOf<RangeRecord>
+		rangeRecord;	/* Array of glyph ranges--ordered by
+				 * Start GlyphID. rangeCount entries
+				 * long */
+  public:
+  DEFINE_SIZE_ARRAY (4, rangeRecord);
+};
+
+struct Coverage
+{
+  inline unsigned int operator () (hb_codepoint_t glyph_id) const { return get_coverage (glyph_id); }
+
+  inline unsigned int get_coverage (hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_coverage(glyph_id);
+    case 2: return u.format2.get_coverage(glyph_id);
+    default:return NOT_COVERED;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  inline bool intersects (const hb_set_t *glyphs) const {
+    /* TODO speed this up */
+    Coverage::Iter iter;
+    for (iter.init (*this); iter.more (); iter.next ()) {
+      if (glyphs->has (iter.get_glyph ()))
+        return true;
+    }
+    return false;
+  }
+
+  inline bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const {
+    switch (u.format) {
+    case 1: return u.format1.intersects_coverage (glyphs, index);
+    case 2: return u.format2.intersects_coverage (glyphs, index);
+    default:return false;
+    }
+  }
+
+  struct Iter {
+    Iter (void) : format (0) {};
+    inline void init (const Coverage &c_) {
+      format = c_.u.format;
+      switch (format) {
+      case 1: return u.format1.init (c_.u.format1);
+      case 2: return u.format2.init (c_.u.format2);
+      default:return;
+      }
+    }
+    inline bool more (void) {
+      switch (format) {
+      case 1: return u.format1.more ();
+      case 2: return u.format2.more ();
+      default:return true;
+      }
+    }
+    inline void next (void) {
+      switch (format) {
+      case 1: u.format1.next (); break;
+      case 2: u.format2.next (); break;
+      default:                   break;
+      }
+    }
+    inline uint16_t get_glyph (void) {
+      switch (format) {
+      case 1: return u.format1.get_glyph ();
+      case 2: return u.format2.get_glyph ();
+      default:return true;
+      }
+    }
+    inline uint16_t get_coverage (void) {
+      switch (format) {
+      case 1: return u.format1.get_coverage ();
+      case 2: return u.format2.get_coverage ();
+      default:return true;
+      }
+    }
+
+    private:
+    unsigned int format;
+    union {
+    CoverageFormat1::Iter	format1;
+    CoverageFormat2::Iter	format2;
+    } u;
+  };
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  CoverageFormat1	format1;
+  CoverageFormat2	format2;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+/*
+ * Class Definition Table
+ */
+
+struct ClassDefFormat1
+{
+  friend struct ClassDef;
+
+  private:
+  inline unsigned int get_class (hb_codepoint_t glyph_id) const
+  {
+    if ((unsigned int) (glyph_id - startGlyph) < classValue.len)
+      return classValue[glyph_id - startGlyph];
+    return 0;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& classValue.sanitize (c);
+  }
+
+  inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
+    unsigned int count = classValue.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (classValue[i] == klass && glyphs->has (startGlyph + i))
+        return true;
+    return false;
+  }
+
+  USHORT	classFormat;		/* Format identifier--format = 1 */
+  GlyphID	startGlyph;		/* First GlyphID of the classValueArray */
+  ArrayOf<USHORT>
+		classValue;		/* Array of Class Values--one per GlyphID */
+  public:
+  DEFINE_SIZE_ARRAY (6, classValue);
+};
+
+struct ClassDefFormat2
+{
+  friend struct ClassDef;
+
+  private:
+  inline unsigned int get_class (hb_codepoint_t glyph_id) const
+  {
+    int i = rangeRecord.search (glyph_id);
+    if (i != -1)
+      return rangeRecord[i].value;
+    return 0;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return rangeRecord.sanitize (c);
+  }
+
+  inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
+    unsigned int count = rangeRecord.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (rangeRecord[i].value == klass && rangeRecord[i].intersects (glyphs))
+        return true;
+    return false;
+  }
+
+  USHORT	classFormat;	/* Format identifier--format = 2 */
+  SortedArrayOf<RangeRecord>
+		rangeRecord;	/* Array of glyph ranges--ordered by
+				 * Start GlyphID */
+  public:
+  DEFINE_SIZE_ARRAY (4, rangeRecord);
+};
+
+struct ClassDef
+{
+  inline unsigned int operator () (hb_codepoint_t glyph_id) const { return get_class (glyph_id); }
+
+  inline unsigned int get_class (hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_class(glyph_id);
+    case 2: return u.format2.get_class(glyph_id);
+    default:return 0;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  inline bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const {
+    switch (u.format) {
+    case 1: return u.format1.intersects_class (glyphs, klass);
+    case 2: return u.format2.intersects_class (glyphs, klass);
+    default:return false;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  ClassDefFormat1	format1;
+  ClassDefFormat2	format2;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+/*
+ * Device Tables
+ */
+
+struct Device
+{
+
+  inline hb_position_t get_x_delta (hb_font_t *font) const
+  { return get_delta (font->x_ppem, font->x_scale); }
+
+  inline hb_position_t get_y_delta (hb_font_t *font) const
+  { return get_delta (font->y_ppem, font->y_scale); }
+
+  inline int get_delta (unsigned int ppem, int scale) const
+  {
+    if (!ppem) return 0;
+
+    int pixels = get_delta_pixels (ppem);
+
+    if (!pixels) return 0;
+
+    return pixels * (int64_t) scale / ppem;
+  }
+
+
+  inline int get_delta_pixels (unsigned int ppem_size) const
+  {
+    unsigned int f = deltaFormat;
+    if (unlikely (f < 1 || f > 3))
+      return 0;
+
+    if (ppem_size < startSize || ppem_size > endSize)
+      return 0;
+
+    unsigned int s = ppem_size - startSize;
+
+    unsigned int byte = deltaValue[s >> (4 - f)];
+    unsigned int bits = (byte >> (16 - (((s & ((1 << (4 - f)) - 1)) + 1) << f)));
+    unsigned int mask = (0xFFFF >> (16 - (1 << f)));
+
+    int delta = bits & mask;
+
+    if ((unsigned int) delta >= ((mask + 1) >> 1))
+      delta -= mask + 1;
+
+    return delta;
+  }
+
+  inline unsigned int get_size (void) const
+  {
+    unsigned int f = deltaFormat;
+    if (unlikely (f < 1 || f > 3 || startSize > endSize)) return 3 * USHORT::static_size;
+    return USHORT::static_size * (4 + ((endSize - startSize) >> (4 - f)));
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& c->check_range (this, this->get_size ());
+  }
+
+  private:
+  USHORT	startSize;		/* Smallest size to correct--in ppem */
+  USHORT	endSize;		/* Largest size to correct--in ppem */
+  USHORT	deltaFormat;		/* Format of DeltaValue array data: 1, 2, or 3
+					 * 1	Signed 2-bit value, 8 values per uint16
+					 * 2	Signed 4-bit value, 4 values per uint16
+					 * 3	Signed 8-bit value, 2 values per uint16
+					 */
+  USHORT	deltaValue[VAR];	/* Array of compressed data */
+  public:
+  DEFINE_SIZE_ARRAY (6, deltaValue);
+};
+
+
+
+#endif /* HB_OT_LAYOUT_COMMON_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-private.hh	2012-05-05 23:46:51.527763796 +0530
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GDEF_PRIVATE_HH
+#define HB_OT_LAYOUT_GDEF_PRIVATE_HH
+
+#include "hb-ot-layout-common-private.hh"
+
+#include "hb-font-private.h"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * Attachment List Table
+ */
+
+typedef ArrayOf<USHORT> AttachPoint;	/* Array of contour point indices--in
+					 * increasing numerical order */
+
+struct AttachList
+{
+  inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
+					 unsigned int start_offset,
+					 unsigned int *point_count /* IN/OUT */,
+					 unsigned int *point_array /* OUT */) const
+  {
+    unsigned int index = (this+coverage) (glyph_id);
+    if (index == NOT_COVERED)
+    {
+      if (point_count)
+	*point_count = 0;
+      return 0;
+    }
+
+    const AttachPoint &points = this+attachPoint[index];
+
+    if (point_count) {
+      const USHORT *array = points.sub_array (start_offset, point_count);
+      unsigned int count = *point_count;
+      for (unsigned int i = 0; i < count; i++)
+	point_array[i] = array[i];
+    }
+
+    return points.len;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& attachPoint.sanitize (c, this);
+  }
+
+  private:
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table -- from
+					 * beginning of AttachList table */
+  OffsetArrayOf<AttachPoint>
+		attachPoint;		/* Array of AttachPoint tables
+					 * in Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (4, attachPoint);
+};
+
+/*
+ * Ligature Caret Table
+ */
+
+struct CaretValueFormat1
+{
+  friend struct CaretValue;
+
+  private:
+  inline int get_caret_value (hb_ot_layout_context_t *c, hb_codepoint_t glyph_id HB_UNUSED) const
+  {
+    /* TODO vertical */
+    return c->scale_x (coordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 1 */
+  SHORT		coordinate;		/* X or Y value, in design units */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CaretValueFormat2
+{
+  friend struct CaretValue;
+
+  private:
+  inline int get_caret_value (hb_ot_layout_context_t *c, hb_codepoint_t glyph_id) const
+  {
+    /* TODO vertical */
+    hb_position_t x, y;
+    if (hb_font_get_contour_point (c->font, c->face, caretValuePoint, glyph_id, &x, &y))
+      return x;
+    else
+      return 0;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 2 */
+  USHORT	caretValuePoint;	/* Contour point index on glyph */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CaretValueFormat3
+{
+  friend struct CaretValue;
+
+  inline int get_caret_value (hb_ot_layout_context_t *c, hb_codepoint_t glyph_id HB_UNUSED) const
+  {
+    /* TODO vertical */
+    return c->scale_x (coordinate) + ((this+deviceTable).get_x_delta (c));
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& deviceTable.sanitize (c, this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 3 */
+  SHORT		coordinate;		/* X or Y value, in design units */
+  OffsetTo<Device>
+		deviceTable;		/* Offset to Device table for X or Y
+					 * value--from beginning of CaretValue
+					 * table */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct CaretValue
+{
+  inline int get_caret_value (hb_ot_layout_context_t *c, hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_caret_value (c, glyph_id);
+    case 2: return u.format2.get_caret_value (c, glyph_id);
+    case 3: return u.format3.get_caret_value (c, glyph_id);
+    default:return 0;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  CaretValueFormat1	format1;
+  CaretValueFormat2	format2;
+  CaretValueFormat3	format3;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+struct LigGlyph
+{
+  inline unsigned int get_lig_carets (hb_ot_layout_context_t *c,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      int *caret_array /* OUT */) const
+  {
+    if (caret_count) {
+      const OffsetTo<CaretValue> *array = carets.sub_array (start_offset, caret_count);
+      unsigned int count = *caret_count;
+      for (unsigned int i = 0; i < count; i++)
+	caret_array[i] = (this+array[i]).get_caret_value (c, glyph_id);
+    }
+
+    return carets.len;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return carets.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<CaretValue>
+		carets;			/* Offset array of CaretValue tables
+					 * --from beginning of LigGlyph table
+					 * --in increasing coordinate order */
+  public:
+  DEFINE_SIZE_ARRAY (2, carets);
+};
+
+struct LigCaretList
+{
+  inline unsigned int get_lig_carets (hb_ot_layout_context_t *c,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      int *caret_array /* OUT */) const
+  {
+    unsigned int index = (this+coverage) (glyph_id);
+    if (index == NOT_COVERED)
+    {
+      if (caret_count)
+	*caret_count = 0;
+      return 0;
+    }
+    const LigGlyph &lig_glyph = this+ligGlyph[index];
+    return lig_glyph.get_lig_carets (c, glyph_id, start_offset, caret_count, caret_array);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ligGlyph.sanitize (c, this);
+  }
+
+  private:
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of LigCaretList table */
+  OffsetArrayOf<LigGlyph>
+		ligGlyph;		/* Array of LigGlyph tables
+					 * in Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (4, ligGlyph);
+};
+
+
+struct MarkGlyphSetsFormat1
+{
+  inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  LongOffsetArrayOf<Coverage>
+		coverage;		/* Array of long offsets to mark set
+					 * coverage tables */
+  public:
+  DEFINE_SIZE_ARRAY (4, coverage);
+};
+
+struct MarkGlyphSets
+{
+  inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.covers (set_index, glyph_id);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkGlyphSetsFormat1	format1;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+/*
+ * GDEF
+ */
+
+struct GDEF
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GDEF;
+
+  enum {
+    UnclassifiedGlyph	= 0,
+    BaseGlyph		= 1,
+    LigatureGlyph	= 2,
+    MarkGlyph		= 3,
+    ComponentGlyph	= 4
+  };
+
+  inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }
+  inline hb_ot_layout_class_t get_glyph_class (hb_codepoint_t glyph) const
+  { return (this+glyphClassDef).get_class (glyph); }
+
+  inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }
+  inline hb_ot_layout_class_t get_mark_attachment_type (hb_codepoint_t glyph) const
+  { return (this+markAttachClassDef).get_class (glyph); }
+
+  inline bool has_attach_points (void) const { return attachList != 0; }
+  inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
+					 unsigned int start_offset,
+					 unsigned int *point_count /* IN/OUT */,
+					 unsigned int *point_array /* OUT */) const
+  { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
+
+  inline bool has_lig_carets (void) const { return ligCaretList != 0; }
+  inline unsigned int get_lig_carets (hb_ot_layout_context_t *c,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      int *caret_array /* OUT */) const
+  { return (this+ligCaretList).get_lig_carets (c, glyph_id, start_offset, caret_count, caret_array); }
+
+  inline bool has_mark_sets (void) const { return version >= 0x00010002 && markGlyphSetsDef[0] != 0; }
+  inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  { return version >= 0x00010002 && (this+markGlyphSetsDef[0]).covers (set_index, glyph_id); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return version.sanitize (c) && likely (version.major == 1)
+	&& glyphClassDef.sanitize (c, this)
+	&& attachList.sanitize (c, this)
+	&& ligCaretList.sanitize (c, this)
+	&& markAttachClassDef.sanitize (c, this)
+	&& (version < 0x00010002 || markGlyphSetsDef[0].sanitize (c, this));
+  }
+
+  private:
+  FixedVersion	version;		/* Version of the GDEF table--currently
+					 * 0x00010002 */
+  OffsetTo<ClassDef>
+		glyphClassDef;		/* Offset to class definition table
+					 * for glyph type--from beginning of
+					 * GDEF header (may be Null) */
+  OffsetTo<AttachList>
+		attachList;		/* Offset to list of glyphs with
+					 * attachment points--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<LigCaretList>
+		ligCaretList;		/* Offset to list of positioning points
+					 * for ligature carets--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<ClassDef>
+		markAttachClassDef;	/* Offset to class definition table for
+					 * mark attachment type--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<MarkGlyphSets>
+		markGlyphSetsDef[VAR];	/* Offset to the table of mark set
+					 * definitions--from beginning of GDEF
+					 * header (may be NULL).  Introduced
+					 * in version 00010002. */
+  public:
+  DEFINE_SIZE_ARRAY (12, markGlyphSetsDef);
+};
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_LAYOUT_GDEF_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gdef-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,427 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
+#define HB_OT_LAYOUT_GDEF_TABLE_HH
+
+#include "hb-ot-layout-common-private.hh"
+
+#include "hb-font-private.hh"
+
+
+
+/*
+ * Attachment List Table
+ */
+
+typedef ArrayOf<USHORT> AttachPoint;	/* Array of contour point indices--in
+					 * increasing numerical order */
+
+struct AttachList
+{
+  inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
+					 unsigned int start_offset,
+					 unsigned int *point_count /* IN/OUT */,
+					 unsigned int *point_array /* OUT */) const
+  {
+    unsigned int index = (this+coverage) (glyph_id);
+    if (index == NOT_COVERED)
+    {
+      if (point_count)
+	*point_count = 0;
+      return 0;
+    }
+
+    const AttachPoint &points = this+attachPoint[index];
+
+    if (point_count) {
+      const USHORT *array = points.sub_array (start_offset, point_count);
+      unsigned int count = *point_count;
+      for (unsigned int i = 0; i < count; i++)
+	point_array[i] = array[i];
+    }
+
+    return points.len;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& attachPoint.sanitize (c, this);
+  }
+
+  private:
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table -- from
+					 * beginning of AttachList table */
+  OffsetArrayOf<AttachPoint>
+		attachPoint;		/* Array of AttachPoint tables
+					 * in Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (4, attachPoint);
+};
+
+/*
+ * Ligature Caret Table
+ */
+
+struct CaretValueFormat1
+{
+  friend struct CaretValue;
+
+  private:
+  inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id HB_UNUSED) const
+  {
+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_x (coordinate) : font->em_scale_y (coordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 1 */
+  SHORT		coordinate;		/* X or Y value, in design units */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CaretValueFormat2
+{
+  friend struct CaretValue;
+
+  private:
+  inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const
+  {
+    hb_position_t x, y;
+    if (hb_font_get_glyph_contour_point_for_origin (font, glyph_id, caretValuePoint, direction, &x, &y))
+      return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;
+    else
+      return 0;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 2 */
+  USHORT	caretValuePoint;	/* Contour point index on glyph */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CaretValueFormat3
+{
+  friend struct CaretValue;
+
+  inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id HB_UNUSED) const
+  {
+    return HB_DIRECTION_IS_HORIZONTAL (direction) ?
+           font->em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font) :
+           font->em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& deviceTable.sanitize (c, this);
+  }
+
+  private:
+  USHORT	caretValueFormat;	/* Format identifier--format = 3 */
+  SHORT		coordinate;		/* X or Y value, in design units */
+  OffsetTo<Device>
+		deviceTable;		/* Offset to Device table for X or Y
+					 * value--from beginning of CaretValue
+					 * table */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct CaretValue
+{
+  inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_caret_value (font, direction, glyph_id);
+    case 2: return u.format2.get_caret_value (font, direction, glyph_id);
+    case 3: return u.format3.get_caret_value (font, direction, glyph_id);
+    default:return 0;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  CaretValueFormat1	format1;
+  CaretValueFormat2	format2;
+  CaretValueFormat3	format3;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+struct LigGlyph
+{
+  inline unsigned int get_lig_carets (hb_font_t *font,
+				      hb_direction_t direction,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      hb_position_t *caret_array /* OUT */) const
+  {
+    if (caret_count) {
+      const OffsetTo<CaretValue> *array = carets.sub_array (start_offset, caret_count);
+      unsigned int count = *caret_count;
+      for (unsigned int i = 0; i < count; i++)
+	caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id);
+    }
+
+    return carets.len;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return carets.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<CaretValue>
+		carets;			/* Offset array of CaretValue tables
+					 * --from beginning of LigGlyph table
+					 * --in increasing coordinate order */
+  public:
+  DEFINE_SIZE_ARRAY (2, carets);
+};
+
+struct LigCaretList
+{
+  inline unsigned int get_lig_carets (hb_font_t *font,
+				      hb_direction_t direction,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      hb_position_t *caret_array /* OUT */) const
+  {
+    unsigned int index = (this+coverage) (glyph_id);
+    if (index == NOT_COVERED)
+    {
+      if (caret_count)
+	*caret_count = 0;
+      return 0;
+    }
+    const LigGlyph &lig_glyph = this+ligGlyph[index];
+    return lig_glyph.get_lig_carets (font, direction, glyph_id, start_offset, caret_count, caret_array);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ligGlyph.sanitize (c, this);
+  }
+
+  private:
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of LigCaretList table */
+  OffsetArrayOf<LigGlyph>
+		ligGlyph;		/* Array of LigGlyph tables
+					 * in Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (4, ligGlyph);
+};
+
+
+struct MarkGlyphSetsFormat1
+{
+  inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  LongOffsetArrayOf<Coverage>
+		coverage;		/* Array of long offsets to mark set
+					 * coverage tables */
+  public:
+  DEFINE_SIZE_ARRAY (4, coverage);
+};
+
+struct MarkGlyphSets
+{
+  inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.covers (set_index, glyph_id);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkGlyphSetsFormat1	format1;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+/*
+ * GDEF -- The Glyph Definition Table
+ */
+
+struct GDEF
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GDEF;
+
+  enum GlyphClasses {
+    UnclassifiedGlyph	= 0,
+    BaseGlyph		= 1,
+    LigatureGlyph	= 2,
+    MarkGlyph		= 3,
+    ComponentGlyph	= 4
+  };
+
+  inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }
+  inline unsigned int get_glyph_class (hb_codepoint_t glyph) const
+  { return (this+glyphClassDef).get_class (glyph); }
+
+  inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }
+  inline unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const
+  { return (this+markAttachClassDef).get_class (glyph); }
+
+  inline bool has_attach_points (void) const { return attachList != 0; }
+  inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
+					 unsigned int start_offset,
+					 unsigned int *point_count /* IN/OUT */,
+					 unsigned int *point_array /* OUT */) const
+  { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
+
+  inline bool has_lig_carets (void) const { return ligCaretList != 0; }
+  inline unsigned int get_lig_carets (hb_font_t *font,
+				      hb_direction_t direction,
+				      hb_codepoint_t glyph_id,
+				      unsigned int start_offset,
+				      unsigned int *caret_count /* IN/OUT */,
+				      hb_position_t *caret_array /* OUT */) const
+  { return (this+ligCaretList).get_lig_carets (font, direction, glyph_id, start_offset, caret_count, caret_array); }
+
+  inline bool has_mark_sets (void) const { return version.to_int () >= 0x00010002 && markGlyphSetsDef[0] != 0; }
+  inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const
+  { return version.to_int () >= 0x00010002 && (this+markGlyphSetsDef[0]).covers (set_index, glyph_id); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return version.sanitize (c) && likely (version.major == 1)
+	&& glyphClassDef.sanitize (c, this)
+	&& attachList.sanitize (c, this)
+	&& ligCaretList.sanitize (c, this)
+	&& markAttachClassDef.sanitize (c, this)
+	&& (version.to_int () < 0x00010002 || markGlyphSetsDef[0].sanitize (c, this));
+  }
+
+
+  /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
+   * glyph class and other bits, and high 8-bit gthe mark attachment type (if any).
+   * Not to be confused with lookup_props which is very similar. */
+  inline unsigned int get_glyph_props (hb_codepoint_t glyph) const
+  {
+    unsigned int klass = get_glyph_class (glyph);
+
+    switch (klass) {
+    default:
+    case UnclassifiedGlyph:	return HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED;
+    case BaseGlyph:		return HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH;
+    case LigatureGlyph:		return HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE;
+    case ComponentGlyph:	return HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT;
+    case MarkGlyph:
+	  klass = get_mark_attachment_type (glyph);
+	  return HB_OT_LAYOUT_GLYPH_CLASS_MARK | (klass << 8);
+    }
+  }
+
+
+  private:
+  FixedVersion	version;		/* Version of the GDEF table--currently
+					 * 0x00010002 */
+  OffsetTo<ClassDef>
+		glyphClassDef;		/* Offset to class definition table
+					 * for glyph type--from beginning of
+					 * GDEF header (may be Null) */
+  OffsetTo<AttachList>
+		attachList;		/* Offset to list of glyphs with
+					 * attachment points--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<LigCaretList>
+		ligCaretList;		/* Offset to list of positioning points
+					 * for ligature carets--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<ClassDef>
+		markAttachClassDef;	/* Offset to class definition table for
+					 * mark attachment type--from beginning
+					 * of GDEF header (may be Null) */
+  OffsetTo<MarkGlyphSets>
+		markGlyphSetsDef[VAR];	/* Offset to the table of mark set
+					 * definitions--from beginning of GDEF
+					 * header (may be NULL).  Introduced
+					 * in version 00010002. */
+  public:
+  DEFINE_SIZE_ARRAY (12, markGlyphSetsDef);
+};
+
+
+
+#endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-private.hh	2012-05-05 23:46:51.528763796 +0530
@@ -0,0 +1,1634 @@
+/*
+ * Copyright (C) 2007,2008,2009,2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GPOS_PRIVATE_HH
+#define HB_OT_LAYOUT_GPOS_PRIVATE_HH
+
+#include "hb-ot-layout-gsubgpos-private.hh"
+
+HB_BEGIN_DECLS
+
+
+#define HB_OT_LAYOUT_GPOS_NO_LAST ((unsigned int) -1)
+
+/* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
+
+typedef USHORT Value;
+
+typedef Value ValueRecord[VAR];
+
+struct ValueFormat : USHORT
+{
+  enum
+  {
+    xPlacement	= 0x0001,	/* Includes horizontal adjustment for placement */
+    yPlacement	= 0x0002,	/* Includes vertical adjustment for placement */
+    xAdvance	= 0x0004,	/* Includes horizontal adjustment for advance */
+    yAdvance	= 0x0008,	/* Includes vertical adjustment for advance */
+    xPlaDevice	= 0x0010,	/* Includes horizontal Device table for placement */
+    yPlaDevice	= 0x0020,	/* Includes vertical Device table for placement */
+    xAdvDevice	= 0x0040,	/* Includes horizontal Device table for advance */
+    yAdvDevice	= 0x0080,	/* Includes vertical Device table for advance */
+    ignored	= 0x0F00,	/* Was used in TrueType Open for MM fonts */
+    reserved	= 0xF000,	/* For future use */
+
+    devices	= 0x00F0	/* Mask for having any Device table */
+  };
+
+/* All fields are options.  Only those available advance the value pointer. */
+#if 0
+  SHORT		xPlacement;		/* Horizontal adjustment for
+					 * placement--in design units */
+  SHORT		yPlacement;		/* Vertical adjustment for
+					 * placement--in design units */
+  SHORT		xAdvance;		/* Horizontal adjustment for
+					 * advance--in design units (only used
+					 * for horizontal writing) */
+  SHORT		yAdvance;		/* Vertical adjustment for advance--in
+					 * design units (only used for vertical
+					 * writing) */
+  Offset	xPlaDevice;		/* Offset to Device table for
+					 * horizontal placement--measured from
+					 * beginning of PosTable (may be NULL) */
+  Offset	yPlaDevice;		/* Offset to Device table for vertical
+					 * placement--measured from beginning
+					 * of PosTable (may be NULL) */
+  Offset	xAdvDevice;		/* Offset to Device table for
+					 * horizontal advance--measured from
+					 * beginning of PosTable (may be NULL) */
+  Offset	yAdvDevice;		/* Offset to Device table for vertical
+					 * advance--measured from beginning of
+					 * PosTable (may be NULL) */
+#endif
+
+  inline unsigned int get_len (void) const
+  { return _hb_popcount32 ((unsigned int) *this); }
+  inline unsigned int get_size (void) const
+  { return get_len () * Value::static_size; }
+
+  void apply_value (hb_ot_layout_context_t       *layout,
+		    const void                   *base,
+		    const Value                  *values,
+		    hb_internal_glyph_position_t &glyph_pos) const
+  {
+    unsigned int x_ppem, y_ppem;
+    unsigned int format = *this;
+
+    if (!format) return;
+
+    /* design units -> fractional pixel */
+    if (format & xPlacement) glyph_pos.x_offset  += layout->scale_x (get_short (values++));
+    if (format & yPlacement) glyph_pos.y_offset  += layout->scale_y (get_short (values++));
+    if (format & xAdvance)   glyph_pos.x_advance += layout->scale_x (get_short (values++));
+    if (format & yAdvance)   glyph_pos.y_advance += layout->scale_y (get_short (values++));
+
+    if (!has_device ()) return;
+
+    x_ppem = layout->font->x_ppem;
+    y_ppem = layout->font->y_ppem;
+
+    if (!x_ppem && !y_ppem) return;
+
+    /* pixel -> fractional pixel */
+    if (format & xPlaDevice) {
+      if (x_ppem) glyph_pos.x_offset  += (base + get_device (values++)).get_x_delta (layout); else values++;
+    }
+    if (format & yPlaDevice) {
+      if (y_ppem) glyph_pos.y_offset  += (base + get_device (values++)).get_y_delta (layout); else values++;
+    }
+    if (format & xAdvDevice) {
+      if (x_ppem) glyph_pos.x_advance += (base + get_device (values++)).get_x_delta (layout); else values++;
+    }
+    if (format & yAdvDevice) {
+      if (y_ppem) glyph_pos.y_advance += (base + get_device (values++)).get_y_delta (layout); else values++;
+    }
+  }
+
+  private:
+  inline bool sanitize_value_devices (hb_sanitize_context_t *c, void *base, Value *values) {
+    unsigned int format = *this;
+
+    if (format & xPlacement) values++;
+    if (format & yPlacement) values++;
+    if (format & xAdvance)   values++;
+    if (format & yAdvance)   values++;
+
+    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
+
+    return true;
+  }
+
+  static inline OffsetTo<Device>& get_device (Value* value)
+  { return *CastP<OffsetTo<Device> > (value); }
+  static inline const OffsetTo<Device>& get_device (const Value* value)
+  { return *CastP<OffsetTo<Device> > (value); }
+
+  static inline const SHORT& get_short (const Value* value)
+  { return *CastP<SHORT> (value); }
+
+  public:
+
+  inline bool has_device (void) const {
+    unsigned int format = *this;
+    return (format & devices) != 0;
+  }
+
+  inline bool sanitize_value (hb_sanitize_context_t *c, void *base, Value *values) {
+    TRACE_SANITIZE ();
+    return c->check_range (values, get_size ())
+	&& (!has_device () || sanitize_value_devices (c, base, values));
+  }
+
+  inline bool sanitize_values (hb_sanitize_context_t *c, void *base, Value *values, unsigned int count) {
+    TRACE_SANITIZE ();
+    unsigned int len = get_len ();
+
+    if (!c->check_array (values, get_size (), count)) return false;
+
+    if (!has_device ()) return true;
+
+    for (unsigned int i = 0; i < count; i++) {
+      if (!sanitize_value_devices (c, base, values))
+        return false;
+      values += len;
+    }
+
+    return true;
+  }
+
+  /* Just sanitize referenced Device tables.  Doesn't check the values themselves. */
+  inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, void *base, Value *values, unsigned int count, unsigned int stride) {
+    TRACE_SANITIZE ();
+
+    if (!has_device ()) return true;
+
+    for (unsigned int i = 0; i < count; i++) {
+      if (!sanitize_value_devices (c, base, values))
+        return false;
+      values += stride;
+    }
+
+    return true;
+  }
+};
+
+
+struct AnchorFormat1
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_ot_layout_context_t *layout, hb_codepoint_t glyph_id HB_UNUSED,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      *x = layout->scale_x (xCoordinate);
+      *y = layout->scale_y (yCoordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct AnchorFormat2
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_ot_layout_context_t *layout, hb_codepoint_t glyph_id,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      unsigned int x_ppem = layout->font->x_ppem;
+      unsigned int y_ppem = layout->font->y_ppem;
+      hb_position_t cx, cy;
+      hb_bool_t ret;
+
+      if (x_ppem || y_ppem)
+	ret = hb_font_get_contour_point (layout->font, layout->face, anchorPoint, glyph_id, &cx, &cy);
+      *x = x_ppem && ret ? cx : layout->scale_x (xCoordinate);
+      *y = y_ppem && ret ? cy : layout->scale_y (yCoordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  USHORT	anchorPoint;		/* Index to glyph contour point */
+  public:
+  DEFINE_SIZE_STATIC (8);
+};
+
+struct AnchorFormat3
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_ot_layout_context_t *layout, hb_codepoint_t glyph_id HB_UNUSED,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      *x = layout->scale_x (xCoordinate);
+      *y = layout->scale_y (yCoordinate);
+
+      /* pixel -> fractional pixel */
+      if (layout->font->x_ppem)
+	*x += (this+xDeviceTable).get_x_delta (layout);
+      if (layout->font->y_ppem)
+	*y += (this+yDeviceTable).get_x_delta (layout);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& xDeviceTable.sanitize (c, this)
+	&& yDeviceTable.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 3 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  OffsetTo<Device>
+		xDeviceTable;		/* Offset to Device table for X
+					 * coordinate-- from beginning of
+					 * Anchor table (may be NULL) */
+  OffsetTo<Device>
+		yDeviceTable;		/* Offset to Device table for Y
+					 * coordinate-- from beginning of
+					 * Anchor table (may be NULL) */
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+struct Anchor
+{
+  inline void get_anchor (hb_ot_layout_context_t *layout, hb_codepoint_t glyph_id,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+    *x = *y = 0;
+    switch (u.format) {
+    case 1: u.format1.get_anchor (layout, glyph_id, x, y); return;
+    case 2: u.format2.get_anchor (layout, glyph_id, x, y); return;
+    case 3: u.format3.get_anchor (layout, glyph_id, x, y); return;
+    default:						    return;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  AnchorFormat1		format1;
+  AnchorFormat2		format2;
+  AnchorFormat3		format3;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+struct AnchorMatrix
+{
+  inline const Anchor& get_anchor (unsigned int row, unsigned int col, unsigned int cols) const {
+    if (unlikely (row >= rows || col >= cols)) return Null(Anchor);
+    return this+matrix[row * cols + col];
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) {
+    TRACE_SANITIZE ();
+    if (!c->check_struct (this)) return false;
+    if (unlikely (rows > 0 && cols >= ((unsigned int) -1) / rows)) return false;
+    unsigned int count = rows * cols;
+    if (!c->check_array (matrix, matrix[0].static_size, count)) return false;
+    for (unsigned int i = 0; i < count; i++)
+      if (!matrix[i].sanitize (c, this)) return false;
+    return true;
+  }
+
+  USHORT	rows;			/* Number of rows */
+  private:
+  OffsetTo<Anchor>
+		matrix[VAR];		/* Matrix of offsets to Anchor tables--
+					 * from beginning of AnchorMatrix table */
+  public:
+  DEFINE_SIZE_ARRAY (2, matrix);
+};
+
+
+struct MarkRecord
+{
+  friend struct MarkArray;
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& markAnchor.sanitize (c, base);
+  }
+
+  private:
+  USHORT	klass;			/* Class defined for this mark */
+  OffsetTo<Anchor>
+		markAnchor;		/* Offset to Anchor table--from
+					 * beginning of MarkArray table */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct MarkArray : ArrayOf<MarkRecord>	/* Array of MarkRecords--in Coverage order */
+{
+  inline bool apply (hb_apply_context_t *c,
+		     unsigned int mark_index, unsigned int glyph_index,
+		     const AnchorMatrix &anchors, unsigned int class_count,
+		     unsigned int glyph_pos) const
+  {
+    TRACE_APPLY ();
+    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);
+    unsigned int mark_class = record.klass;
+
+    const Anchor& mark_anchor = this + record.markAnchor;
+    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count);
+
+    hb_position_t mark_x, mark_y, base_x, base_y;
+
+    mark_anchor.get_anchor (c->layout, c->buffer->info[c->buffer->i].codepoint, &mark_x, &mark_y);
+    glyph_anchor.get_anchor (c->layout, c->buffer->info[glyph_pos].codepoint, &base_x, &base_y);
+
+    hb_internal_glyph_position_t &o = c->buffer->pos[c->buffer->i];
+    o.x_offset  = base_x - mark_x;
+    o.y_offset  = base_y - mark_y;
+    o.back      = c->buffer->i - glyph_pos;
+
+    c->buffer->i++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ArrayOf<MarkRecord>::sanitize (c, this);
+  }
+};
+
+
+/* Lookups */
+
+struct SinglePosFormat1
+{
+  friend struct SinglePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    valueFormat.apply_value (c->layout, this, values, c->buffer->pos[c->buffer->i]);
+
+    c->buffer->i++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& valueFormat.sanitize_value (c, this, values);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat;		/* Defines the types of data in the
+					 * ValueRecord */
+  ValueRecord	values;			/* Defines positioning
+					 * value(s)--applied to all glyphs in
+					 * the Coverage table */
+  public:
+  DEFINE_SIZE_ARRAY (6, values);
+};
+
+struct SinglePosFormat2
+{
+  friend struct SinglePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (likely (index >= valueCount))
+      return false;
+
+    valueFormat.apply_value (c->layout, this,
+			     &values[index * valueFormat.get_len ()],
+			     c->buffer->pos[c->buffer->i]);
+
+    c->buffer->i++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& valueFormat.sanitize_values (c, this, values, valueCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat;		/* Defines the types of data in the
+					 * ValueRecord */
+  USHORT	valueCount;		/* Number of ValueRecords */
+  ValueRecord	values;			/* Array of ValueRecords--positioning
+					 * values applied to glyphs */
+  public:
+  DEFINE_SIZE_ARRAY (8, values);
+};
+
+struct SinglePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  SinglePosFormat1	format1;
+  SinglePosFormat2	format2;
+  } u;
+};
+
+
+struct PairValueRecord
+{
+  friend struct PairSet;
+
+  private:
+  GlyphID	secondGlyph;		/* GlyphID of second glyph in the
+					 * pair--first glyph is listed in the
+					 * Coverage table */
+  ValueRecord	values;			/* Positioning data for the first glyph
+					 * followed by for second glyph */
+  public:
+  DEFINE_SIZE_ARRAY (2, values);
+};
+
+struct PairSet
+{
+  friend struct PairPosFormat1;
+
+  inline bool apply (hb_apply_context_t *c,
+		     const ValueFormat *valueFormats,
+		     unsigned int pos) const
+  {
+    TRACE_APPLY ();
+    unsigned int len1 = valueFormats[0].get_len ();
+    unsigned int len2 = valueFormats[1].get_len ();
+    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);
+
+    unsigned int count = len;
+    const PairValueRecord *record = CastP<PairValueRecord> (array);
+    for (unsigned int i = 0; i < count; i++)
+    {
+      if (c->buffer->info[pos].codepoint == record->secondGlyph)
+      {
+	valueFormats[0].apply_value (c->layout, this, &record->values[0], c->buffer->pos[c->buffer->i]);
+	valueFormats[1].apply_value (c->layout, this, &record->values[len1], c->buffer->pos[pos]);
+	if (len2)
+	  pos++;
+	c->buffer->i = pos;
+	return true;
+      }
+      record = &StructAtOffset<PairValueRecord> (record, record_size);
+    }
+
+    return false;
+  }
+
+  struct sanitize_closure_t {
+    void *base;
+    ValueFormat *valueFormats;
+    unsigned int len1; /* valueFormats[0].get_len() */
+    unsigned int stride; /* 1 + len1 + len2 */
+  };
+
+  inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) {
+    TRACE_SANITIZE ();
+    if (!(c->check_struct (this)
+       && c->check_array (array, USHORT::static_size * closure->stride, len))) return false;
+
+    unsigned int count = len;
+    PairValueRecord *record = CastP<PairValueRecord> (array);
+    return closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride)
+	&& closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride);
+  }
+
+  private:
+  USHORT	len;			/* Number of PairValueRecords */
+  USHORT	array[VAR];		/* Array of PairValueRecords--ordered
+					 * by GlyphID of the second glyph */
+  public:
+  DEFINE_SIZE_ARRAY (2, array);
+};
+
+struct PairPosFormat1
+{
+  friend struct PairPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int end = MIN (c->buffer->len, c->buffer->i + c->context_length);
+    if (unlikely (c->buffer->i + 2 > end))
+      return false;
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    unsigned int j = c->buffer->i + 1;
+    while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], c->lookup_flag, NULL))
+    {
+      if (unlikely (j == end))
+	return false;
+      j++;
+    }
+
+    return (this+pairSet[index]).apply (c, &valueFormat1, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    PairSet::sanitize_closure_t closure = {
+      this,
+      &valueFormat1,
+      len1,
+      1 + len1 + len2
+    };
+
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& pairSet.sanitize (c, this, &closure);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat1;		/* Defines the types of data in
+					 * ValueRecord1--for the first glyph
+					 * in the pair--may be zero (0) */
+  ValueFormat	valueFormat2;		/* Defines the types of data in
+					 * ValueRecord2--for the second glyph
+					 * in the pair--may be zero (0) */
+  OffsetArrayOf<PairSet>
+		pairSet;		/* Array of PairSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (10, pairSet);
+};
+
+struct PairPosFormat2
+{
+  friend struct PairPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int end = MIN (c->buffer->len, c->buffer->i + c->context_length);
+    if (unlikely (c->buffer->i + 2 > end))
+      return false;
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    unsigned int j = c->buffer->i + 1;
+    while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], c->lookup_flag, NULL))
+    {
+      if (unlikely (j == end))
+	return false;
+      j++;
+    }
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    unsigned int record_len = len1 + len2;
+
+    unsigned int klass1 = (this+classDef1) (c->buffer->info[c->buffer->i].codepoint);
+    unsigned int klass2 = (this+classDef2) (c->buffer->info[j].codepoint);
+    if (unlikely (klass1 >= class1Count || klass2 >= class2Count))
+      return false;
+
+    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];
+    valueFormat1.apply_value (c->layout, this, v, c->buffer->pos[c->buffer->i]);
+    valueFormat2.apply_value (c->layout, this, v + len1, c->buffer->pos[j]);
+
+    if (len2)
+      j++;
+    c->buffer->i = j;
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!(c->check_struct (this)
+       && coverage.sanitize (c, this)
+       && classDef1.sanitize (c, this)
+       && classDef2.sanitize (c, this))) return false;
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    unsigned int stride = len1 + len2;
+    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
+    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
+    return c->check_array (values, record_size, count) &&
+	   valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&
+	   valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat1;		/* ValueRecord definition--for the
+					 * first glyph of the pair--may be zero
+					 * (0) */
+  ValueFormat	valueFormat2;		/* ValueRecord definition--for the
+					 * second glyph of the pair--may be
+					 * zero (0) */
+  OffsetTo<ClassDef>
+		classDef1;		/* Offset to ClassDef table--from
+					 * beginning of PairPos subtable--for
+					 * the first glyph of the pair */
+  OffsetTo<ClassDef>
+		classDef2;		/* Offset to ClassDef table--from
+					 * beginning of PairPos subtable--for
+					 * the second glyph of the pair */
+  USHORT	class1Count;		/* Number of classes in ClassDef1
+					 * table--includes Class0 */
+  USHORT	class2Count;		/* Number of classes in ClassDef2
+					 * table--includes Class0 */
+  ValueRecord	values;			/* Matrix of value pairs:
+					 * class1-major, class2-minor,
+					 * Each entry has value1 and value2 */
+  public:
+  DEFINE_SIZE_ARRAY (16, values);
+};
+
+struct PairPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  PairPosFormat1	format1;
+  PairPosFormat2	format2;
+  } u;
+};
+
+
+struct EntryExitRecord
+{
+  friend struct CursivePosFormat1;
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    return entryAnchor.sanitize (c, base)
+	&& exitAnchor.sanitize (c, base);
+  }
+
+  private:
+  OffsetTo<Anchor>
+		entryAnchor;		/* Offset to EntryAnchor table--from
+					 * beginning of CursivePos
+					 * subtable--may be NULL */
+  OffsetTo<Anchor>
+		exitAnchor;		/* Offset to ExitAnchor table--from
+					 * beginning of CursivePos
+					 * subtable--may be NULL */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CursivePosFormat1
+{
+  friend struct CursivePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    /* Now comes the messiest part of the whole OpenType
+       specification.  At first glance, cursive connections seem easy
+       to understand, but there are pitfalls!  The reason is that
+       the specs don't mention how to compute the advance values
+       resp. glyph offsets.  I was told it would be an omission, to
+       be fixed in the next OpenType version...  Again many thanks to
+       Andrei Burago <andreib@microsoft.com> for clarifications.
+
+       Consider the following example:
+
+			|  xadv1    |
+			 +---------+
+			 |         |
+		   +-----+--+ 1    |
+		   |     | .|      |
+		   |    0+--+------+
+		   |   2    |
+		   |        |
+		  0+--------+
+		  |  xadv2   |
+
+	 glyph1: advance width = 12
+		 anchor point = (3,1)
+
+	 glyph2: advance width = 11
+		 anchor point = (9,4)
+
+	 LSB is 1 for both glyphs (so the boxes drawn above are glyph
+	 bboxes).  Writing direction is R2L; `0' denotes the glyph's
+	 coordinate origin.
+
+       Now the surprising part: The advance width of the *left* glyph
+       (resp. of the *bottom* glyph) will be modified, no matter
+       whether the writing direction is L2R or R2L (resp. T2B or
+       B2T)!  This assymetry is caused by the fact that the glyph's
+       coordinate origin is always the lower left corner for all
+       writing directions.
+
+       Continuing the above example, we can compute the new
+       (horizontal) advance width of glyph2 as
+
+	 9 - 3 = 6  ,
+
+       and the new vertical offset of glyph2 as
+
+	 1 - 4 = -3  .
+
+
+       Vertical writing direction is far more complicated:
+
+       a) Assuming that we recompute the advance height of the lower glyph:
+
+				    --
+			 +---------+
+		--       |         |
+		   +-----+--+ 1    | yadv1
+		   |     | .|      |
+	     yadv2 |    0+--+------+        -- BSB1  --
+		   |   2    |       --      --        y_offset
+		   |        |
+     BSB2 --      0+--------+                        --
+	  --    --
+
+	 glyph1: advance height = 6
+		 anchor point = (3,1)
+
+	 glyph2: advance height = 7
+		 anchor point = (9,4)
+
+	 TSB is 1 for both glyphs; writing direction is T2B.
+
+
+	   BSB1     = yadv1 - (TSB1 + ymax1)
+	   BSB2     = yadv2 - (TSB2 + ymax2)
+	   y_offset = y2 - y1
+
+	 vertical advance width of glyph2
+	   = y_offset + BSB2 - BSB1
+	   = (y2 - y1) + (yadv2 - (TSB2 + ymax2)) - (yadv1 - (TSB1 + ymax1))
+	   = y2 - y1 + yadv2 - TSB2 - ymax2 - (yadv1 - TSB1 - ymax1)
+	   = y2 - y1 + yadv2 - TSB2 - ymax2 - yadv1 + TSB1 + ymax1
+
+
+       b) Assuming that we recompute the advance height of the upper glyph:
+
+				    --      --
+			 +---------+        -- TSB1
+	  --    --       |         |
+     TSB2 --       +-----+--+ 1    | yadv1   ymax1
+		   |     | .|      |
+	     yadv2 |    0+--+------+        --       --
+      ymax2        |   2    |       --                y_offset
+		   |        |
+	  --      0+--------+                        --
+		--
+
+	 glyph1: advance height = 6
+		 anchor point = (3,1)
+
+	 glyph2: advance height = 7
+		 anchor point = (9,4)
+
+	 TSB is 1 for both glyphs; writing direction is T2B.
+
+	 y_offset = y2 - y1
+
+	 vertical advance width of glyph2
+	   = TSB1 + ymax1 + y_offset - (TSB2 + ymax2)
+	   = TSB1 + ymax1 + y2 - y1 - TSB2 - ymax2
+
+
+       Comparing a) with b) shows that b) is easier to compute.  I'll wait
+       for a reply from Andrei to see what should really be implemented...
+
+       Since horizontal advance widths or vertical advance heights
+       can be used alone but not together, no ambiguity occurs.        */
+
+    struct hb_ot_layout_context_t::info_t::gpos_t *gpi = &c->layout->info.gpos;
+    hb_codepoint_t last_pos = gpi->last;
+    gpi->last = HB_OT_LAYOUT_GPOS_NO_LAST;
+
+    /* We don't handle mark glyphs here. */
+    if (c->property == HB_OT_LAYOUT_GLYPH_CLASS_MARK)
+      return false;
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const EntryExitRecord &record = entryExitRecord[index];
+
+    if (last_pos == HB_OT_LAYOUT_GPOS_NO_LAST || !record.entryAnchor)
+      goto end;
+
+    hb_position_t entry_x, entry_y;
+    (this+record.entryAnchor).get_anchor (c->layout, c->buffer->info[c->buffer->i].codepoint, &entry_x, &entry_y);
+
+    /* TODO vertical */
+
+    if (c->buffer->props.direction == HB_DIRECTION_RTL)
+    {
+      /* advance is absolute, not relative */
+      c->buffer->pos[c->buffer->i].x_advance = entry_x - gpi->anchor_x;
+    }
+    else
+    {
+      /* advance is absolute, not relative */
+      c->buffer->pos[last_pos].x_advance = gpi->anchor_x - entry_x;
+    }
+
+    if  (c->lookup_flag & LookupFlag::RightToLeft)
+    {
+      c->buffer->pos[last_pos].cursive_chain = last_pos - c->buffer->i;
+      c->buffer->pos[last_pos].y_offset = entry_y - gpi->anchor_y;
+    }
+    else
+    {
+      c->buffer->pos[c->buffer->i].cursive_chain = c->buffer->i - last_pos;
+      c->buffer->pos[c->buffer->i].y_offset = gpi->anchor_y - entry_y;
+    }
+
+  end:
+    if (record.exitAnchor)
+    {
+      gpi->last = c->buffer->i;
+      (this+record.exitAnchor).get_anchor (c->layout, c->buffer->info[c->buffer->i].codepoint, &gpi->anchor_x, &gpi->anchor_y);
+    }
+
+    c->buffer->i++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& entryExitRecord.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ArrayOf<EntryExitRecord>
+		entryExitRecord;	/* Array of EntryExit records--in
+					 * Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (6, entryExitRecord);
+};
+
+struct CursivePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  CursivePosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix BaseArray;		/* base-major--
+					 * in order of BaseCoverage Index--,
+					 * mark-minor--
+					 * ordered by class--zero-based. */
+
+struct MarkBasePosFormat1
+{
+  friend struct MarkBasePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark_index = (this+markCoverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (mark_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a non-mark glyph */
+    unsigned int property;
+    unsigned int j = c->buffer->i;
+    do
+    {
+      if (unlikely (!j))
+	return false;
+      j--;
+    } while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], LookupFlag::IgnoreMarks, &property));
+
+    /* The following assertion is too strong, so we've disabled it. */
+    if (false && !(property & HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH))
+      return false;
+
+    unsigned int base_index = (this+baseCoverage) (c->buffer->info[j].codepoint);
+    if (base_index == NOT_COVERED)
+      return false;
+
+    return (this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+        && markCoverage.sanitize (c, this)
+	&& baseCoverage.sanitize (c, this)
+	&& markArray.sanitize (c, this)
+	&& baseArray.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		markCoverage;		/* Offset to MarkCoverage table--from
+					 * beginning of MarkBasePos subtable */
+  OffsetTo<Coverage>
+		baseCoverage;		/* Offset to BaseCoverage table--from
+					 * beginning of MarkBasePos subtable */
+  USHORT	classCount;		/* Number of classes defined for marks */
+  OffsetTo<MarkArray>
+		markArray;		/* Offset to MarkArray table--from
+					 * beginning of MarkBasePos subtable */
+  OffsetTo<BaseArray>
+		baseArray;		/* Offset to BaseArray table--from
+					 * beginning of MarkBasePos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkBasePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkBasePosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix LigatureAttach;	/* component-major--
+					 * in order of writing direction--,
+					 * mark-minor--
+					 * ordered by class--zero-based. */
+
+typedef OffsetListOf<LigatureAttach> LigatureArray;
+					/* Array of LigatureAttach
+					 * tables ordered by
+					 * LigatureCoverage Index */
+
+struct MarkLigPosFormat1
+{
+  friend struct MarkLigPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark_index = (this+markCoverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (mark_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a non-mark glyph */
+    unsigned int property;
+    unsigned int j = c->buffer->i;
+    do
+    {
+      if (unlikely (!j))
+	return false;
+      j--;
+    } while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], LookupFlag::IgnoreMarks, &property));
+
+    /* The following assertion is too strong, so we've disabled it. */
+    if (false && !(property & HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE))
+      return false;
+
+    unsigned int lig_index = (this+ligatureCoverage) (c->buffer->info[j].codepoint);
+    if (lig_index == NOT_COVERED)
+      return false;
+
+    const LigatureArray& lig_array = this+ligatureArray;
+    const LigatureAttach& lig_attach = lig_array[lig_index];
+
+    /* Find component to attach to */
+    unsigned int comp_count = lig_attach.rows;
+    if (unlikely (!comp_count))
+      return false;
+    unsigned int comp_index;
+    /* We must now check whether the ligature ID of the current mark glyph
+     * is identical to the ligature ID of the found ligature.  If yes, we
+     * can directly use the component index.  If not, we attach the mark
+     * glyph to the last component of the ligature. */
+    if (c->buffer->info[j].lig_id && c->buffer->info[j].lig_id == c->buffer->info[c->buffer->i].lig_id && c->buffer->info[c->buffer->i].component)
+    {
+      comp_index = c->buffer->info[c->buffer->i].component - 1;
+      if (comp_index >= comp_count)
+	comp_index = comp_count - 1;
+    }
+    else
+      comp_index = comp_count - 1;
+
+    return (this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+        && markCoverage.sanitize (c, this)
+	&& ligatureCoverage.sanitize (c, this)
+	&& markArray.sanitize (c, this)
+	&& ligatureArray.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		markCoverage;		/* Offset to Mark Coverage table--from
+					 * beginning of MarkLigPos subtable */
+  OffsetTo<Coverage>
+		ligatureCoverage;	/* Offset to Ligature Coverage
+					 * table--from beginning of MarkLigPos
+					 * subtable */
+  USHORT	classCount;		/* Number of defined mark classes */
+  OffsetTo<MarkArray>
+		markArray;		/* Offset to MarkArray table--from
+					 * beginning of MarkLigPos subtable */
+  OffsetTo<LigatureArray>
+		ligatureArray;		/* Offset to LigatureArray table--from
+					 * beginning of MarkLigPos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkLigPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkLigPosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix Mark2Array;	/* mark2-major--
+					 * in order of Mark2Coverage Index--,
+					 * mark1-minor--
+					 * ordered by class--zero-based. */
+
+struct MarkMarkPosFormat1
+{
+  friend struct MarkMarkPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark1_index = (this+mark1Coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (mark1_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a suitable mark glyph until a non-mark glyph */
+    unsigned int property;
+    unsigned int j = c->buffer->i;
+    do
+    {
+      if (unlikely (!j))
+	return false;
+      j--;
+    } while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], c->lookup_flag, &property));
+
+    if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+      return false;
+
+    /* Two marks match only if they belong to the same base, or same component
+     * of the same ligature.  That is, the component numbers must match, and
+     * if those are non-zero, the ligid number should also match. */
+    if ((c->buffer->info[j].component != c->buffer->info[c->buffer->i].component) ||
+	(c->buffer->info[j].component && c->buffer->info[j].lig_id != c->buffer->info[c->buffer->i].lig_id))
+      return false;
+
+    unsigned int mark2_index = (this+mark2Coverage) (c->buffer->info[j].codepoint);
+    if (mark2_index == NOT_COVERED)
+      return false;
+
+    return (this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& mark1Coverage.sanitize (c, this)
+	&& mark2Coverage.sanitize (c, this)
+	&& mark1Array.sanitize (c, this)
+	&& mark2Array.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		mark1Coverage;		/* Offset to Combining Mark1 Coverage
+					 * table--from beginning of MarkMarkPos
+					 * subtable */
+  OffsetTo<Coverage>
+		mark2Coverage;		/* Offset to Combining Mark2 Coverage
+					 * table--from beginning of MarkMarkPos
+					 * subtable */
+  USHORT	classCount;		/* Number of defined mark classes */
+  OffsetTo<MarkArray>
+		mark1Array;		/* Offset to Mark1Array table--from
+					 * beginning of MarkMarkPos subtable */
+  OffsetTo<Mark2Array>
+		mark2Array;		/* Offset to Mark2Array table--from
+					 * beginning of MarkMarkPos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkMarkPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkMarkPosFormat1	format1;
+  } u;
+};
+
+
+HB_BEGIN_DECLS
+static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index);
+HB_END_DECLS
+
+struct ContextPos : Context
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return Context::apply (c, position_lookup);
+  }
+};
+
+struct ChainContextPos : ChainContext
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return ChainContext::apply (c, position_lookup);
+  }
+};
+
+
+struct ExtensionPos : Extension
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline const struct PosLookupSubTable& get_subtable (void) const
+  {
+    unsigned int offset = get_offset ();
+    if (unlikely (!offset)) return Null(PosLookupSubTable);
+    return StructAtOffset<PosLookupSubTable> (this, offset);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const;
+
+  inline bool sanitize (hb_sanitize_context_t *c);
+};
+
+
+
+/*
+ * PosLookup
+ */
+
+
+struct PosLookupSubTable
+{
+  friend struct PosLookup;
+
+  enum {
+    Single		= 1,
+    Pair		= 2,
+    Cursive		= 3,
+    MarkBase		= 4,
+    MarkLig		= 5,
+    MarkMark		= 6,
+    Context		= 7,
+    ChainContext	= 8,
+    Extension		= 9
+  };
+
+  inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
+  {
+    TRACE_APPLY ();
+    switch (lookup_type) {
+    case Single:		return u.single.apply (c);
+    case Pair:			return u.pair.apply (c);
+    case Cursive:		return u.cursive.apply (c);
+    case MarkBase:		return u.markBase.apply (c);
+    case MarkLig:		return u.markLig.apply (c);
+    case MarkMark:		return u.markMark.apply (c);
+    case Context:		return u.c.apply (c);
+    case ChainContext:		return u.chainContext.apply (c);
+    case Extension:		return u.extension.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
+    TRACE_SANITIZE ();
+    switch (lookup_type) {
+    case Single:		return u.single.sanitize (c);
+    case Pair:			return u.pair.sanitize (c);
+    case Cursive:		return u.cursive.sanitize (c);
+    case MarkBase:		return u.markBase.sanitize (c);
+    case MarkLig:		return u.markLig.sanitize (c);
+    case MarkMark:		return u.markMark.sanitize (c);
+    case Context:		return u.c.sanitize (c);
+    case ChainContext:		return u.chainContext.sanitize (c);
+    case Extension:		return u.extension.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		sub_format;
+  SinglePos		single;
+  PairPos		pair;
+  CursivePos		cursive;
+  MarkBasePos		markBase;
+  MarkLigPos		markLig;
+  MarkMarkPos		markMark;
+  ContextPos		c;
+  ChainContextPos	chainContext;
+  ExtensionPos		extension;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, sub_format);
+};
+
+
+struct PosLookup : Lookup
+{
+  inline const PosLookupSubTable& get_subtable (unsigned int i) const
+  { return this+CastR<OffsetArrayOf<PosLookupSubTable> > (subTable)[i]; }
+
+  inline bool apply_once (hb_ot_layout_context_t *layout,
+			  hb_buffer_t *buffer,
+			  hb_mask_t lookup_mask,
+			  unsigned int context_length,
+			  unsigned int nesting_level_left) const
+  {
+    unsigned int lookup_type = get_type ();
+    hb_apply_context_t c[1] = {{0}};
+
+    c->layout = layout;
+    c->buffer = buffer;
+    c->lookup_mask = lookup_mask;
+    c->context_length = context_length;
+    c->nesting_level_left = nesting_level_left;
+    c->lookup_flag = get_flag ();
+
+    if (!_hb_ot_layout_check_glyph_property (c->layout->face, &c->buffer->info[c->buffer->i], c->lookup_flag, &c->property))
+      return false;
+
+    for (unsigned int i = 0; i < get_subtable_count (); i++)
+      if (get_subtable (i).apply (c, lookup_type))
+	return true;
+
+    return false;
+  }
+
+   inline bool apply_string (hb_ot_layout_context_t *layout,
+			     hb_buffer_t *buffer,
+			     hb_mask_t    mask) const
+  {
+    bool ret = false;
+
+    if (unlikely (!buffer->len))
+      return false;
+
+    layout->info.gpos.last = HB_OT_LAYOUT_GPOS_NO_LAST; /* no last valid glyph for cursive pos. */
+
+    buffer->i = 0;
+    while (buffer->i < buffer->len)
+    {
+      bool done;
+      if (buffer->info[buffer->i].mask & mask)
+      {
+	  done = apply_once (layout, buffer, mask, NO_CONTEXT, MAX_NESTING_LEVEL);
+	  ret |= done;
+      }
+      else
+      {
+          done = false;
+	  /* Contrary to properties defined in GDEF, user-defined properties
+	     will always stop a possible cursive positioning.                */
+	  layout->info.gpos.last = HB_OT_LAYOUT_GPOS_NO_LAST;
+      }
+
+      if (!done)
+	buffer->i++;
+    }
+
+    return ret;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!Lookup::sanitize (c))) return false;
+    OffsetArrayOf<PosLookupSubTable> &list = CastR<OffsetArrayOf<PosLookupSubTable> > (subTable);
+    return list.sanitize (c, this, get_type ());
+  }
+};
+
+typedef OffsetListOf<PosLookup> PosLookupList;
+
+/*
+ * GPOS
+ */
+
+struct GPOS : GSUBGPOS
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GPOS;
+
+  inline const PosLookup& get_lookup (unsigned int i) const
+  { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }
+
+  inline bool position_lookup (hb_ot_layout_context_t *layout,
+			       hb_buffer_t  *buffer,
+			       unsigned int  lookup_index,
+			       hb_mask_t     mask) const
+  { return get_lookup (lookup_index).apply_string (layout, buffer, mask); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!GSUBGPOS::sanitize (c))) return false;
+    OffsetTo<PosLookupList> &list = CastR<OffsetTo<PosLookupList> > (lookupList);
+    return list.sanitize (c, this);
+  }
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+
+/* Out-of-class implementation for methods recursing */
+
+inline bool ExtensionPos::apply (hb_apply_context_t *c) const
+{
+  TRACE_APPLY ();
+  return get_subtable ().apply (c, get_type ());
+}
+
+inline bool ExtensionPos::sanitize (hb_sanitize_context_t *c)
+{
+  TRACE_SANITIZE ();
+  if (unlikely (!Extension::sanitize (c))) return false;
+  unsigned int offset = get_offset ();
+  if (unlikely (!offset)) return true;
+  return StructAtOffset<PosLookupSubTable> (this, offset).sanitize (c, get_type ());
+}
+
+static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index)
+{
+  const GPOS &gpos = *(c->layout->face->ot_layout->gpos);
+  const PosLookup &l = gpos.get_lookup (lookup_index);
+
+  if (unlikely (c->nesting_level_left == 0))
+    return false;
+
+  if (unlikely (c->context_length < 1))
+    return false;
+
+  return l.apply_once (c->layout, c->buffer, c->lookup_mask, c->context_length, c->nesting_level_left - 1);
+}
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_LAYOUT_GPOS_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gpos-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,1594 @@
+/*
+ * Copyright  2007,2008,2009,2010  Red Hat, Inc.
+ * Copyright  2010,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
+#define HB_OT_LAYOUT_GPOS_TABLE_HH
+
+#include "hb-ot-layout-gsubgpos-private.hh"
+
+
+
+/* buffer **position** var allocations */
+#define attach_lookback() var.u16[0] /* number of glyphs to go back to attach this glyph to its base */
+#define cursive_chain() var.i16[1] /* character to which this connects, may be positive or negative */
+
+
+/* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
+
+typedef USHORT Value;
+
+typedef Value ValueRecord[VAR];
+
+struct ValueFormat : USHORT
+{
+  enum Flags {
+    xPlacement	= 0x0001,	/* Includes horizontal adjustment for placement */
+    yPlacement	= 0x0002,	/* Includes vertical adjustment for placement */
+    xAdvance	= 0x0004,	/* Includes horizontal adjustment for advance */
+    yAdvance	= 0x0008,	/* Includes vertical adjustment for advance */
+    xPlaDevice	= 0x0010,	/* Includes horizontal Device table for placement */
+    yPlaDevice	= 0x0020,	/* Includes vertical Device table for placement */
+    xAdvDevice	= 0x0040,	/* Includes horizontal Device table for advance */
+    yAdvDevice	= 0x0080,	/* Includes vertical Device table for advance */
+    ignored	= 0x0F00,	/* Was used in TrueType Open for MM fonts */
+    reserved	= 0xF000,	/* For future use */
+
+    devices	= 0x00F0	/* Mask for having any Device table */
+  };
+
+/* All fields are options.  Only those available advance the value pointer. */
+#if 0
+  SHORT		xPlacement;		/* Horizontal adjustment for
+					 * placement--in design units */
+  SHORT		yPlacement;		/* Vertical adjustment for
+					 * placement--in design units */
+  SHORT		xAdvance;		/* Horizontal adjustment for
+					 * advance--in design units (only used
+					 * for horizontal writing) */
+  SHORT		yAdvance;		/* Vertical adjustment for advance--in
+					 * design units (only used for vertical
+					 * writing) */
+  Offset	xPlaDevice;		/* Offset to Device table for
+					 * horizontal placement--measured from
+					 * beginning of PosTable (may be NULL) */
+  Offset	yPlaDevice;		/* Offset to Device table for vertical
+					 * placement--measured from beginning
+					 * of PosTable (may be NULL) */
+  Offset	xAdvDevice;		/* Offset to Device table for
+					 * horizontal advance--measured from
+					 * beginning of PosTable (may be NULL) */
+  Offset	yAdvDevice;		/* Offset to Device table for vertical
+					 * advance--measured from beginning of
+					 * PosTable (may be NULL) */
+#endif
+
+  inline unsigned int get_len (void) const
+  { return _hb_popcount32 ((unsigned int) *this); }
+  inline unsigned int get_size (void) const
+  { return get_len () * Value::static_size; }
+
+  void apply_value (hb_font_t            *font,
+		    hb_direction_t        direction,
+		    const void           *base,
+		    const Value          *values,
+		    hb_glyph_position_t  &glyph_pos) const
+  {
+    unsigned int x_ppem, y_ppem;
+    unsigned int format = *this;
+    hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (direction);
+
+    if (!format) return;
+
+    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++));
+    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++));
+    if (format & xAdvance) {
+      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values++)); else values++;
+    }
+    /* y_advance values grow downward but font-space grows upward, hence negation */
+    if (format & yAdvance) {
+      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values++)); else values++;
+    }
+
+    if (!has_device ()) return;
+
+    x_ppem = font->x_ppem;
+    y_ppem = font->y_ppem;
+
+    if (!x_ppem && !y_ppem) return;
+
+    /* pixel -> fractional pixel */
+    if (format & xPlaDevice) {
+      if (x_ppem) glyph_pos.x_offset  += (base + get_device (values++)).get_x_delta (font); else values++;
+    }
+    if (format & yPlaDevice) {
+      if (y_ppem) glyph_pos.y_offset  += (base + get_device (values++)).get_y_delta (font); else values++;
+    }
+    if (format & xAdvDevice) {
+      if (horizontal && x_ppem) glyph_pos.x_advance += (base + get_device (values++)).get_x_delta (font); else values++;
+    }
+    if (format & yAdvDevice) {
+      /* y_advance values grow downward but font-space grows upward, hence negation */
+      if (!horizontal && y_ppem) glyph_pos.y_advance -= (base + get_device (values++)).get_y_delta (font); else values++;
+    }
+  }
+
+  private:
+  inline bool sanitize_value_devices (hb_sanitize_context_t *c, void *base, Value *values) {
+    unsigned int format = *this;
+
+    if (format & xPlacement) values++;
+    if (format & yPlacement) values++;
+    if (format & xAdvance)   values++;
+    if (format & yAdvance)   values++;
+
+    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
+    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;
+
+    return true;
+  }
+
+  static inline OffsetTo<Device>& get_device (Value* value)
+  { return *CastP<OffsetTo<Device> > (value); }
+  static inline const OffsetTo<Device>& get_device (const Value* value)
+  { return *CastP<OffsetTo<Device> > (value); }
+
+  static inline const SHORT& get_short (const Value* value)
+  { return *CastP<SHORT> (value); }
+
+  public:
+
+  inline bool has_device (void) const {
+    unsigned int format = *this;
+    return (format & devices) != 0;
+  }
+
+  inline bool sanitize_value (hb_sanitize_context_t *c, void *base, Value *values) {
+    TRACE_SANITIZE ();
+    return c->check_range (values, get_size ())
+	&& (!has_device () || sanitize_value_devices (c, base, values));
+  }
+
+  inline bool sanitize_values (hb_sanitize_context_t *c, void *base, Value *values, unsigned int count) {
+    TRACE_SANITIZE ();
+    unsigned int len = get_len ();
+
+    if (!c->check_array (values, get_size (), count)) return false;
+
+    if (!has_device ()) return true;
+
+    for (unsigned int i = 0; i < count; i++) {
+      if (!sanitize_value_devices (c, base, values))
+        return false;
+      values += len;
+    }
+
+    return true;
+  }
+
+  /* Just sanitize referenced Device tables.  Doesn't check the values themselves. */
+  inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, void *base, Value *values, unsigned int count, unsigned int stride) {
+    TRACE_SANITIZE ();
+
+    if (!has_device ()) return true;
+
+    for (unsigned int i = 0; i < count; i++) {
+      if (!sanitize_value_devices (c, base, values))
+        return false;
+      values += stride;
+    }
+
+    return true;
+  }
+};
+
+
+struct AnchorFormat1
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      *x = font->em_scale_x (xCoordinate);
+      *y = font->em_scale_y (yCoordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct AnchorFormat2
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      unsigned int x_ppem = font->x_ppem;
+      unsigned int y_ppem = font->y_ppem;
+      hb_position_t cx, cy;
+      hb_bool_t ret = false;
+
+      if (x_ppem || y_ppem)
+	ret = hb_font_get_glyph_contour_point_for_origin (font, glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);
+      *x = x_ppem && ret ? cx : font->em_scale_x (xCoordinate);
+      *y = y_ppem && ret ? cy : font->em_scale_y (yCoordinate);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  USHORT	anchorPoint;		/* Index to glyph contour point */
+  public:
+  DEFINE_SIZE_STATIC (8);
+};
+
+struct AnchorFormat3
+{
+  friend struct Anchor;
+
+  private:
+  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id HB_UNUSED,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+      *x = font->em_scale_x (xCoordinate);
+      *y = font->em_scale_y (yCoordinate);
+
+      if (font->x_ppem)
+	*x += (this+xDeviceTable).get_x_delta (font);
+      if (font->y_ppem)
+	*y += (this+yDeviceTable).get_x_delta (font);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& xDeviceTable.sanitize (c, this)
+	&& yDeviceTable.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 3 */
+  SHORT		xCoordinate;		/* Horizontal value--in design units */
+  SHORT		yCoordinate;		/* Vertical value--in design units */
+  OffsetTo<Device>
+		xDeviceTable;		/* Offset to Device table for X
+					 * coordinate-- from beginning of
+					 * Anchor table (may be NULL) */
+  OffsetTo<Device>
+		yDeviceTable;		/* Offset to Device table for Y
+					 * coordinate-- from beginning of
+					 * Anchor table (may be NULL) */
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+struct Anchor
+{
+  inline void get_anchor (hb_font_t *font, hb_codepoint_t glyph_id,
+			  hb_position_t *x, hb_position_t *y) const
+  {
+    *x = *y = 0;
+    switch (u.format) {
+    case 1: u.format1.get_anchor (font, glyph_id, x, y); return;
+    case 2: u.format2.get_anchor (font, glyph_id, x, y); return;
+    case 3: u.format3.get_anchor (font, glyph_id, x, y); return;
+    default:						 return;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  AnchorFormat1		format1;
+  AnchorFormat2		format2;
+  AnchorFormat3		format3;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, format);
+};
+
+
+struct AnchorMatrix
+{
+  inline const Anchor& get_anchor (unsigned int row, unsigned int col, unsigned int cols) const {
+    if (unlikely (row >= rows || col >= cols)) return Null(Anchor);
+    return this+matrix[row * cols + col];
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) {
+    TRACE_SANITIZE ();
+    if (!c->check_struct (this)) return false;
+    if (unlikely (rows > 0 && cols >= ((unsigned int) -1) / rows)) return false;
+    unsigned int count = rows * cols;
+    if (!c->check_array (matrix, matrix[0].static_size, count)) return false;
+    for (unsigned int i = 0; i < count; i++)
+      if (!matrix[i].sanitize (c, this)) return false;
+    return true;
+  }
+
+  USHORT	rows;			/* Number of rows */
+  private:
+  OffsetTo<Anchor>
+		matrix[VAR];		/* Matrix of offsets to Anchor tables--
+					 * from beginning of AnchorMatrix table */
+  public:
+  DEFINE_SIZE_ARRAY (2, matrix);
+};
+
+
+struct MarkRecord
+{
+  friend struct MarkArray;
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& markAnchor.sanitize (c, base);
+  }
+
+  private:
+  USHORT	klass;			/* Class defined for this mark */
+  OffsetTo<Anchor>
+		markAnchor;		/* Offset to Anchor table--from
+					 * beginning of MarkArray table */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct MarkArray : ArrayOf<MarkRecord>	/* Array of MarkRecords--in Coverage order */
+{
+  inline bool apply (hb_apply_context_t *c,
+		     unsigned int mark_index, unsigned int glyph_index,
+		     const AnchorMatrix &anchors, unsigned int class_count,
+		     unsigned int glyph_pos) const
+  {
+    TRACE_APPLY ();
+    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);
+    unsigned int mark_class = record.klass;
+
+    const Anchor& mark_anchor = this + record.markAnchor;
+    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count);
+
+    hb_position_t mark_x, mark_y, base_x, base_y;
+
+    mark_anchor.get_anchor (c->font, c->buffer->info[c->buffer->idx].codepoint, &mark_x, &mark_y);
+    glyph_anchor.get_anchor (c->font, c->buffer->info[glyph_pos].codepoint, &base_x, &base_y);
+
+    hb_glyph_position_t &o = c->buffer->pos[c->buffer->idx];
+    o.x_offset = base_x - mark_x;
+    o.y_offset = base_y - mark_y;
+    o.attach_lookback() = c->buffer->idx - glyph_pos;
+
+    c->buffer->idx++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ArrayOf<MarkRecord>::sanitize (c, this);
+  }
+};
+
+
+/* Lookups */
+
+struct SinglePosFormat1
+{
+  friend struct SinglePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    valueFormat.apply_value (c->font, c->direction, this,
+			     values, c->buffer->pos[c->buffer->idx]);
+
+    c->buffer->idx++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& valueFormat.sanitize_value (c, this, values);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat;		/* Defines the types of data in the
+					 * ValueRecord */
+  ValueRecord	values;			/* Defines positioning
+					 * value(s)--applied to all glyphs in
+					 * the Coverage table */
+  public:
+  DEFINE_SIZE_ARRAY (6, values);
+};
+
+struct SinglePosFormat2
+{
+  friend struct SinglePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (likely (index >= valueCount))
+      return false;
+
+    valueFormat.apply_value (c->font, c->direction, this,
+			     &values[index * valueFormat.get_len ()],
+			     c->buffer->pos[c->buffer->idx]);
+
+    c->buffer->idx++;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& valueFormat.sanitize_values (c, this, values, valueCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat;		/* Defines the types of data in the
+					 * ValueRecord */
+  USHORT	valueCount;		/* Number of ValueRecords */
+  ValueRecord	values;			/* Array of ValueRecords--positioning
+					 * values applied to glyphs */
+  public:
+  DEFINE_SIZE_ARRAY (8, values);
+};
+
+struct SinglePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  SinglePosFormat1	format1;
+  SinglePosFormat2	format2;
+  } u;
+};
+
+
+struct PairValueRecord
+{
+  friend struct PairSet;
+
+  private:
+  GlyphID	secondGlyph;		/* GlyphID of second glyph in the
+					 * pair--first glyph is listed in the
+					 * Coverage table */
+  ValueRecord	values;			/* Positioning data for the first glyph
+					 * followed by for second glyph */
+  public:
+  DEFINE_SIZE_ARRAY (2, values);
+};
+
+struct PairSet
+{
+  friend struct PairPosFormat1;
+
+  inline bool apply (hb_apply_context_t *c,
+		     const ValueFormat *valueFormats,
+		     unsigned int pos) const
+  {
+    TRACE_APPLY ();
+    unsigned int len1 = valueFormats[0].get_len ();
+    unsigned int len2 = valueFormats[1].get_len ();
+    unsigned int record_size = USHORT::static_size * (1 + len1 + len2);
+
+    unsigned int count = len;
+    const PairValueRecord *record = CastP<PairValueRecord> (array);
+    for (unsigned int i = 0; i < count; i++)
+    {
+      if (c->buffer->info[pos].codepoint == record->secondGlyph)
+      {
+	valueFormats[0].apply_value (c->font, c->direction, this,
+				     &record->values[0], c->buffer->pos[c->buffer->idx]);
+	valueFormats[1].apply_value (c->font, c->direction, this,
+				     &record->values[len1], c->buffer->pos[pos]);
+	if (len2)
+	  pos++;
+	c->buffer->idx = pos;
+	return true;
+      }
+      record = &StructAtOffset<PairValueRecord> (record, record_size);
+    }
+
+    return false;
+  }
+
+  struct sanitize_closure_t {
+    void *base;
+    ValueFormat *valueFormats;
+    unsigned int len1; /* valueFormats[0].get_len() */
+    unsigned int stride; /* 1 + len1 + len2 */
+  };
+
+  inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) {
+    TRACE_SANITIZE ();
+    if (!(c->check_struct (this)
+       && c->check_array (array, USHORT::static_size * closure->stride, len))) return false;
+
+    unsigned int count = len;
+    PairValueRecord *record = CastP<PairValueRecord> (array);
+    return closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride)
+	&& closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride);
+  }
+
+  private:
+  USHORT	len;			/* Number of PairValueRecords */
+  USHORT	array[VAR];		/* Array of PairValueRecords--ordered
+					 * by GlyphID of the second glyph */
+  public:
+  DEFINE_SIZE_ARRAY (2, array);
+};
+
+struct PairPosFormat1
+{
+  friend struct PairPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (skippy_iter.has_no_chance ())
+      return false;
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (!skippy_iter.next ())
+      return false;
+
+    return (this+pairSet[index]).apply (c, &valueFormat1, skippy_iter.idx);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    PairSet::sanitize_closure_t closure = {
+      this,
+      &valueFormat1,
+      len1,
+      1 + len1 + len2
+    };
+
+    return c->check_struct (this)
+	&& coverage.sanitize (c, this)
+	&& pairSet.sanitize (c, this, &closure);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat1;		/* Defines the types of data in
+					 * ValueRecord1--for the first glyph
+					 * in the pair--may be zero (0) */
+  ValueFormat	valueFormat2;		/* Defines the types of data in
+					 * ValueRecord2--for the second glyph
+					 * in the pair--may be zero (0) */
+  OffsetArrayOf<PairSet>
+		pairSet;		/* Array of PairSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (10, pairSet);
+};
+
+struct PairPosFormat2
+{
+  friend struct PairPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (skippy_iter.has_no_chance ())
+      return false;
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (!skippy_iter.next ())
+      return false;
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    unsigned int record_len = len1 + len2;
+
+    unsigned int klass1 = (this+classDef1) (c->buffer->info[c->buffer->idx].codepoint);
+    unsigned int klass2 = (this+classDef2) (c->buffer->info[skippy_iter.idx].codepoint);
+    if (unlikely (klass1 >= class1Count || klass2 >= class2Count))
+      return false;
+
+    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];
+    valueFormat1.apply_value (c->font, c->direction, this,
+			      v, c->buffer->pos[c->buffer->idx]);
+    valueFormat2.apply_value (c->font, c->direction, this,
+			      v + len1, c->buffer->pos[skippy_iter.idx]);
+
+    c->buffer->idx = skippy_iter.idx;
+    if (len2)
+      c->buffer->idx++;
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!(c->check_struct (this)
+       && coverage.sanitize (c, this)
+       && classDef1.sanitize (c, this)
+       && classDef2.sanitize (c, this))) return false;
+
+    unsigned int len1 = valueFormat1.get_len ();
+    unsigned int len2 = valueFormat2.get_len ();
+    unsigned int stride = len1 + len2;
+    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
+    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
+    return c->check_array (values, record_size, count) &&
+	   valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&
+	   valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ValueFormat	valueFormat1;		/* ValueRecord definition--for the
+					 * first glyph of the pair--may be zero
+					 * (0) */
+  ValueFormat	valueFormat2;		/* ValueRecord definition--for the
+					 * second glyph of the pair--may be
+					 * zero (0) */
+  OffsetTo<ClassDef>
+		classDef1;		/* Offset to ClassDef table--from
+					 * beginning of PairPos subtable--for
+					 * the first glyph of the pair */
+  OffsetTo<ClassDef>
+		classDef2;		/* Offset to ClassDef table--from
+					 * beginning of PairPos subtable--for
+					 * the second glyph of the pair */
+  USHORT	class1Count;		/* Number of classes in ClassDef1
+					 * table--includes Class0 */
+  USHORT	class2Count;		/* Number of classes in ClassDef2
+					 * table--includes Class0 */
+  ValueRecord	values;			/* Matrix of value pairs:
+					 * class1-major, class2-minor,
+					 * Each entry has value1 and value2 */
+  public:
+  DEFINE_SIZE_ARRAY (16, values);
+};
+
+struct PairPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  PairPosFormat1	format1;
+  PairPosFormat2	format2;
+  } u;
+};
+
+
+struct EntryExitRecord
+{
+  friend struct CursivePosFormat1;
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    return entryAnchor.sanitize (c, base)
+	&& exitAnchor.sanitize (c, base);
+  }
+
+  private:
+  OffsetTo<Anchor>
+		entryAnchor;		/* Offset to EntryAnchor table--from
+					 * beginning of CursivePos
+					 * subtable--may be NULL */
+  OffsetTo<Anchor>
+		exitAnchor;		/* Offset to ExitAnchor table--from
+					 * beginning of CursivePos
+					 * subtable--may be NULL */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+struct CursivePosFormat1
+{
+  friend struct CursivePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+
+    /* We don't handle mark glyphs here. */
+    if (c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK)
+      return false;
+
+    hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (skippy_iter.has_no_chance ())
+      return false;
+
+    const EntryExitRecord &this_record = entryExitRecord[(this+coverage) (c->buffer->info[c->buffer->idx].codepoint)];
+    if (!this_record.exitAnchor)
+      return false;
+
+    if (!skippy_iter.next ())
+      return false;
+
+    const EntryExitRecord &next_record = entryExitRecord[(this+coverage) (c->buffer->info[skippy_iter.idx].codepoint)];
+    if (!next_record.entryAnchor)
+      return false;
+
+    unsigned int i = c->buffer->idx;
+    unsigned int j = skippy_iter.idx;
+
+    hb_position_t entry_x, entry_y, exit_x, exit_y;
+    (this+this_record.exitAnchor).get_anchor (c->font, c->buffer->info[i].codepoint, &exit_x, &exit_y);
+    (this+next_record.entryAnchor).get_anchor (c->font, c->buffer->info[j].codepoint, &entry_x, &entry_y);
+
+    hb_glyph_position_t *pos = c->buffer->pos;
+
+    hb_position_t d;
+    /* Main-direction adjustment */
+    switch (c->direction) {
+      case HB_DIRECTION_LTR:
+	pos[i].x_advance  =  exit_x + pos[i].x_offset;
+
+	d = entry_x + pos[j].x_offset;
+	pos[j].x_advance -= d;
+	pos[j].x_offset  -= d;
+	break;
+      case HB_DIRECTION_RTL:
+	d = exit_x + pos[i].x_offset;
+	pos[i].x_advance -= d;
+	pos[i].x_offset  -= d;
+
+	pos[j].x_advance  =  entry_x + pos[j].x_offset;
+	break;
+      case HB_DIRECTION_TTB:
+	pos[i].y_advance  =  exit_y + pos[i].y_offset;
+
+	d = entry_y + pos[j].y_offset;
+	pos[j].y_advance -= d;
+	pos[j].y_offset  -= d;
+	break;
+      case HB_DIRECTION_BTT:
+	d = exit_y + pos[i].y_offset;
+	pos[i].y_advance -= d;
+	pos[i].y_offset  -= d;
+
+	pos[j].y_advance  =  entry_y;
+	break;
+      case HB_DIRECTION_INVALID:
+      default:
+	break;
+    }
+
+    /* Cross-direction adjustment */
+    if  (c->lookup_props & LookupFlag::RightToLeft) {
+      pos[i].cursive_chain() = j - i;
+      if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))
+	pos[i].y_offset = entry_y - exit_y;
+      else
+	pos[i].x_offset = entry_x - exit_x;
+    } else {
+      pos[j].cursive_chain() = i - j;
+      if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))
+	pos[j].y_offset = exit_y - entry_y;
+      else
+	pos[j].x_offset = exit_x - entry_x;
+    }
+
+    c->buffer->idx = j;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& entryExitRecord.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of subtable */
+  ArrayOf<EntryExitRecord>
+		entryExitRecord;	/* Array of EntryExit records--in
+					 * Coverage Index order */
+  public:
+  DEFINE_SIZE_ARRAY (6, entryExitRecord);
+};
+
+struct CursivePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  CursivePosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix BaseArray;		/* base-major--
+					 * in order of BaseCoverage Index--,
+					 * mark-minor--
+					 * ordered by class--zero-based. */
+
+struct MarkBasePosFormat1
+{
+  friend struct MarkBasePos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark_index = (this+markCoverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (mark_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a non-mark glyph */
+    unsigned int property;
+    hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (!skippy_iter.prev (&property, LookupFlag::IgnoreMarks))
+      return false;
+
+    /* The following assertion is too strong, so we've disabled it. */
+    if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH))
+    {/*return false;*/}
+
+    unsigned int base_index = (this+baseCoverage) (c->buffer->info[skippy_iter.idx].codepoint);
+    if (base_index == NOT_COVERED)
+      return false;
+
+    return (this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+        && markCoverage.sanitize (c, this)
+	&& baseCoverage.sanitize (c, this)
+	&& markArray.sanitize (c, this)
+	&& baseArray.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		markCoverage;		/* Offset to MarkCoverage table--from
+					 * beginning of MarkBasePos subtable */
+  OffsetTo<Coverage>
+		baseCoverage;		/* Offset to BaseCoverage table--from
+					 * beginning of MarkBasePos subtable */
+  USHORT	classCount;		/* Number of classes defined for marks */
+  OffsetTo<MarkArray>
+		markArray;		/* Offset to MarkArray table--from
+					 * beginning of MarkBasePos subtable */
+  OffsetTo<BaseArray>
+		baseArray;		/* Offset to BaseArray table--from
+					 * beginning of MarkBasePos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkBasePos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkBasePosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix LigatureAttach;	/* component-major--
+					 * in order of writing direction--,
+					 * mark-minor--
+					 * ordered by class--zero-based. */
+
+typedef OffsetListOf<LigatureAttach> LigatureArray;
+					/* Array of LigatureAttach
+					 * tables ordered by
+					 * LigatureCoverage Index */
+
+struct MarkLigPosFormat1
+{
+  friend struct MarkLigPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark_index = (this+markCoverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (mark_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a non-mark glyph */
+    unsigned int property;
+    hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (!skippy_iter.prev (&property, LookupFlag::IgnoreMarks))
+      return false;
+
+    /* The following assertion is too strong, so we've disabled it. */
+    if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE))
+    {/*return false;*/}
+
+    unsigned int j = skippy_iter.idx;
+    unsigned int lig_index = (this+ligatureCoverage) (c->buffer->info[j].codepoint);
+    if (lig_index == NOT_COVERED)
+      return false;
+
+    const LigatureArray& lig_array = this+ligatureArray;
+    const LigatureAttach& lig_attach = lig_array[lig_index];
+
+    /* Find component to attach to */
+    unsigned int comp_count = lig_attach.rows;
+    if (unlikely (!comp_count))
+      return false;
+    unsigned int comp_index;
+    /* We must now check whether the ligature ID of the current mark glyph
+     * is identical to the ligature ID of the found ligature.  If yes, we
+     * can directly use the component index.  If not, we attach the mark
+     * glyph to the last component of the ligature. */
+    if (c->buffer->info[j].lig_id() && c->buffer->info[j].lig_id() == c->buffer->info[c->buffer->idx].lig_id() && c->buffer->info[c->buffer->idx].lig_comp())
+    {
+      comp_index = c->buffer->info[c->buffer->idx].lig_comp() - 1;
+      if (comp_index >= comp_count)
+	comp_index = comp_count - 1;
+    }
+    else
+      comp_index = comp_count - 1;
+
+    return (this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+        && markCoverage.sanitize (c, this)
+	&& ligatureCoverage.sanitize (c, this)
+	&& markArray.sanitize (c, this)
+	&& ligatureArray.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		markCoverage;		/* Offset to Mark Coverage table--from
+					 * beginning of MarkLigPos subtable */
+  OffsetTo<Coverage>
+		ligatureCoverage;	/* Offset to Ligature Coverage
+					 * table--from beginning of MarkLigPos
+					 * subtable */
+  USHORT	classCount;		/* Number of defined mark classes */
+  OffsetTo<MarkArray>
+		markArray;		/* Offset to MarkArray table--from
+					 * beginning of MarkLigPos subtable */
+  OffsetTo<LigatureArray>
+		ligatureArray;		/* Offset to LigatureArray table--from
+					 * beginning of MarkLigPos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkLigPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkLigPosFormat1	format1;
+  } u;
+};
+
+
+typedef AnchorMatrix Mark2Array;	/* mark2-major--
+					 * in order of Mark2Coverage Index--,
+					 * mark1-minor--
+					 * ordered by class--zero-based. */
+
+struct MarkMarkPosFormat1
+{
+  friend struct MarkMarkPos;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int mark1_index = (this+mark1Coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (mark1_index == NOT_COVERED))
+      return false;
+
+    /* now we search backwards for a suitable mark glyph until a non-mark glyph */
+    unsigned int property;
+    hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->idx, 1);
+    if (!skippy_iter.prev (&property))
+      return false;
+
+    if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+      return false;
+
+    unsigned int j = skippy_iter.idx;
+
+    /* Two marks match only if they belong to the same base, or same component
+     * of the same ligature.  That is, the component numbers must match, and
+     * if those are non-zero, the ligid number should also match. */
+    if ((c->buffer->info[j].lig_comp() != c->buffer->info[c->buffer->idx].lig_comp()) ||
+	(c->buffer->info[j].lig_comp() && c->buffer->info[j].lig_id() != c->buffer->info[c->buffer->idx].lig_id()))
+      return false;
+
+    unsigned int mark2_index = (this+mark2Coverage) (c->buffer->info[j].codepoint);
+    if (mark2_index == NOT_COVERED)
+      return false;
+
+    return (this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this)
+	&& mark1Coverage.sanitize (c, this)
+	&& mark2Coverage.sanitize (c, this)
+	&& mark1Array.sanitize (c, this)
+	&& mark2Array.sanitize (c, this, (unsigned int) classCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		mark1Coverage;		/* Offset to Combining Mark1 Coverage
+					 * table--from beginning of MarkMarkPos
+					 * subtable */
+  OffsetTo<Coverage>
+		mark2Coverage;		/* Offset to Combining Mark2 Coverage
+					 * table--from beginning of MarkMarkPos
+					 * subtable */
+  USHORT	classCount;		/* Number of defined mark classes */
+  OffsetTo<MarkArray>
+		mark1Array;		/* Offset to Mark1Array table--from
+					 * beginning of MarkMarkPos subtable */
+  OffsetTo<Mark2Array>
+		mark2Array;		/* Offset to Mark2Array table--from
+					 * beginning of MarkMarkPos subtable */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct MarkMarkPos
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MarkMarkPosFormat1	format1;
+  } u;
+};
+
+
+static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index);
+
+struct ContextPos : Context
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return Context::apply (c, position_lookup);
+  }
+};
+
+struct ChainContextPos : ChainContext
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return ChainContext::apply (c, position_lookup);
+  }
+};
+
+
+struct ExtensionPos : Extension
+{
+  friend struct PosLookupSubTable;
+
+  private:
+  inline const struct PosLookupSubTable& get_subtable (void) const
+  {
+    unsigned int offset = get_offset ();
+    if (unlikely (!offset)) return Null(PosLookupSubTable);
+    return StructAtOffset<PosLookupSubTable> (this, offset);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const;
+
+  inline bool sanitize (hb_sanitize_context_t *c);
+};
+
+
+
+/*
+ * PosLookup
+ */
+
+
+struct PosLookupSubTable
+{
+  friend struct PosLookup;
+
+  enum Type {
+    Single		= 1,
+    Pair		= 2,
+    Cursive		= 3,
+    MarkBase		= 4,
+    MarkLig		= 5,
+    MarkMark		= 6,
+    Context		= 7,
+    ChainContext	= 8,
+    Extension		= 9
+  };
+
+  inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
+  {
+    TRACE_APPLY ();
+    switch (lookup_type) {
+    case Single:		return u.single.apply (c);
+    case Pair:			return u.pair.apply (c);
+    case Cursive:		return u.cursive.apply (c);
+    case MarkBase:		return u.markBase.apply (c);
+    case MarkLig:		return u.markLig.apply (c);
+    case MarkMark:		return u.markMark.apply (c);
+    case Context:		return u.c.apply (c);
+    case ChainContext:		return u.chainContext.apply (c);
+    case Extension:		return u.extension.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
+    TRACE_SANITIZE ();
+    switch (lookup_type) {
+    case Single:		return u.single.sanitize (c);
+    case Pair:			return u.pair.sanitize (c);
+    case Cursive:		return u.cursive.sanitize (c);
+    case MarkBase:		return u.markBase.sanitize (c);
+    case MarkLig:		return u.markLig.sanitize (c);
+    case MarkMark:		return u.markMark.sanitize (c);
+    case Context:		return u.c.sanitize (c);
+    case ChainContext:		return u.chainContext.sanitize (c);
+    case Extension:		return u.extension.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		sub_format;
+  SinglePos		single;
+  PairPos		pair;
+  CursivePos		cursive;
+  MarkBasePos		markBase;
+  MarkLigPos		markLig;
+  MarkMarkPos		markMark;
+  ContextPos		c;
+  ChainContextPos	chainContext;
+  ExtensionPos		extension;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, sub_format);
+};
+
+
+struct PosLookup : Lookup
+{
+  inline const PosLookupSubTable& get_subtable (unsigned int i) const
+  { return this+CastR<OffsetArrayOf<PosLookupSubTable> > (subTable)[i]; }
+
+  inline bool apply_once (hb_apply_context_t *c) const
+  {
+    unsigned int lookup_type = get_type ();
+
+    if (!_hb_ot_layout_check_glyph_property (c->face, &c->buffer->info[c->buffer->idx], c->lookup_props, &c->property))
+      return false;
+
+    for (unsigned int i = 0; i < get_subtable_count (); i++)
+      if (get_subtable (i).apply (c, lookup_type))
+	return true;
+
+    return false;
+  }
+
+  inline bool apply_string (hb_apply_context_t *c) const
+  {
+    bool ret = false;
+
+    if (unlikely (!c->buffer->len))
+      return false;
+
+    c->set_lookup (*this);
+
+    c->buffer->idx = 0;
+    while (c->buffer->idx < c->buffer->len)
+    {
+      if ((c->buffer->info[c->buffer->idx].mask & c->lookup_mask) && apply_once (c))
+	ret = true;
+      else
+	c->buffer->idx++;
+    }
+
+    return ret;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!Lookup::sanitize (c))) return false;
+    OffsetArrayOf<PosLookupSubTable> &list = CastR<OffsetArrayOf<PosLookupSubTable> > (subTable);
+    return list.sanitize (c, this, get_type ());
+  }
+};
+
+typedef OffsetListOf<PosLookup> PosLookupList;
+
+/*
+ * GPOS -- The Glyph Positioning Table
+ */
+
+struct GPOS : GSUBGPOS
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GPOS;
+
+  inline const PosLookup& get_lookup (unsigned int i) const
+  { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }
+
+  inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index) const
+  { return get_lookup (lookup_index).apply_string (c); }
+
+  static inline void position_start (hb_buffer_t *buffer);
+  static inline void position_finish (hb_buffer_t *buffer);
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!GSUBGPOS::sanitize (c))) return false;
+    OffsetTo<PosLookupList> &list = CastR<OffsetTo<PosLookupList> > (lookupList);
+    return list.sanitize (c, this);
+  }
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+
+static void
+fix_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)
+{
+    unsigned int j = pos[i].cursive_chain();
+    if (likely (!j))
+      return;
+
+    j += i;
+
+    pos[i].cursive_chain() = 0;
+
+    fix_cursive_minor_offset (pos, j, direction);
+
+    if (HB_DIRECTION_IS_HORIZONTAL (direction))
+      pos[i].y_offset += pos[j].y_offset;
+    else
+      pos[i].x_offset += pos[j].x_offset;
+}
+
+static void
+fix_mark_attachment (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)
+{
+  if (likely (!(pos[i].attach_lookback())))
+    return;
+
+  unsigned int j = i - pos[i].attach_lookback();
+
+  pos[i].x_advance = 0;
+  pos[i].y_advance = 0;
+  pos[i].x_offset += pos[j].x_offset;
+  pos[i].y_offset += pos[j].y_offset;
+
+  if (HB_DIRECTION_IS_FORWARD (direction))
+    for (unsigned int k = j; k < i; k++) {
+      pos[i].x_offset -= pos[k].x_advance;
+      pos[i].y_offset -= pos[k].y_advance;
+    }
+  else
+    for (unsigned int k = j + 1; k < i + 1; k++) {
+      pos[i].x_offset += pos[k].x_advance;
+      pos[i].y_offset += pos[k].y_advance;
+    }
+}
+
+void
+GPOS::position_start (hb_buffer_t *buffer)
+{
+  buffer->clear_positions ();
+
+  unsigned int count = buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+    buffer->pos[i].attach_lookback() = buffer->pos[i].cursive_chain() = 0;
+}
+
+void
+GPOS::position_finish (hb_buffer_t *buffer)
+{
+  unsigned int len;
+  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);
+  hb_direction_t direction = buffer->props.direction;
+
+  /* Handle cursive connections */
+  for (unsigned int i = 0; i < len; i++)
+    fix_cursive_minor_offset (pos, i, direction);
+
+  /* Handle attachments */
+  for (unsigned int i = 0; i < len; i++)
+    fix_mark_attachment (pos, i, direction);
+
+  HB_BUFFER_DEALLOCATE_VAR (buffer, lig_comp);
+  HB_BUFFER_DEALLOCATE_VAR (buffer, lig_id);
+  HB_BUFFER_DEALLOCATE_VAR (buffer, props_cache);
+}
+
+
+/* Out-of-class implementation for methods recursing */
+
+inline bool ExtensionPos::apply (hb_apply_context_t *c) const
+{
+  TRACE_APPLY ();
+  return get_subtable ().apply (c, get_type ());
+}
+
+inline bool ExtensionPos::sanitize (hb_sanitize_context_t *c)
+{
+  TRACE_SANITIZE ();
+  if (unlikely (!Extension::sanitize (c))) return false;
+  unsigned int offset = get_offset ();
+  if (unlikely (!offset)) return true;
+  return StructAtOffset<PosLookupSubTable> (this, offset).sanitize (c, get_type ());
+}
+
+static inline bool position_lookup (hb_apply_context_t *c, unsigned int lookup_index)
+{
+  const GPOS &gpos = *(c->face->ot_layout->gpos);
+  const PosLookup &l = gpos.get_lookup (lookup_index);
+
+  if (unlikely (c->nesting_level_left == 0))
+    return false;
+
+  if (unlikely (c->context_length < 1))
+    return false;
+
+  hb_apply_context_t new_c (*c);
+  new_c.nesting_level_left--;
+  new_c.set_lookup (l);
+  return l.apply_once (&new_c);
+}
+
+
+#undef attach_lookback
+#undef cursive_chain
+
+
+
+#endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsubgpos-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,1387 @@
+/*
+ * Copyright  2007,2008,2009,2010  Red Hat, Inc.
+ * Copyright  2010,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH
+#define HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH
+
+#include "hb-buffer-private.hh"
+#include "hb-ot-layout-gdef-table.hh"
+
+
+
+/* buffer var allocations */
+#define lig_id() var2.u8[2] /* unique ligature id */
+#define lig_comp() var2.u8[3] /* component number in the ligature (0 = base) */
+
+static inline uint8_t allocate_lig_id (hb_buffer_t *buffer) {
+  uint8_t lig_id = buffer->next_serial ();
+  if (unlikely (!lig_id)) lig_id = buffer->next_serial (); /* in case of overflow */
+  return lig_id;
+}
+
+
+
+#ifndef HB_DEBUG_CLOSURE
+#define HB_DEBUG_CLOSURE (HB_DEBUG+0)
+#endif
+
+#define TRACE_CLOSURE() \
+	hb_auto_trace_t<HB_DEBUG_CLOSURE> trace (&c->debug_depth, "CLOSURE", this, NULL, HB_FUNC);
+
+
+
+struct hb_closure_context_t
+{
+  hb_face_t *face;
+  hb_set_t *glyphs;
+  unsigned int nesting_level_left;
+  unsigned int debug_depth;
+
+
+  hb_closure_context_t (hb_face_t *face_,
+			hb_set_t *glyphs_,
+		        unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :
+			  face (face_), glyphs (glyphs_),
+			  nesting_level_left (nesting_level_left_),
+			  debug_depth (0) {}
+};
+
+
+
+#ifndef HB_DEBUG_APPLY
+#define HB_DEBUG_APPLY (HB_DEBUG+0)
+#endif
+
+#define TRACE_APPLY() \
+	hb_auto_trace_t<HB_DEBUG_APPLY> trace (&c->debug_depth, "APPLY", this, NULL, HB_FUNC);
+
+
+
+struct hb_apply_context_t
+{
+  hb_font_t *font;
+  hb_face_t *face;
+  hb_buffer_t *buffer;
+  hb_direction_t direction;
+  hb_mask_t lookup_mask;
+  unsigned int context_length;
+  unsigned int nesting_level_left;
+  unsigned int lookup_props;
+  unsigned int property; /* propety of first glyph */
+  unsigned int debug_depth;
+
+
+  hb_apply_context_t (hb_font_t *font_,
+		      hb_face_t *face_,
+		      hb_buffer_t *buffer_,
+		      hb_mask_t lookup_mask_,
+		      unsigned int context_length_ = NO_CONTEXT,
+		      unsigned int nesting_level_left_ = MAX_NESTING_LEVEL) :
+			font (font_), face (face_), buffer (buffer_),
+			direction (buffer_->props.direction),
+			lookup_mask (lookup_mask_),
+			context_length (context_length_),
+			nesting_level_left (nesting_level_left_),
+			lookup_props (0), property (0), debug_depth (0) {}
+
+  void set_lookup (const Lookup &l) {
+    lookup_props = l.get_props ();
+  }
+
+  struct mark_skipping_forward_iterator_t
+  {
+    inline mark_skipping_forward_iterator_t (hb_apply_context_t *c_,
+					     unsigned int start_index_,
+					     unsigned int num_items_)
+    {
+      c = c_;
+      idx = start_index_;
+      num_items = num_items_;
+      end = MIN (c->buffer->len, c->buffer->idx + c->context_length);
+    }
+    inline bool has_no_chance (void) const
+    {
+      return unlikely (num_items && idx + num_items >= end);
+    }
+    inline bool next (unsigned int *property_out,
+		      unsigned int lookup_props)
+    {
+      assert (num_items > 0);
+      do
+      {
+	if (has_no_chance ())
+	  return false;
+	idx++;
+      } while (_hb_ot_layout_skip_mark (c->face, &c->buffer->info[idx], lookup_props, property_out));
+      num_items--;
+      return true;
+    }
+    inline bool next (unsigned int *property_out = NULL)
+    {
+      return next (property_out, c->lookup_props);
+    }
+
+    unsigned int idx;
+    private:
+    hb_apply_context_t *c;
+    unsigned int num_items;
+    unsigned int end;
+  };
+
+  struct mark_skipping_backward_iterator_t
+  {
+    inline mark_skipping_backward_iterator_t (hb_apply_context_t *c_,
+					      unsigned int start_index_,
+					      unsigned int num_items_)
+    {
+      c = c_;
+      idx = start_index_;
+      num_items = num_items_;
+    }
+    inline bool has_no_chance (void) const
+    {
+      return unlikely (idx < num_items);
+    }
+    inline bool prev (unsigned int *property_out,
+		      unsigned int lookup_props)
+    {
+      assert (num_items > 0);
+      do
+      {
+	if (has_no_chance ())
+	  return false;
+	idx--;
+      } while (_hb_ot_layout_skip_mark (c->face, &c->buffer->out_info[idx], lookup_props, property_out));
+      num_items--;
+      return true;
+    }
+    inline bool prev (unsigned int *property_out = NULL)
+    {
+      return prev (property_out, c->lookup_props);
+    }
+
+    unsigned int idx;
+    private:
+    hb_apply_context_t *c;
+    unsigned int num_items;
+  };
+
+  inline bool should_mark_skip_current_glyph (void) const
+  {
+    return _hb_ot_layout_skip_mark (face, &buffer->info[buffer->idx], lookup_props, NULL);
+  }
+
+
+
+  inline void replace_glyph (hb_codepoint_t glyph_index) const
+  {
+    clear_property ();
+    buffer->replace_glyph (glyph_index);
+  }
+  inline void replace_glyphs_be16 (unsigned int num_in,
+				   unsigned int num_out,
+				   const uint16_t *glyph_data_be) const
+  {
+    clear_property ();
+    buffer->replace_glyphs_be16 (num_in, num_out, glyph_data_be);
+  }
+
+  inline void guess_glyph_class (unsigned int klass)
+  {
+    /* XXX if ! has gdef */
+    buffer->info[buffer->idx].props_cache() = klass;
+  }
+
+  private:
+  inline void clear_property (void) const
+  {
+    /* XXX if has gdef */
+    buffer->info[buffer->idx].props_cache() = 0;
+  }
+};
+
+
+
+typedef bool (*intersects_func_t) (hb_set_t *glyphs, const USHORT &value, const void *data);
+typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const USHORT &value, const void *data);
+typedef void (*closure_lookup_func_t) (hb_closure_context_t *c, unsigned int lookup_index);
+typedef bool (*apply_lookup_func_t) (hb_apply_context_t *c, unsigned int lookup_index);
+
+struct ContextClosureFuncs
+{
+  intersects_func_t intersects;
+  closure_lookup_func_t closure;
+};
+struct ContextApplyFuncs
+{
+  match_func_t match;
+  apply_lookup_func_t apply;
+};
+
+static inline bool intersects_glyph (hb_set_t *glyphs, const USHORT &value, const void *data HB_UNUSED)
+{
+  return glyphs->has (value);
+}
+static inline bool intersects_class (hb_set_t *glyphs, const USHORT &value, const void *data)
+{
+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);
+  return class_def.intersects_class (glyphs, value);
+}
+static inline bool intersects_coverage (hb_set_t *glyphs, const USHORT &value, const void *data)
+{
+  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;
+  return (data+coverage).intersects (glyphs);
+}
+
+static inline bool intersects_array (hb_closure_context_t *c,
+				     unsigned int count,
+				     const USHORT values[],
+				     intersects_func_t intersects_func,
+				     const void *intersects_data)
+{
+  for (unsigned int i = 0; i < count; i++)
+    if (likely (!intersects_func (c->glyphs, values[i], intersects_data)))
+      return false;
+  return true;
+}
+
+
+static inline bool match_glyph (hb_codepoint_t glyph_id, const USHORT &value, const void *data HB_UNUSED)
+{
+  return glyph_id == value;
+}
+static inline bool match_class (hb_codepoint_t glyph_id, const USHORT &value, const void *data)
+{
+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);
+  return class_def.get_class (glyph_id) == value;
+}
+static inline bool match_coverage (hb_codepoint_t glyph_id, const USHORT &value, const void *data)
+{
+  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;
+  return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;
+}
+
+
+static inline bool match_input (hb_apply_context_t *c,
+				unsigned int count, /* Including the first glyph (not matched) */
+				const USHORT input[], /* Array of input values--start with second glyph */
+				match_func_t match_func,
+				const void *match_data,
+				unsigned int *context_length_out)
+{
+  hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, count - 1);
+  if (skippy_iter.has_no_chance ())
+    return false;
+
+  for (unsigned int i = 1; i < count; i++)
+  {
+    if (!skippy_iter.next ())
+      return false;
+
+    if (likely (!match_func (c->buffer->info[skippy_iter.idx].codepoint, input[i - 1], match_data)))
+      return false;
+  }
+
+  *context_length_out = skippy_iter.idx - c->buffer->idx + 1;
+
+  return true;
+}
+
+static inline bool match_backtrack (hb_apply_context_t *c,
+				    unsigned int count,
+				    const USHORT backtrack[],
+				    match_func_t match_func,
+				    const void *match_data)
+{
+  hb_apply_context_t::mark_skipping_backward_iterator_t skippy_iter (c, c->buffer->backtrack_len (), count);
+  if (skippy_iter.has_no_chance ())
+    return false;
+
+  for (unsigned int i = 0; i < count; i++)
+  {
+    if (!skippy_iter.prev ())
+      return false;
+
+    if (likely (!match_func (c->buffer->out_info[skippy_iter.idx].codepoint, backtrack[i], match_data)))
+      return false;
+  }
+
+  return true;
+}
+
+static inline bool match_lookahead (hb_apply_context_t *c,
+				    unsigned int count,
+				    const USHORT lookahead[],
+				    match_func_t match_func,
+				    const void *match_data,
+				    unsigned int offset)
+{
+  hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx + offset - 1, count);
+  if (skippy_iter.has_no_chance ())
+    return false;
+
+  for (unsigned int i = 0; i < count; i++)
+  {
+    if (!skippy_iter.next ())
+      return false;
+
+    if (likely (!match_func (c->buffer->info[skippy_iter.idx].codepoint, lookahead[i], match_data)))
+      return false;
+  }
+
+  return true;
+}
+
+
+
+struct LookupRecord
+{
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  USHORT	sequenceIndex;		/* Index into current glyph
+					 * sequence--first glyph = 0 */
+  USHORT	lookupListIndex;	/* Lookup to apply to that
+					 * position--zero--based */
+  public:
+  DEFINE_SIZE_STATIC (4);
+};
+
+
+static inline void closure_lookup (hb_closure_context_t *c,
+				   unsigned int lookupCount,
+				   const LookupRecord lookupRecord[], /* Array of LookupRecords--in design order */
+				   closure_lookup_func_t closure_func)
+{
+  for (unsigned int i = 0; i < lookupCount; i++)
+    closure_func (c, lookupRecord->lookupListIndex);
+}
+
+static inline bool apply_lookup (hb_apply_context_t *c,
+				 unsigned int count, /* Including the first glyph */
+				 unsigned int lookupCount,
+				 const LookupRecord lookupRecord[], /* Array of LookupRecords--in design order */
+				 apply_lookup_func_t apply_func)
+{
+  unsigned int end = MIN (c->buffer->len, c->buffer->idx + c->context_length);
+  if (unlikely (count == 0 || c->buffer->idx + count > end))
+    return false;
+
+  /* TODO We don't support lookupRecord arrays that are not increasing:
+   *      Should be easy for in_place ones at least. */
+
+  /* Note: If sublookup is reverse, it will underflow after the first loop
+   * and we jump out of it.  Not entirely disastrous.  So we don't check
+   * for reverse lookup here.
+   */
+  for (unsigned int i = 0; i < count; /* NOP */)
+  {
+    if (unlikely (c->buffer->idx == end))
+      return true;
+    while (c->should_mark_skip_current_glyph ())
+    {
+      /* No lookup applied for this index */
+      c->buffer->next_glyph ();
+      if (unlikely (c->buffer->idx == end))
+	return true;
+    }
+
+    if (lookupCount && i == lookupRecord->sequenceIndex)
+    {
+      unsigned int old_pos = c->buffer->idx;
+
+      /* Apply a lookup */
+      bool done = apply_func (c, lookupRecord->lookupListIndex);
+
+      lookupRecord++;
+      lookupCount--;
+      /* Err, this is wrong if the lookup jumped over some glyphs */
+      i += c->buffer->idx - old_pos;
+      if (unlikely (c->buffer->idx == end))
+	return true;
+
+      if (!done)
+	goto not_applied;
+    }
+    else
+    {
+    not_applied:
+      /* No lookup applied for this index */
+      c->buffer->next_glyph ();
+      i++;
+    }
+  }
+
+  return true;
+}
+
+
+
+/* Contextual lookups */
+
+struct ContextClosureLookupContext
+{
+  ContextClosureFuncs funcs;
+  const void *intersects_data;
+};
+
+struct ContextApplyLookupContext
+{
+  ContextApplyFuncs funcs;
+  const void *match_data;
+};
+
+static inline void context_closure_lookup (hb_closure_context_t *c,
+					   unsigned int inputCount, /* Including the first glyph (not matched) */
+					   const USHORT input[], /* Array of input values--start with second glyph */
+					   unsigned int lookupCount,
+					   const LookupRecord lookupRecord[],
+					   ContextClosureLookupContext &lookup_context)
+{
+  if (intersects_array (c,
+			inputCount ? inputCount - 1 : 0, input,
+			lookup_context.funcs.intersects, lookup_context.intersects_data))
+    closure_lookup (c,
+		    lookupCount, lookupRecord,
+		    lookup_context.funcs.closure);
+}
+
+
+static inline bool context_apply_lookup (hb_apply_context_t *c,
+					 unsigned int inputCount, /* Including the first glyph (not matched) */
+					 const USHORT input[], /* Array of input values--start with second glyph */
+					 unsigned int lookupCount,
+					 const LookupRecord lookupRecord[],
+					 ContextApplyLookupContext &lookup_context)
+{
+  hb_apply_context_t new_context = *c;
+  return match_input (c,
+		      inputCount, input,
+		      lookup_context.funcs.match, lookup_context.match_data,
+		      &new_context.context_length)
+      && apply_lookup (&new_context,
+		       inputCount,
+		       lookupCount, lookupRecord,
+		       lookup_context.funcs.apply);
+}
+
+struct Rule
+{
+  friend struct RuleSet;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const
+  {
+    TRACE_CLOSURE ();
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (input, input[0].static_size * (inputCount ? inputCount - 1 : 0));
+    context_closure_lookup (c,
+			    inputCount, input,
+			    lookupCount, lookupRecord,
+			    lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_APPLY ();
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (input, input[0].static_size * (inputCount ? inputCount - 1 : 0));
+    return context_apply_lookup (c,
+				 inputCount, input,
+				 lookupCount, lookupRecord,
+				 lookup_context);
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return inputCount.sanitize (c)
+	&& lookupCount.sanitize (c)
+	&& c->check_range (input,
+			   input[0].static_size * inputCount
+			   + lookupRecordX[0].static_size * lookupCount);
+  }
+
+  private:
+  USHORT	inputCount;		/* Total number of glyphs in input
+					 * glyph sequence--includes the first
+					 * glyph */
+  USHORT	lookupCount;		/* Number of LookupRecords */
+  USHORT	input[VAR];		/* Array of match inputs--start with
+					 * second glyph */
+  LookupRecord	lookupRecordX[VAR];	/* Array of LookupRecords--in
+					 * design order */
+  public:
+  DEFINE_SIZE_ARRAY2 (4, input, lookupRecordX);
+};
+
+struct RuleSet
+{
+  inline void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const
+  {
+    TRACE_CLOSURE ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+      (this+rule[i]).closure (c, lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, ContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_APPLY ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+    {
+      if ((this+rule[i]).apply (c, lookup_context))
+        return true;
+    }
+    return false;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return rule.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<Rule>
+		rule;			/* Array of Rule tables
+					 * ordered by preference */
+  public:
+  DEFINE_SIZE_ARRAY (2, rule);
+};
+
+
+struct ContextFormat1
+{
+  friend struct Context;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+
+    const Coverage &cov = (this+coverage);
+
+    struct ContextClosureLookupContext lookup_context = {
+      {intersects_glyph, closure_func},
+      NULL
+    };
+
+    unsigned int count = ruleSet.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (cov.intersects_coverage (c->glyphs, i)) {
+	const RuleSet &rule_set = this+ruleSet[i];
+	rule_set.closure (c, lookup_context);
+      }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const RuleSet &rule_set = this+ruleSet[index];
+    struct ContextApplyLookupContext lookup_context = {
+      {match_glyph, apply_func},
+      NULL
+    };
+    return rule_set.apply (c, lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ruleSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetArrayOf<RuleSet>
+		ruleSet;		/* Array of RuleSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, ruleSet);
+};
+
+
+struct ContextFormat2
+{
+  friend struct Context;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    if (!(this+coverage).intersects (c->glyphs))
+      return;
+
+    const ClassDef &class_def = this+classDef;
+
+    struct ContextClosureLookupContext lookup_context = {
+      {intersects_class, closure_func},
+      NULL
+    };
+
+    unsigned int count = ruleSet.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (class_def.intersects_class (c->glyphs, i)) {
+	const RuleSet &rule_set = this+ruleSet[i];
+	rule_set.closure (c, lookup_context);
+      }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const ClassDef &class_def = this+classDef;
+    index = class_def (c->buffer->info[c->buffer->idx].codepoint);
+    const RuleSet &rule_set = this+ruleSet[index];
+    struct ContextApplyLookupContext lookup_context = {
+      {match_class, apply_func},
+      &class_def
+    };
+    return rule_set.apply (c, lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+        && classDef.sanitize (c, this)
+	&& ruleSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetTo<ClassDef>
+		classDef;		/* Offset to glyph ClassDef table--from
+					 * beginning of table */
+  OffsetArrayOf<RuleSet>
+		ruleSet;		/* Array of RuleSet tables
+					 * ordered by class */
+  public:
+  DEFINE_SIZE_ARRAY (8, ruleSet);
+};
+
+
+struct ContextFormat3
+{
+  friend struct Context;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    if (!(this+coverage[0]).intersects (c->glyphs))
+      return;
+
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * glyphCount);
+    struct ContextClosureLookupContext lookup_context = {
+      {intersects_coverage, closure_func},
+      this
+    };
+    context_closure_lookup (c,
+			    glyphCount, (const USHORT *) (coverage + 1),
+			    lookupCount, lookupRecord,
+			    lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage[0]) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * glyphCount);
+    struct ContextApplyLookupContext lookup_context = {
+      {match_coverage, apply_func},
+      this
+    };
+    return context_apply_lookup (c,
+				 glyphCount, (const USHORT *) (coverage + 1),
+				 lookupCount, lookupRecord,
+				 lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!c->check_struct (this)) return false;
+    unsigned int count = glyphCount;
+    if (!c->check_array (coverage, coverage[0].static_size, count)) return false;
+    for (unsigned int i = 0; i < count; i++)
+      if (!coverage[i].sanitize (c, this)) return false;
+    LookupRecord *lookupRecord = &StructAtOffset<LookupRecord> (coverage, coverage[0].static_size * count);
+    return c->check_array (lookupRecord, lookupRecord[0].static_size, lookupCount);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 3 */
+  USHORT	glyphCount;		/* Number of glyphs in the input glyph
+					 * sequence */
+  USHORT	lookupCount;		/* Number of LookupRecords */
+  OffsetTo<Coverage>
+		coverage[VAR];		/* Array of offsets to Coverage
+					 * table in glyph sequence order */
+  LookupRecord	lookupRecordX[VAR];	/* Array of LookupRecords--in
+					 * design order */
+  public:
+  DEFINE_SIZE_ARRAY2 (6, coverage, lookupRecordX);
+};
+
+struct Context
+{
+  protected:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c, closure_func); break;
+    case 2: u.format2.closure (c, closure_func); break;
+    case 3: u.format3.closure (c, closure_func); break;
+    default:                                     break;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c, apply_func);
+    case 2: return u.format2.apply (c, apply_func);
+    case 3: return u.format3.apply (c, apply_func);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  ContextFormat1	format1;
+  ContextFormat2	format2;
+  ContextFormat3	format3;
+  } u;
+};
+
+
+/* Chaining Contextual lookups */
+
+struct ChainContextClosureLookupContext
+{
+  ContextClosureFuncs funcs;
+  const void *intersects_data[3];
+};
+
+struct ChainContextApplyLookupContext
+{
+  ContextApplyFuncs funcs;
+  const void *match_data[3];
+};
+
+static inline void chain_context_closure_lookup (hb_closure_context_t *c,
+						 unsigned int backtrackCount,
+						 const USHORT backtrack[],
+						 unsigned int inputCount, /* Including the first glyph (not matched) */
+						 const USHORT input[], /* Array of input values--start with second glyph */
+						 unsigned int lookaheadCount,
+						 const USHORT lookahead[],
+						 unsigned int lookupCount,
+						 const LookupRecord lookupRecord[],
+						 ChainContextClosureLookupContext &lookup_context)
+{
+  if (intersects_array (c,
+			backtrackCount, backtrack,
+			lookup_context.funcs.intersects, lookup_context.intersects_data[0])
+   && intersects_array (c,
+			inputCount ? inputCount - 1 : 0, input,
+			lookup_context.funcs.intersects, lookup_context.intersects_data[1])
+  && intersects_array (c,
+		       lookaheadCount, lookahead,
+		       lookup_context.funcs.intersects, lookup_context.intersects_data[2]))
+    closure_lookup (c,
+		    lookupCount, lookupRecord,
+		    lookup_context.funcs.closure);
+}
+
+static inline bool chain_context_apply_lookup (hb_apply_context_t *c,
+					       unsigned int backtrackCount,
+					       const USHORT backtrack[],
+					       unsigned int inputCount, /* Including the first glyph (not matched) */
+					       const USHORT input[], /* Array of input values--start with second glyph */
+					       unsigned int lookaheadCount,
+					       const USHORT lookahead[],
+					       unsigned int lookupCount,
+					       const LookupRecord lookupRecord[],
+					       ChainContextApplyLookupContext &lookup_context)
+{
+  /* First guess */
+  if (unlikely (c->buffer->backtrack_len () < backtrackCount ||
+		c->buffer->idx + inputCount + lookaheadCount > c->buffer->len ||
+		inputCount + lookaheadCount > c->context_length))
+    return false;
+
+  hb_apply_context_t new_context = *c;
+  return match_backtrack (c,
+			  backtrackCount, backtrack,
+			  lookup_context.funcs.match, lookup_context.match_data[0])
+      && match_input (c,
+		      inputCount, input,
+		      lookup_context.funcs.match, lookup_context.match_data[1],
+		      &new_context.context_length)
+      && match_lookahead (c,
+			  lookaheadCount, lookahead,
+			  lookup_context.funcs.match, lookup_context.match_data[2],
+			  new_context.context_length)
+      && apply_lookup (&new_context,
+		       inputCount,
+		       lookupCount, lookupRecord,
+		       lookup_context.funcs.apply);
+}
+
+struct ChainRule
+{
+  friend struct ChainRuleSet;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const
+  {
+    TRACE_CLOSURE ();
+    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
+    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    chain_context_closure_lookup (c,
+				  backtrack.len, backtrack.array,
+				  input.len, input.array,
+				  lookahead.len, lookahead.array,
+				  lookup.len, lookup.array,
+				  lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_APPLY ();
+    const HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
+    const ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    return chain_context_apply_lookup (c,
+				       backtrack.len, backtrack.array,
+				       input.len, input.array,
+				       lookahead.len, lookahead.array,
+				       lookup.len, lookup.array,
+				       lookup_context);
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!backtrack.sanitize (c)) return false;
+    HeadlessArrayOf<USHORT> &input = StructAfter<HeadlessArrayOf<USHORT> > (backtrack);
+    if (!input.sanitize (c)) return false;
+    ArrayOf<USHORT> &lookahead = StructAfter<ArrayOf<USHORT> > (input);
+    if (!lookahead.sanitize (c)) return false;
+    ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    return lookup.sanitize (c);
+  }
+
+  private:
+  ArrayOf<USHORT>
+		backtrack;		/* Array of backtracking values
+					 * (to be matched before the input
+					 * sequence) */
+  HeadlessArrayOf<USHORT>
+		inputX;			/* Array of input values (start with
+					 * second glyph) */
+  ArrayOf<USHORT>
+		lookaheadX;		/* Array of lookahead values's (to be
+					 * matched after the input sequence) */
+  ArrayOf<LookupRecord>
+		lookupX;		/* Array of LookupRecords--in
+					 * design order) */
+  public:
+  DEFINE_SIZE_MIN (8);
+};
+
+struct ChainRuleSet
+{
+  inline void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const
+  {
+    TRACE_CLOSURE ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+      (this+rule[i]).closure (c, lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const
+  {
+    TRACE_APPLY ();
+    unsigned int num_rules = rule.len;
+    for (unsigned int i = 0; i < num_rules; i++)
+    {
+      if ((this+rule[i]).apply (c, lookup_context))
+        return true;
+    }
+
+    return false;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return rule.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<ChainRule>
+		rule;			/* Array of ChainRule tables
+					 * ordered by preference */
+  public:
+  DEFINE_SIZE_ARRAY (2, rule);
+};
+
+struct ChainContextFormat1
+{
+  friend struct ChainContext;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    const Coverage &cov = (this+coverage);
+
+    struct ChainContextClosureLookupContext lookup_context = {
+      {intersects_glyph, closure_func},
+      {NULL, NULL, NULL}
+    };
+
+    unsigned int count = ruleSet.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (cov.intersects_coverage (c->glyphs, i)) {
+	const ChainRuleSet &rule_set = this+ruleSet[i];
+	rule_set.closure (c, lookup_context);
+      }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const ChainRuleSet &rule_set = this+ruleSet[index];
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_glyph, apply_func},
+      {NULL, NULL, NULL}
+    };
+    return rule_set.apply (c, lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ruleSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetArrayOf<ChainRuleSet>
+		ruleSet;		/* Array of ChainRuleSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, ruleSet);
+};
+
+struct ChainContextFormat2
+{
+  friend struct ChainContext;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    if (!(this+coverage).intersects (c->glyphs))
+      return;
+
+    const ClassDef &backtrack_class_def = this+backtrackClassDef;
+    const ClassDef &input_class_def = this+inputClassDef;
+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;
+
+    struct ChainContextClosureLookupContext lookup_context = {
+      {intersects_class, closure_func},
+      {&backtrack_class_def,
+       &input_class_def,
+       &lookahead_class_def}
+    };
+
+    unsigned int count = ruleSet.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (input_class_def.intersects_class (c->glyphs, i)) {
+	const ChainRuleSet &rule_set = this+ruleSet[i];
+	rule_set.closure (c, lookup_context);
+      }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const ClassDef &backtrack_class_def = this+backtrackClassDef;
+    const ClassDef &input_class_def = this+inputClassDef;
+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;
+
+    index = input_class_def (c->buffer->info[c->buffer->idx].codepoint);
+    const ChainRuleSet &rule_set = this+ruleSet[index];
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_class, apply_func},
+      {&backtrack_class_def,
+       &input_class_def,
+       &lookahead_class_def}
+    };
+    return rule_set.apply (c, lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& backtrackClassDef.sanitize (c, this)
+	&& inputClassDef.sanitize (c, this)
+	&& lookaheadClassDef.sanitize (c, this)
+	&& ruleSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetTo<ClassDef>
+		backtrackClassDef;	/* Offset to glyph ClassDef table
+					 * containing backtrack sequence
+					 * data--from beginning of table */
+  OffsetTo<ClassDef>
+		inputClassDef;		/* Offset to glyph ClassDef
+					 * table containing input sequence
+					 * data--from beginning of table */
+  OffsetTo<ClassDef>
+		lookaheadClassDef;	/* Offset to glyph ClassDef table
+					 * containing lookahead sequence
+					 * data--from beginning of table */
+  OffsetArrayOf<ChainRuleSet>
+		ruleSet;		/* Array of ChainRuleSet tables
+					 * ordered by class */
+  public:
+  DEFINE_SIZE_ARRAY (12, ruleSet);
+};
+
+struct ChainContextFormat3
+{
+  friend struct ChainContext;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+
+    if (!(this+input[0]).intersects (c->glyphs))
+      return;
+
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    struct ChainContextClosureLookupContext lookup_context = {
+      {intersects_coverage, closure_func},
+      {this, this, this}
+    };
+    chain_context_closure_lookup (c,
+				  backtrack.len, (const USHORT *) backtrack.array,
+				  input.len, (const USHORT *) input.array + 1,
+				  lookahead.len, (const USHORT *) lookahead.array,
+				  lookup.len, lookup.array,
+				  lookup_context);
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+
+    unsigned int index = (this+input[0]) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);
+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    struct ChainContextApplyLookupContext lookup_context = {
+      {match_coverage, apply_func},
+      {this, this, this}
+    };
+    return chain_context_apply_lookup (c,
+				       backtrack.len, (const USHORT *) backtrack.array,
+				       input.len, (const USHORT *) input.array + 1,
+				       lookahead.len, (const USHORT *) lookahead.array,
+				       lookup.len, lookup.array,
+				       lookup_context);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!backtrack.sanitize (c, this)) return false;
+    OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    if (!input.sanitize (c, this)) return false;
+    OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);
+    if (!lookahead.sanitize (c, this)) return false;
+    ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);
+    return lookup.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 3 */
+  OffsetArrayOf<Coverage>
+		backtrack;		/* Array of coverage tables
+					 * in backtracking sequence, in  glyph
+					 * sequence order */
+  OffsetArrayOf<Coverage>
+		inputX		;	/* Array of coverage
+					 * tables in input sequence, in glyph
+					 * sequence order */
+  OffsetArrayOf<Coverage>
+		lookaheadX;		/* Array of coverage tables
+					 * in lookahead sequence, in glyph
+					 * sequence order */
+  ArrayOf<LookupRecord>
+		lookupX;		/* Array of LookupRecords--in
+					 * design order) */
+  public:
+  DEFINE_SIZE_MIN (10);
+};
+
+struct ChainContext
+{
+  protected:
+
+  inline void closure (hb_closure_context_t *c, closure_lookup_func_t closure_func) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c, closure_func); break;
+    case 2: u.format2.closure (c, closure_func); break;
+    case 3: u.format3.closure (c, closure_func); break;
+    default:                                     break;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c, apply_lookup_func_t apply_func) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c, apply_func);
+    case 2: return u.format2.apply (c, apply_func);
+    case 3: return u.format3.apply (c, apply_func);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    case 3: return u.format3.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;	/* Format identifier */
+  ChainContextFormat1	format1;
+  ChainContextFormat2	format2;
+  ChainContextFormat3	format3;
+  } u;
+};
+
+
+struct ExtensionFormat1
+{
+  friend struct Extension;
+
+  protected:
+  inline unsigned int get_type (void) const { return extensionLookupType; }
+  inline unsigned int get_offset (void) const { return extensionOffset; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier. Set to 1. */
+  USHORT	extensionLookupType;	/* Lookup type of subtable referenced
+					 * by ExtensionOffset (i.e. the
+					 * extension subtable). */
+  ULONG		extensionOffset;	/* Offset to the extension subtable,
+					 * of lookup type subtable. */
+  public:
+  DEFINE_SIZE_STATIC (8);
+};
+
+struct Extension
+{
+  inline unsigned int get_type (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_type ();
+    default:return 0;
+    }
+  }
+  inline unsigned int get_offset (void) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.get_offset ();
+    default:return 0;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  ExtensionFormat1	format1;
+  } u;
+};
+
+
+/*
+ * GSUB/GPOS Common
+ */
+
+struct GSUBGPOS
+{
+  static const hb_tag_t GSUBTag	= HB_OT_TAG_GSUB;
+  static const hb_tag_t GPOSTag	= HB_OT_TAG_GPOS;
+
+  inline unsigned int get_script_count (void) const
+  { return (this+scriptList).len; }
+  inline const Tag& get_script_tag (unsigned int i) const
+  { return (this+scriptList).get_tag (i); }
+  inline unsigned int get_script_tags (unsigned int start_offset,
+				       unsigned int *script_count /* IN/OUT */,
+				       hb_tag_t     *script_tags /* OUT */) const
+  { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }
+  inline const Script& get_script (unsigned int i) const
+  { return (this+scriptList)[i]; }
+  inline bool find_script_index (hb_tag_t tag, unsigned int *index) const
+  { return (this+scriptList).find_index (tag, index); }
+
+  inline unsigned int get_feature_count (void) const
+  { return (this+featureList).len; }
+  inline const Tag& get_feature_tag (unsigned int i) const
+  { return (this+featureList).get_tag (i); }
+  inline unsigned int get_feature_tags (unsigned int start_offset,
+					unsigned int *feature_count /* IN/OUT */,
+					hb_tag_t     *feature_tags /* OUT */) const
+  { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }
+  inline const Feature& get_feature (unsigned int i) const
+  { return (this+featureList)[i]; }
+  inline bool find_feature_index (hb_tag_t tag, unsigned int *index) const
+  { return (this+featureList).find_index (tag, index); }
+
+  inline unsigned int get_lookup_count (void) const
+  { return (this+lookupList).len; }
+  inline const Lookup& get_lookup (unsigned int i) const
+  { return (this+lookupList)[i]; }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return version.sanitize (c) && likely (version.major == 1)
+	&& scriptList.sanitize (c, this)
+	&& featureList.sanitize (c, this)
+	&& lookupList.sanitize (c, this);
+  }
+
+  protected:
+  FixedVersion	version;	/* Version of the GSUB/GPOS table--initially set
+				 * to 0x00010000 */
+  OffsetTo<ScriptList>
+		scriptList;  	/* ScriptList table */
+  OffsetTo<FeatureList>
+		featureList; 	/* FeatureList table */
+  OffsetTo<LookupList>
+		lookupList; 	/* LookupList table */
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+
+
+#endif /* HB_OT_LAYOUT_GSUBGPOS_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-private.hh	2012-05-05 23:46:51.525763796 +0530
@@ -0,0 +1,944 @@
+/*
+ * Copyright (C) 2007,2008,2009,2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GSUB_PRIVATE_HH
+#define HB_OT_LAYOUT_GSUB_PRIVATE_HH
+
+#include "hb-ot-layout-gsubgpos-private.hh"
+
+HB_BEGIN_DECLS
+
+
+struct SingleSubstFormat1
+{
+  friend struct SingleSubst;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->i].codepoint;
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    glyph_id += deltaGlyphID;
+    c->buffer->replace_glyph (glyph_id);
+
+    /* We inherit the old glyph class to the substituted glyph */
+    if (_hb_ot_layout_has_new_glyph_classes (c->layout->face))
+      _hb_ot_layout_set_glyph_property (c->layout->face, glyph_id, c->property);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& deltaGlyphID.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  SHORT		deltaGlyphID;		/* Add to original GlyphID to get
+					 * substitute GlyphID */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct SingleSubstFormat2
+{
+  friend struct SingleSubst;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->i].codepoint;
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (unlikely (index >= substitute.len))
+      return false;
+
+    glyph_id = substitute[index];
+    c->buffer->replace_glyph (glyph_id);
+
+    /* We inherit the old glyph class to the substituted glyph */
+    if (_hb_ot_layout_has_new_glyph_classes (c->layout->face))
+      _hb_ot_layout_set_glyph_property (c->layout->face, glyph_id, c->property);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& substitute.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  ArrayOf<GlyphID>
+		substitute;		/* Array of substitute
+					 * GlyphIDs--ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, substitute);
+};
+
+struct SingleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  SingleSubstFormat1	format1;
+  SingleSubstFormat2	format2;
+  } u;
+};
+
+
+struct Sequence
+{
+  friend struct MultipleSubstFormat1;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    if (unlikely (!substitute.len))
+      return false;
+
+    c->buffer->add_output_glyphs_be16 (1,
+				       substitute.len, (const uint16_t *) substitute.array,
+				       0xFFFF, 0xFFFF);
+
+    /* This is a guess only ... */
+    if (_hb_ot_layout_has_new_glyph_classes (c->layout->face))
+    {
+      unsigned int property = c->property;
+      if (property == HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE)
+        property = HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH;
+
+      unsigned int count = substitute.len;
+      for (unsigned int n = 0; n < count; n++)
+	_hb_ot_layout_set_glyph_property (c->layout->face, substitute[n], property);
+    }
+
+    return true;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return substitute.sanitize (c);
+  }
+
+  private:
+  ArrayOf<GlyphID>
+		substitute;		/* String of GlyphIDs to substitute */
+  public:
+  DEFINE_SIZE_ARRAY (2, substitute);
+};
+
+struct MultipleSubstFormat1
+{
+  friend struct MultipleSubst;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    return (this+sequence[index]).apply (c);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& sequence.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<Sequence>
+		sequence;		/* Array of Sequence tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, sequence);
+};
+
+struct MultipleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MultipleSubstFormat1	format1;
+  } u;
+};
+
+
+typedef ArrayOf<GlyphID> AlternateSet;	/* Array of alternate GlyphIDs--in
+					 * arbitrary order */
+
+struct AlternateSubstFormat1
+{
+  friend struct AlternateSubst;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->i].codepoint;
+    hb_mask_t glyph_mask = c->buffer->info[c->buffer->i].mask;
+    hb_mask_t lookup_mask = c->lookup_mask;
+
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const AlternateSet &alt_set = this+alternateSet[index];
+
+    if (unlikely (!alt_set.len))
+      return false;
+
+    /* Note: This breaks badly if two features enabled this lookup together. */
+    unsigned int shift = _hb_ctz (lookup_mask);
+    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);
+
+    if (unlikely (alt_index > alt_set.len || alt_index == 0))
+      return false;
+
+    glyph_id = alt_set[alt_index - 1];
+
+    c->buffer->replace_glyph (glyph_id);
+
+    /* We inherit the old glyph class to the substituted glyph */
+    if (_hb_ot_layout_has_new_glyph_classes (c->layout->face))
+      _hb_ot_layout_set_glyph_property (c->layout->face, glyph_id, c->property);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& alternateSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<AlternateSet>
+		alternateSet;		/* Array of AlternateSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, alternateSet);
+};
+
+struct AlternateSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  AlternateSubstFormat1	format1;
+  } u;
+};
+
+
+struct Ligature
+{
+  friend struct LigatureSet;
+
+  private:
+  inline bool apply (hb_apply_context_t *c, bool is_mark) const
+  {
+    TRACE_APPLY ();
+    unsigned int i, j;
+    unsigned int count = component.len;
+    unsigned int end = MIN (c->buffer->len, c->buffer->i + c->context_length);
+    if (unlikely (c->buffer->i + count > end))
+      return false;
+
+    for (i = 1, j = c->buffer->i + 1; i < count; i++, j++)
+    {
+      unsigned int property;
+      while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[j], c->lookup_flag, &property))
+      {
+	if (unlikely (j + count - i == end))
+	  return false;
+	j++;
+      }
+
+      if (!(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK))
+	is_mark = false;
+
+      if (likely (c->buffer->info[j].codepoint != component[i]))
+        return false;
+    }
+    /* This is just a guess ... */
+    if (_hb_ot_layout_has_new_glyph_classes (c->layout->face))
+      _hb_ot_layout_set_glyph_class (c->layout->face, ligGlyph,
+				     is_mark ? HB_OT_LAYOUT_GLYPH_CLASS_MARK
+					     : HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE);
+
+    if (j == c->buffer->i + i) /* No input glyphs skipped */
+      /* We don't use a new ligature ID if there are no skipped
+	 glyphs and the ligature already has an ID. */
+      c->buffer->add_output_glyphs_be16 (i,
+					 1, (const uint16_t *) &ligGlyph,
+					 0,
+					 c->buffer->info[c->buffer->i].lig_id && !c->buffer->info[c->buffer->i].component ?
+					 0xFFFF : c->buffer->allocate_lig_id ());
+    else
+    {
+      unsigned int lig_id = c->buffer->allocate_lig_id ();
+      c->buffer->add_output_glyph (ligGlyph, 0xFFFF, lig_id);
+
+      /* Now we must do a second loop to copy the skipped glyphs to
+	 `out' and assign component values to it.  We start with the
+	 glyph after the first component.  Glyphs between component
+	 i and i+1 belong to component i.  Together with the lig_id
+	 value it is later possible to check whether a specific
+	 component value really belongs to a given ligature. */
+
+      for ( i = 1; i < count; i++ )
+      {
+	while (_hb_ot_layout_skip_mark (c->layout->face, &c->buffer->info[c->buffer->i], c->lookup_flag, NULL))
+	  c->buffer->add_output_glyph (c->buffer->info[c->buffer->i].codepoint, i, lig_id);
+
+	(c->buffer->i)++;
+      }
+    }
+
+    return true;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ligGlyph.sanitize (c)
+        && component.sanitize (c);
+  }
+
+  private:
+  GlyphID	ligGlyph;		/* GlyphID of ligature to substitute */
+  HeadlessArrayOf<GlyphID>
+		component;		/* Array of component GlyphIDs--start
+					 * with the second  component--ordered
+					 * in writing direction */
+  public:
+  DEFINE_SIZE_ARRAY (4, component);
+};
+
+struct LigatureSet
+{
+  friend struct LigatureSubstFormat1;
+
+  private:
+  inline bool apply (hb_apply_context_t *c, bool is_mark) const
+  {
+    TRACE_APPLY ();
+    unsigned int num_ligs = ligature.len;
+    for (unsigned int i = 0; i < num_ligs; i++)
+    {
+      const Ligature &lig = this+ligature[i];
+      if (lig.apply (c, is_mark))
+        return true;
+    }
+
+    return false;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ligature.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<Ligature>
+		ligature;		/* Array LigatureSet tables
+					 * ordered by preference */
+  public:
+  DEFINE_SIZE_ARRAY (2, ligature);
+};
+
+struct LigatureSubstFormat1
+{
+  friend struct LigatureSubst;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->i].codepoint;
+
+    bool first_is_mark = !!(c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const LigatureSet &lig_set = this+ligatureSet[index];
+    return lig_set.apply (c, first_is_mark);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ligatureSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<LigatureSet>
+		ligatureSet;		/* Array LigatureSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, ligatureSet);
+};
+
+struct LigatureSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  LigatureSubstFormat1	format1;
+  } u;
+};
+
+
+HB_BEGIN_DECLS
+static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index);
+HB_END_DECLS
+
+struct ContextSubst : Context
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return Context::apply (c, substitute_lookup);
+  }
+};
+
+struct ChainContextSubst : ChainContext
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return ChainContext::apply (c, substitute_lookup);
+  }
+};
+
+
+struct ExtensionSubst : Extension
+{
+  friend struct SubstLookupSubTable;
+  friend struct SubstLookup;
+
+  private:
+  inline const struct SubstLookupSubTable& get_subtable (void) const
+  {
+    unsigned int offset = get_offset ();
+    if (unlikely (!offset)) return Null(SubstLookupSubTable);
+    return StructAtOffset<SubstLookupSubTable> (this, offset);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const;
+
+  inline bool sanitize (hb_sanitize_context_t *c);
+
+  inline bool is_reverse (void) const;
+};
+
+
+struct ReverseChainSingleSubstFormat1
+{
+  friend struct ReverseChainSingleSubst;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    if (unlikely (c->context_length != NO_CONTEXT))
+      return false; /* No chaining to this type */
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->i].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
+
+    if (match_backtrack (c,
+			 backtrack.len, (USHORT *) backtrack.array,
+			 match_coverage, this) &&
+        match_lookahead (c,
+			 lookahead.len, (USHORT *) lookahead.array,
+			 match_coverage, this,
+			 1))
+    {
+      c->buffer->info[c->buffer->i].codepoint = substitute[index];
+      c->buffer->i--; /* Reverse! */
+      return true;
+    }
+
+    return false;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!(coverage.sanitize (c, this)
+       && backtrack.sanitize (c, this)))
+      return false;
+    OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    if (!lookahead.sanitize (c, this))
+      return false;
+    ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
+    return substitute.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetArrayOf<Coverage>
+		backtrack;		/* Array of coverage tables
+					 * in backtracking sequence, in  glyph
+					 * sequence order */
+  OffsetArrayOf<Coverage>
+		lookaheadX;		/* Array of coverage tables
+					 * in lookahead sequence, in glyph
+					 * sequence order */
+  ArrayOf<GlyphID>
+		substituteX;		/* Array of substitute
+					 * GlyphIDs--ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_MIN (10);
+};
+
+struct ReverseChainSingleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT				format;		/* Format identifier */
+  ReverseChainSingleSubstFormat1	format1;
+  } u;
+};
+
+
+
+/*
+ * SubstLookup
+ */
+
+struct SubstLookupSubTable
+{
+  friend struct SubstLookup;
+
+  enum {
+    Single		= 1,
+    Multiple		= 2,
+    Alternate		= 3,
+    Ligature		= 4,
+    Context		= 5,
+    ChainContext	= 6,
+    Extension		= 7,
+    ReverseChainSingle	= 8
+  };
+
+  inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
+  {
+    TRACE_APPLY ();
+    switch (lookup_type) {
+    case Single:		return u.single.apply (c);
+    case Multiple:		return u.multiple.apply (c);
+    case Alternate:		return u.alternate.apply (c);
+    case Ligature:		return u.ligature.apply (c);
+    case Context:		return u.c.apply (c);
+    case ChainContext:		return u.chainContext.apply (c);
+    case Extension:		return u.extension.apply (c);
+    case ReverseChainSingle:	return u.reverseChainContextSingle.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
+    TRACE_SANITIZE ();
+    switch (lookup_type) {
+    case Single:		return u.single.sanitize (c);
+    case Multiple:		return u.multiple.sanitize (c);
+    case Alternate:		return u.alternate.sanitize (c);
+    case Ligature:		return u.ligature.sanitize (c);
+    case Context:		return u.c.sanitize (c);
+    case ChainContext:		return u.chainContext.sanitize (c);
+    case Extension:		return u.extension.sanitize (c);
+    case ReverseChainSingle:	return u.reverseChainContextSingle.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT			sub_format;
+  SingleSubst			single;
+  MultipleSubst			multiple;
+  AlternateSubst		alternate;
+  LigatureSubst			ligature;
+  ContextSubst			c;
+  ChainContextSubst		chainContext;
+  ExtensionSubst		extension;
+  ReverseChainSingleSubst	reverseChainContextSingle;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, sub_format);
+};
+
+
+struct SubstLookup : Lookup
+{
+  inline const SubstLookupSubTable& get_subtable (unsigned int i) const
+  { return this+CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable)[i]; }
+
+  inline static bool lookup_type_is_reverse (unsigned int lookup_type)
+  { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }
+
+  inline bool is_reverse (void) const
+  {
+    unsigned int type = get_type ();
+    if (unlikely (type == SubstLookupSubTable::Extension))
+      return CastR<ExtensionSubst> (get_subtable(0)).is_reverse ();
+    return lookup_type_is_reverse (type);
+  }
+
+
+  inline bool apply_once (hb_ot_layout_context_t *layout,
+			  hb_buffer_t *buffer,
+			  hb_mask_t lookup_mask,
+			  unsigned int context_length,
+			  unsigned int nesting_level_left) const
+  {
+    unsigned int lookup_type = get_type ();
+    hb_apply_context_t c[1] = {{0}};
+
+    c->layout = layout;
+    c->buffer = buffer;
+    c->lookup_mask = lookup_mask;
+    c->context_length = context_length;
+    c->nesting_level_left = nesting_level_left;
+    c->lookup_flag = get_flag ();
+
+    if (!_hb_ot_layout_check_glyph_property (c->layout->face, &c->buffer->info[c->buffer->i], c->lookup_flag, &c->property))
+      return false;
+
+    if (unlikely (lookup_type == SubstLookupSubTable::Extension))
+    {
+      /* The spec says all subtables should have the same type.
+       * This is specially important if one has a reverse type!
+       *
+       * This is rather slow to do this here for every glyph,
+       * but it's easiest, and who uses extension lookups anyway?!*/
+      unsigned int count = get_subtable_count ();
+      unsigned int type = get_subtable(0).u.extension.get_type ();
+      for (unsigned int i = 1; i < count; i++)
+        if (get_subtable(i).u.extension.get_type () != type)
+	  return false;
+    }
+
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
+      if (get_subtable (i).apply (c, lookup_type))
+	return true;
+
+    return false;
+  }
+
+  inline bool apply_string (hb_ot_layout_context_t *layout,
+			    hb_buffer_t *buffer,
+			    hb_mask_t    mask) const
+  {
+    bool ret = false;
+
+    if (unlikely (!buffer->len))
+      return false;
+
+    if (likely (!is_reverse ()))
+    {
+	/* in/out forward substitution */
+	buffer->clear_output ();
+	buffer->i = 0;
+	while (buffer->i < buffer->len)
+	{
+	  if ((buffer->info[buffer->i].mask & mask) &&
+	      apply_once (layout, buffer, mask, NO_CONTEXT, MAX_NESTING_LEVEL))
+	    ret = true;
+	  else
+	    buffer->next_glyph ();
+
+	}
+	if (ret)
+	  buffer->swap ();
+    }
+    else
+    {
+	/* in-place backward substitution */
+	buffer->i = buffer->len - 1;
+	do
+	{
+	  if ((buffer->info[buffer->i].mask & mask) &&
+	      apply_once (layout, buffer, mask, NO_CONTEXT, MAX_NESTING_LEVEL))
+	    ret = true;
+	  else
+	    buffer->i--;
+
+	}
+	while ((int) buffer->i >= 0);
+    }
+
+    return ret;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!Lookup::sanitize (c))) return false;
+    OffsetArrayOf<SubstLookupSubTable> &list = CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable);
+    return list.sanitize (c, this, get_type ());
+  }
+};
+
+typedef OffsetListOf<SubstLookup> SubstLookupList;
+
+/*
+ * GSUB
+ */
+
+struct GSUB : GSUBGPOS
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GSUB;
+
+  inline const SubstLookup& get_lookup (unsigned int i) const
+  { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }
+
+  inline bool substitute_lookup (hb_ot_layout_context_t *layout,
+				 hb_buffer_t  *buffer,
+			         unsigned int  lookup_index,
+				 hb_mask_t     mask) const
+  { return get_lookup (lookup_index).apply_string (layout, buffer, mask); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!GSUBGPOS::sanitize (c))) return false;
+    OffsetTo<SubstLookupList> &list = CastR<OffsetTo<SubstLookupList> > (lookupList);
+    return list.sanitize (c, this);
+  }
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+
+/* Out-of-class implementation for methods recursing */
+
+inline bool ExtensionSubst::apply (hb_apply_context_t *c) const
+{
+  TRACE_APPLY ();
+  return get_subtable ().apply (c, get_type ());
+}
+
+inline bool ExtensionSubst::sanitize (hb_sanitize_context_t *c)
+{
+  TRACE_SANITIZE ();
+  if (unlikely (!Extension::sanitize (c))) return false;
+  unsigned int offset = get_offset ();
+  if (unlikely (!offset)) return true;
+  return StructAtOffset<SubstLookupSubTable> (this, offset).sanitize (c, get_type ());
+}
+
+inline bool ExtensionSubst::is_reverse (void) const
+{
+  unsigned int type = get_type ();
+  if (unlikely (type == SubstLookupSubTable::Extension))
+    return CastR<ExtensionSubst> (get_subtable()).is_reverse ();
+  return SubstLookup::lookup_type_is_reverse (type);
+}
+
+static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index)
+{
+  const GSUB &gsub = *(c->layout->face->ot_layout->gsub);
+  const SubstLookup &l = gsub.get_lookup (lookup_index);
+
+  if (unlikely (c->nesting_level_left == 0))
+    return false;
+
+  if (unlikely (c->context_length < 1))
+    return false;
+
+  return l.apply_once (c->layout, c->buffer, c->lookup_mask, c->context_length, c->nesting_level_left - 1);
+}
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_LAYOUT_GSUB_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-gsub-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,1282 @@
+/*
+ * Copyright  2007,2008,2009,2010  Red Hat, Inc.
+ * Copyright  2010,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
+#define HB_OT_LAYOUT_GSUB_TABLE_HH
+
+#include "hb-ot-layout-gsubgpos-private.hh"
+
+
+
+struct SingleSubstFormat1
+{
+  friend struct SingleSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      hb_codepoint_t glyph_id = iter.get_glyph ();
+      if (c->glyphs->has (glyph_id))
+	c->glyphs->add ((glyph_id + deltaGlyphID) & 0xFFFF);
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    return (this+coverage) (glyph_id) != NOT_COVERED;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->idx].codepoint;
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    /* According to the Adobe Annotated OpenType Suite, result is always
+     * limited to 16bit. */
+    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFF;
+    c->replace_glyph (glyph_id);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& deltaGlyphID.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  SHORT		deltaGlyphID;		/* Add to original GlyphID to get
+					 * substitute GlyphID */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+struct SingleSubstFormat2
+{
+  friend struct SingleSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      if (c->glyphs->has (iter.get_glyph ()))
+	c->glyphs->add (substitute[iter.get_coverage ()]);
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    return (this+coverage) (glyph_id) != NOT_COVERED;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->idx].codepoint;
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    if (unlikely (index >= substitute.len))
+      return false;
+
+    glyph_id = substitute[index];
+    c->replace_glyph (glyph_id);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& substitute.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 2 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  ArrayOf<GlyphID>
+		substitute;		/* Array of substitute
+					 * GlyphIDs--ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, substitute);
+};
+
+struct SingleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c); break;
+    case 2: u.format2.closure (c); break;
+    default:                       break;
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (glyph_id);
+    case 2: return u.format2.would_apply (glyph_id);
+    default:return false;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    case 2: return u.format2.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    case 2: return u.format2.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  SingleSubstFormat1	format1;
+  SingleSubstFormat2	format2;
+  } u;
+};
+
+
+struct Sequence
+{
+  friend struct MultipleSubstFormat1;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    unsigned int count = substitute.len;
+    for (unsigned int i = 0; i < count; i++)
+      c->glyphs->add (substitute[i]);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    if (unlikely (!substitute.len))
+      return false;
+
+    if (c->property & HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE)
+      c->guess_glyph_class (HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH);
+    c->replace_glyphs_be16 (1, substitute.len, (const uint16_t *) substitute.array);
+
+    return true;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return substitute.sanitize (c);
+  }
+
+  private:
+  ArrayOf<GlyphID>
+		substitute;		/* String of GlyphIDs to substitute */
+  public:
+  DEFINE_SIZE_ARRAY (2, substitute);
+};
+
+struct MultipleSubstFormat1
+{
+  friend struct MultipleSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      if (c->glyphs->has (iter.get_glyph ()))
+	(this+sequence[iter.get_coverage ()]).closure (c);
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    return (this+coverage) (glyph_id) != NOT_COVERED;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    return (this+sequence[index]).apply (c);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& sequence.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<Sequence>
+		sequence;		/* Array of Sequence tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, sequence);
+};
+
+struct MultipleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c); break;
+    default:                       break;
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (glyph_id);
+    default:return false;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  MultipleSubstFormat1	format1;
+  } u;
+};
+
+
+typedef ArrayOf<GlyphID> AlternateSet;	/* Array of alternate GlyphIDs--in
+					 * arbitrary order */
+
+struct AlternateSubstFormat1
+{
+  friend struct AlternateSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      if (c->glyphs->has (iter.get_glyph ())) {
+	const AlternateSet &alt_set = this+alternateSet[iter.get_coverage ()];
+	unsigned int count = alt_set.len;
+	for (unsigned int i = 0; i < count; i++)
+	  c->glyphs->add (alt_set[i]);
+      }
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    return (this+coverage) (glyph_id) != NOT_COVERED;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->idx].codepoint;
+
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const AlternateSet &alt_set = this+alternateSet[index];
+
+    if (unlikely (!alt_set.len))
+      return false;
+
+    hb_mask_t glyph_mask = c->buffer->info[c->buffer->idx].mask;
+    hb_mask_t lookup_mask = c->lookup_mask;
+
+    /* Note: This breaks badly if two features enabled this lookup together. */
+    unsigned int shift = _hb_ctz (lookup_mask);
+    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);
+
+    if (unlikely (alt_index > alt_set.len || alt_index == 0))
+      return false;
+
+    glyph_id = alt_set[alt_index - 1];
+
+    c->replace_glyph (glyph_id);
+
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& alternateSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<AlternateSet>
+		alternateSet;		/* Array of AlternateSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, alternateSet);
+};
+
+struct AlternateSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c); break;
+    default:                       break;
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (glyph_id);
+    default:return false;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  AlternateSubstFormat1	format1;
+  } u;
+};
+
+
+struct Ligature
+{
+  friend struct LigatureSet;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    unsigned int count = component.len;
+    for (unsigned int i = 1; i < count; i++)
+      if (!c->glyphs->has (component[i]))
+        return;
+    c->glyphs->add (ligGlyph);
+  }
+
+  inline bool would_apply (hb_codepoint_t second) const
+  {
+    return component.len == 2 && component[1] == second;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int count = component.len;
+    if (unlikely (count < 2))
+      return false;
+
+    hb_apply_context_t::mark_skipping_forward_iterator_t skippy_iter (c, c->buffer->idx, count - 1);
+    if (skippy_iter.has_no_chance ())
+      return false;
+
+    bool first_was_mark = (c->property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+    bool found_non_mark = false;
+
+    for (unsigned int i = 1; i < count; i++)
+    {
+      unsigned int property;
+
+      if (!skippy_iter.next (&property))
+	return false;
+
+      found_non_mark |= !(property & HB_OT_LAYOUT_GLYPH_CLASS_MARK);
+
+      if (likely (c->buffer->info[skippy_iter.idx].codepoint != component[i]))
+        return false;
+    }
+
+    if (first_was_mark && found_non_mark)
+      c->guess_glyph_class (HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE);
+
+    /* Allocate new ligature id */
+    unsigned int lig_id = allocate_lig_id (c->buffer);
+    c->buffer->info[c->buffer->idx].lig_comp() = 0;
+    c->buffer->info[c->buffer->idx].lig_id() = lig_id;
+
+    if (skippy_iter.idx < c->buffer->idx + count) /* No input glyphs skipped */
+    {
+      c->replace_glyphs_be16 (count, 1, (const uint16_t *) &ligGlyph);
+    }
+    else
+    {
+      c->replace_glyph (ligGlyph);
+
+      /* Now we must do a second loop to copy the skipped glyphs to
+	 `out' and assign component values to it.  We start with the
+	 glyph after the first component.  Glyphs between component
+	 i and i+1 belong to component i.  Together with the lig_id
+	 value it is later possible to check whether a specific
+	 component value really belongs to a given ligature. */
+
+      for (unsigned int i = 1; i < count; i++)
+      {
+	while (c->should_mark_skip_current_glyph ())
+	{
+	  c->buffer->info[c->buffer->idx].lig_comp() = i;
+	  c->buffer->info[c->buffer->idx].lig_id() = lig_id;
+	  c->replace_glyph (c->buffer->info[c->buffer->idx].codepoint);
+	}
+
+	/* Skip the base glyph */
+	c->buffer->idx++;
+      }
+    }
+
+    return true;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ligGlyph.sanitize (c)
+        && component.sanitize (c);
+  }
+
+  private:
+  GlyphID	ligGlyph;		/* GlyphID of ligature to substitute */
+  HeadlessArrayOf<GlyphID>
+		component;		/* Array of component GlyphIDs--start
+					 * with the second  component--ordered
+					 * in writing direction */
+  public:
+  DEFINE_SIZE_ARRAY (4, component);
+};
+
+struct LigatureSet
+{
+  friend struct LigatureSubstFormat1;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    unsigned int num_ligs = ligature.len;
+    for (unsigned int i = 0; i < num_ligs; i++)
+      (this+ligature[i]).closure (c);
+  }
+
+  inline bool would_apply (hb_codepoint_t second) const
+  {
+    unsigned int num_ligs = ligature.len;
+    for (unsigned int i = 0; i < num_ligs; i++)
+    {
+      const Ligature &lig = this+ligature[i];
+      if (lig.would_apply (second))
+        return true;
+    }
+    return false;
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    unsigned int num_ligs = ligature.len;
+    for (unsigned int i = 0; i < num_ligs; i++)
+    {
+      const Ligature &lig = this+ligature[i];
+      if (lig.apply (c))
+        return true;
+    }
+
+    return false;
+  }
+
+  public:
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return ligature.sanitize (c, this);
+  }
+
+  private:
+  OffsetArrayOf<Ligature>
+		ligature;		/* Array LigatureSet tables
+					 * ordered by preference */
+  public:
+  DEFINE_SIZE_ARRAY (2, ligature);
+};
+
+struct LigatureSubstFormat1
+{
+  friend struct LigatureSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      if (c->glyphs->has (iter.get_glyph ()))
+	(this+ligatureSet[iter.get_coverage ()]).closure (c);
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+  {
+    unsigned int index;
+    return (index = (this+coverage) (first)) != NOT_COVERED &&
+	   (this+ligatureSet[index]).would_apply (second);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    hb_codepoint_t glyph_id = c->buffer->info[c->buffer->idx].codepoint;
+
+    unsigned int index = (this+coverage) (glyph_id);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const LigatureSet &lig_set = this+ligatureSet[index];
+    return lig_set.apply (c);
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return coverage.sanitize (c, this)
+	&& ligatureSet.sanitize (c, this);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of Substitution table */
+  OffsetArrayOf<LigatureSet>
+		ligatureSet;		/* Array LigatureSet tables
+					 * ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_ARRAY (6, ligatureSet);
+};
+
+struct LigatureSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c); break;
+    default:                       break;
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+  {
+    switch (u.format) {
+    case 1: return u.format1.would_apply (first, second);
+    default:return false;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT		format;		/* Format identifier */
+  LigatureSubstFormat1	format1;
+  } u;
+};
+
+
+static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index);
+static inline void closure_lookup (hb_closure_context_t *c, unsigned int lookup_index);
+
+struct ContextSubst : Context
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    return Context::closure (c, closure_lookup);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return Context::apply (c, substitute_lookup);
+  }
+};
+
+struct ChainContextSubst : ChainContext
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    return ChainContext::closure (c, closure_lookup);
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    return ChainContext::apply (c, substitute_lookup);
+  }
+};
+
+
+struct ExtensionSubst : Extension
+{
+  friend struct SubstLookupSubTable;
+  friend struct SubstLookup;
+
+  private:
+  inline const struct SubstLookupSubTable& get_subtable (void) const
+  {
+    unsigned int offset = get_offset ();
+    if (unlikely (!offset)) return Null(SubstLookupSubTable);
+    return StructAtOffset<SubstLookupSubTable> (this, offset);
+  }
+
+  inline void closure (hb_closure_context_t *c) const;
+  inline bool would_apply (hb_codepoint_t glyph_id) const;
+  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const;
+
+  inline bool apply (hb_apply_context_t *c) const;
+
+  inline bool sanitize (hb_sanitize_context_t *c);
+
+  inline bool is_reverse (void) const;
+};
+
+
+struct ReverseChainSingleSubstFormat1
+{
+  friend struct ReverseChainSingleSubst;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+
+    unsigned int count;
+
+    count = backtrack.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (!(this+backtrack[i]).intersects (c->glyphs))
+        return;
+
+    count = lookahead.len;
+    for (unsigned int i = 0; i < count; i++)
+      if (!(this+lookahead[i]).intersects (c->glyphs))
+        return;
+
+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
+    Coverage::Iter iter;
+    for (iter.init (this+coverage); iter.more (); iter.next ()) {
+      if (c->glyphs->has (iter.get_glyph ()))
+	c->glyphs->add (substitute[iter.get_coverage ()]);
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    if (unlikely (c->context_length != NO_CONTEXT))
+      return false; /* No chaining to this type */
+
+    unsigned int index = (this+coverage) (c->buffer->info[c->buffer->idx].codepoint);
+    if (likely (index == NOT_COVERED))
+      return false;
+
+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
+
+    if (match_backtrack (c,
+			 backtrack.len, (USHORT *) backtrack.array,
+			 match_coverage, this) &&
+        match_lookahead (c,
+			 lookahead.len, (USHORT *) lookahead.array,
+			 match_coverage, this,
+			 1))
+    {
+      c->buffer->info[c->buffer->idx].codepoint = substitute[index];
+      c->buffer->idx--; /* Reverse! */
+      return true;
+    }
+
+    return false;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!(coverage.sanitize (c, this)
+       && backtrack.sanitize (c, this)))
+      return false;
+    OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);
+    if (!lookahead.sanitize (c, this))
+      return false;
+    ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);
+    return substitute.sanitize (c);
+  }
+
+  private:
+  USHORT	format;			/* Format identifier--format = 1 */
+  OffsetTo<Coverage>
+		coverage;		/* Offset to Coverage table--from
+					 * beginning of table */
+  OffsetArrayOf<Coverage>
+		backtrack;		/* Array of coverage tables
+					 * in backtracking sequence, in  glyph
+					 * sequence order */
+  OffsetArrayOf<Coverage>
+		lookaheadX;		/* Array of coverage tables
+					 * in lookahead sequence, in glyph
+					 * sequence order */
+  ArrayOf<GlyphID>
+		substituteX;		/* Array of substitute
+					 * GlyphIDs--ordered by Coverage Index */
+  public:
+  DEFINE_SIZE_MIN (10);
+};
+
+struct ReverseChainSingleSubst
+{
+  friend struct SubstLookupSubTable;
+
+  private:
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    TRACE_CLOSURE ();
+    switch (u.format) {
+    case 1: u.format1.closure (c); break;
+    default:                       break;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c) const
+  {
+    TRACE_APPLY ();
+    switch (u.format) {
+    case 1: return u.format1.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (!u.format.sanitize (c)) return false;
+    switch (u.format) {
+    case 1: return u.format1.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT				format;		/* Format identifier */
+  ReverseChainSingleSubstFormat1	format1;
+  } u;
+};
+
+
+
+/*
+ * SubstLookup
+ */
+
+struct SubstLookupSubTable
+{
+  friend struct SubstLookup;
+
+  enum Type {
+    Single		= 1,
+    Multiple		= 2,
+    Alternate		= 3,
+    Ligature		= 4,
+    Context		= 5,
+    ChainContext	= 6,
+    Extension		= 7,
+    ReverseChainSingle	= 8
+  };
+
+  inline void closure (hb_closure_context_t *c,
+		       unsigned int    lookup_type) const
+  {
+    TRACE_CLOSURE ();
+    switch (lookup_type) {
+    case Single:		u.single.closure (c); break;
+    case Multiple:		u.multiple.closure (c); break;
+    case Alternate:		u.alternate.closure (c); break;
+    case Ligature:		u.ligature.closure (c); break;
+    case Context:		u.c.closure (c); break;
+    case ChainContext:		u.chainContext.closure (c); break;
+    case Extension:		u.extension.closure (c); break;
+    case ReverseChainSingle:	u.reverseChainContextSingle.closure (c); break;
+    default:                    break;
+    }
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id,
+			   unsigned int lookup_type) const
+  {
+    switch (lookup_type) {
+    case Single:		return u.single.would_apply (glyph_id);
+    case Multiple:		return u.multiple.would_apply (glyph_id);
+    case Alternate:		return u.alternate.would_apply (glyph_id);
+    case Extension:		return u.extension.would_apply (glyph_id);
+    default:return false;
+    }
+  }
+  inline bool would_apply (hb_codepoint_t first,
+			   hb_codepoint_t second,
+			   unsigned int lookup_type) const
+  {
+    switch (lookup_type) {
+    case Ligature:		return u.ligature.would_apply (first, second);
+    case Extension:		return u.extension.would_apply (first, second);
+    default:return false;
+    }
+  }
+
+  inline bool apply (hb_apply_context_t *c, unsigned int lookup_type) const
+  {
+    TRACE_APPLY ();
+    switch (lookup_type) {
+    case Single:		return u.single.apply (c);
+    case Multiple:		return u.multiple.apply (c);
+    case Alternate:		return u.alternate.apply (c);
+    case Ligature:		return u.ligature.apply (c);
+    case Context:		return u.c.apply (c);
+    case ChainContext:		return u.chainContext.apply (c);
+    case Extension:		return u.extension.apply (c);
+    case ReverseChainSingle:	return u.reverseChainContextSingle.apply (c);
+    default:return false;
+    }
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) {
+    TRACE_SANITIZE ();
+    switch (lookup_type) {
+    case Single:		return u.single.sanitize (c);
+    case Multiple:		return u.multiple.sanitize (c);
+    case Alternate:		return u.alternate.sanitize (c);
+    case Ligature:		return u.ligature.sanitize (c);
+    case Context:		return u.c.sanitize (c);
+    case ChainContext:		return u.chainContext.sanitize (c);
+    case Extension:		return u.extension.sanitize (c);
+    case ReverseChainSingle:	return u.reverseChainContextSingle.sanitize (c);
+    default:return true;
+    }
+  }
+
+  private:
+  union {
+  USHORT			sub_format;
+  SingleSubst			single;
+  MultipleSubst			multiple;
+  AlternateSubst		alternate;
+  LigatureSubst			ligature;
+  ContextSubst			c;
+  ChainContextSubst		chainContext;
+  ExtensionSubst		extension;
+  ReverseChainSingleSubst	reverseChainContextSingle;
+  } u;
+  public:
+  DEFINE_SIZE_UNION (2, sub_format);
+};
+
+
+struct SubstLookup : Lookup
+{
+  inline const SubstLookupSubTable& get_subtable (unsigned int i) const
+  { return this+CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable)[i]; }
+
+  inline static bool lookup_type_is_reverse (unsigned int lookup_type)
+  { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }
+
+  inline bool is_reverse (void) const
+  {
+    unsigned int type = get_type ();
+    if (unlikely (type == SubstLookupSubTable::Extension))
+      return CastR<ExtensionSubst> (get_subtable(0)).is_reverse ();
+    return lookup_type_is_reverse (type);
+  }
+
+  inline void closure (hb_closure_context_t *c) const
+  {
+    unsigned int lookup_type = get_type ();
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
+      get_subtable (i).closure (c, lookup_type);
+  }
+
+  inline bool would_apply (hb_codepoint_t glyph_id) const
+  {
+    unsigned int lookup_type = get_type ();
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
+      if (get_subtable (i).would_apply (glyph_id, lookup_type))
+	return true;
+    return false;
+  }
+  inline bool would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+  {
+    unsigned int lookup_type = get_type ();
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
+      if (get_subtable (i).would_apply (first, second, lookup_type))
+	return true;
+    return false;
+  }
+
+  inline bool apply_once (hb_apply_context_t *c) const
+  {
+    unsigned int lookup_type = get_type ();
+
+    if (!_hb_ot_layout_check_glyph_property (c->face, &c->buffer->info[c->buffer->idx], c->lookup_props, &c->property))
+      return false;
+
+    if (unlikely (lookup_type == SubstLookupSubTable::Extension))
+    {
+      /* The spec says all subtables should have the same type.
+       * This is specially important if one has a reverse type!
+       *
+       * This is rather slow to do this here for every glyph,
+       * but it's easiest, and who uses extension lookups anyway?!*/
+      unsigned int type = get_subtable(0).u.extension.get_type ();
+      unsigned int count = get_subtable_count ();
+      for (unsigned int i = 1; i < count; i++)
+        if (get_subtable(i).u.extension.get_type () != type)
+	  return false;
+    }
+
+    unsigned int count = get_subtable_count ();
+    for (unsigned int i = 0; i < count; i++)
+      if (get_subtable (i).apply (c, lookup_type))
+	return true;
+
+    return false;
+  }
+
+  inline bool apply_string (hb_apply_context_t *c) const
+  {
+    bool ret = false;
+
+    if (unlikely (!c->buffer->len))
+      return false;
+
+    c->set_lookup (*this);
+
+    if (likely (!is_reverse ()))
+    {
+	/* in/out forward substitution */
+	c->buffer->clear_output ();
+	c->buffer->idx = 0;
+	while (c->buffer->idx < c->buffer->len)
+	{
+	  if ((c->buffer->info[c->buffer->idx].mask & c->lookup_mask) && apply_once (c))
+	    ret = true;
+	  else
+	    c->buffer->next_glyph ();
+
+	}
+	if (ret)
+	  c->buffer->swap_buffers ();
+    }
+    else
+    {
+	/* in-place backward substitution */
+	c->buffer->idx = c->buffer->len - 1;
+	do
+	{
+	  if ((c->buffer->info[c->buffer->idx].mask & c->lookup_mask) && apply_once (c))
+	    ret = true;
+	  else
+	    c->buffer->idx--;
+
+	}
+	while ((int) c->buffer->idx >= 0);
+    }
+
+    return ret;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!Lookup::sanitize (c))) return false;
+    OffsetArrayOf<SubstLookupSubTable> &list = CastR<OffsetArrayOf<SubstLookupSubTable> > (subTable);
+    return list.sanitize (c, this, get_type ());
+  }
+};
+
+typedef OffsetListOf<SubstLookup> SubstLookupList;
+
+/*
+ * GSUB -- The Glyph Substitution Table
+ */
+
+struct GSUB : GSUBGPOS
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_GSUB;
+
+  inline const SubstLookup& get_lookup (unsigned int i) const
+  { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }
+
+  inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index) const
+  { return get_lookup (lookup_index).apply_string (c); }
+
+  static inline void substitute_start (hb_buffer_t *buffer);
+  static inline void substitute_finish (hb_buffer_t *buffer);
+
+  inline void closure_lookup (hb_closure_context_t *c,
+			      unsigned int          lookup_index) const
+  { return get_lookup (lookup_index).closure (c); }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    if (unlikely (!GSUBGPOS::sanitize (c))) return false;
+    OffsetTo<SubstLookupList> &list = CastR<OffsetTo<SubstLookupList> > (lookupList);
+    return list.sanitize (c, this);
+  }
+  public:
+  DEFINE_SIZE_STATIC (10);
+};
+
+
+void
+GSUB::substitute_start (hb_buffer_t *buffer)
+{
+  HB_BUFFER_ALLOCATE_VAR (buffer, props_cache);
+  HB_BUFFER_ALLOCATE_VAR (buffer, lig_id);
+  HB_BUFFER_ALLOCATE_VAR (buffer, lig_comp);
+
+  unsigned int count = buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+    buffer->info[i].props_cache() = buffer->info[i].lig_id() = buffer->info[i].lig_comp() = 0;
+}
+
+void
+GSUB::substitute_finish (hb_buffer_t *buffer)
+{
+}
+
+
+/* Out-of-class implementation for methods recursing */
+
+inline void ExtensionSubst::closure (hb_closure_context_t *c) const
+{
+  get_subtable ().closure (c, get_type ());
+}
+
+inline bool ExtensionSubst::would_apply (hb_codepoint_t glyph_id) const
+{
+  return get_subtable ().would_apply (glyph_id, get_type ());
+}
+
+inline bool ExtensionSubst::would_apply (hb_codepoint_t first, hb_codepoint_t second) const
+{
+  return get_subtable ().would_apply (first, second, get_type ());
+}
+
+inline bool ExtensionSubst::apply (hb_apply_context_t *c) const
+{
+  TRACE_APPLY ();
+  return get_subtable ().apply (c, get_type ());
+}
+
+inline bool ExtensionSubst::sanitize (hb_sanitize_context_t *c)
+{
+  TRACE_SANITIZE ();
+  if (unlikely (!Extension::sanitize (c))) return false;
+  unsigned int offset = get_offset ();
+  if (unlikely (!offset)) return true;
+  return StructAtOffset<SubstLookupSubTable> (this, offset).sanitize (c, get_type ());
+}
+
+inline bool ExtensionSubst::is_reverse (void) const
+{
+  unsigned int type = get_type ();
+  if (unlikely (type == SubstLookupSubTable::Extension))
+    return CastR<ExtensionSubst> (get_subtable()).is_reverse ();
+  return SubstLookup::lookup_type_is_reverse (type);
+}
+
+static inline void closure_lookup (hb_closure_context_t *c, unsigned int lookup_index)
+{
+  const GSUB &gsub = *(c->face->ot_layout->gsub);
+  const SubstLookup &l = gsub.get_lookup (lookup_index);
+
+  if (unlikely (c->nesting_level_left == 0))
+    return;
+
+  c->nesting_level_left--;
+  l.closure (c);
+  c->nesting_level_left++;
+}
+
+static inline bool substitute_lookup (hb_apply_context_t *c, unsigned int lookup_index)
+{
+  const GSUB &gsub = *(c->face->ot_layout->gsub);
+  const SubstLookup &l = gsub.get_lookup (lookup_index);
+
+  if (unlikely (c->nesting_level_left == 0))
+    return false;
+
+  if (unlikely (c->context_length < 1))
+    return false;
+
+  hb_apply_context_t new_c (*c);
+  new_c.nesting_level_left--;
+  new_c.set_lookup (l);
+  return l.apply_once (&new_c);
+}
+
+
+
+#endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout.h	2012-05-05 20:34:25.000000000 +0530
@@ -0,0 +1,231 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_H_IN
+#error "Include <hb-ot.h> instead."
+#endif
+
+#ifndef HB_OT_LAYOUT_H
+#define HB_OT_LAYOUT_H
+
+#include "hb.h"
+
+#include "hb-ot.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_OT_TAG_GDEF HB_TAG('G','D','E','F')
+#define HB_OT_TAG_GSUB HB_TAG('G','S','U','B')
+#define HB_OT_TAG_GPOS HB_TAG('G','P','O','S')
+
+/*
+ * GDEF
+ */
+
+hb_bool_t
+hb_ot_layout_has_glyph_classes (hb_face_t *face);
+
+/* Not that useful.  Provides list of attach points for a glyph that a
+ * client may want to cache */
+unsigned int
+hb_ot_layout_get_attach_points (hb_face_t      *face,
+				hb_codepoint_t  glyph,
+				unsigned int    start_offset,
+				unsigned int   *point_count /* IN/OUT */,
+				unsigned int   *point_array /* OUT */);
+
+/* Ligature caret positions */
+unsigned int
+hb_ot_layout_get_ligature_carets (hb_font_t      *font,
+				  hb_direction_t  direction,
+				  hb_codepoint_t  glyph,
+				  unsigned int    start_offset,
+				  unsigned int   *caret_count /* IN/OUT */,
+				  hb_position_t  *caret_array /* OUT */);
+
+
+/*
+ * GSUB/GPOS feature query and enumeration interface
+ */
+
+#define HB_OT_LAYOUT_NO_SCRIPT_INDEX		((unsigned int) 0xFFFF)
+#define HB_OT_LAYOUT_NO_FEATURE_INDEX		((unsigned int) 0xFFFF)
+#define HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX	((unsigned int) 0xFFFF)
+
+unsigned int
+hb_ot_layout_table_get_script_tags (hb_face_t    *face,
+				    hb_tag_t      table_tag,
+				    unsigned int  start_offset,
+				    unsigned int *script_count /* IN/OUT */,
+				    hb_tag_t     *script_tags /* OUT */);
+
+hb_bool_t
+hb_ot_layout_table_find_script (hb_face_t    *face,
+				hb_tag_t      table_tag,
+				hb_tag_t      script_tag,
+				unsigned int *script_index);
+
+/* Like find_script, but takes zero-terminated array of scripts to test */
+hb_bool_t
+hb_ot_layout_table_choose_script (hb_face_t      *face,
+				  hb_tag_t        table_tag,
+				  const hb_tag_t *script_tags,
+				  unsigned int   *script_index,
+				  hb_tag_t       *chosen_script);
+/************/
+
+unsigned int
+hb_ot_layout_table_get_script_count(hb_face_t    *face,
+                                    hb_tag_t      table_tag);
+
+unsigned int
+hb_ot_layout_script_get_language_count(hb_face_t    *face,
+                                    hb_tag_t      table_tag,
+                                    unsigned int  script_index);
+unsigned int
+hb_ot_layout_language_get_feature_count(hb_face_t    *face,
+                                            hb_tag_t      table_tag,
+                                            unsigned int   script_index,
+                                            unsigned int   language_index);
+/************/
+
+unsigned int
+hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
+				     hb_tag_t      table_tag,
+				     unsigned int  start_offset,
+				     unsigned int *feature_count /* IN/OUT */,
+				     hb_tag_t     *feature_tags /* OUT */);
+
+unsigned int
+hb_ot_layout_script_get_language_tags (hb_face_t    *face,
+				       hb_tag_t      table_tag,
+				       unsigned int  script_index,
+				       unsigned int  start_offset,
+				       unsigned int *language_count /* IN/OUT */,
+				       hb_tag_t     *language_tags /* OUT */);
+
+hb_bool_t
+hb_ot_layout_script_find_language (hb_face_t    *face,
+				   hb_tag_t      table_tag,
+				   unsigned int  script_index,
+				   hb_tag_t      language_tag,
+				   unsigned int *language_index);
+
+hb_bool_t
+hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
+						  hb_tag_t      table_tag,
+						  unsigned int  script_index,
+						  unsigned int  language_index,
+						  unsigned int *feature_index);
+
+unsigned int
+hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
+					   hb_tag_t      table_tag,
+					   unsigned int  script_index,
+					   unsigned int  language_index,
+					   unsigned int  start_offset,
+					   unsigned int *feature_count /* IN/OUT */,
+					   unsigned int *feature_indexes /* OUT */);
+
+unsigned int
+hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
+					hb_tag_t      table_tag,
+					unsigned int  script_index,
+					unsigned int  language_index,
+					unsigned int  start_offset,
+					unsigned int *feature_count /* IN/OUT */,
+					hb_tag_t     *feature_tags /* OUT */);
+
+hb_bool_t
+hb_ot_layout_language_find_feature (hb_face_t    *face,
+				    hb_tag_t      table_tag,
+				    unsigned int  script_index,
+				    unsigned int  language_index,
+				    hb_tag_t      feature_tag,
+				    unsigned int *feature_index);
+
+unsigned int
+hb_ot_layout_feature_get_lookup_indexes (hb_face_t    *face,
+					 hb_tag_t      table_tag,
+					 unsigned int  feature_index,
+					 unsigned int  start_offset,
+					 unsigned int *lookup_count /* IN/OUT */,
+					 unsigned int *lookup_indexes /* OUT */);
+
+
+/*
+ * GSUB
+ */
+
+hb_bool_t
+hb_ot_layout_has_substitution (hb_face_t *face);
+
+/* Should be called before all the substitute_lookup's are done. */
+void
+hb_ot_layout_substitute_start (hb_buffer_t  *buffer);
+
+hb_bool_t
+hb_ot_layout_substitute_lookup (hb_face_t    *face,
+				hb_buffer_t  *buffer,
+				unsigned int  lookup_index,
+				hb_mask_t     mask);
+
+/* Should be called after all the substitute_lookup's are done */
+void
+hb_ot_layout_substitute_finish (hb_buffer_t  *buffer);
+
+
+void
+hb_ot_layout_substitute_closure_lookup (hb_face_t    *face,
+				        hb_set_t     *glyphs,
+				        unsigned int  lookup_index);
+
+/*
+ * GPOS
+ */
+
+hb_bool_t
+hb_ot_layout_has_positioning (hb_face_t *face);
+
+/* Should be called before all the position_lookup's are done.  Resets positions to zero. */
+void
+hb_ot_layout_position_start (hb_buffer_t  *buffer);
+
+hb_bool_t
+hb_ot_layout_position_lookup (hb_font_t    *font,
+			      hb_buffer_t  *buffer,
+			      unsigned int  lookup_index,
+			      hb_mask_t     mask);
+
+/* Should be called after all the position_lookup's are done */
+void
+hb_ot_layout_position_finish (hb_buffer_t  *buffer);
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_LAYOUT_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-layout-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-layout-private.hh	2012-05-05 20:31:21.000000000 +0530
@@ -0,0 +1,98 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_LAYOUT_PRIVATE_HH
+#define HB_OT_LAYOUT_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-ot.h"
+
+#include "hb-font-private.hh"
+#include "hb-buffer-private.hh"
+
+
+
+/*
+ * GDEF
+ */
+
+/* buffer var allocations */
+#define props_cache() var1.u16[1] /* glyph_props cache */
+
+/* XXX cleanup */
+typedef enum {
+  HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED	= 0x0001,
+  HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH	= 0x0002,
+  HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE	= 0x0004,
+  HB_OT_LAYOUT_GLYPH_CLASS_MARK		= 0x0008,
+  HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT	= 0x0010
+} hb_ot_layout_glyph_class_t;
+
+
+HB_INTERNAL unsigned int
+_hb_ot_layout_get_glyph_property (hb_face_t       *face,
+				  hb_glyph_info_t *info);
+
+HB_INTERNAL hb_bool_t
+_hb_ot_layout_check_glyph_property (hb_face_t    *face,
+				    hb_glyph_info_t *ginfo,
+				    unsigned int  lookup_props,
+				    unsigned int *property_out);
+
+HB_INTERNAL hb_bool_t
+_hb_ot_layout_skip_mark (hb_face_t    *face,
+			 hb_glyph_info_t *ginfo,
+			 unsigned int  lookup_props,
+			 unsigned int *property_out);
+
+
+
+/*
+ * hb_ot_layout_t
+ */
+
+struct hb_ot_layout_t
+{
+  hb_blob_t *gdef_blob;
+  hb_blob_t *gsub_blob;
+  hb_blob_t *gpos_blob;
+
+  const struct GDEF *gdef;
+  const struct GSUB *gsub;
+  const struct GPOS *gpos;
+};
+
+
+HB_INTERNAL hb_ot_layout_t *
+_hb_ot_layout_create (hb_face_t *face);
+
+HB_INTERNAL void
+_hb_ot_layout_destroy (hb_ot_layout_t *layout);
+
+
+
+#endif /* HB_OT_LAYOUT_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-map.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-map.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-map.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-map.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,289 @@
+/*
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-map-private.hh"
+
+#include "hb-ot-shape-private.hh"
+
+
+
+void
+hb_ot_map_t::add_lookups (hb_face_t    *face,
+			  unsigned int  table_index,
+			  unsigned int  feature_index,
+			  hb_mask_t     mask)
+{
+  unsigned int lookup_indices[32];
+  unsigned int offset, len;
+
+  offset = 0;
+  do {
+    len = ARRAY_LENGTH (lookup_indices);
+    hb_ot_layout_feature_get_lookup_indexes (face,
+					     table_tags[table_index],
+					     feature_index,
+					     offset, &len,
+					     lookup_indices);
+
+    for (unsigned int i = 0; i < len; i++) {
+      hb_ot_map_t::lookup_map_t *lookup = lookups[table_index].push ();
+      if (unlikely (!lookup))
+        return;
+      lookup->mask = mask;
+      lookup->index = lookup_indices[i];
+    }
+
+    offset += len;
+  } while (len == ARRAY_LENGTH (lookup_indices));
+}
+
+
+void hb_ot_map_builder_t::add_feature (hb_tag_t tag, unsigned int value, bool global)
+{
+  feature_info_t *info = feature_infos.push();
+  if (unlikely (!info)) return;
+  info->tag = tag;
+  info->seq = feature_infos.len;
+  info->max_value = value;
+  info->global = global;
+  info->default_value = global ? value : 0;
+  info->stage[0] = current_stage[0];
+  info->stage[1] = current_stage[1];
+}
+
+void hb_ot_map_t::apply (unsigned int table_index,
+			 hb_ot_map_t::apply_lookup_func_t apply_lookup_func,
+			 void *face_or_font,
+			 hb_buffer_t *buffer) const
+{
+  unsigned int i = 0;
+
+  for (unsigned int pause_index = 0; pause_index < pauses[table_index].len; pause_index++) {
+    const pause_map_t *pause = &pauses[table_index][pause_index];
+    for (; i < pause->num_lookups; i++)
+      apply_lookup_func (face_or_font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+
+    pause->callback.func (this, face_or_font, buffer, pause->callback.user_data);
+  }
+
+  for (; i < lookups[table_index].len; i++)
+    apply_lookup_func (face_or_font, buffer, lookups[table_index][i].index, lookups[table_index][i].mask);
+}
+
+void hb_ot_map_t::substitute_closure (hb_face_t *face,
+				      hb_set_t *glyphs) const
+{
+  unsigned int table_index = 0;
+  unsigned int i = 0;
+
+  for (unsigned int pause_index = 0; pause_index < pauses[table_index].len; pause_index++) {
+    const pause_map_t *pause = &pauses[table_index][pause_index];
+    for (; i < pause->num_lookups; i++)
+      hb_ot_layout_substitute_closure_lookup (face, glyphs, lookups[table_index][i].index);
+  }
+
+  for (; i < lookups[table_index].len; i++)
+    hb_ot_layout_substitute_closure_lookup (face, glyphs, lookups[table_index][i].index);
+}
+
+void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func, void *user_data)
+{
+  if (pause_func) {
+    pause_info_t *p = pauses[table_index].push ();
+    if (likely (p)) {
+      p->stage = current_stage[table_index];
+      p->callback.func = pause_func;
+      p->callback.user_data = user_data;
+    }
+  }
+
+  current_stage[table_index]++;
+}
+
+void
+hb_ot_map_builder_t::compile (hb_face_t *face,
+			      const hb_segment_properties_t *props,
+			      hb_ot_map_t &m)
+{
+ m.global_mask = 1;
+
+  if (!feature_infos.len)
+    return;
+
+
+  /* Fetch script/language indices for GSUB/GPOS.  We need these later to skip
+   * features not available in either table and not waste precious bits for them. */
+
+  hb_tag_t script_tags[3] = {HB_TAG_NONE};
+  hb_tag_t language_tag;
+
+  hb_ot_tags_from_script (props->script, &script_tags[0], &script_tags[1]);
+  language_tag = hb_ot_tag_from_language (props->language);
+
+  unsigned int script_index[2], language_index[2];
+  for (unsigned int table_index = 0; table_index < 2; table_index++) {
+    hb_tag_t table_tag = table_tags[table_index];
+    hb_ot_layout_table_choose_script (face, table_tag, script_tags, &script_index[table_index], &m.chosen_script[table_index]);
+    hb_ot_layout_script_find_language (face, table_tag, script_index[table_index], language_tag, &language_index[table_index]);
+  }
+
+
+  /* Sort features and merge duplicates */
+  {
+    feature_infos.sort ();
+    unsigned int j = 0;
+    for (unsigned int i = 1; i < feature_infos.len; i++)
+      if (feature_infos[i].tag != feature_infos[j].tag)
+	feature_infos[++j] = feature_infos[i];
+      else {
+	if (feature_infos[i].global) {
+	  feature_infos[j].global = true;
+	  feature_infos[j].max_value = feature_infos[i].max_value;
+	  feature_infos[j].default_value = feature_infos[i].default_value;
+	} else {
+	  feature_infos[j].global = false;
+	  feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);
+	}
+	feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);
+	feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);
+	/* Inherit default_value from j */
+      }
+    feature_infos.shrink (j + 1);
+  }
+
+
+  /* Allocate bits now */
+  unsigned int next_bit = 1;
+  for (unsigned int i = 0; i < feature_infos.len; i++) {
+    const feature_info_t *info = &feature_infos[i];
+
+    unsigned int bits_needed;
+
+    if (info->global && info->max_value == 1)
+      /* Uses the global bit */
+      bits_needed = 0;
+    else
+      bits_needed = _hb_bit_storage (info->max_value);
+
+    if (!info->max_value || next_bit + bits_needed > 8 * sizeof (hb_mask_t))
+      continue; /* Feature disabled, or not enough bits. */
+
+
+    bool found = false;
+    unsigned int feature_index[2];
+    for (unsigned int table_index = 0; table_index < 2; table_index++)
+      found |= hb_ot_layout_language_find_feature (face,
+						   table_tags[table_index],
+						   script_index[table_index],
+						   language_index[table_index],
+						   info->tag,
+						   &feature_index[table_index]);
+    if (!found)
+      continue;
+
+
+    hb_ot_map_t::feature_map_t *map = m.features.push ();
+    if (unlikely (!map))
+      break;
+
+    map->tag = info->tag;
+    map->index[0] = feature_index[0];
+    map->index[1] = feature_index[1];
+    map->stage[0] = info->stage[0];
+    map->stage[1] = info->stage[1];
+    if (info->global && info->max_value == 1) {
+      /* Uses the global bit */
+      map->shift = 0;
+      map->mask = 1;
+    } else {
+      map->shift = next_bit;
+      map->mask = (1 << (next_bit + bits_needed)) - (1 << next_bit);
+      next_bit += bits_needed;
+      if (info->global)
+	m.global_mask |= (info->default_value << map->shift) & map->mask;
+    }
+    map->_1_mask = (1 << map->shift) & map->mask;
+
+  }
+  feature_infos.shrink (0); /* Done with these */
+
+
+  add_gsub_pause (NULL, NULL);
+  add_gpos_pause (NULL, NULL);
+
+  for (unsigned int table_index = 0; table_index < 2; table_index++) {
+    hb_tag_t table_tag = table_tags[table_index];
+
+    /* Collect lookup indices for features */
+
+    unsigned int required_feature_index;
+    if (hb_ot_layout_language_get_required_feature_index (face,
+							  table_tag,
+							  script_index[table_index],
+							  language_index[table_index],
+							  &required_feature_index))
+      m.add_lookups (face, table_index, required_feature_index, 1);
+
+    unsigned int pause_index = 0;
+    unsigned int last_num_lookups = 0;
+    for (unsigned stage = 0; stage < current_stage[table_index]; stage++)
+    {
+      for (unsigned i = 0; i < m.features.len; i++)
+        if (m.features[i].stage[table_index] == stage)
+	  m.add_lookups (face, table_index, m.features[i].index[table_index], m.features[i].mask);
+
+      /* Sort lookups and merge duplicates */
+      if (last_num_lookups < m.lookups[table_index].len)
+      {
+	m.lookups[table_index].sort (last_num_lookups, m.lookups[table_index].len);
+
+	unsigned int j = last_num_lookups;
+	for (unsigned int i = j + 1; i < m.lookups[table_index].len; i++)
+	  if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)
+	    m.lookups[table_index][++j] = m.lookups[table_index][i];
+	  else
+	    m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;
+	m.lookups[table_index].shrink (j + 1);
+      }
+
+      last_num_lookups = m.lookups[table_index].len;
+
+      if (pause_index < pauses[table_index].len && pauses[table_index][pause_index].stage == stage) {
+	hb_ot_map_t::pause_map_t *pause_map = m.pauses[table_index].push ();
+	if (likely (pause_map)) {
+	  pause_map->num_lookups = last_num_lookups;
+	  pause_map->callback = pauses[table_index][pause_index].callback;
+	}
+
+	pause_index++;
+      }
+    }
+  }
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-map-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-map-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-map-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-map-private.hh	2012-05-05 20:32:56.000000000 +0530
@@ -0,0 +1,194 @@
+/*
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_MAP_PRIVATE_HH
+#define HB_OT_MAP_PRIVATE_HH
+
+#include "hb-buffer-private.hh"
+
+#include "hb-ot.h"
+
+
+
+static const hb_tag_t table_tags[2] = {HB_OT_TAG_GSUB, HB_OT_TAG_GPOS};
+
+struct hb_ot_map_t
+{
+  friend struct hb_ot_map_builder_t;
+
+  public:
+
+  hb_ot_map_t (void) { memset (this, 0, sizeof (*this)); }
+
+  typedef void (*gsub_pause_func_t) (const hb_ot_map_t *map, hb_face_t *face, hb_buffer_t *buffer, void *user_data);
+  typedef void (*gpos_pause_func_t) (const hb_ot_map_t *map, hb_font_t *font, hb_buffer_t *buffer, void *user_data);
+
+  inline hb_mask_t get_global_mask (void) const { return global_mask; }
+
+  inline hb_mask_t get_mask (hb_tag_t tag, unsigned int *shift = NULL) const {
+    const feature_map_t *map = features.bsearch (&tag);
+    if (shift) *shift = map ? map->shift : 0;
+    return map ? map->mask : 0;
+  }
+
+  inline hb_mask_t get_1_mask (hb_tag_t tag) const {
+    const feature_map_t *map = features.bsearch (&tag);
+    return map ? map->_1_mask : 0;
+  }
+
+  inline hb_tag_t get_chosen_script (unsigned int table_index) const
+  { return chosen_script[table_index]; }
+
+  inline void substitute (hb_face_t *face, hb_buffer_t *buffer) const
+  { apply (0, (hb_ot_map_t::apply_lookup_func_t) hb_ot_layout_substitute_lookup, face, buffer); }
+  inline void position (hb_font_t *font, hb_buffer_t *buffer) const
+  { apply (1, (hb_ot_map_t::apply_lookup_func_t) hb_ot_layout_position_lookup, font, buffer); }
+
+  inline void finish (void) {
+    features.finish ();
+    lookups[0].finish ();
+    lookups[1].finish ();
+    pauses[0].finish ();
+    pauses[1].finish ();
+  }
+
+  private:
+
+  struct feature_map_t {
+    hb_tag_t tag; /* should be first for our bsearch to work */
+    unsigned int index[2]; /* GSUB/GPOS */
+    unsigned int stage[2]; /* GSUB/GPOS */
+    unsigned int shift;
+    hb_mask_t mask;
+    hb_mask_t _1_mask; /* mask for value=1, for quick access */
+
+    static int cmp (const feature_map_t *a, const feature_map_t *b)
+    { return a->tag < b->tag ? -1 : a->tag > b->tag ? 1 : 0; }
+  };
+
+  struct lookup_map_t {
+    unsigned int index;
+    hb_mask_t mask;
+
+    static int cmp (const lookup_map_t *a, const lookup_map_t *b)
+    { return a->index < b->index ? -1 : a->index > b->index ? 1 : 0; }
+  };
+
+  typedef void (*pause_func_t) (const hb_ot_map_t *map, void *face_or_font, hb_buffer_t *buffer, void *user_data);
+  typedef struct {
+    pause_func_t func;
+    void *user_data;
+  } pause_callback_t;
+
+  struct pause_map_t {
+    unsigned int num_lookups; /* Cumulative */
+    pause_callback_t callback;
+  };
+
+  typedef hb_bool_t (*apply_lookup_func_t) (void *face_or_font,
+					    hb_buffer_t  *buffer,
+					    unsigned int  lookup_index,
+					    hb_mask_t     mask);
+
+  HB_INTERNAL void add_lookups (hb_face_t    *face,
+				unsigned int  table_index,
+				unsigned int  feature_index,
+				hb_mask_t     mask);
+
+  HB_INTERNAL void apply (unsigned int table_index,
+			  hb_ot_map_t::apply_lookup_func_t apply_lookup_func,
+			  void *face_or_font,
+			  hb_buffer_t *buffer) const;
+
+  HB_INTERNAL void substitute_closure (hb_face_t *face,
+				       hb_set_t *glyphs) const;
+
+  hb_mask_t global_mask;
+
+  hb_tag_t chosen_script[2];
+  hb_prealloced_array_t<feature_map_t, 8> features;
+  hb_prealloced_array_t<lookup_map_t, 32> lookups[2]; /* GSUB/GPOS */
+  hb_prealloced_array_t<pause_map_t, 1> pauses[2]; /* GSUB/GPOS */
+};
+
+
+struct hb_ot_map_builder_t
+{
+  public:
+
+  hb_ot_map_builder_t (void) { memset (this, 0, sizeof (*this)); }
+
+  HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value, bool global);
+
+  inline void add_bool_feature (hb_tag_t tag, bool global = true)
+  { add_feature (tag, 1, global); }
+
+  inline void add_gsub_pause (hb_ot_map_t::gsub_pause_func_t pause_func, void *user_data)
+  { add_pause (0, (hb_ot_map_t::pause_func_t) pause_func, user_data); }
+  inline void add_gpos_pause (hb_ot_map_t::gpos_pause_func_t pause_func, void *user_data)
+  { add_pause (1, (hb_ot_map_t::pause_func_t) pause_func, user_data); }
+
+  HB_INTERNAL void compile (hb_face_t *face,
+			    const hb_segment_properties_t *props,
+			    struct hb_ot_map_t &m);
+
+  inline void finish (void) {
+    feature_infos.finish ();
+    pauses[0].finish ();
+    pauses[1].finish ();
+  }
+
+  private:
+
+  struct feature_info_t {
+    hb_tag_t tag;
+    unsigned int seq; /* sequence#, used for stable sorting only */
+    unsigned int max_value;
+    bool global; /* whether the feature applies value to every glyph in the buffer */
+    unsigned int default_value; /* for non-global features, what should the unset glyphs take */
+    unsigned int stage[2]; /* GSUB/GPOS */
+
+    static int cmp (const feature_info_t *a, const feature_info_t *b)
+    { return (a->tag != b->tag) ?  (a->tag < b->tag ? -1 : 1) : (a->seq < b->seq ? -1 : 1); }
+  };
+
+  struct pause_info_t {
+    unsigned int stage;
+    hb_ot_map_t::pause_callback_t callback;
+  };
+
+  HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func, void *user_data);
+
+  unsigned int current_stage[2]; /* GSUB/GPOS */
+  hb_prealloced_array_t<feature_info_t,16> feature_infos;
+  hb_prealloced_array_t<pause_info_t, 1> pauses[2]; /* GSUB/GPOS */
+};
+
+
+
+#endif /* HB_OT_MAP_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-maxp-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-maxp-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-maxp-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-maxp-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,66 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_MAXP_TABLE_HH
+#define HB_OT_MAXP_TABLE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ * maxp -- The Maximum Profile Table
+ */
+
+#define HB_OT_TAG_maxp HB_TAG('m','a','x','p')
+
+struct maxp
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_maxp;
+
+  inline unsigned int get_num_glyphs (void) const {
+    return numGlyphs;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this) &&
+	   likely (version.major == 1 ||
+		   (version.major == 0 && version.minor == 0x5000));
+  }
+
+  /* We only implement version 0.5 as none of the extra fields in version 1.0 are useful. */
+  private:
+  FixedVersion	version;		/* Version of the maxp table (0.5 or 1.0),
+					 * 0x00005000 or 0x00010000. */
+  USHORT	numGlyphs;		/* The number of glyphs in the font. */
+  public:
+  DEFINE_SIZE_STATIC (6);
+};
+
+
+
+#endif /* HB_OT_MAXP_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-name-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-name-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-name-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-name-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,129 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_NAME_TABLE_HH
+#define HB_OT_NAME_TABLE_HH
+
+#include "hb-open-type-private.hh"
+
+
+
+/*
+ * name -- The Naming Table
+ */
+
+#define HB_OT_TAG_name HB_TAG('n','a','m','e')
+
+
+struct NameRecord
+{
+  static int cmp (const NameRecord *a, const NameRecord *b)
+  {
+    int ret;
+    ret = b->platformID.cmp (a->platformID);
+    if (ret) return ret;
+    ret = b->encodingID.cmp (a->encodingID);
+    if (ret) return ret;
+    ret = b->languageID.cmp (a->languageID);
+    if (ret) return ret;
+    ret = b->nameID.cmp (a->nameID);
+    if (ret) return ret;
+    return 0;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c, void *base) {
+    TRACE_SANITIZE ();
+    /* We can check from base all the way up to the end of string... */
+    return c->check_struct (this) &&
+	   c->check_range ((char *) base, (unsigned int) length + offset);
+  }
+
+  USHORT	platformID;	/* Platform ID. */
+  USHORT	encodingID;	/* Platform-specific encoding ID. */
+  USHORT	languageID;	/* Language ID. */
+  USHORT	nameID;		/* Name ID. */
+  USHORT	length;		/* String length (in bytes). */
+  USHORT	offset;		/* String offset from start of storage area (in bytes). */
+  public:
+  DEFINE_SIZE_STATIC (12);
+};
+
+struct name
+{
+  static const hb_tag_t Tag	= HB_OT_TAG_name;
+
+  inline unsigned int get_name (unsigned int platform_id,
+				unsigned int encoding_id,
+				unsigned int language_id,
+				unsigned int name_id,
+				void *buffer,
+				unsigned int buffer_length) const
+  {
+    NameRecord key;
+    key.platformID.set (platform_id);
+    key.encodingID.set (encoding_id);
+    key.languageID.set (language_id);
+    key.nameID.set (name_id);
+    NameRecord *match = (NameRecord *) bsearch (&key, nameRecord, count, sizeof (nameRecord[0]), (hb_compare_func_t) NameRecord::cmp);
+
+    if (!match)
+      return 0;
+
+    unsigned int length = MIN (buffer_length, (unsigned int) match->length);
+    memcpy (buffer, (char *) this + stringOffset + match->offset, length);
+    return length;
+  }
+
+  inline bool sanitize_records (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    char *string_pool = (char *) this + stringOffset;
+    unsigned int _count = count;
+    for (unsigned int i = 0; i < _count; i++)
+      if (!nameRecord[i].sanitize (c, string_pool)) return false;
+    return true;
+  }
+
+  inline bool sanitize (hb_sanitize_context_t *c) {
+    TRACE_SANITIZE ();
+    return c->check_struct (this) &&
+	   likely (format == 0 || format == 1) &&
+	   c->check_array (nameRecord, nameRecord[0].static_size, count) &&
+	   sanitize_records (c);
+  }
+
+  /* We only implement format 0 for now. */
+  private:
+  USHORT	format;			/* Format selector (=0/1). */
+  USHORT	count;			/* Number of name records. */
+  Offset	stringOffset;		/* Offset to start of string storage (from start of table). */
+  NameRecord	nameRecord[VAR];	/* The name records where count is the number of records. */
+  public:
+  DEFINE_SIZE_ARRAY (6, nameRecord);
+};
+
+
+
+#endif /* HB_OT_NAME_TABLE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape.cc	2012-08-09 00:15:24.119770642 +0530
@@ -0,0 +1,492 @@
+/*
+ * Copyright  2009,2010  Red Hat, Inc.
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-shape-private.hh"
+#include "hb-ot-shape-normalize-private.hh"
+
+#include "hb-font-private.hh"
+
+
+
+hb_tag_t common_features[] = {
+  HB_TAG('c','c','m','p'),
+  HB_TAG('l','i','g','a'),
+  HB_TAG('l','o','c','l'),
+  HB_TAG('m','a','r','k'),
+  HB_TAG('m','k','m','k'),
+  HB_TAG('r','l','i','g'),
+};
+
+hb_tag_t horizontal_features[] = {
+  HB_TAG('c','a','l','t'),
+  HB_TAG('c','l','i','g'),
+  HB_TAG('c','u','r','s'),
+  HB_TAG('k','e','r','n'),
+};
+
+/* Note:
+ * Technically speaking, vrt2 and vert are mutually exclusive.
+ * According to the spec, valt and vpal are also mutually exclusive.
+ * But we apply them all for now.
+ */
+hb_tag_t vertical_features[] = {
+  HB_TAG('v','a','l','t'),
+  HB_TAG('v','e','r','t'),
+  HB_TAG('v','k','r','n'),
+  HB_TAG('v','p','a','l'),
+  HB_TAG('v','r','t','2'),
+};
+
+
+
+struct hb_ot_shape_planner_t
+{
+  hb_ot_map_builder_t map;
+  hb_ot_complex_shaper_t shaper;
+
+  hb_ot_shape_planner_t (void) : map () {}
+  ~hb_ot_shape_planner_t (void) { map.finish (); }
+
+  inline void compile (hb_face_t *face,
+		       const hb_segment_properties_t *props,
+		       struct hb_ot_shape_plan_t &plan)
+  {
+    plan.shaper = shaper;
+    map.compile (face, props, plan.map);
+  }
+
+  private:
+  NO_COPY (hb_ot_shape_planner_t);
+};
+
+static void
+hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
+			      const hb_segment_properties_t  *props,
+			      const hb_feature_t             *user_features,
+			      unsigned int                    num_user_features)
+{
+  switch (props->direction) {
+    case HB_DIRECTION_LTR:
+      planner->map.add_bool_feature (HB_TAG ('l','t','r','a'));
+      planner->map.add_bool_feature (HB_TAG ('l','t','r','m'));
+      break;
+    case HB_DIRECTION_RTL:
+      planner->map.add_bool_feature (HB_TAG ('r','t','l','a'));
+      planner->map.add_bool_feature (HB_TAG ('r','t','l','m'), false);
+      break;
+    case HB_DIRECTION_TTB:
+    case HB_DIRECTION_BTT:
+    case HB_DIRECTION_INVALID:
+    default:
+      break;
+  }
+
+#define ADD_FEATURES(array) \
+  HB_STMT_START { \
+    for (unsigned int i = 0; i < ARRAY_LENGTH (array); i++) \
+      planner->map.add_bool_feature (array[i]); \
+  } HB_STMT_END
+
+  hb_ot_shape_complex_collect_features (planner->shaper, &planner->map, props);
+
+  ADD_FEATURES (common_features);
+
+  if (HB_DIRECTION_IS_HORIZONTAL (props->direction))
+    ADD_FEATURES (horizontal_features);
+  else
+    ADD_FEATURES (vertical_features);
+
+#undef ADD_FEATURES
+
+  for (unsigned int i = 0; i < num_user_features; i++) {
+    const hb_feature_t *feature = &user_features[i];
+    planner->map.add_feature (feature->tag, feature->value, (feature->start == 0 && feature->end == (unsigned int) -1));
+  }
+}
+
+
+struct hb_ot_shape_context_t
+{
+  /* Input to hb_ot_shape_execute() */
+  hb_ot_shape_plan_t *plan;
+  hb_font_t *font;
+  hb_face_t *face;
+  hb_buffer_t  *buffer;
+  const hb_feature_t *user_features;
+  unsigned int        num_user_features;
+
+  /* Transient stuff */
+  hb_direction_t target_direction;
+  hb_bool_t applied_position_complex;
+};
+
+static void
+hb_ot_shape_setup_masks (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  hb_mask_t global_mask = c->plan->map.get_global_mask ();
+  c->buffer->reset_masks (global_mask);
+
+  hb_ot_shape_complex_setup_masks (c->plan->shaper, &c->plan->map, c->buffer, c->font);
+
+  for (unsigned int i = 0; i < c->num_user_features; i++)
+  {
+    const hb_feature_t *feature = &c->user_features[i];
+    if (!(feature->start == 0 && feature->end == (unsigned int)-1)) {
+      unsigned int shift;
+      hb_mask_t mask = c->plan->map.get_mask (feature->tag, &shift);
+      c->buffer->set_masks (feature->value << shift, mask, feature->start, feature->end);
+    }
+  }
+}
+
+
+/* Main shaper */
+
+/* Prepare */
+
+static inline void
+set_unicode_props (hb_glyph_info_t *info, hb_unicode_funcs_t *unicode)
+{
+  info->general_category() = hb_unicode_general_category (unicode, info->codepoint);
+  info->combining_class() = _hb_unicode_modified_combining_class (unicode, info->codepoint);
+}
+
+static void
+hb_set_unicode_props (hb_buffer_t *buffer)
+{
+  unsigned int count = buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+    set_unicode_props (&buffer->info[i], buffer->unicode);
+}
+
+static void
+hb_form_clusters (hb_buffer_t *buffer)
+{
+  unsigned int count = buffer->len;
+  for (unsigned int i = 1; i < count; i++)
+    if (FLAG (buffer->info[i].general_category()) &
+	(FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) |
+	 FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |
+	 FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
+      buffer->info[i].cluster = buffer->info[i - 1].cluster; /* XXX do the min() here */
+}
+
+static void
+hb_ensure_native_direction (hb_buffer_t *buffer)
+{
+  hb_direction_t direction = buffer->props.direction;
+
+  /* TODO vertical:
+   * The only BTT vertical script is Ogham, but it's not clear to me whether OpenType
+   * Ogham fonts are supposed to be implemented BTT or not.  Need to research that
+   * first. */
+  if ((HB_DIRECTION_IS_HORIZONTAL (direction) && direction != hb_script_get_horizontal_direction (buffer->props.script)) ||
+      (HB_DIRECTION_IS_VERTICAL   (direction) && direction != HB_DIRECTION_TTB))
+  {
+    hb_buffer_reverse_clusters (buffer);
+    buffer->props.direction = HB_DIRECTION_REVERSE (buffer->props.direction);
+  }
+}
+
+
+/* Substitute */
+
+static void
+hb_mirror_chars (hb_ot_shape_context_t *c)
+{
+  hb_unicode_funcs_t *unicode = c->buffer->unicode;
+
+  if (HB_DIRECTION_IS_FORWARD (c->target_direction))
+    return;
+
+  hb_mask_t rtlm_mask = c->plan->map.get_1_mask (HB_TAG ('r','t','l','m'));
+
+  unsigned int count = c->buffer->len;
+  for (unsigned int i = 0; i < count; i++) {
+    hb_codepoint_t codepoint = hb_unicode_mirroring (unicode, c->buffer->info[i].codepoint);
+    if (likely (codepoint == c->buffer->info[i].codepoint))
+      c->buffer->info[i].mask |= rtlm_mask; /* XXX this should be moved to before setting user-feature masks */
+    else
+      c->buffer->info[i].codepoint = codepoint;
+  }
+}
+
+static void
+hb_map_glyphs (hb_font_t    *font,
+	       hb_buffer_t  *buffer)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  hb_codepoint_t glyph;
+
+  if (unlikely (!buffer->len))
+    return;
+
+  buffer->clear_output ();
+
+  unsigned int count = buffer->len - 1;
+  for (buffer->idx = 0; buffer->idx < count;) {
+    if (unlikely (_hb_unicode_is_variation_selector (buffer->info[buffer->idx + 1].codepoint))) {
+      hb_font_get_glyph (font, buffer->info[buffer->idx].codepoint, buffer->info[buffer->idx + 1].codepoint, &glyph);
+      buffer->replace_glyphs (2, 1, &glyph);
+    } else {
+      hb_font_get_glyph (font, buffer->info[buffer->idx].codepoint, 0, &glyph);
+      buffer->replace_glyph (glyph);
+    }
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[buffer->idx].codepoint) ;
+  }
+  if (likely (buffer->idx < buffer->len)) {
+    hb_font_get_glyph (font, buffer->info[buffer->idx].codepoint, 0, &glyph);
+    buffer->replace_glyph (glyph);
+  }
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  buffer->swap_buffers ();
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+}
+
+static void
+hb_substitute_default (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  hb_ot_layout_substitute_start (c->buffer);
+
+  hb_mirror_chars (c);
+
+  hb_map_glyphs (c->font, c->buffer);
+}
+
+static void
+hb_ot_substitute_complex (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  if (hb_ot_layout_has_substitution (c->face)) {
+    c->plan->map.substitute (c->face, c->buffer);
+  }
+
+  hb_ot_layout_substitute_finish (c->buffer);
+
+  return;
+}
+
+
+/* Position */
+
+static void
+hb_position_default (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  hb_ot_layout_position_start (c->buffer);
+
+  unsigned int count = c->buffer->len;
+  for (unsigned int i = 0; i < count; i++) {
+    hb_font_get_glyph_advance_for_direction (c->font, c->buffer->info[i].codepoint,
+					     c->buffer->props.direction,
+					     &c->buffer->pos[i].x_advance,
+					     &c->buffer->pos[i].y_advance);
+    hb_font_subtract_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
+						 c->buffer->props.direction,
+						 &c->buffer->pos[i].x_offset,
+						 &c->buffer->pos[i].y_offset);
+  }
+}
+
+static void
+hb_ot_position_complex (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  if (hb_ot_layout_has_positioning (c->face))
+  {
+    /* Change glyph origin to what GPOS expects, apply GPOS, change it back. */
+
+    unsigned int count = c->buffer->len;
+    for (unsigned int i = 0; i < count; i++) {
+      hb_font_add_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
+					      HB_DIRECTION_LTR,
+					      &c->buffer->pos[i].x_offset,
+					      &c->buffer->pos[i].y_offset);
+    }
+
+    c->plan->map.position (c->font, c->buffer);
+
+    for (unsigned int i = 0; i < count; i++) {
+      hb_font_subtract_glyph_origin_for_direction (c->font, c->buffer->info[i].codepoint,
+						   HB_DIRECTION_LTR,
+						   &c->buffer->pos[i].x_offset,
+						   &c->buffer->pos[i].y_offset);
+    }
+
+    c->applied_position_complex = TRUE;
+  }
+
+  hb_ot_layout_position_finish (c->buffer);
+
+  return;
+}
+
+static void
+hb_position_complex_fallback (hb_ot_shape_context_t *c HB_UNUSED)
+{
+  /* TODO Mark pos */
+}
+
+static void
+hb_truetype_kern (hb_ot_shape_context_t *c)
+{
+  /* TODO Check for kern=0 */
+  unsigned int count = c->buffer->len;
+  for (unsigned int i = 1; i < count; i++) {
+    hb_position_t x_kern, y_kern, kern1, kern2;
+    hb_font_get_glyph_kerning_for_direction (c->font,
+					     c->buffer->info[i - 1].codepoint, c->buffer->info[i].codepoint,
+					     c->buffer->props.direction,
+					     &x_kern, &y_kern);
+
+    kern1 = x_kern >> 1;
+    kern2 = x_kern - kern1;
+    c->buffer->pos[i - 1].x_advance += kern1;
+    c->buffer->pos[i].x_advance += kern2;
+    c->buffer->pos[i].x_offset += kern2;
+
+    kern1 = y_kern >> 1;
+    kern2 = y_kern - kern1;
+    c->buffer->pos[i - 1].y_advance += kern1;
+    c->buffer->pos[i].y_advance += kern2;
+    c->buffer->pos[i].y_offset += kern2;
+  }
+}
+
+static void
+hb_position_complex_fallback_visual (hb_ot_shape_context_t *c)
+{
+  hb_truetype_kern (c);
+}
+
+
+/* Do it! */
+
+static void
+hb_ot_shape_execute_internal (hb_ot_shape_context_t *c)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,c->buffer->info[0].codepoint) ;
+  c->buffer->deallocate_var_all ();
+
+  /* Save the original direction, we use it later. */
+  c->target_direction = c->buffer->props.direction;
+
+  HB_BUFFER_ALLOCATE_VAR (c->buffer, general_category);
+  HB_BUFFER_ALLOCATE_VAR (c->buffer, combining_class);
+
+  hb_set_unicode_props (c->buffer); /* BUFFER: Set general_category and combining_class */
+
+  hb_form_clusters (c->buffer);
+
+  hb_ensure_native_direction (c->buffer);
+
+  _hb_ot_shape_normalize (c->font, c->buffer, hb_ot_shape_complex_normalization_preference (c->plan->shaper));
+
+  hb_ot_shape_setup_masks (c);
+
+  /* SUBSTITUTE */
+  {
+    hb_substitute_default (c);
+
+    hb_ot_substitute_complex (c);
+  }
+
+  /* POSITION */
+  {
+    hb_position_default (c);
+
+    hb_ot_position_complex (c);
+
+    hb_bool_t position_fallback = !c->applied_position_complex;
+    if (position_fallback)
+      hb_position_complex_fallback (c);
+
+    if (HB_DIRECTION_IS_BACKWARD (c->buffer->props.direction))
+      hb_buffer_reverse (c->buffer);
+
+    if (position_fallback)
+      hb_position_complex_fallback_visual (c);
+  }
+
+//  HB_BUFFER_DEALLOCATE_VAR (c->buffer, combining_class);
+//  HB_BUFFER_DEALLOCATE_VAR (c->buffer, general_category);
+
+//  c->buffer->props.direction = c->target_direction;
+
+//  c->buffer->deallocate_var_all ();
+}
+
+static void
+hb_ot_shape_plan_internal (hb_ot_shape_plan_t       *plan,
+			   hb_face_t                *face,
+			   const hb_segment_properties_t  *props,
+			   const hb_feature_t       *user_features,
+			   unsigned int              num_user_features)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__) ;
+  hb_ot_shape_planner_t planner;
+
+  assert (HB_DIRECTION_IS_VALID (props->direction));
+
+  planner.shaper = hb_ot_shape_complex_categorize (props);
+
+  hb_ot_shape_collect_features (&planner, props, user_features, num_user_features);
+
+  planner.compile (face, props, *plan);
+}
+
+static void
+hb_ot_shape_execute (hb_ot_shape_plan_t *plan,
+		     hb_font_t          *font,
+		     hb_buffer_t        *buffer,
+		     const hb_feature_t *user_features,
+		     unsigned int        num_user_features)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  hb_ot_shape_context_t c = {plan, font, font->face, buffer, user_features, num_user_features};
+  hb_ot_shape_execute_internal (&c);
+}
+
+hb_bool_t
+_hb_ot_shape (hb_font_t          *font,
+	      hb_buffer_t        *buffer,
+	      const hb_feature_t *features,
+	      unsigned int        num_features)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  hb_ot_shape_plan_t plan;
+
+  buffer->guess_properties ();
+
+  hb_ot_shape_plan_internal (&plan, font->face, &buffer->props, features, num_features);
+  hb_ot_shape_execute (&plan, font, buffer, features, num_features);
+
+  return TRUE;
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic.cc	2012-07-21 22:56:34.728338787 +0530
@@ -0,0 +1,295 @@
+/*
+ * Copyright  2010  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-shape-complex-private.hh"
+
+
+
+/* buffer var allocations */
+#define arabic_shaping_action() complex_var_temporary_u16() /* arabic shaping action */
+
+
+/*
+ * Bits used in the joining tables
+ */
+enum {
+  JOINING_TYPE_U		= 0,
+  JOINING_TYPE_R		= 1,
+  JOINING_TYPE_D		= 2,
+  JOINING_TYPE_C		= JOINING_TYPE_D,
+  JOINING_GROUP_ALAPH		= 3,
+  JOINING_GROUP_DALATH_RISH	= 4,
+  NUM_STATE_MACHINE_COLS	= 5,
+
+  /* We deliberately don't have a JOINING_TYPE_L since that's unused in Unicode. */
+
+  JOINING_TYPE_T = 6,
+  JOINING_TYPE_X = 7  /* means: use general-category to choose between U or T. */
+};
+
+/*
+ * Joining types:
+ */
+
+#include "hb-ot-shape-complex-arabic-table.hh"
+
+static unsigned int get_joining_type (hb_codepoint_t u, hb_unicode_general_category_t gen_cat)
+{
+  if (likely (hb_in_range<hb_codepoint_t> (u, JOINING_TABLE_FIRST, JOINING_TABLE_LAST))) {
+    unsigned int j_type = joining_table[u - JOINING_TABLE_FIRST];
+    if (likely (j_type != JOINING_TYPE_X))
+      return j_type;
+  }
+
+  /* Mongolian joining data is not in ArabicJoining.txt yet */
+  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x1800, 0x18AF)))
+  {
+    /* All letters, SIBE SYLLABLE BOUNDARY MARKER, and NIRUGU are D */
+    if (gen_cat == HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER || u == 0x1807 || u == 0x180A)
+      return JOINING_TYPE_D;
+  }
+
+  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x200C, 0x200D))) {
+    return u == 0x200C ? JOINING_TYPE_U : JOINING_TYPE_C;
+  }
+
+  return (FLAG(gen_cat) & (FLAG(HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) | FLAG(HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) | FLAG(HB_UNICODE_GENERAL_CATEGORY_FORMAT))) ?
+	 JOINING_TYPE_T : JOINING_TYPE_U;
+}
+
+static hb_codepoint_t get_arabic_shape (hb_codepoint_t u, unsigned int shape)
+{
+  if (likely (hb_in_range<hb_codepoint_t> (u, SHAPING_TABLE_FIRST, SHAPING_TABLE_LAST)) && shape < 4)
+    return shaping_table[u - SHAPING_TABLE_FIRST][shape];
+  return u;
+}
+
+static uint16_t get_ligature (hb_codepoint_t first, hb_codepoint_t second)
+{
+  if (unlikely (!second)) return 0;
+  for (unsigned i = 0; i < ARRAY_LENGTH (ligature_table); i++)
+    if (ligature_table[i].first == first)
+      for (unsigned j = 0; j < ARRAY_LENGTH (ligature_table[i].ligatures); j++)
+	if (ligature_table[i].ligatures[j].second == second)
+	  return ligature_table[i].ligatures[j].ligature;
+  return 0;
+}
+
+static const hb_tag_t arabic_syriac_features[] =
+{
+  HB_TAG('i','n','i','t'),
+  HB_TAG('m','e','d','i'),
+  HB_TAG('f','i','n','a'),
+  HB_TAG('i','s','o','l'),
+  /* Syriac */
+  HB_TAG('m','e','d','2'),
+  HB_TAG('f','i','n','2'),
+  HB_TAG('f','i','n','3'),
+  HB_TAG_NONE
+};
+
+
+/* Same order as the feature array */
+enum {
+  INIT,
+  MEDI,
+  FINA,
+  ISOL,
+
+  /* Syriac */
+  MED2,
+  FIN2,
+  FIN3,
+
+  NONE,
+
+  COMMON_NUM_FEATURES = 4,
+  SYRIAC_NUM_FEATURES = 7,
+  TOTAL_NUM_FEATURES = NONE
+};
+
+static const struct arabic_state_table_entry {
+	uint8_t prev_action;
+	uint8_t curr_action;
+	uint16_t next_state;
+} arabic_state_table[][NUM_STATE_MACHINE_COLS] =
+{
+  /*   jt_U,          jt_R,          jt_D,          jg_ALAPH,      jg_DALATH_RISH */
+
+  /* State 0: prev was U, not willing to join. */
+  { {NONE,NONE,0}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,6}, },
+
+  /* State 1: prev was R or ISOL/ALAPH, not willing to join. */
+  { {NONE,NONE,0}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN2,5}, {NONE,ISOL,6}, },
+
+  /* State 2: prev was D/ISOL, willing to join. */
+  { {NONE,NONE,0}, {INIT,FINA,1}, {INIT,FINA,3}, {INIT,FINA,4}, {INIT,FINA,6}, },
+
+  /* State 3: prev was D/FINA, willing to join. */
+  { {NONE,NONE,0}, {MEDI,FINA,1}, {MEDI,FINA,3}, {MEDI,FINA,4}, {MEDI,FINA,6}, },
+
+  /* State 4: prev was FINA ALAPH, not willing to join. */
+  { {NONE,NONE,0}, {MED2,ISOL,1}, {MED2,ISOL,2}, {MED2,FIN2,5}, {MED2,ISOL,6}, },
+
+  /* State 5: prev was FIN2/FIN3 ALAPH, not willing to join. */
+  { {NONE,NONE,0}, {ISOL,ISOL,1}, {ISOL,ISOL,2}, {ISOL,FIN2,5}, {ISOL,ISOL,6}, },
+
+  /* State 6: prev was DALATH/RISH, not willing to join. */
+  { {NONE,NONE,0}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }
+};
+
+
+
+void
+_hb_ot_shape_complex_collect_features_arabic (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props)
+{
+  /* For Language forms (in ArabicOT speak), we do the iso/fina/medi/init together,
+   * then rlig and calt each in their own stage.  This makes IranNastaliq's ALLAH
+   * ligature work correctly. It's unfortunate though...
+   *
+   * This also makes Arial Bold in Windows7 work.  See:
+   * https://bugzilla.mozilla.org/show_bug.cgi?id=644184
+   *
+   * TODO: Add test cases for these two.
+   */
+
+  map->add_bool_feature (HB_TAG('c','c','m','p'));
+  map->add_bool_feature (HB_TAG('l','o','c','l'));
+
+  map->add_gsub_pause (NULL, NULL);
+
+  unsigned int num_features = props->script == HB_SCRIPT_SYRIAC ? SYRIAC_NUM_FEATURES : COMMON_NUM_FEATURES;
+  for (unsigned int i = 0; i < num_features; i++)
+    map->add_bool_feature (arabic_syriac_features[i], false);
+
+  map->add_gsub_pause (NULL, NULL);
+
+  map->add_bool_feature (HB_TAG('r','l','i','g'));
+  map->add_gsub_pause (NULL, NULL);
+
+  map->add_bool_feature (HB_TAG('c','a','l','t'));
+  map->add_gsub_pause (NULL, NULL);
+
+  /* ArabicOT spec enables 'cswh' for Arabic where as for basic shaper it's disabled by default. */
+  map->add_bool_feature (HB_TAG('c','s','w','h'));
+}
+
+hb_ot_shape_normalization_mode_t
+_hb_ot_shape_complex_normalization_preference_arabic (void)
+{
+  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;
+}
+
+
+static void
+arabic_fallback_shape (hb_font_t *font, hb_buffer_t *buffer)
+{
+  unsigned int count = buffer->len;
+  hb_codepoint_t glyph;
+
+  /* Shape to presentation forms */
+  for (unsigned int i = 0; i < count; i++) {
+    hb_codepoint_t u = buffer->info[i].codepoint;
+    hb_codepoint_t shaped = get_arabic_shape (u, buffer->info[i].arabic_shaping_action());
+    if (shaped != u && hb_font_get_glyph (font, shaped, 0, &glyph))
+      buffer->info[i].codepoint = shaped;
+  }
+
+  /* Mandatory ligatures */
+  buffer->clear_output ();
+  for (buffer->idx = 0; buffer->idx + 1 < count;) {
+    hb_codepoint_t ligature = get_ligature (buffer->info[buffer->idx].codepoint,
+					    buffer->info[buffer->idx + 1].codepoint);
+    if (likely (!ligature) || !(hb_font_get_glyph (font, ligature, 0, &glyph))) {
+      buffer->next_glyph ();
+      continue;
+    }
+
+    buffer->replace_glyphs (2, 1, &ligature);
+
+    /* Technically speaking we can skip marks and stuff, like the GSUB path does.
+     * But who cares, we're in fallback! */
+  }
+  for (; buffer->idx < count;)
+      buffer->next_glyph ();
+  buffer->swap_buffers ();
+}
+
+void
+_hb_ot_shape_complex_setup_masks_arabic (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font)
+{
+  unsigned int count = buffer->len;
+  unsigned int prev = 0, state = 0;
+
+  HB_BUFFER_ALLOCATE_VAR (buffer, arabic_shaping_action);
+
+  for (unsigned int i = 0; i < count; i++)
+  {
+    unsigned int this_type = get_joining_type (buffer->info[i].codepoint, (hb_unicode_general_category_t) buffer->info[i].general_category());
+
+    if (unlikely (this_type == JOINING_TYPE_T)) {
+      buffer->info[i].arabic_shaping_action() = NONE;
+      continue;
+    }
+
+    const arabic_state_table_entry *entry = &arabic_state_table[state][this_type];
+
+    if (entry->prev_action != NONE)
+      buffer->info[prev].arabic_shaping_action() = entry->prev_action;
+
+    buffer->info[i].arabic_shaping_action() = entry->curr_action;
+
+    prev = i;
+    state = entry->next_state;
+  }
+
+  hb_mask_t mask_array[TOTAL_NUM_FEATURES + 1] = {0};
+  hb_mask_t total_masks = 0;
+  unsigned int num_masks = buffer->props.script == HB_SCRIPT_SYRIAC ? SYRIAC_NUM_FEATURES : COMMON_NUM_FEATURES;
+  for (unsigned int i = 0; i < num_masks; i++) {
+    mask_array[i] = map->get_1_mask (arabic_syriac_features[i]);
+    total_masks |= mask_array[i];
+  }
+
+  if (total_masks) {
+    /* Has OpenType tables */
+    for (unsigned int i = 0; i < count; i++)
+      buffer->info[i].mask |= mask_array[buffer->info[i].arabic_shaping_action()];
+  } else if (buffer->props.script == HB_SCRIPT_ARABIC) {
+    /* Fallback Arabic shaping to Presentation Forms */
+    /* Pitfalls:
+     * - This path fires if user force-set init/medi/fina/isol off,
+     * - If font does not declare script 'arab', well, what to do?
+     *   Most probably it's safe to assume that init/medi/fina/isol
+     *   still mean Arabic shaping, although they do not have to.
+     */
+    arabic_fallback_shape (font, buffer);
+  }
+
+  HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-arabic-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,942 @@
+/* == Start of generated table == */
+/*
+ * The following table is generated by running:
+ *
+ *   ./gen-arabic-table.py ArabicShaping.txt UnicodeData.txt
+ *
+ * on files with these headers:
+ *
+ * # ArabicShaping-6.1.0.txt
+ * # Date: 2011-04-15, 23:16:00 GMT [KW]
+ * UnicodeData.txt does not have a header.
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH
+#define HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH
+
+
+static const uint8_t joining_table[] =
+{
+
+  /* Arabic Characters */
+
+  JOINING_TYPE_U, /* 0600; ARABIC NUMBER SIGN; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0601; ARABIC SIGN SANAH; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0602; ARABIC FOOTNOTE MARKER; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0603; ARABIC SIGN SAFHA; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0604; ARABIC SIGN SAMVAT; U; No_Joining_Group */
+  JOINING_TYPE_X, /* 0605 */
+  JOINING_TYPE_X, /* 0606 */
+  JOINING_TYPE_X, /* 0607 */
+  JOINING_TYPE_U, /* 0608; ARABIC RAY; U; No_Joining_Group */
+  JOINING_TYPE_X, /* 0609 */
+  JOINING_TYPE_X, /* 060A */
+  JOINING_TYPE_U, /* 060B; AFGHANI SIGN; U; No_Joining_Group */
+  JOINING_TYPE_X, /* 060C */
+  JOINING_TYPE_X, /* 060D */
+  JOINING_TYPE_X, /* 060E */
+  JOINING_TYPE_X, /* 060F */
+  JOINING_TYPE_X, /* 0610 */
+  JOINING_TYPE_X, /* 0611 */
+  JOINING_TYPE_X, /* 0612 */
+  JOINING_TYPE_X, /* 0613 */
+  JOINING_TYPE_X, /* 0614 */
+  JOINING_TYPE_X, /* 0615 */
+  JOINING_TYPE_X, /* 0616 */
+  JOINING_TYPE_X, /* 0617 */
+  JOINING_TYPE_X, /* 0618 */
+  JOINING_TYPE_X, /* 0619 */
+  JOINING_TYPE_X, /* 061A */
+  JOINING_TYPE_X, /* 061B */
+  JOINING_TYPE_X, /* 061C */
+  JOINING_TYPE_X, /* 061D */
+  JOINING_TYPE_X, /* 061E */
+  JOINING_TYPE_X, /* 061F */
+  JOINING_TYPE_D, /* 0620; DOTLESS YEH WITH SEPARATE RING BELOW; D; YEH */
+  JOINING_TYPE_U, /* 0621; HAMZA; U; No_Joining_Group */
+  JOINING_TYPE_R, /* 0622; ALEF WITH MADDA ABOVE; R; ALEF */
+  JOINING_TYPE_R, /* 0623; ALEF WITH HAMZA ABOVE; R; ALEF */
+  JOINING_TYPE_R, /* 0624; WAW WITH HAMZA ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 0625; ALEF WITH HAMZA BELOW; R; ALEF */
+  JOINING_TYPE_D, /* 0626; DOTLESS YEH WITH HAMZA ABOVE; D; YEH */
+  JOINING_TYPE_R, /* 0627; ALEF; R; ALEF */
+  JOINING_TYPE_D, /* 0628; BEH; D; BEH */
+  JOINING_TYPE_R, /* 0629; TEH MARBUTA; R; TEH MARBUTA */
+  JOINING_TYPE_D, /* 062A; DOTLESS BEH WITH 2 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 062B; DOTLESS BEH WITH 3 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 062C; HAH WITH DOT BELOW; D; HAH */
+  JOINING_TYPE_D, /* 062D; HAH; D; HAH */
+  JOINING_TYPE_D, /* 062E; HAH WITH DOT ABOVE; D; HAH */
+  JOINING_TYPE_R, /* 062F; DAL; R; DAL */
+  JOINING_TYPE_R, /* 0630; DAL WITH DOT ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 0631; REH; R; REH */
+  JOINING_TYPE_R, /* 0632; REH WITH DOT ABOVE; R; REH */
+  JOINING_TYPE_D, /* 0633; SEEN; D; SEEN */
+  JOINING_TYPE_D, /* 0634; SEEN WITH 3 DOTS ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 0635; SAD; D; SAD */
+  JOINING_TYPE_D, /* 0636; SAD WITH DOT ABOVE; D; SAD */
+  JOINING_TYPE_D, /* 0637; TAH; D; TAH */
+  JOINING_TYPE_D, /* 0638; TAH WITH DOT ABOVE; D; TAH */
+  JOINING_TYPE_D, /* 0639; AIN; D; AIN */
+  JOINING_TYPE_D, /* 063A; AIN WITH DOT ABOVE; D; AIN */
+  JOINING_TYPE_D, /* 063B; KEHEH WITH 2 DOTS ABOVE; D; GAF */
+  JOINING_TYPE_D, /* 063C; KEHEH WITH 3 DOTS BELOW; D; GAF */
+  JOINING_TYPE_D, /* 063D; FARSI YEH WITH INVERTED V ABOVE; D; FARSI YEH */
+  JOINING_TYPE_D, /* 063E; FARSI YEH WITH 2 DOTS ABOVE; D; FARSI YEH */
+  JOINING_TYPE_D, /* 063F; FARSI YEH WITH 3 DOTS ABOVE; D; FARSI YEH */
+  JOINING_TYPE_C, /* 0640; TATWEEL; C; No_Joining_Group */
+  JOINING_TYPE_D, /* 0641; FEH; D; FEH */
+  JOINING_TYPE_D, /* 0642; QAF; D; QAF */
+  JOINING_TYPE_D, /* 0643; KAF; D; KAF */
+  JOINING_TYPE_D, /* 0644; LAM; D; LAM */
+  JOINING_TYPE_D, /* 0645; MEEM; D; MEEM */
+  JOINING_TYPE_D, /* 0646; NOON; D; NOON */
+  JOINING_TYPE_D, /* 0647; HEH; D; HEH */
+  JOINING_TYPE_R, /* 0648; WAW; R; WAW */
+  JOINING_TYPE_D, /* 0649; DOTLESS YEH; D; YEH */
+  JOINING_TYPE_D, /* 064A; YEH; D; YEH */
+  JOINING_TYPE_X, /* 064B */
+  JOINING_TYPE_X, /* 064C */
+  JOINING_TYPE_X, /* 064D */
+  JOINING_TYPE_X, /* 064E */
+  JOINING_TYPE_X, /* 064F */
+  JOINING_TYPE_X, /* 0650 */
+  JOINING_TYPE_X, /* 0651 */
+  JOINING_TYPE_X, /* 0652 */
+  JOINING_TYPE_X, /* 0653 */
+  JOINING_TYPE_X, /* 0654 */
+  JOINING_TYPE_X, /* 0655 */
+  JOINING_TYPE_X, /* 0656 */
+  JOINING_TYPE_X, /* 0657 */
+  JOINING_TYPE_X, /* 0658 */
+  JOINING_TYPE_X, /* 0659 */
+  JOINING_TYPE_X, /* 065A */
+  JOINING_TYPE_X, /* 065B */
+  JOINING_TYPE_X, /* 065C */
+  JOINING_TYPE_X, /* 065D */
+  JOINING_TYPE_X, /* 065E */
+  JOINING_TYPE_X, /* 065F */
+  JOINING_TYPE_X, /* 0660 */
+  JOINING_TYPE_X, /* 0661 */
+  JOINING_TYPE_X, /* 0662 */
+  JOINING_TYPE_X, /* 0663 */
+  JOINING_TYPE_X, /* 0664 */
+  JOINING_TYPE_X, /* 0665 */
+  JOINING_TYPE_X, /* 0666 */
+  JOINING_TYPE_X, /* 0667 */
+  JOINING_TYPE_X, /* 0668 */
+  JOINING_TYPE_X, /* 0669 */
+  JOINING_TYPE_X, /* 066A */
+  JOINING_TYPE_X, /* 066B */
+  JOINING_TYPE_X, /* 066C */
+  JOINING_TYPE_X, /* 066D */
+  JOINING_TYPE_D, /* 066E; DOTLESS BEH; D; BEH */
+  JOINING_TYPE_D, /* 066F; DOTLESS QAF; D; QAF */
+  JOINING_TYPE_X, /* 0670 */
+  JOINING_TYPE_R, /* 0671; ALEF WITH WASLA ABOVE; R; ALEF */
+  JOINING_TYPE_R, /* 0672; ALEF WITH WAVY HAMZA ABOVE; R; ALEF */
+  JOINING_TYPE_R, /* 0673; ALEF WITH WAVY HAMZA BELOW; R; ALEF */
+  JOINING_TYPE_U, /* 0674; HIGH HAMZA; U; No_Joining_Group */
+  JOINING_TYPE_R, /* 0675; HIGH HAMZA ALEF; R; ALEF */
+  JOINING_TYPE_R, /* 0676; HIGH HAMZA WAW; R; WAW */
+  JOINING_TYPE_R, /* 0677; HIGH HAMZA WAW WITH DAMMA ABOVE; R; WAW */
+  JOINING_TYPE_D, /* 0678; HIGH HAMZA DOTLESS YEH; D; YEH */
+  JOINING_TYPE_D, /* 0679; DOTLESS BEH WITH TAH ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 067A; DOTLESS BEH WITH VERTICAL 2 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 067B; DOTLESS BEH WITH VERTICAL 2 DOTS BELOW; D; BEH */
+  JOINING_TYPE_D, /* 067C; DOTLESS BEH WITH ATTACHED RING BELOW AND 2 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 067D; DOTLESS BEH WITH INVERTED 3 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 067E; DOTLESS BEH WITH 3 DOTS BELOW; D; BEH */
+  JOINING_TYPE_D, /* 067F; DOTLESS BEH WITH 4 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 0680; DOTLESS BEH WITH 4 DOTS BELOW; D; BEH */
+  JOINING_TYPE_D, /* 0681; HAH WITH HAMZA ABOVE; D; HAH */
+  JOINING_TYPE_D, /* 0682; HAH WITH VERTICAL 2 DOTS ABOVE; D; HAH */
+  JOINING_TYPE_D, /* 0683; HAH WITH 2 DOTS BELOW; D; HAH */
+  JOINING_TYPE_D, /* 0684; HAH WITH VERTICAL 2 DOTS BELOW; D; HAH */
+  JOINING_TYPE_D, /* 0685; HAH WITH 3 DOTS ABOVE; D; HAH */
+  JOINING_TYPE_D, /* 0686; HAH WITH 3 DOTS BELOW; D; HAH */
+  JOINING_TYPE_D, /* 0687; HAH WITH 4 DOTS BELOW; D; HAH */
+  JOINING_TYPE_R, /* 0688; DAL WITH TAH ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 0689; DAL WITH ATTACHED RING BELOW; R; DAL */
+  JOINING_TYPE_R, /* 068A; DAL WITH DOT BELOW; R; DAL */
+  JOINING_TYPE_R, /* 068B; DAL WITH DOT BELOW AND TAH ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 068C; DAL WITH 2 DOTS ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 068D; DAL WITH 2 DOTS BELOW; R; DAL */
+  JOINING_TYPE_R, /* 068E; DAL WITH 3 DOTS ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 068F; DAL WITH INVERTED 3 DOTS ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 0690; DAL WITH 4 DOTS ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 0691; REH WITH TAH ABOVE; R; REH */
+  JOINING_TYPE_R, /* 0692; REH WITH V ABOVE; R; REH */
+  JOINING_TYPE_R, /* 0693; REH WITH ATTACHED RING BELOW; R; REH */
+  JOINING_TYPE_R, /* 0694; REH WITH DOT BELOW; R; REH */
+  JOINING_TYPE_R, /* 0695; REH WITH V BELOW; R; REH */
+  JOINING_TYPE_R, /* 0696; REH WITH DOT BELOW AND DOT WITHIN; R; REH */
+  JOINING_TYPE_R, /* 0697; REH WITH 2 DOTS ABOVE; R; REH */
+  JOINING_TYPE_R, /* 0698; REH WITH 3 DOTS ABOVE; R; REH */
+  JOINING_TYPE_R, /* 0699; REH WITH 4 DOTS ABOVE; R; REH */
+  JOINING_TYPE_D, /* 069A; SEEN WITH DOT BELOW AND DOT ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 069B; SEEN WITH 3 DOTS BELOW; D; SEEN */
+  JOINING_TYPE_D, /* 069C; SEEN WITH 3 DOTS BELOW AND 3 DOTS ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 069D; SAD WITH 2 DOTS BELOW; D; SAD */
+  JOINING_TYPE_D, /* 069E; SAD WITH 3 DOTS ABOVE; D; SAD */
+  JOINING_TYPE_D, /* 069F; TAH WITH 3 DOTS ABOVE; D; TAH */
+  JOINING_TYPE_D, /* 06A0; AIN WITH 3 DOTS ABOVE; D; AIN */
+  JOINING_TYPE_D, /* 06A1; DOTLESS FEH; D; FEH */
+  JOINING_TYPE_D, /* 06A2; DOTLESS FEH WITH DOT BELOW; D; FEH */
+  JOINING_TYPE_D, /* 06A3; FEH WITH DOT BELOW; D; FEH */
+  JOINING_TYPE_D, /* 06A4; DOTLESS FEH WITH 3 DOTS ABOVE; D; FEH */
+  JOINING_TYPE_D, /* 06A5; DOTLESS FEH WITH 3 DOTS BELOW; D; FEH */
+  JOINING_TYPE_D, /* 06A6; DOTLESS FEH WITH 4 DOTS ABOVE; D; FEH */
+  JOINING_TYPE_D, /* 06A7; DOTLESS QAF WITH DOT ABOVE; D; QAF */
+  JOINING_TYPE_D, /* 06A8; DOTLESS QAF WITH 3 DOTS ABOVE; D; QAF */
+  JOINING_TYPE_D, /* 06A9; KEHEH; D; GAF */
+  JOINING_TYPE_D, /* 06AA; SWASH KAF; D; SWASH KAF */
+  JOINING_TYPE_D, /* 06AB; KEHEH WITH ATTACHED RING BELOW; D; GAF */
+  JOINING_TYPE_D, /* 06AC; KAF WITH DOT ABOVE; D; KAF */
+  JOINING_TYPE_D, /* 06AD; KAF WITH 3 DOTS ABOVE; D; KAF */
+  JOINING_TYPE_D, /* 06AE; KAF WITH 3 DOTS BELOW; D; KAF */
+  JOINING_TYPE_D, /* 06AF; GAF; D; GAF */
+  JOINING_TYPE_D, /* 06B0; GAF WITH ATTACHED RING BELOW; D; GAF */
+  JOINING_TYPE_D, /* 06B1; GAF WITH 2 DOTS ABOVE; D; GAF */
+  JOINING_TYPE_D, /* 06B2; GAF WITH 2 DOTS BELOW; D; GAF */
+  JOINING_TYPE_D, /* 06B3; GAF WITH VERTICAL 2 DOTS BELOW; D; GAF */
+  JOINING_TYPE_D, /* 06B4; GAF WITH 3 DOTS ABOVE; D; GAF */
+  JOINING_TYPE_D, /* 06B5; LAM WITH V ABOVE; D; LAM */
+  JOINING_TYPE_D, /* 06B6; LAM WITH DOT ABOVE; D; LAM */
+  JOINING_TYPE_D, /* 06B7; LAM WITH 3 DOTS ABOVE; D; LAM */
+  JOINING_TYPE_D, /* 06B8; LAM WITH 3 DOTS BELOW; D; LAM */
+  JOINING_TYPE_D, /* 06B9; NOON WITH DOT BELOW; D; NOON */
+  JOINING_TYPE_D, /* 06BA; DOTLESS NOON; D; NOON */
+  JOINING_TYPE_D, /* 06BB; DOTLESS NOON WITH TAH ABOVE; D; NOON */
+  JOINING_TYPE_D, /* 06BC; NOON WITH ATTACHED RING BELOW; D; NOON */
+  JOINING_TYPE_D, /* 06BD; NYA; D; NYA */
+  JOINING_TYPE_D, /* 06BE; KNOTTED HEH; D; KNOTTED HEH */
+  JOINING_TYPE_D, /* 06BF; HAH WITH 3 DOTS BELOW AND DOT ABOVE; D; HAH */
+  JOINING_TYPE_R, /* 06C0; DOTLESS TEH MARBUTA WITH HAMZA ABOVE; R; TEH MARBUTA */
+  JOINING_TYPE_D, /* 06C1; HEH GOAL; D; HEH GOAL */
+  JOINING_TYPE_D, /* 06C2; HEH GOAL WITH HAMZA ABOVE; D; HEH GOAL */
+  JOINING_TYPE_R, /* 06C3; TEH MARBUTA GOAL; R; TEH MARBUTA GOAL */
+  JOINING_TYPE_R, /* 06C4; WAW WITH ATTACHED RING WITHIN; R; WAW */
+  JOINING_TYPE_R, /* 06C5; WAW WITH BAR; R; WAW */
+  JOINING_TYPE_R, /* 06C6; WAW WITH V ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 06C7; WAW WITH DAMMA ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 06C8; WAW WITH ALEF ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 06C9; WAW WITH INVERTED V ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 06CA; WAW WITH 2 DOTS ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 06CB; WAW WITH 3 DOTS ABOVE; R; WAW */
+  JOINING_TYPE_D, /* 06CC; FARSI YEH; D; FARSI YEH */
+  JOINING_TYPE_R, /* 06CD; YEH WITH TAIL; R; YEH WITH TAIL */
+  JOINING_TYPE_D, /* 06CE; FARSI YEH WITH V ABOVE; D; FARSI YEH */
+  JOINING_TYPE_R, /* 06CF; WAW WITH DOT ABOVE; R; WAW */
+  JOINING_TYPE_D, /* 06D0; DOTLESS YEH WITH VERTICAL 2 DOTS BELOW; D; YEH */
+  JOINING_TYPE_D, /* 06D1; DOTLESS YEH WITH 3 DOTS BELOW; D; YEH */
+  JOINING_TYPE_R, /* 06D2; YEH BARREE; R; YEH BARREE */
+  JOINING_TYPE_R, /* 06D3; YEH BARREE WITH HAMZA ABOVE; R; YEH BARREE */
+  JOINING_TYPE_X, /* 06D4 */
+  JOINING_TYPE_R, /* 06D5; DOTLESS TEH MARBUTA; R; TEH MARBUTA */
+  JOINING_TYPE_X, /* 06D6 */
+  JOINING_TYPE_X, /* 06D7 */
+  JOINING_TYPE_X, /* 06D8 */
+  JOINING_TYPE_X, /* 06D9 */
+  JOINING_TYPE_X, /* 06DA */
+  JOINING_TYPE_X, /* 06DB */
+  JOINING_TYPE_X, /* 06DC */
+  JOINING_TYPE_U, /* 06DD; ARABIC END OF AYAH; U; No_Joining_Group */
+  JOINING_TYPE_X, /* 06DE */
+  JOINING_TYPE_X, /* 06DF */
+  JOINING_TYPE_X, /* 06E0 */
+  JOINING_TYPE_X, /* 06E1 */
+  JOINING_TYPE_X, /* 06E2 */
+  JOINING_TYPE_X, /* 06E3 */
+  JOINING_TYPE_X, /* 06E4 */
+  JOINING_TYPE_X, /* 06E5 */
+  JOINING_TYPE_X, /* 06E6 */
+  JOINING_TYPE_X, /* 06E7 */
+  JOINING_TYPE_X, /* 06E8 */
+  JOINING_TYPE_X, /* 06E9 */
+  JOINING_TYPE_X, /* 06EA */
+  JOINING_TYPE_X, /* 06EB */
+  JOINING_TYPE_X, /* 06EC */
+  JOINING_TYPE_X, /* 06ED */
+  JOINING_TYPE_R, /* 06EE; DAL WITH INVERTED V ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 06EF; REH WITH INVERTED V ABOVE; R; REH */
+  JOINING_TYPE_X, /* 06F0 */
+  JOINING_TYPE_X, /* 06F1 */
+  JOINING_TYPE_X, /* 06F2 */
+  JOINING_TYPE_X, /* 06F3 */
+  JOINING_TYPE_X, /* 06F4 */
+  JOINING_TYPE_X, /* 06F5 */
+  JOINING_TYPE_X, /* 06F6 */
+  JOINING_TYPE_X, /* 06F7 */
+  JOINING_TYPE_X, /* 06F8 */
+  JOINING_TYPE_X, /* 06F9 */
+  JOINING_TYPE_D, /* 06FA; SEEN WITH DOT BELOW AND 3 DOTS ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 06FB; SAD WITH DOT BELOW AND DOT ABOVE; D; SAD */
+  JOINING_TYPE_D, /* 06FC; AIN WITH DOT BELOW AND DOT ABOVE; D; AIN */
+  JOINING_TYPE_X, /* 06FD */
+  JOINING_TYPE_X, /* 06FE */
+  JOINING_TYPE_D, /* 06FF; KNOTTED HEH WITH INVERTED V ABOVE; D; KNOTTED HEH */
+
+  /* Syriac Characters */
+
+  JOINING_TYPE_X, /* 0700 */
+  JOINING_TYPE_X, /* 0701 */
+  JOINING_TYPE_X, /* 0702 */
+  JOINING_TYPE_X, /* 0703 */
+  JOINING_TYPE_X, /* 0704 */
+  JOINING_TYPE_X, /* 0705 */
+  JOINING_TYPE_X, /* 0706 */
+  JOINING_TYPE_X, /* 0707 */
+  JOINING_TYPE_X, /* 0708 */
+  JOINING_TYPE_X, /* 0709 */
+  JOINING_TYPE_X, /* 070A */
+  JOINING_TYPE_X, /* 070B */
+  JOINING_TYPE_X, /* 070C */
+  JOINING_TYPE_X, /* 070D */
+  JOINING_TYPE_X, /* 070E */
+  JOINING_TYPE_X, /* 070F */
+  JOINING_GROUP_ALAPH, /* 0710; ALAPH; R; ALAPH */
+  JOINING_TYPE_X, /* 0711 */
+  JOINING_TYPE_D, /* 0712; BETH; D; BETH */
+  JOINING_TYPE_D, /* 0713; GAMAL; D; GAMAL */
+  JOINING_TYPE_D, /* 0714; GAMAL GARSHUNI; D; GAMAL */
+  JOINING_GROUP_DALATH_RISH, /* 0715; DALATH; R; DALATH RISH */
+  JOINING_GROUP_DALATH_RISH, /* 0716; DOTLESS DALATH RISH; R; DALATH RISH */
+  JOINING_TYPE_R, /* 0717; HE; R; HE */
+  JOINING_TYPE_R, /* 0718; WAW; R; SYRIAC WAW */
+  JOINING_TYPE_R, /* 0719; ZAIN; R; ZAIN */
+  JOINING_TYPE_D, /* 071A; HETH; D; HETH */
+  JOINING_TYPE_D, /* 071B; TETH; D; TETH */
+  JOINING_TYPE_D, /* 071C; TETH GARSHUNI; D; TETH */
+  JOINING_TYPE_D, /* 071D; YUDH; D; YUDH */
+  JOINING_TYPE_R, /* 071E; YUDH HE; R; YUDH HE */
+  JOINING_TYPE_D, /* 071F; KAPH; D; KAPH */
+  JOINING_TYPE_D, /* 0720; LAMADH; D; LAMADH */
+  JOINING_TYPE_D, /* 0721; MIM; D; MIM */
+  JOINING_TYPE_D, /* 0722; NUN; D; NUN */
+  JOINING_TYPE_D, /* 0723; SEMKATH; D; SEMKATH */
+  JOINING_TYPE_D, /* 0724; FINAL SEMKATH; D; FINAL SEMKATH */
+  JOINING_TYPE_D, /* 0725; E; D; E */
+  JOINING_TYPE_D, /* 0726; PE; D; PE */
+  JOINING_TYPE_D, /* 0727; REVERSED PE; D; REVERSED PE */
+  JOINING_TYPE_R, /* 0728; SADHE; R; SADHE */
+  JOINING_TYPE_D, /* 0729; QAPH; D; QAPH */
+  JOINING_GROUP_DALATH_RISH, /* 072A; RISH; R; DALATH RISH */
+  JOINING_TYPE_D, /* 072B; SHIN; D; SHIN */
+  JOINING_TYPE_R, /* 072C; TAW; R; TAW */
+  JOINING_TYPE_D, /* 072D; PERSIAN BHETH; D; BETH */
+  JOINING_TYPE_D, /* 072E; PERSIAN GHAMAL; D; GAMAL */
+  JOINING_GROUP_DALATH_RISH, /* 072F; PERSIAN DHALATH; R; DALATH RISH */
+  JOINING_TYPE_X, /* 0730 */
+  JOINING_TYPE_X, /* 0731 */
+  JOINING_TYPE_X, /* 0732 */
+  JOINING_TYPE_X, /* 0733 */
+  JOINING_TYPE_X, /* 0734 */
+  JOINING_TYPE_X, /* 0735 */
+  JOINING_TYPE_X, /* 0736 */
+  JOINING_TYPE_X, /* 0737 */
+  JOINING_TYPE_X, /* 0738 */
+  JOINING_TYPE_X, /* 0739 */
+  JOINING_TYPE_X, /* 073A */
+  JOINING_TYPE_X, /* 073B */
+  JOINING_TYPE_X, /* 073C */
+  JOINING_TYPE_X, /* 073D */
+  JOINING_TYPE_X, /* 073E */
+  JOINING_TYPE_X, /* 073F */
+  JOINING_TYPE_X, /* 0740 */
+  JOINING_TYPE_X, /* 0741 */
+  JOINING_TYPE_X, /* 0742 */
+  JOINING_TYPE_X, /* 0743 */
+  JOINING_TYPE_X, /* 0744 */
+  JOINING_TYPE_X, /* 0745 */
+  JOINING_TYPE_X, /* 0746 */
+  JOINING_TYPE_X, /* 0747 */
+  JOINING_TYPE_X, /* 0748 */
+  JOINING_TYPE_X, /* 0749 */
+  JOINING_TYPE_X, /* 074A */
+  JOINING_TYPE_X, /* 074B */
+  JOINING_TYPE_X, /* 074C */
+  JOINING_TYPE_R, /* 074D; SOGDIAN ZHAIN; R; ZHAIN */
+  JOINING_TYPE_D, /* 074E; SOGDIAN KHAPH; D; KHAPH */
+  JOINING_TYPE_D, /* 074F; SOGDIAN FE; D; FE */
+
+  /* Arabic Supplement Characters */
+
+  JOINING_TYPE_D, /* 0750; DOTLESS BEH WITH HORIZONTAL 3 DOTS BELOW; D; BEH */
+  JOINING_TYPE_D, /* 0751; BEH WITH 3 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 0752; DOTLESS BEH WITH INVERTED 3 DOTS BELOW; D; BEH */
+  JOINING_TYPE_D, /* 0753; DOTLESS BEH WITH INVERTED 3 DOTS BELOW AND 2 DOTS ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 0754; DOTLESS BEH WITH 2 DOTS BELOW AND DOT ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 0755; DOTLESS BEH WITH INVERTED V BELOW; D; BEH */
+  JOINING_TYPE_D, /* 0756; DOTLESS BEH WITH V ABOVE; D; BEH */
+  JOINING_TYPE_D, /* 0757; HAH WITH 2 DOTS ABOVE; D; HAH */
+  JOINING_TYPE_D, /* 0758; HAH WITH INVERTED 3 DOTS BELOW; D; HAH */
+  JOINING_TYPE_R, /* 0759; DAL WITH VERTICAL 2 DOTS BELOW AND TAH ABOVE; R; DAL */
+  JOINING_TYPE_R, /* 075A; DAL WITH INVERTED V BELOW; R; DAL */
+  JOINING_TYPE_R, /* 075B; REH WITH BAR; R; REH */
+  JOINING_TYPE_D, /* 075C; SEEN WITH 4 DOTS ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 075D; AIN WITH 2 DOTS ABOVE; D; AIN */
+  JOINING_TYPE_D, /* 075E; AIN WITH INVERTED 3 DOTS ABOVE; D; AIN */
+  JOINING_TYPE_D, /* 075F; AIN WITH VERTICAL 2 DOTS ABOVE; D; AIN */
+  JOINING_TYPE_D, /* 0760; DOTLESS FEH WITH 2 DOTS BELOW; D; FEH */
+  JOINING_TYPE_D, /* 0761; DOTLESS FEH WITH INVERTED 3 DOTS BELOW; D; FEH */
+  JOINING_TYPE_D, /* 0762; KEHEH WITH DOT ABOVE; D; GAF */
+  JOINING_TYPE_D, /* 0763; KEHEH WITH 3 DOTS ABOVE; D; GAF */
+  JOINING_TYPE_D, /* 0764; KEHEH WITH INVERTED 3 DOTS BELOW; D; GAF */
+  JOINING_TYPE_D, /* 0765; MEEM WITH DOT ABOVE; D; MEEM */
+  JOINING_TYPE_D, /* 0766; MEEM WITH DOT BELOW; D; MEEM */
+  JOINING_TYPE_D, /* 0767; NOON WITH 2 DOTS BELOW; D; NOON */
+  JOINING_TYPE_D, /* 0768; NOON WITH TAH ABOVE; D; NOON */
+  JOINING_TYPE_D, /* 0769; NOON WITH V ABOVE; D; NOON */
+  JOINING_TYPE_D, /* 076A; LAM WITH BAR; D; LAM */
+  JOINING_TYPE_R, /* 076B; REH WITH VERTICAL 2 DOTS ABOVE; R; REH */
+  JOINING_TYPE_R, /* 076C; REH WITH HAMZA ABOVE; R; REH */
+  JOINING_TYPE_D, /* 076D; SEEN WITH VERTICAL 2 DOTS ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 076E; HAH WITH TAH BELOW; D; HAH */
+  JOINING_TYPE_D, /* 076F; HAH WITH TAH AND 2 DOTS BELOW; D; HAH */
+  JOINING_TYPE_D, /* 0770; SEEN WITH 2 DOTS AND TAH ABOVE; D; SEEN */
+  JOINING_TYPE_R, /* 0771; REH WITH 2 DOTS AND TAH ABOVE; R; REH */
+  JOINING_TYPE_D, /* 0772; HAH WITH TAH ABOVE; D; HAH */
+  JOINING_TYPE_R, /* 0773; ALEF WITH DIGIT TWO ABOVE; R; ALEF */
+  JOINING_TYPE_R, /* 0774; ALEF WITH DIGIT THREE ABOVE; R; ALEF */
+  JOINING_TYPE_D, /* 0775; FARSI YEH WITH DIGIT TWO ABOVE; D; FARSI YEH */
+  JOINING_TYPE_D, /* 0776; FARSI YEH WITH DIGIT THREE ABOVE; D; FARSI YEH */
+  JOINING_TYPE_D, /* 0777; DOTLESS YEH WITH DIGIT FOUR BELOW; D; YEH */
+  JOINING_TYPE_R, /* 0778; WAW WITH DIGIT TWO ABOVE; R; WAW */
+  JOINING_TYPE_R, /* 0779; WAW WITH DIGIT THREE ABOVE; R; WAW */
+  JOINING_TYPE_D, /* 077A; BURUSHASKI YEH BARREE WITH DIGIT TWO ABOVE; D; BURUSHASKI YEH BARREE */
+  JOINING_TYPE_D, /* 077B; BURUSHASKI YEH BARREE WITH DIGIT THREE ABOVE; D; BURUSHASKI YEH BARREE */
+  JOINING_TYPE_D, /* 077C; HAH WITH DIGIT FOUR BELOW; D; HAH */
+  JOINING_TYPE_D, /* 077D; SEEN WITH DIGIT FOUR ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 077E; SEEN WITH INVERTED V ABOVE; D; SEEN */
+  JOINING_TYPE_D, /* 077F; KAF WITH 2 DOTS ABOVE; D; KAF */
+
+  /* N'Ko Characters */
+
+  JOINING_TYPE_X, /* 0780 */
+  JOINING_TYPE_X, /* 0781 */
+  JOINING_TYPE_X, /* 0782 */
+  JOINING_TYPE_X, /* 0783 */
+  JOINING_TYPE_X, /* 0784 */
+  JOINING_TYPE_X, /* 0785 */
+  JOINING_TYPE_X, /* 0786 */
+  JOINING_TYPE_X, /* 0787 */
+  JOINING_TYPE_X, /* 0788 */
+  JOINING_TYPE_X, /* 0789 */
+  JOINING_TYPE_X, /* 078A */
+  JOINING_TYPE_X, /* 078B */
+  JOINING_TYPE_X, /* 078C */
+  JOINING_TYPE_X, /* 078D */
+  JOINING_TYPE_X, /* 078E */
+  JOINING_TYPE_X, /* 078F */
+  JOINING_TYPE_X, /* 0790 */
+  JOINING_TYPE_X, /* 0791 */
+  JOINING_TYPE_X, /* 0792 */
+  JOINING_TYPE_X, /* 0793 */
+  JOINING_TYPE_X, /* 0794 */
+  JOINING_TYPE_X, /* 0795 */
+  JOINING_TYPE_X, /* 0796 */
+  JOINING_TYPE_X, /* 0797 */
+  JOINING_TYPE_X, /* 0798 */
+  JOINING_TYPE_X, /* 0799 */
+  JOINING_TYPE_X, /* 079A */
+  JOINING_TYPE_X, /* 079B */
+  JOINING_TYPE_X, /* 079C */
+  JOINING_TYPE_X, /* 079D */
+  JOINING_TYPE_X, /* 079E */
+  JOINING_TYPE_X, /* 079F */
+  JOINING_TYPE_X, /* 07A0 */
+  JOINING_TYPE_X, /* 07A1 */
+  JOINING_TYPE_X, /* 07A2 */
+  JOINING_TYPE_X, /* 07A3 */
+  JOINING_TYPE_X, /* 07A4 */
+  JOINING_TYPE_X, /* 07A5 */
+  JOINING_TYPE_X, /* 07A6 */
+  JOINING_TYPE_X, /* 07A7 */
+  JOINING_TYPE_X, /* 07A8 */
+  JOINING_TYPE_X, /* 07A9 */
+  JOINING_TYPE_X, /* 07AA */
+  JOINING_TYPE_X, /* 07AB */
+  JOINING_TYPE_X, /* 07AC */
+  JOINING_TYPE_X, /* 07AD */
+  JOINING_TYPE_X, /* 07AE */
+  JOINING_TYPE_X, /* 07AF */
+  JOINING_TYPE_X, /* 07B0 */
+  JOINING_TYPE_X, /* 07B1 */
+  JOINING_TYPE_X, /* 07B2 */
+  JOINING_TYPE_X, /* 07B3 */
+  JOINING_TYPE_X, /* 07B4 */
+  JOINING_TYPE_X, /* 07B5 */
+  JOINING_TYPE_X, /* 07B6 */
+  JOINING_TYPE_X, /* 07B7 */
+  JOINING_TYPE_X, /* 07B8 */
+  JOINING_TYPE_X, /* 07B9 */
+  JOINING_TYPE_X, /* 07BA */
+  JOINING_TYPE_X, /* 07BB */
+  JOINING_TYPE_X, /* 07BC */
+  JOINING_TYPE_X, /* 07BD */
+  JOINING_TYPE_X, /* 07BE */
+  JOINING_TYPE_X, /* 07BF */
+  JOINING_TYPE_X, /* 07C0 */
+  JOINING_TYPE_X, /* 07C1 */
+  JOINING_TYPE_X, /* 07C2 */
+  JOINING_TYPE_X, /* 07C3 */
+  JOINING_TYPE_X, /* 07C4 */
+  JOINING_TYPE_X, /* 07C5 */
+  JOINING_TYPE_X, /* 07C6 */
+  JOINING_TYPE_X, /* 07C7 */
+  JOINING_TYPE_X, /* 07C8 */
+  JOINING_TYPE_X, /* 07C9 */
+  JOINING_TYPE_D, /* 07CA; NKO A; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07CB; NKO EE; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07CC; NKO I; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07CD; NKO E; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07CE; NKO U; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07CF; NKO OO; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D0; NKO O; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D1; NKO DAGBASINNA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D2; NKO N; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D3; NKO BA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D4; NKO PA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D5; NKO TA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D6; NKO JA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D7; NKO CHA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D8; NKO DA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07D9; NKO RA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DA; NKO RRA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DB; NKO SA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DC; NKO GBA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DD; NKO FA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DE; NKO KA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07DF; NKO LA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E0; NKO NA WOLOSO; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E1; NKO MA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E2; NKO NYA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E3; NKO NA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E4; NKO HA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E5; NKO WA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E6; NKO YA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E7; NKO NYA WOLOSO; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E8; NKO JONA JA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07E9; NKO JONA CHA; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 07EA; NKO JONA RA; D; No_Joining_Group */
+  JOINING_TYPE_X, /* 07EB */
+  JOINING_TYPE_X, /* 07EC */
+  JOINING_TYPE_X, /* 07ED */
+  JOINING_TYPE_X, /* 07EE */
+  JOINING_TYPE_X, /* 07EF */
+  JOINING_TYPE_X, /* 07F0 */
+  JOINING_TYPE_X, /* 07F1 */
+  JOINING_TYPE_X, /* 07F2 */
+  JOINING_TYPE_X, /* 07F3 */
+  JOINING_TYPE_X, /* 07F4 */
+  JOINING_TYPE_X, /* 07F5 */
+  JOINING_TYPE_X, /* 07F6 */
+  JOINING_TYPE_X, /* 07F7 */
+  JOINING_TYPE_X, /* 07F8 */
+  JOINING_TYPE_X, /* 07F9 */
+  JOINING_TYPE_C, /* 07FA; NKO LAJANYALAN; C; No_Joining_Group */
+
+  /* Mandaic Characters */
+
+  JOINING_TYPE_X, /* 07FB */
+  JOINING_TYPE_X, /* 07FC */
+  JOINING_TYPE_X, /* 07FD */
+  JOINING_TYPE_X, /* 07FE */
+  JOINING_TYPE_X, /* 07FF */
+  JOINING_TYPE_X, /* 0800 */
+  JOINING_TYPE_X, /* 0801 */
+  JOINING_TYPE_X, /* 0802 */
+  JOINING_TYPE_X, /* 0803 */
+  JOINING_TYPE_X, /* 0804 */
+  JOINING_TYPE_X, /* 0805 */
+  JOINING_TYPE_X, /* 0806 */
+  JOINING_TYPE_X, /* 0807 */
+  JOINING_TYPE_X, /* 0808 */
+  JOINING_TYPE_X, /* 0809 */
+  JOINING_TYPE_X, /* 080A */
+  JOINING_TYPE_X, /* 080B */
+  JOINING_TYPE_X, /* 080C */
+  JOINING_TYPE_X, /* 080D */
+  JOINING_TYPE_X, /* 080E */
+  JOINING_TYPE_X, /* 080F */
+  JOINING_TYPE_X, /* 0810 */
+  JOINING_TYPE_X, /* 0811 */
+  JOINING_TYPE_X, /* 0812 */
+  JOINING_TYPE_X, /* 0813 */
+  JOINING_TYPE_X, /* 0814 */
+  JOINING_TYPE_X, /* 0815 */
+  JOINING_TYPE_X, /* 0816 */
+  JOINING_TYPE_X, /* 0817 */
+  JOINING_TYPE_X, /* 0818 */
+  JOINING_TYPE_X, /* 0819 */
+  JOINING_TYPE_X, /* 081A */
+  JOINING_TYPE_X, /* 081B */
+  JOINING_TYPE_X, /* 081C */
+  JOINING_TYPE_X, /* 081D */
+  JOINING_TYPE_X, /* 081E */
+  JOINING_TYPE_X, /* 081F */
+  JOINING_TYPE_X, /* 0820 */
+  JOINING_TYPE_X, /* 0821 */
+  JOINING_TYPE_X, /* 0822 */
+  JOINING_TYPE_X, /* 0823 */
+  JOINING_TYPE_X, /* 0824 */
+  JOINING_TYPE_X, /* 0825 */
+  JOINING_TYPE_X, /* 0826 */
+  JOINING_TYPE_X, /* 0827 */
+  JOINING_TYPE_X, /* 0828 */
+  JOINING_TYPE_X, /* 0829 */
+  JOINING_TYPE_X, /* 082A */
+  JOINING_TYPE_X, /* 082B */
+  JOINING_TYPE_X, /* 082C */
+  JOINING_TYPE_X, /* 082D */
+  JOINING_TYPE_X, /* 082E */
+  JOINING_TYPE_X, /* 082F */
+  JOINING_TYPE_X, /* 0830 */
+  JOINING_TYPE_X, /* 0831 */
+  JOINING_TYPE_X, /* 0832 */
+  JOINING_TYPE_X, /* 0833 */
+  JOINING_TYPE_X, /* 0834 */
+  JOINING_TYPE_X, /* 0835 */
+  JOINING_TYPE_X, /* 0836 */
+  JOINING_TYPE_X, /* 0837 */
+  JOINING_TYPE_X, /* 0838 */
+  JOINING_TYPE_X, /* 0839 */
+  JOINING_TYPE_X, /* 083A */
+  JOINING_TYPE_X, /* 083B */
+  JOINING_TYPE_X, /* 083C */
+  JOINING_TYPE_X, /* 083D */
+  JOINING_TYPE_X, /* 083E */
+  JOINING_TYPE_X, /* 083F */
+  JOINING_TYPE_R, /* 0840; MANDAIC HALQA; R; No_Joining_Group */
+  JOINING_TYPE_D, /* 0841; MANDAIC AB; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0842; MANDAIC AG; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0843; MANDAIC AD; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0844; MANDAIC AH; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0845; MANDAIC USHENNA; D; No_Joining_Group */
+  JOINING_TYPE_R, /* 0846; MANDAIC AZ; R; No_Joining_Group */
+  JOINING_TYPE_D, /* 0847; MANDAIC IT; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0848; MANDAIC ATT; D; No_Joining_Group */
+  JOINING_TYPE_R, /* 0849; MANDAIC AKSA; R; No_Joining_Group */
+  JOINING_TYPE_D, /* 084A; MANDAIC AK; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 084B; MANDAIC AL; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 084C; MANDAIC AM; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 084D; MANDAIC AN; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 084E; MANDAIC AS; D; No_Joining_Group */
+  JOINING_TYPE_R, /* 084F; MANDAIC IN; R; No_Joining_Group */
+  JOINING_TYPE_D, /* 0850; MANDAIC AP; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0851; MANDAIC ASZ; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0852; MANDAIC AQ; D; No_Joining_Group */
+  JOINING_TYPE_D, /* 0853; MANDAIC AR; D; No_Joining_Group */
+  JOINING_TYPE_R, /* 0854; MANDAIC ASH; R; No_Joining_Group */
+  JOINING_TYPE_D, /* 0855; MANDAIC AT; D; No_Joining_Group */
+  JOINING_TYPE_U, /* 0856; MANDAIC DUSHENNA; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0857; MANDAIC KAD; U; No_Joining_Group */
+  JOINING_TYPE_U, /* 0858; MANDAIC AIN; U; No_Joining_Group */
+
+  /* Arabic Extended-A Characters */
+
+  JOINING_TYPE_X, /* 0859 */
+  JOINING_TYPE_X, /* 085A */
+  JOINING_TYPE_X, /* 085B */
+  JOINING_TYPE_X, /* 085C */
+  JOINING_TYPE_X, /* 085D */
+  JOINING_TYPE_X, /* 085E */
+  JOINING_TYPE_X, /* 085F */
+  JOINING_TYPE_X, /* 0860 */
+  JOINING_TYPE_X, /* 0861 */
+  JOINING_TYPE_X, /* 0862 */
+  JOINING_TYPE_X, /* 0863 */
+  JOINING_TYPE_X, /* 0864 */
+  JOINING_TYPE_X, /* 0865 */
+  JOINING_TYPE_X, /* 0866 */
+  JOINING_TYPE_X, /* 0867 */
+  JOINING_TYPE_X, /* 0868 */
+  JOINING_TYPE_X, /* 0869 */
+  JOINING_TYPE_X, /* 086A */
+  JOINING_TYPE_X, /* 086B */
+  JOINING_TYPE_X, /* 086C */
+  JOINING_TYPE_X, /* 086D */
+  JOINING_TYPE_X, /* 086E */
+  JOINING_TYPE_X, /* 086F */
+  JOINING_TYPE_X, /* 0870 */
+  JOINING_TYPE_X, /* 0871 */
+  JOINING_TYPE_X, /* 0872 */
+  JOINING_TYPE_X, /* 0873 */
+  JOINING_TYPE_X, /* 0874 */
+  JOINING_TYPE_X, /* 0875 */
+  JOINING_TYPE_X, /* 0876 */
+  JOINING_TYPE_X, /* 0877 */
+  JOINING_TYPE_X, /* 0878 */
+  JOINING_TYPE_X, /* 0879 */
+  JOINING_TYPE_X, /* 087A */
+  JOINING_TYPE_X, /* 087B */
+  JOINING_TYPE_X, /* 087C */
+  JOINING_TYPE_X, /* 087D */
+  JOINING_TYPE_X, /* 087E */
+  JOINING_TYPE_X, /* 087F */
+  JOINING_TYPE_X, /* 0880 */
+  JOINING_TYPE_X, /* 0881 */
+  JOINING_TYPE_X, /* 0882 */
+  JOINING_TYPE_X, /* 0883 */
+  JOINING_TYPE_X, /* 0884 */
+  JOINING_TYPE_X, /* 0885 */
+  JOINING_TYPE_X, /* 0886 */
+  JOINING_TYPE_X, /* 0887 */
+  JOINING_TYPE_X, /* 0888 */
+  JOINING_TYPE_X, /* 0889 */
+  JOINING_TYPE_X, /* 088A */
+  JOINING_TYPE_X, /* 088B */
+  JOINING_TYPE_X, /* 088C */
+  JOINING_TYPE_X, /* 088D */
+  JOINING_TYPE_X, /* 088E */
+  JOINING_TYPE_X, /* 088F */
+  JOINING_TYPE_X, /* 0890 */
+  JOINING_TYPE_X, /* 0891 */
+  JOINING_TYPE_X, /* 0892 */
+  JOINING_TYPE_X, /* 0893 */
+  JOINING_TYPE_X, /* 0894 */
+  JOINING_TYPE_X, /* 0895 */
+  JOINING_TYPE_X, /* 0896 */
+  JOINING_TYPE_X, /* 0897 */
+  JOINING_TYPE_X, /* 0898 */
+  JOINING_TYPE_X, /* 0899 */
+  JOINING_TYPE_X, /* 089A */
+  JOINING_TYPE_X, /* 089B */
+  JOINING_TYPE_X, /* 089C */
+  JOINING_TYPE_X, /* 089D */
+  JOINING_TYPE_X, /* 089E */
+  JOINING_TYPE_X, /* 089F */
+  JOINING_TYPE_D, /* 08A0; DOTLESS BEH WITH V BELOW; D; BEH */
+  JOINING_TYPE_X, /* 08A1 */
+  JOINING_TYPE_D, /* 08A2; HAH WITH DOT BELOW AND 2 DOTS ABOVE; D; HAH */
+  JOINING_TYPE_D, /* 08A3; TAH WITH 2 DOTS ABOVE; D; TAH */
+  JOINING_TYPE_D, /* 08A4; DOTLESS FEH WITH DOT BELOW AND 3 DOTS ABOVE; D; FEH */
+  JOINING_TYPE_D, /* 08A5; QAF WITH DOT BELOW; D; QAF */
+  JOINING_TYPE_D, /* 08A6; LAM WITH DOUBLE BAR; D; LAM */
+  JOINING_TYPE_D, /* 08A7; MEEM WITH 3 DOTS ABOVE; D; MEEM */
+  JOINING_TYPE_D, /* 08A8; YEH WITH HAMZA ABOVE; D; YEH */
+  JOINING_TYPE_D, /* 08A9; YEH WITH DOT ABOVE; D; YEH */
+  JOINING_TYPE_R, /* 08AA; REH WITH LOOP; R; REH */
+  JOINING_TYPE_R, /* 08AB; WAW WITH DOT WITHIN; R; WAW */
+  JOINING_TYPE_R, /* 08AC; ROHINGYA YEH; R; ROHINGYA YEH */
+
+};
+
+#define JOINING_TABLE_FIRST	0x0600
+#define JOINING_TABLE_LAST	0x08AC
+
+
+static const uint16_t shaping_table[][4] =
+{
+  {0x0621, 0x0621, 0x0621, 0xFE80}, /* U+0621 ARABIC LETTER HAMZA ISOLATED FORM */
+  {0x0622, 0x0622, 0xFE82, 0xFE81}, /* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE */
+  {0x0623, 0x0623, 0xFE84, 0xFE83}, /* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE */
+  {0x0624, 0x0624, 0xFE86, 0xFE85}, /* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE */
+  {0x0625, 0x0625, 0xFE88, 0xFE87}, /* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW */
+  {0xFE8B, 0xFE8C, 0xFE8A, 0xFE89}, /* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE */
+  {0x0627, 0x0627, 0xFE8E, 0xFE8D}, /* U+0627 ARABIC LETTER ALEF */
+  {0xFE91, 0xFE92, 0xFE90, 0xFE8F}, /* U+0628 ARABIC LETTER BEH */
+  {0x0629, 0x0629, 0xFE94, 0xFE93}, /* U+0629 ARABIC LETTER TEH MARBUTA */
+  {0xFE97, 0xFE98, 0xFE96, 0xFE95}, /* U+062A ARABIC LETTER TEH */
+  {0xFE9B, 0xFE9C, 0xFE9A, 0xFE99}, /* U+062B ARABIC LETTER THEH */
+  {0xFE9F, 0xFEA0, 0xFE9E, 0xFE9D}, /* U+062C ARABIC LETTER JEEM */
+  {0xFEA3, 0xFEA4, 0xFEA2, 0xFEA1}, /* U+062D ARABIC LETTER HAH */
+  {0xFEA7, 0xFEA8, 0xFEA6, 0xFEA5}, /* U+062E ARABIC LETTER KHAH */
+  {0x062F, 0x062F, 0xFEAA, 0xFEA9}, /* U+062F ARABIC LETTER DAL */
+  {0x0630, 0x0630, 0xFEAC, 0xFEAB}, /* U+0630 ARABIC LETTER THAL */
+  {0x0631, 0x0631, 0xFEAE, 0xFEAD}, /* U+0631 ARABIC LETTER REH */
+  {0x0632, 0x0632, 0xFEB0, 0xFEAF}, /* U+0632 ARABIC LETTER ZAIN */
+  {0xFEB3, 0xFEB4, 0xFEB2, 0xFEB1}, /* U+0633 ARABIC LETTER SEEN */
+  {0xFEB7, 0xFEB8, 0xFEB6, 0xFEB5}, /* U+0634 ARABIC LETTER SHEEN */
+  {0xFEBB, 0xFEBC, 0xFEBA, 0xFEB9}, /* U+0635 ARABIC LETTER SAD */
+  {0xFEBF, 0xFEC0, 0xFEBE, 0xFEBD}, /* U+0636 ARABIC LETTER DAD */
+  {0xFEC3, 0xFEC4, 0xFEC2, 0xFEC1}, /* U+0637 ARABIC LETTER TAH */
+  {0xFEC7, 0xFEC8, 0xFEC6, 0xFEC5}, /* U+0638 ARABIC LETTER ZAH */
+  {0xFECB, 0xFECC, 0xFECA, 0xFEC9}, /* U+0639 ARABIC LETTER AIN */
+  {0xFECF, 0xFED0, 0xFECE, 0xFECD}, /* U+063A ARABIC LETTER GHAIN */
+  {0x063B, 0x063B, 0x063B, 0x063B}, /* U+063B  */
+  {0x063C, 0x063C, 0x063C, 0x063C}, /* U+063C  */
+  {0x063D, 0x063D, 0x063D, 0x063D}, /* U+063D  */
+  {0x063E, 0x063E, 0x063E, 0x063E}, /* U+063E  */
+  {0x063F, 0x063F, 0x063F, 0x063F}, /* U+063F  */
+  {0x0640, 0x0640, 0x0640, 0x0640}, /* U+0640  */
+  {0xFED3, 0xFED4, 0xFED2, 0xFED1}, /* U+0641 ARABIC LETTER FEH */
+  {0xFED7, 0xFED8, 0xFED6, 0xFED5}, /* U+0642 ARABIC LETTER QAF */
+  {0xFEDB, 0xFEDC, 0xFEDA, 0xFED9}, /* U+0643 ARABIC LETTER KAF */
+  {0xFEDF, 0xFEE0, 0xFEDE, 0xFEDD}, /* U+0644 ARABIC LETTER LAM */
+  {0xFEE3, 0xFEE4, 0xFEE2, 0xFEE1}, /* U+0645 ARABIC LETTER MEEM */
+  {0xFEE7, 0xFEE8, 0xFEE6, 0xFEE5}, /* U+0646 ARABIC LETTER NOON */
+  {0xFEEB, 0xFEEC, 0xFEEA, 0xFEE9}, /* U+0647 ARABIC LETTER HEH */
+  {0x0648, 0x0648, 0xFEEE, 0xFEED}, /* U+0648 ARABIC LETTER WAW */
+  {0xFBE8, 0xFBE9, 0xFEF0, 0xFEEF}, /* U+0649 ARABIC LETTER */
+  {0xFEF3, 0xFEF4, 0xFEF2, 0xFEF1}, /* U+064A ARABIC LETTER YEH */
+  {0x064B, 0x064B, 0x064B, 0x064B}, /* U+064B  */
+  {0x064C, 0x064C, 0x064C, 0x064C}, /* U+064C  */
+  {0x064D, 0x064D, 0x064D, 0x064D}, /* U+064D  */
+  {0x064E, 0x064E, 0x064E, 0x064E}, /* U+064E  */
+  {0x064F, 0x064F, 0x064F, 0x064F}, /* U+064F  */
+  {0x0650, 0x0650, 0x0650, 0x0650}, /* U+0650  */
+  {0x0651, 0x0651, 0x0651, 0x0651}, /* U+0651  */
+  {0x0652, 0x0652, 0x0652, 0x0652}, /* U+0652  */
+  {0x0653, 0x0653, 0x0653, 0x0653}, /* U+0653  */
+  {0x0654, 0x0654, 0x0654, 0x0654}, /* U+0654  */
+  {0x0655, 0x0655, 0x0655, 0x0655}, /* U+0655  */
+  {0x0656, 0x0656, 0x0656, 0x0656}, /* U+0656  */
+  {0x0657, 0x0657, 0x0657, 0x0657}, /* U+0657  */
+  {0x0658, 0x0658, 0x0658, 0x0658}, /* U+0658  */
+  {0x0659, 0x0659, 0x0659, 0x0659}, /* U+0659  */
+  {0x065A, 0x065A, 0x065A, 0x065A}, /* U+065A  */
+  {0x065B, 0x065B, 0x065B, 0x065B}, /* U+065B  */
+  {0x065C, 0x065C, 0x065C, 0x065C}, /* U+065C  */
+  {0x065D, 0x065D, 0x065D, 0x065D}, /* U+065D  */
+  {0x065E, 0x065E, 0x065E, 0x065E}, /* U+065E  */
+  {0x065F, 0x065F, 0x065F, 0x065F}, /* U+065F  */
+  {0x0660, 0x0660, 0x0660, 0x0660}, /* U+0660  */
+  {0x0661, 0x0661, 0x0661, 0x0661}, /* U+0661  */
+  {0x0662, 0x0662, 0x0662, 0x0662}, /* U+0662  */
+  {0x0663, 0x0663, 0x0663, 0x0663}, /* U+0663  */
+  {0x0664, 0x0664, 0x0664, 0x0664}, /* U+0664  */
+  {0x0665, 0x0665, 0x0665, 0x0665}, /* U+0665  */
+  {0x0666, 0x0666, 0x0666, 0x0666}, /* U+0666  */
+  {0x0667, 0x0667, 0x0667, 0x0667}, /* U+0667  */
+  {0x0668, 0x0668, 0x0668, 0x0668}, /* U+0668  */
+  {0x0669, 0x0669, 0x0669, 0x0669}, /* U+0669  */
+  {0x066A, 0x066A, 0x066A, 0x066A}, /* U+066A  */
+  {0x066B, 0x066B, 0x066B, 0x066B}, /* U+066B  */
+  {0x066C, 0x066C, 0x066C, 0x066C}, /* U+066C  */
+  {0x066D, 0x066D, 0x066D, 0x066D}, /* U+066D  */
+  {0x066E, 0x066E, 0x066E, 0x066E}, /* U+066E  */
+  {0x066F, 0x066F, 0x066F, 0x066F}, /* U+066F  */
+  {0x0670, 0x0670, 0x0670, 0x0670}, /* U+0670  */
+  {0x0671, 0x0671, 0xFB51, 0xFB50}, /* U+0671 ARABIC LETTER ALEF WASLA */
+  {0x0672, 0x0672, 0x0672, 0x0672}, /* U+0672  */
+  {0x0673, 0x0673, 0x0673, 0x0673}, /* U+0673  */
+  {0x0674, 0x0674, 0x0674, 0x0674}, /* U+0674  */
+  {0x0675, 0x0675, 0x0675, 0x0675}, /* U+0675  */
+  {0x0676, 0x0676, 0x0676, 0x0676}, /* U+0676  */
+  {0x0677, 0x0677, 0x0677, 0xFBDD}, /* U+0677 ARABIC LETTER U WITH HAMZA ABOVE ISOLATED FORM */
+  {0x0678, 0x0678, 0x0678, 0x0678}, /* U+0678  */
+  {0xFB68, 0xFB69, 0xFB67, 0xFB66}, /* U+0679 ARABIC LETTER TTEH */
+  {0xFB60, 0xFB61, 0xFB5F, 0xFB5E}, /* U+067A ARABIC LETTER TTEHEH */
+  {0xFB54, 0xFB55, 0xFB53, 0xFB52}, /* U+067B ARABIC LETTER BEEH */
+  {0x067C, 0x067C, 0x067C, 0x067C}, /* U+067C  */
+  {0x067D, 0x067D, 0x067D, 0x067D}, /* U+067D  */
+  {0xFB58, 0xFB59, 0xFB57, 0xFB56}, /* U+067E ARABIC LETTER PEH */
+  {0xFB64, 0xFB65, 0xFB63, 0xFB62}, /* U+067F ARABIC LETTER TEHEH */
+  {0xFB5C, 0xFB5D, 0xFB5B, 0xFB5A}, /* U+0680 ARABIC LETTER BEHEH */
+  {0x0681, 0x0681, 0x0681, 0x0681}, /* U+0681  */
+  {0x0682, 0x0682, 0x0682, 0x0682}, /* U+0682  */
+  {0xFB78, 0xFB79, 0xFB77, 0xFB76}, /* U+0683 ARABIC LETTER NYEH */
+  {0xFB74, 0xFB75, 0xFB73, 0xFB72}, /* U+0684 ARABIC LETTER DYEH */
+  {0x0685, 0x0685, 0x0685, 0x0685}, /* U+0685  */
+  {0xFB7C, 0xFB7D, 0xFB7B, 0xFB7A}, /* U+0686 ARABIC LETTER TCHEH */
+  {0xFB80, 0xFB81, 0xFB7F, 0xFB7E}, /* U+0687 ARABIC LETTER TCHEHEH */
+  {0x0688, 0x0688, 0xFB89, 0xFB88}, /* U+0688 ARABIC LETTER DDAL */
+  {0x0689, 0x0689, 0x0689, 0x0689}, /* U+0689  */
+  {0x068A, 0x068A, 0x068A, 0x068A}, /* U+068A  */
+  {0x068B, 0x068B, 0x068B, 0x068B}, /* U+068B  */
+  {0x068C, 0x068C, 0xFB85, 0xFB84}, /* U+068C ARABIC LETTER DAHAL */
+  {0x068D, 0x068D, 0xFB83, 0xFB82}, /* U+068D ARABIC LETTER DDAHAL */
+  {0x068E, 0x068E, 0xFB87, 0xFB86}, /* U+068E ARABIC LETTER DUL */
+  {0x068F, 0x068F, 0x068F, 0x068F}, /* U+068F  */
+  {0x0690, 0x0690, 0x0690, 0x0690}, /* U+0690  */
+  {0x0691, 0x0691, 0xFB8D, 0xFB8C}, /* U+0691 ARABIC LETTER RREH */
+  {0x0692, 0x0692, 0x0692, 0x0692}, /* U+0692  */
+  {0x0693, 0x0693, 0x0693, 0x0693}, /* U+0693  */
+  {0x0694, 0x0694, 0x0694, 0x0694}, /* U+0694  */
+  {0x0695, 0x0695, 0x0695, 0x0695}, /* U+0695  */
+  {0x0696, 0x0696, 0x0696, 0x0696}, /* U+0696  */
+  {0x0697, 0x0697, 0x0697, 0x0697}, /* U+0697  */
+  {0x0698, 0x0698, 0xFB8B, 0xFB8A}, /* U+0698 ARABIC LETTER JEH */
+  {0x0699, 0x0699, 0x0699, 0x0699}, /* U+0699  */
+  {0x069A, 0x069A, 0x069A, 0x069A}, /* U+069A  */
+  {0x069B, 0x069B, 0x069B, 0x069B}, /* U+069B  */
+  {0x069C, 0x069C, 0x069C, 0x069C}, /* U+069C  */
+  {0x069D, 0x069D, 0x069D, 0x069D}, /* U+069D  */
+  {0x069E, 0x069E, 0x069E, 0x069E}, /* U+069E  */
+  {0x069F, 0x069F, 0x069F, 0x069F}, /* U+069F  */
+  {0x06A0, 0x06A0, 0x06A0, 0x06A0}, /* U+06A0  */
+  {0x06A1, 0x06A1, 0x06A1, 0x06A1}, /* U+06A1  */
+  {0x06A2, 0x06A2, 0x06A2, 0x06A2}, /* U+06A2  */
+  {0x06A3, 0x06A3, 0x06A3, 0x06A3}, /* U+06A3  */
+  {0xFB6C, 0xFB6D, 0xFB6B, 0xFB6A}, /* U+06A4 ARABIC LETTER VEH */
+  {0x06A5, 0x06A5, 0x06A5, 0x06A5}, /* U+06A5  */
+  {0xFB70, 0xFB71, 0xFB6F, 0xFB6E}, /* U+06A6 ARABIC LETTER PEHEH */
+  {0x06A7, 0x06A7, 0x06A7, 0x06A7}, /* U+06A7  */
+  {0x06A8, 0x06A8, 0x06A8, 0x06A8}, /* U+06A8  */
+  {0xFB90, 0xFB91, 0xFB8F, 0xFB8E}, /* U+06A9 ARABIC LETTER KEHEH */
+  {0x06AA, 0x06AA, 0x06AA, 0x06AA}, /* U+06AA  */
+  {0x06AB, 0x06AB, 0x06AB, 0x06AB}, /* U+06AB  */
+  {0x06AC, 0x06AC, 0x06AC, 0x06AC}, /* U+06AC  */
+  {0xFBD5, 0xFBD6, 0xFBD4, 0xFBD3}, /* U+06AD ARABIC LETTER NG */
+  {0x06AE, 0x06AE, 0x06AE, 0x06AE}, /* U+06AE  */
+  {0xFB94, 0xFB95, 0xFB93, 0xFB92}, /* U+06AF ARABIC LETTER GAF */
+  {0x06B0, 0x06B0, 0x06B0, 0x06B0}, /* U+06B0  */
+  {0xFB9C, 0xFB9D, 0xFB9B, 0xFB9A}, /* U+06B1 ARABIC LETTER NGOEH */
+  {0x06B2, 0x06B2, 0x06B2, 0x06B2}, /* U+06B2  */
+  {0xFB98, 0xFB99, 0xFB97, 0xFB96}, /* U+06B3 ARABIC LETTER GUEH */
+  {0x06B4, 0x06B4, 0x06B4, 0x06B4}, /* U+06B4  */
+  {0x06B5, 0x06B5, 0x06B5, 0x06B5}, /* U+06B5  */
+  {0x06B6, 0x06B6, 0x06B6, 0x06B6}, /* U+06B6  */
+  {0x06B7, 0x06B7, 0x06B7, 0x06B7}, /* U+06B7  */
+  {0x06B8, 0x06B8, 0x06B8, 0x06B8}, /* U+06B8  */
+  {0x06B9, 0x06B9, 0x06B9, 0x06B9}, /* U+06B9  */
+  {0x06BA, 0x06BA, 0xFB9F, 0xFB9E}, /* U+06BA ARABIC LETTER NOON GHUNNA */
+  {0xFBA2, 0xFBA3, 0xFBA1, 0xFBA0}, /* U+06BB ARABIC LETTER RNOON */
+  {0x06BC, 0x06BC, 0x06BC, 0x06BC}, /* U+06BC  */
+  {0x06BD, 0x06BD, 0x06BD, 0x06BD}, /* U+06BD  */
+  {0xFBAC, 0xFBAD, 0xFBAB, 0xFBAA}, /* U+06BE ARABIC LETTER HEH DOACHASHMEE */
+  {0x06BF, 0x06BF, 0x06BF, 0x06BF}, /* U+06BF  */
+  {0x06C0, 0x06C0, 0xFBA5, 0xFBA4}, /* U+06C0 ARABIC LETTER HEH WITH YEH ABOVE */
+  {0xFBA8, 0xFBA9, 0xFBA7, 0xFBA6}, /* U+06C1 ARABIC LETTER HEH GOAL */
+  {0x06C2, 0x06C2, 0x06C2, 0x06C2}, /* U+06C2  */
+  {0x06C3, 0x06C3, 0x06C3, 0x06C3}, /* U+06C3  */
+  {0x06C4, 0x06C4, 0x06C4, 0x06C4}, /* U+06C4  */
+  {0x06C5, 0x06C5, 0xFBE1, 0xFBE0}, /* U+06C5 ARABIC LETTER KIRGHIZ OE */
+  {0x06C6, 0x06C6, 0xFBDA, 0xFBD9}, /* U+06C6 ARABIC LETTER OE */
+  {0x06C7, 0x06C7, 0xFBD8, 0xFBD7}, /* U+06C7 ARABIC LETTER U */
+  {0x06C8, 0x06C8, 0xFBDC, 0xFBDB}, /* U+06C8 ARABIC LETTER YU */
+  {0x06C9, 0x06C9, 0xFBE3, 0xFBE2}, /* U+06C9 ARABIC LETTER KIRGHIZ YU */
+  {0x06CA, 0x06CA, 0x06CA, 0x06CA}, /* U+06CA  */
+  {0x06CB, 0x06CB, 0xFBDF, 0xFBDE}, /* U+06CB ARABIC LETTER VE */
+  {0xFBFE, 0xFBFF, 0xFBFD, 0xFBFC}, /* U+06CC ARABIC LETTER FARSI YEH */
+  {0x06CD, 0x06CD, 0x06CD, 0x06CD}, /* U+06CD  */
+  {0x06CE, 0x06CE, 0x06CE, 0x06CE}, /* U+06CE  */
+  {0x06CF, 0x06CF, 0x06CF, 0x06CF}, /* U+06CF  */
+  {0xFBE6, 0xFBE7, 0xFBE5, 0xFBE4}, /* U+06D0 ARABIC LETTER E */
+  {0x06D1, 0x06D1, 0x06D1, 0x06D1}, /* U+06D1  */
+  {0x06D2, 0x06D2, 0xFBAF, 0xFBAE}, /* U+06D2 ARABIC LETTER YEH BARREE */
+  {0x06D3, 0x06D3, 0xFBB1, 0xFBB0}, /* U+06D3 ARABIC LETTER YEH BARREE WITH HAMZA ABOVE */
+};
+
+#define SHAPING_TABLE_FIRST	0x0621
+#define SHAPING_TABLE_LAST	0x06D3
+
+
+static const struct {
+ uint16_t first;
+ struct {
+   uint16_t second;
+   uint16_t ligature;
+ } ligatures[4];
+} ligature_table[] =
+{
+  { 0xFEDF, {
+    { 0xFE88, 0xFEF9 }, /* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM */
+    { 0xFE82, 0xFEF5 }, /* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM */
+    { 0xFE8E, 0xFEFB }, /* ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM */
+    { 0xFE84, 0xFEF7 }, /* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM */
+  }},
+  { 0xFEE0, {
+    { 0xFE88, 0xFEFA }, /* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM */
+    { 0xFE82, 0xFEF6 }, /* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM */
+    { 0xFE8E, 0xFEFC }, /* ARABIC LIGATURE LAM WITH ALEF FINAL FORM */
+    { 0xFE84, 0xFEF8 }, /* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM */
+  }},
+};
+
+
+#endif /* HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH */
+
+/* == End of generated table == */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic.cc	2012-05-08 16:18:47.381387010 +0530
@@ -0,0 +1,626 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+
+#include "hb-ot-shape-complex-indic-private.hh"
+
+static int
+compare_codepoint (const void *pa, const void *pb)
+{
+  hb_codepoint_t a = * (hb_codepoint_t *) pa;
+  hb_codepoint_t b = * (hb_codepoint_t *) pb;
+
+  return a < b ? -1 : a == b ? 0 : +1;
+}
+
+static indic_position_t
+consonant_position (hb_codepoint_t u)
+{
+  consonant_position_t *record;
+
+  record = (consonant_position_t *) bsearch (&u, consonant_positions,
+					     ARRAY_LENGTH (consonant_positions),
+					     sizeof (consonant_positions[0]),
+					     compare_codepoint);
+
+  return record ? record->position : POS_BASE;
+}
+
+static bool
+is_ra (hb_codepoint_t u)
+{
+  return !!bsearch (&u, ra_chars,
+		    ARRAY_LENGTH (ra_chars),
+		    sizeof (ra_chars[0]),
+		    compare_codepoint);
+}
+
+//// vowel matras that have to be split into two parts.
+static const unsigned short split_matras[]  = {
+    //  matra, split1, split2, split3
+
+    // bengalis
+    0x9cb, 0x9c7, 0x9be, 0x0,
+    0x9cc, 0x9c7, 0x9d7, 0x0,
+    // oriya
+    0xb48, 0xb47, 0xb56, 0x0,
+    0xb4b, 0xb47, 0xb3e, 0x0,
+    0xb4c, 0xb47, 0xb57, 0x0,
+    // tamil
+    0xbca, 0xbc6, 0xbbe, 0x0,
+    0xbcb, 0xbc7, 0xbbe, 0x0,
+    0xbcc, 0xbc6, 0xbd7, 0x0,
+    // telugu
+    0xc48, 0xc46, 0xc56, 0x0,
+    // kannada
+    0xcc0, 0xcbf, 0xcd5, 0x0,
+    0xcc7, 0xcc6, 0xcd5, 0x0,
+    0xcc8, 0xcc6, 0xcd6, 0x0,
+    0xcca, 0xcc6, 0xcc2, 0x0,
+    0xccb, 0xcc6, 0xcc2, 0xcd5,
+    // malayalam
+    0xd4a, 0xd46, 0xd3e, 0x0,
+    0xd4b, 0xd47, 0xd3e, 0x0,
+    0xd4c, 0xd46, 0xd57, 0x0,
+    // sinhala
+    0xdda, 0xdd9, 0xdca, 0x0,
+    0xddc, 0xdd9, 0xdcf, 0x0,
+    0xddd, 0xdd9, 0xdcf, 0xdca,
+    0xdde, 0xdd9, 0xddf, 0x0,
+    0xffff
+};
+
+static inline void splitMatra(unsigned short *reordered, int matra, int &len)
+{
+    unsigned short matra_uc = reordered[matra];
+    //qDebug("matra=%d, reordered[matra]=%x", matra, reordered[matra]);
+
+    const unsigned short *split = split_matras;
+    while (split[0] < matra_uc)
+        split += 4;
+
+    assert(*split == matra_uc);
+    ++split;
+
+    int added_chars = split[2] == 0x0 ? 1 : 2;
+
+    memmove(reordered + matra + added_chars, reordered + matra, (len-matra)*sizeof(unsigned short));
+    reordered[matra] = split[0];
+    reordered[matra+1] = split[1];
+    if(added_chars == 2)
+        reordered[matra+2] = split[2];
+    len += added_chars;
+}
+
+static bool
+is_joiner (const hb_glyph_info_t &info)
+{
+  return !!(FLAG (info.indic_category()) & (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ)));
+}
+
+static bool
+is_consonant (const hb_glyph_info_t &info)
+{
+  return !!(FLAG (info.indic_category()) & (FLAG (OT_C) | FLAG (OT_Ra)));
+}
+
+static const struct {
+  hb_tag_t tag;
+  hb_bool_t is_global;
+} indic_basic_features[] =
+{
+  {HB_TAG('n','u','k','t'), true},
+  {HB_TAG('a','k','h','n'), false},
+  {HB_TAG('r','p','h','f'), false},
+  {HB_TAG('r','k','r','f'), false},
+  {HB_TAG('p','r','e','f'), false},
+  {HB_TAG('b','l','w','f'), false},
+  {HB_TAG('h','a','l','f'), false},
+  {HB_TAG('v','a','t','u'), true},
+  {HB_TAG('p','s','t','f'), false},
+  {HB_TAG('c','j','c','t'), false},
+};
+
+/* Same order as the indic_basic_features array */
+enum {
+  _NUKT,
+  AKHN,
+  RPHF,
+  RKRF,
+  PREF,
+  BLWF,
+  HALF,
+  _VATU,
+  PSTF,
+  CJCT
+};
+
+static const hb_tag_t indic_other_features[] =
+{
+  HB_TAG('p','r','e','s'),
+  HB_TAG('a','b','v','s'),
+  HB_TAG('b','l','w','s'),
+  HB_TAG('p','s','t','s'),
+  HB_TAG('h','a','l','n'),
+
+  HB_TAG('d','i','s','t'),
+  HB_TAG('a','b','v','m'),
+  HB_TAG('b','l','w','m'),
+};
+
+
+static void
+initial_reordering (const hb_ot_map_t *map,
+		    hb_face_t *face,
+		    hb_buffer_t *buffer,
+		    void *user_data HB_UNUSED);
+static void
+final_reordering (const hb_ot_map_t *map,
+		  hb_face_t *face,
+		  hb_buffer_t *buffer,
+		  void *user_data HB_UNUSED);
+
+void
+_hb_ot_shape_complex_collect_features_indic (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__) ;
+  map->add_bool_feature (HB_TAG('l','o','c','l'));
+  /* The Indic specs do not require ccmp, but we apply it here since if
+   * there is a use of it, it's typically at the beginning. */
+  map->add_bool_feature (HB_TAG('c','c','m','p'));
+
+  map->add_gsub_pause (initial_reordering, NULL);
+
+  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_basic_features); i++)
+    map->add_bool_feature (indic_basic_features[i].tag, indic_basic_features[i].is_global);
+
+  map->add_gsub_pause (final_reordering, NULL);
+
+  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_other_features); i++)
+    map->add_bool_feature (indic_other_features[i], true);
+}
+
+
+hb_ot_shape_normalization_mode_t
+_hb_ot_shape_complex_normalization_preference_indic (void)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__) ;
+  /* We want split matras decomposed by the common shaping logic. */
+  return HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;
+}
+
+
+void
+_hb_ot_shape_complex_setup_masks_indic (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font)
+{
+//printf ( "(%s)(%d)(%s)  \n", __FILE__, __LINE__, __func__ ) ;
+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);
+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);
+
+  /* We cannot setup masks here.  We save information about characters
+   * and setup masks later on in a pause-callback. */
+
+  unsigned int count = buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+  {
+    unsigned int type = get_indic_categories (buffer->info[i].codepoint);
+
+    buffer->info[i].indic_category() = type & 0x0F;
+    buffer->info[i].indic_position() = (type >> 4) & 7;
+
+    if (buffer->info[i].indic_category() == OT_C) {
+      buffer->info[i].indic_position() = consonant_position (buffer->info[i].codepoint);
+      if (is_ra (buffer->info[i].codepoint))
+	buffer->info[i].indic_category() = OT_Ra;
+//**** For Malayalam start *****/
+      if ( i > 2 ) {
+         if ((buffer->info[i-1].codepoint == 0xd4d) && (buffer->info[i].codepoint == 0xd30)) {
+            buffer->info[i].indic_category() = OT_Ra ; 
+            buffer->info[i].indic_position() = POS_PRE ;
+         }
+      }
+//**** For Malayalam  ends *****/
+    } else if (buffer->info[i].codepoint == 0x200C)
+      buffer->info[i].indic_category() = OT_ZWNJ;
+    else if (buffer->info[i].codepoint == 0x200D)
+      //buffer->info[i].indic_category() = OT_ZWJ;
+      buffer->info[i].indic_category() = OT_X;
+  }
+}
+
+static int
+compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
+{
+  int a = pa->indic_position();
+  int b = pb->indic_position();
+
+  return a < b ? -1 : a == b ? 0 : +1;
+}
+
+static void
+found_consonant_syllable (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array,
+			  unsigned int start, unsigned int end)
+{
+  unsigned int i;
+  hb_glyph_info_t *info = buffer->info;
+//printf ( "(%s)(%d)(%s) (%d)-(%d)(%X)  \n", __FILE__, __LINE__, __func__, start, end,info[start].codepoint  ) ;
+
+  /* Comments from:
+   * https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx */
+
+  /* 1. Find base consonant:
+   *
+   * The shaping engine finds the base consonant of the syllable, using the
+   * following algorithm: starting from the end of the syllable, move backwards
+   * until a consonant is found that does not have a below-base or post-base
+   * form (post-base forms have to follow below-base forms), or that is not a
+   * pre-base reordering Ra, or arrive at the first consonant. The consonant
+   * stopped at will be the base.
+   *
+   *   o If the syllable starts with Ra + Halant (in a script that has Reph)
+   *     and has more than one consonant, Ra is excluded from candidates for
+   *     base consonants.
+   */
+
+  unsigned int base = end;
+
+  /* -> starting from the end of the syllable, move backwards */
+  i = end;
+  unsigned int limit = start;
+  if (info[start].indic_category() == OT_Ra && start + 2 <= end) {
+    limit += 2;
+    base = start;
+  };
+  do {
+    i--;
+//printf ( "(%s)(%d)(%s) (%d)(%X)  \n", __FILE__, __LINE__, __func__, i, info[i].codepoint ) ;
+    /* -> until a consonant is found */
+    if (is_consonant (info[i]))
+    {
+      /* -> that does not have a below-base or post-base form
+       * (post-base forms have to follow below-base forms), */
+      if (info[i].indic_position() != POS_BELOW &&
+	  info[i].indic_position() != POS_POST)
+      {
+        base = i;
+	break;
+      }
+
+      /* -> or that is not a pre-base reordering Ra,
+       *
+       * TODO
+       */
+
+      /* ->  o If the syllable starts with Ra + Halant (in a script that has Reph)
+       *       and has more than one consonant, Ra is excluded from candidates for
+       *       base consonants.
+       *
+       * IMPLEMENTATION NOTES:
+       *
+       * We do this by adjusting limit accordingly before entering the loop.
+       */
+
+      /* -> or arrive at the first consonant. The consonant stopped at will
+       * be the base. */
+      base = i;
+    }
+    else
+      if (is_joiner (info[i]))
+        break;
+  } while (i > limit);
+  if (base < start)
+    base = start; /* Just in case... */
+
+
+  /* 2. Decompose and reorder Matras:
+   *
+   * Each matra and any syllable modifier sign in the cluster are moved to the
+   * appropriate position relative to the consonant(s) in the cluster. The
+   * shaping engine decomposes two- or three-part matras into their constituent
+   * parts before any repositioning. Matra characters are classified by which
+   * consonant in a conjunct they have affinity for and are reordered to the
+   * following positions:
+   *
+   *   o Before first half form in the syllable
+   *   o After subjoined consonants
+   *   o After post-form consonant
+   *   o After main consonant (for above marks)
+   *
+   * IMPLEMENTATION NOTES:
+   *
+   * The normalize() routine has already decomposed matras for us, so we don't
+   * need to worry about that.
+   */
+
+
+  /* 3.  Reorder marks to canonical order:
+   *
+   * Adjacent nukta and halant or nukta and vedic sign are always repositioned
+   * if necessary, so that the nukta is first.
+   *
+   * IMPLEMENTATION NOTES:
+   *
+   * We don't need to do this: the normalize() routine already did this for us.
+   */
+
+
+  /* Reorder characters */
+
+  for (i = start; i < base; i++)
+    info[i].indic_position() = POS_PRE;
+  info[base].indic_position() = POS_BASE;
+
+
+  /* Handle beginning Ra */
+  if (start + 3 <= end &&
+      info[start].indic_category() == OT_Ra &&
+      info[start + 1].indic_category() == OT_H &&
+      !is_joiner (info[start + 2]))
+   {
+    info[start].indic_position() = POS_POST;
+    info[start].mask = mask_array[RPHF];
+   }
+
+  /* For old-style Indic script tags, move the first post-base Halant after
+   * last consonant. */
+//printf ( "(%s)(%d)(%s) (%X)(%X)  \n", __FILE__, __LINE__, __func__, map->get_chosen_script (0), map->get_chosen_script (1) ) ;
+  if ((map->get_chosen_script (0) & 0x000000FF) != '2') {
+    /* We should only do this for Indic scripts which have a version two I guess. */
+    for (i = base + 1; i < end; i++)
+      if (info[i].indic_category() == OT_H) {
+        unsigned int j;
+        for (j = end - 1; j > i; j--)
+	  if ((FLAG (info[j].indic_category()) & (FLAG (OT_C) | FLAG (OT_Ra))))
+	    break;
+	if (j > i) {
+	  /* Move Halant to after last consonant. */
+	  hb_glyph_info_t t = info[i];
+	  memmove (&info[i], &info[i + 1], (j - i) * sizeof (info[0]));
+	  info[j] = t;
+	}
+        break;
+      }
+  }
+
+  /* Attach ZWJ, ZWNJ, nukta, and halant to previous char to move with them. */
+  for (i = start + 1; i < end; i++)
+    if ((FLAG (info[i].indic_category()) &
+	 (FLAG (OT_ZWNJ) | FLAG (OT_ZWJ) | FLAG (OT_N) | FLAG (OT_H))))
+      info[i].indic_position() = info[i - 1].indic_position();
+
+  /* We do bubble-sort, skip malicious clusters attempts */
+  if (end - start > 20)
+    return;
+
+  /* Sit tight, rock 'n roll! */
+  hb_bubble_sort (info + start, end - start, compare_indic_order);
+
+  /* Setup masks now */
+
+  {
+    hb_mask_t mask;
+
+    /* Pre-base */
+    mask = mask_array[HALF] | mask_array[AKHN] | mask_array[CJCT];
+    for (i = start; i < base; i++)
+      info[i].mask  |= mask;
+    /* Base */
+    mask = mask_array[AKHN] | mask_array[CJCT];
+    info[base].mask |= mask;
+    /* Post-base */
+    mask = mask_array[BLWF] | mask_array[PSTF] | mask_array[CJCT];
+    for (i = base + 1; i < end; i++)
+      info[i].mask  |= mask;
+  }
+
+  /* Apply ZWJ/ZWNJ effects */
+  for (i = start + 1; i < end; i++)
+    if (is_joiner (info[i])) {
+      bool non_joiner = info[i].indic_category() == OT_ZWNJ;
+      unsigned int j = i;
+
+      do {
+	j--;
+
+	/* Reading the Unicode and OpenType specs, I think the following line
+	 * is correct, but this is not what the test suite expects currently.
+	 * The test suite has been drinking, not me...  But disable while
+	 * investigating.
+	 */
+	//info[j].mask &= !mask_array[CJCT];
+	info[j].mask &= !mask_array[CJCT];
+	if (non_joiner)
+	  info[j].mask &= !mask_array[HALF];
+
+      } while (j > start && !is_consonant (info[j]));
+    }
+}
+
+
+static void
+found_vowel_syllable (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array,
+		      unsigned int start, unsigned int end)
+{
+//printf ( "(%s)(%d)(%s) (%d)-(%d)(%X)  \n", __FILE__, __LINE__, __func__, start, end,buffer->info[start].codepoint  ) ;
+  /* TODO
+   * Not clear to me how this should work.  Do the matras move to before the
+   * independent vowel?  No idea.
+   */
+}
+
+static void
+found_standalone_cluster (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array,
+			  unsigned int start, unsigned int end)
+{
+//printf ( "(%s)(%d)(%s) (%d)-(%d)(%X)  \n", __FILE__, __LINE__, __func__, start, end,buffer->info[start].codepoint  ) ;
+  /* TODO
+   * Easiest thing to do here is to convert the NBSP to consonant and
+   * call found_consonant_syllable.
+   */
+}
+
+static void
+found_non_indic (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array,
+		 unsigned int start, unsigned int end)
+{
+//printf ( "(%s)(%d)(%s) (%d)-(%d)(%X)  \n", __FILE__, __LINE__, __func__, start, end,buffer->info[start].codepoint  ) ;
+  /* Nothing to do right now.  If we ever switch to using the output
+   * buffer in the reordering process, we'd need to next_glyph() here. */
+}
+
+#include "hb-ot-shape-complex-indic-machine.hh"
+
+static void
+remove_joiners (hb_buffer_t *buffer)
+{
+  /* For now we remove joiners.  However, Uniscbire seems to keep them
+   * and output a zero-width space glyph for them.  It is not clear to
+   * me how that is supposed to interact with GSUB. */
+
+  buffer->clear_output ();
+  unsigned int count = buffer->len;
+  for (buffer->idx = 0; buffer->idx < count;)
+    if (unlikely (is_joiner (buffer->info[buffer->idx])))
+      buffer->skip_glyph ();
+    else
+      buffer->next_glyph ();
+
+  buffer->swap_buffers ();
+}
+
+static void
+initial_reordering (const hb_ot_map_t *map,
+		    hb_face_t *face,
+		    hb_buffer_t *buffer,
+		    void *user_data HB_UNUSED)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__, buffer->info[0].codepoint  ) ;
+  hb_mask_t mask_array[ARRAY_LENGTH (indic_basic_features)] = {0};
+  unsigned int num_masks = ARRAY_LENGTH (indic_basic_features);
+  for (unsigned int i = 0; i < num_masks; i++)
+    mask_array[i] = map->get_1_mask (indic_basic_features[i].tag);
+
+  find_syllables (map, buffer, mask_array);
+
+  //remove_joiners (buffer);
+}
+
+static void
+final_reordering (const hb_ot_map_t *map,
+		  hb_face_t *face,
+		  hb_buffer_t *buffer,
+		  void *user_data HB_UNUSED)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__, buffer->info[0].codepoint  ) ;
+  /* 4. Final reordering:
+   *
+   * After the localized forms and basic shaping forms GSUB features have been
+   * applied (see below), the shaping engine performs some final glyph
+   * reordering before applying all the remaining font features to the entire
+   * cluster.
+   *
+   *   o Reorder matras:
+   *
+   *     If a pre-base matra character had been reordered before applying basic
+   *     features, the glyph can be moved closer to the main consonant based on
+   *     whether half-forms had been formed. Actual position for the matra is
+   *     defined as after last standalone halant glyph, after initial matra
+   *     position and before the main consonant. If ZWJ or ZWNJ follow this
+   *     halant, position is moved after it.
+   *
+   *   o Reorder reph:
+   *
+   *     Rephs original position is always at the beginning of the syllable,
+   *     (i.e. it is not reordered at the character reordering stage). However,
+   *     it will be reordered according to the basic-forms shaping results.
+   *     Possible positions for reph, depending on the script, are; after main,
+   *     before post-base consonant forms, and after post-base consonant forms.
+   *
+   *       1. If reph should be positioned after post-base consonant forms,
+   *          proceed to step 5.
+   *
+   *       2. If the reph repositioning class is not after post-base: target
+   *          position is after the first explicit halant glyph between the
+   *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ
+   *          are following this halant, position is moved after it. If such
+   *          position is found, this is the target position. Otherwise,
+   *          proceed to the next step.
+   *
+   *          Note: in old-implementation fonts, where classifications were
+   *          fixed in shaping engine, there was no case where reph position
+   *          will be found on this step.
+   *
+   *       3. If reph should be repositioned after the main consonant: from the
+   *          first consonant not ligated with main, or find the first
+   *          consonant that is not a potential pre-base reordering Ra.
+   *
+   *
+   *       4. If reph should be positioned before post-base consonant, find
+   *          first post-base classified consonant not ligated with main. If no
+   *          consonant is found, the target position should be before the
+   *          first matra, syllable modifier sign or vedic sign.
+   *
+   *       5. If no consonant is found in steps 3 or 4, move reph to a position
+   *          immediately before the first post-base matra, syllable modifier
+   *          sign or vedic sign that has a reordering class after the intended
+   *          reph position. For example, if the reordering position for reph
+   *          is post-main, it will skip above-base matras that also have a
+   *          post-main position.
+   *
+   *       6. Otherwise, reorder reph to the end of the syllable.
+   *
+   *   o Reorder pre-base reordering consonants:
+   *
+   *     If a pre-base reordering consonant is found, reorder it according to
+   *     the following rules:
+   *
+   *       1. Only reorder a glyph produced by substitution during application
+   *          of the feature. (Note that a font may shape a Ra consonant with
+   *          the feature generally but block it in certain contexts.)
+   *
+   *       2. Try to find a target position the same way as for pre-base matra.
+   *          If it is found, reorder pre-base consonant glyph.
+   *
+   *       3. If position is not found, reorder immediately before main
+   *          consonant.
+   */
+
+  /* TODO */
+
+  unsigned int i;
+  for (i = 0; i < buffer->len; i++) {
+    if ((FLAG (buffer->info[i].indic_category()) & (FLAG (OT_Ra) ))) {
+       buffer->info[i].indic_position() = POS_PRE;
+//printf ( "(%s)(%d)(%s) (%X)(%X)(%X)  \n", __FILE__, __LINE__, __func__, buffer->info[i].codepoint, buffer->info[i].indic_category(), buffer->info[i].indic_position()  ) ;
+    }
+  }
+
+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
+}
+
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.hh	2012-05-08 16:19:00.863387386 +0530
@@ -0,0 +1,309 @@
+
+#line 1 "hb-ot-shape-complex-indic-machine.rl"
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
+#define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
+
+#include "hb-private.hh"
+
+HB_BEGIN_DECLS
+
+
+#line 38 "hb-ot-shape-complex-indic-machine.hh.tmp"
+static const unsigned char _indic_syllable_machine_trans_keys[] = {
+	0u, 0u, 5u, 5u, 1u, 2u, 1u, 2u, 5u, 5u, 1u, 5u, 5u, 5u, 1u, 2u, 
+	0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 
+	0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 
+	0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 
+	0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 0u, 12u, 
+	0u, 12u, 0
+};
+
+static const char _indic_syllable_machine_key_spans[] = {
+	0, 1, 2, 2, 1, 5, 1, 2, 
+	13, 13, 13, 13, 13, 13, 13, 13, 
+	13, 13, 13, 13, 13, 13, 13, 13, 
+	13, 13, 13, 13, 13, 13, 13, 13, 
+	13, 13, 13, 13, 13, 13, 13, 13, 
+	13
+};
+
+static const short _indic_syllable_machine_index_offsets[] = {
+	0, 0, 2, 5, 8, 10, 16, 18, 
+	21, 35, 49, 63, 77, 91, 105, 119, 
+	133, 147, 161, 175, 189, 203, 217, 231, 
+	245, 259, 273, 287, 301, 315, 329, 343, 
+	357, 371, 385, 399, 413, 427, 441, 455, 
+	469
+};
+
+static const char _indic_syllable_machine_indicies[] = {
+	0, 1, 2, 2, 1, 3, 3, 
+	1, 4, 1, 2, 2, 1, 1, 0, 
+	1, 5, 1, 6, 6, 1, 7, 6, 
+	8, 9, 1, 1, 1, 1, 1, 1, 
+	1, 1, 10, 1, 11, 12, 13, 14, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	15, 1, 16, 17, 18, 19, 20, 21, 
+	22, 22, 23, 24, 25, 26, 27, 1, 
+	16, 17, 18, 19, 20, 28, 22, 22, 
+	23, 24, 25, 26, 27, 1, 29, 30, 
+	31, 32, 33, 1, 34, 35, 36, 37, 
+	38, 1, 39, 1, 29, 30, 31, 32, 
+	1, 1, 34, 35, 36, 37, 38, 1, 
+	39, 1, 29, 30, 31, 32, 1, 1, 
+	1, 1, 36, 37, 38, 1, 39, 1, 
+	29, 30, 31, 32, 40, 2, 1, 1, 
+	36, 37, 38, 1, 39, 1, 29, 30, 
+	31, 32, 1, 2, 1, 1, 36, 37, 
+	38, 1, 39, 1, 29, 30, 31, 32, 
+	1, 1, 1, 1, 1, 1, 38, 1, 
+	39, 1, 29, 30, 31, 32, 1, 1, 
+	1, 1, 1, 1, 41, 1, 39, 1, 
+	29, 30, 31, 32, 1, 1, 1, 1, 
+	1, 1, 1, 1, 39, 1, 42, 43, 
+	44, 45, 46, 4, 47, 47, 48, 49, 
+	50, 1, 51, 1, 42, 43, 44, 45, 
+	1, 4, 47, 47, 48, 49, 50, 1, 
+	51, 1, 42, 43, 44, 45, 1, 1, 
+	1, 1, 48, 49, 50, 1, 51, 1, 
+	42, 43, 44, 45, 52, 3, 1, 1, 
+	48, 49, 50, 1, 51, 1, 42, 43, 
+	44, 45, 1, 3, 1, 1, 48, 49, 
+	50, 1, 51, 1, 42, 43, 44, 45, 
+	1, 1, 1, 1, 1, 1, 50, 1, 
+	51, 1, 42, 43, 44, 45, 1, 1, 
+	1, 1, 1, 1, 53, 1, 51, 1, 
+	42, 43, 44, 45, 1, 1, 1, 1, 
+	1, 1, 1, 1, 51, 1, 16, 17, 
+	18, 19, 1, 21, 22, 22, 23, 24, 
+	25, 26, 27, 1, 16, 6, 6, 19, 
+	1, 1, 54, 54, 1, 24, 25, 1, 
+	27, 1, 16, 6, 6, 19, 1, 1, 
+	1, 1, 1, 24, 25, 1, 27, 1, 
+	16, 17, 18, 19, 1, 1, 1, 1, 
+	1, 1, 25, 1, 27, 1, 16, 17, 
+	18, 19, 1, 1, 1, 1, 1, 1, 
+	55, 1, 27, 1, 16, 17, 18, 19, 
+	1, 1, 1, 1, 1, 1, 1, 1, 
+	27, 1, 16, 17, 18, 19, 56, 57, 
+	1, 1, 23, 24, 25, 1, 27, 1, 
+	16, 17, 18, 19, 1, 57, 1, 1, 
+	23, 24, 25, 1, 27, 1, 16, 17, 
+	18, 19, 1, 1, 1, 1, 23, 24, 
+	25, 1, 27, 1, 16, 17, 18, 19, 
+	1, 58, 1, 1, 23, 24, 25, 1, 
+	27, 1, 16, 17, 18, 19, 1, 1, 
+	59, 59, 1, 24, 25, 1, 27, 1, 
+	16, 17, 18, 19, 1, 1, 1, 1, 
+	1, 24, 25, 1, 27, 1, 16, 6, 
+	6, 9, 1, 1, 54, 54, 1, 24, 
+	25, 1, 10, 1, 0
+};
+
+static const char _indic_syllable_machine_trans_targs[] = {
+	2, 0, 14, 22, 3, 7, 10, 9, 
+	11, 12, 20, 9, 10, 11, 12, 20, 
+	9, 10, 11, 12, 28, 29, 6, 34, 
+	31, 32, 37, 20, 40, 9, 10, 11, 
+	12, 13, 1, 5, 15, 17, 18, 20, 
+	16, 19, 9, 10, 11, 12, 21, 4, 
+	23, 25, 26, 20, 24, 27, 30, 33, 
+	35, 36, 38, 39
+};
+
+static const char _indic_syllable_machine_trans_actions[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+//	0, 0, 0, 1, 1, 1, 1, 1, 
+	0, 0, 0, 2, 2, 2, 2, 2, 
+	2, 2, 2, 2, 0, 0, 0, 0, 
+	0, 0, 0, 2, 0, 3, 3, 3, 
+	3, 0, 0, 0, 0, 0, 0, 3, 
+	0, 0, 4, 4, 4, 4, 0, 0, 
+	0, 0, 0, 4, 0, 0, 0, 0, 
+	0, 0, 0, 0
+};
+
+static const char _indic_syllable_machine_eof_actions[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 
+//	0, 1, 2, 2, 3, 3, 3, 3, 
+	0, 2, 2, 2, 3, 3, 3, 3, 
+	3, 3, 3, 3, 4, 4, 4, 4, 
+	4, 4, 4, 4, 2, 2, 2, 2, 
+	2, 2, 2, 2, 2, 2, 2, 2, 
+	2
+};
+
+static const int indic_syllable_machine_start = 8;
+static const int indic_syllable_machine_first_final = 8;
+static const int indic_syllable_machine_error = 0;
+
+static const int indic_syllable_machine_en_main = 8;
+
+
+#line 38 "hb-ot-shape-complex-indic-machine.rl"
+
+
+
+#line 83 "hb-ot-shape-complex-indic-machine.rl"
+
+
+
+static void
+set_cluster (hb_buffer_t *buffer,
+	     unsigned int start, unsigned int end)
+{
+  unsigned int cluster = buffer->info[start].cluster;
+
+  for (unsigned int i = start + 1; i < end; i++)
+    cluster = MIN (cluster, buffer->info[i].cluster);
+  for (unsigned int i = start; i < end; i++)
+    buffer->info[i].cluster = cluster;
+}
+
+static void
+find_syllables (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array)
+{
+  unsigned int p, pe, eof;
+  int cs;
+  
+#line 194 "hb-ot-shape-complex-indic-machine.hh.tmp"
+	{
+	cs = indic_syllable_machine_start;
+	}
+
+//printf ( "(%s)(%d)(%s) -(%d)(%X)  \n", __FILE__, __LINE__, __func__, cs, buffer->info[0].codepoint ) ;
+#line 106 "hb-ot-shape-complex-indic-machine.rl"
+
+
+  p = 0;
+  pe = eof = buffer->len;
+
+  unsigned int last = 0;
+  
+#line 207 "hb-ot-shape-complex-indic-machine.hh.tmp"
+	{
+	int _slen;
+	int _trans;
+	const unsigned char *_keys;
+	const char *_inds;
+	if ( p == pe )
+		goto _test_eof;
+	if ( cs == 0 )
+		goto _out;
+_resume:
+	_keys = _indic_syllable_machine_trans_keys + (cs<<1);
+	_inds = _indic_syllable_machine_indicies + _indic_syllable_machine_index_offsets[cs];
+
+	_slen = _indic_syllable_machine_key_spans[cs];
+	_trans = _inds[ _slen > 0 && _keys[0] <=( buffer->info[p].indic_category()) &&
+		( buffer->info[p].indic_category()) <= _keys[1] ?
+		( buffer->info[p].indic_category()) - _keys[0] : _slen ];
+
+	cs = _indic_syllable_machine_trans_targs[_trans];
+//printf ( "(%s)(%d)(%s) -u(%X) c(%X)cs(%X)a(%X)i(%x)sl(%X)k(%X)in(%X) \n", __FILE__, __LINE__, __func__,buffer->info[p].codepoint, buffer->info[p].indic_category(), cs, _indic_syllable_machine_trans_actions[_trans],_trans,_slen, _keys, _inds ) ;
+
+	if ( _indic_syllable_machine_trans_actions[_trans] == 0 )
+		goto _again;
+
+	switch ( _indic_syllable_machine_trans_actions[_trans] ) {
+	case 2:
+#line 62 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_consonant_syllable (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 3:
+#line 63 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_vowel_syllable (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 4:
+#line 64 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_standalone_cluster (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 1:
+#line 65 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_non_indic (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+#line 256 "hb-ot-shape-complex-indic-machine.hh.tmp"
+	}
+
+_again:
+	if ( cs == 0 )
+		goto _out;
+	if ( ++p != pe )
+		goto _resume;
+	_test_eof: {}
+	if ( p == eof )
+	{
+//printf ( "(%s)(%d)(%s) -(%d)(%d)  \n", __FILE__, __LINE__, __func__, cs, _indic_syllable_machine_trans_actions[cs] ) ;
+	switch ( _indic_syllable_machine_eof_actions[cs] ) {
+	case 2:
+#line 62 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_consonant_syllable (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 3:
+#line 63 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_vowel_syllable (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 4:
+#line 64 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_standalone_cluster (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+	case 1:
+#line 65 "hb-ot-shape-complex-indic-machine.rl"
+	{ found_non_indic (map, buffer, mask_array, last, p); }
+#line 67 "hb-ot-shape-complex-indic-machine.rl"
+	{ set_cluster (buffer, last, p); last = p; }
+	break;
+#line 292 "hb-ot-shape-complex-indic-machine.hh.tmp"
+	}
+	}
+
+	_out: {}
+	}
+
+#line 114 "hb-ot-shape-complex-indic-machine.rl"
+
+}
+
+HB_END_DECLS
+
+#endif /* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-machine.rl	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,107 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
+#define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH
+
+#include "hb-private.hh"
+
+HB_BEGIN_DECLS
+
+%%{
+  machine indic_syllable_machine;
+  alphtype unsigned char;
+  write data;
+}%%
+
+%%{
+
+# Same order as enum indic_category_t.  Not sure how to avoid duplication.
+X    = 0;
+C    = 1;
+Ra   = 2;
+V    = 3;
+N    = 4;
+H    = 5;
+ZWNJ = 6;
+ZWJ  = 7;
+M    = 8;
+SM   = 9;
+VD   = 10;
+A    = 11;
+NBSP = 12;
+
+c = C | Ra;
+z = ZWJ|ZWNJ;
+matra_group = M N? H?;
+syllable_tail = SM? (VD VD?)?;
+
+action found_consonant_syllable { found_consonant_syllable (map, buffer, mask_array, last, p); }
+action found_vowel_syllable { found_vowel_syllable (map, buffer, mask_array, last, p); }
+action found_standalone_cluster { found_standalone_cluster (map, buffer, mask_array, last, p); }
+action found_non_indic { found_non_indic (map, buffer, mask_array, last, p); }
+
+action next_syllable { buffer->merge_clusters (last, p); last = p; }
+
+consonant_syllable =	(c.N? (H.z?|z.H))* c.N? A? (H.z? | matra_group*)? syllable_tail %(found_consonant_syllable);
+vowel_syllable =	(Ra H)? V N? (z?.H.c | ZWJ.c)? matra_group* syllable_tail %(found_vowel_syllable);
+standalone_cluster =	(Ra H)? NBSP N? (z? H c)? matra_group* syllable_tail %(found_standalone_cluster);
+non_indic = X %(found_non_indic);
+
+syllable =
+	  consonant_syllable
+	| vowel_syllable
+	| standalone_cluster
+	| non_indic
+	;
+
+main := (syllable %(next_syllable))**;
+
+}%%
+
+
+static void
+find_syllables (const hb_ot_map_t *map, hb_buffer_t *buffer, hb_mask_t *mask_array)
+{
+  unsigned int p, pe, eof;
+  int cs;
+  %%{
+    write init;
+    getkey buffer->info[p].indic_category();
+  }%%
+
+  p = 0;
+  pe = eof = buffer->len;
+
+  unsigned int last = 0;
+  %%{
+    write exec;
+  }%%
+}
+
+HB_END_DECLS
+
+#endif /* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-private.hh	2012-05-08 13:28:33.397102124 +0530
@@ -0,0 +1,266 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
+#define HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
+
+#include "hb-private.hh"
+
+
+#include "hb-ot-shape-complex-private.hh"
+
+
+/* buffer var allocations */
+#define indic_category() complex_var_persistent_u8_0() /* indic_category_t */
+#define indic_position() complex_var_persistent_u8_1() /* indic_matra_category_t */
+
+#define INDIC_TABLE_ELEMENT_TYPE uint8_t
+
+/* Cateories used in the OpenType spec:
+ * https://www.microsoft.com/typography/otfntdev/devanot/shaping.aspx
+ */
+/* Note: This enum is duplicated in the -machine.rl source file.
+ * Not sure how to avoid duplication. */
+enum indic_category_t {
+  OT_X = 0,
+  OT_C,
+  OT_Ra, /* Not explicitly listed in the OT spec, but used in the grammar. */
+  OT_V,
+  OT_N,
+  OT_H,
+  OT_ZWNJ,
+  OT_ZWJ,
+  OT_M,
+  OT_SM,
+  OT_VD,
+  OT_A,
+  OT_NBSP
+};
+
+/* Visual positions in a syllable from left to right. */
+enum indic_position_t {
+  POS_PRE = 1,
+  POS_BASE = 2,
+  POS_ABOVE = 3,
+  POS_BELOW = 4,
+  POS_POST = 5
+};
+
+/* Categories used in IndicSyllabicCategory.txt from UCD */
+/* The assignments are guesswork */
+enum indic_syllabic_category_t {
+  INDIC_SYLLABIC_CATEGORY_OTHER			= OT_X,
+
+  INDIC_SYLLABIC_CATEGORY_AVAGRAHA		= OT_X,
+  INDIC_SYLLABIC_CATEGORY_BINDU			= OT_X,
+  //INDIC_SYLLABIC_CATEGORY_BINDU			= OT_SM,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT		= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER	= OT_NBSP,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_CONSONANT_REPHA	= OT_C,
+  INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER	= OT_X,
+  INDIC_SYLLABIC_CATEGORY_NUKTA			= OT_N,
+  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER	= OT_X,
+  INDIC_SYLLABIC_CATEGORY_TONE_LETTER		= OT_X,
+  INDIC_SYLLABIC_CATEGORY_TONE_MARK		= OT_X,
+  INDIC_SYLLABIC_CATEGORY_VIRAMA		= OT_H,
+  INDIC_SYLLABIC_CATEGORY_VISARGA		= OT_X,
+  //INDIC_SYLLABIC_CATEGORY_VISARGA		= OT_SM,
+  INDIC_SYLLABIC_CATEGORY_VOWEL			= OT_V,
+  INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT	= OT_M,
+  INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT	= OT_V
+};
+
+/* Categories used in IndicSMatraCategory.txt from UCD */
+enum indic_matra_category_t {
+  INDIC_MATRA_CATEGORY_NOT_APPLICABLE		= POS_BASE,
+
+  INDIC_MATRA_CATEGORY_LEFT			= POS_PRE - 1, /* Move *before* existing "pre" chars */
+  INDIC_MATRA_CATEGORY_TOP			= POS_ABOVE,
+  INDIC_MATRA_CATEGORY_BOTTOM			= POS_BELOW,
+  INDIC_MATRA_CATEGORY_RIGHT			= POS_POST,
+
+  /* We don't really care much about these since we decompose them
+   * in the generic pre-shaping layer.  They will only be used if
+   * the font does not cover the decomposition.  In which case, we
+   * define these as aliases to the place we want the split-matra
+   * glyph to show up.  Quite arbitrary.
+   *
+   * TODO: There are some split matras without Unicode decompositions.
+   * We have to figure out what to do with them.
+   */
+  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT		= 8 | INDIC_MATRA_CATEGORY_BOTTOM,
+  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT		= 8 | INDIC_MATRA_CATEGORY_LEFT,
+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM		= 8 | INDIC_MATRA_CATEGORY_BOTTOM,
+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT	= 8 | INDIC_MATRA_CATEGORY_BOTTOM,
+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT		= 8 | INDIC_MATRA_CATEGORY_LEFT,
+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT	= 8 | INDIC_MATRA_CATEGORY_LEFT,
+  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT		= 8 | INDIC_MATRA_CATEGORY_RIGHT,
+
+  INDIC_MATRA_CATEGORY_INVISIBLE		= INDIC_MATRA_CATEGORY_NOT_APPLICABLE,
+  INDIC_MATRA_CATEGORY_OVERSTRUCK		= INDIC_MATRA_CATEGORY_NOT_APPLICABLE,
+  INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT	= INDIC_MATRA_CATEGORY_NOT_APPLICABLE
+};
+
+/* Note: We use ASSERT_STATIC_EXPR_ZERO() instead of ASSERT_STATIC_EXPR() and the comma operation
+ * because gcc fails to optimize the latter and fills the table in at runtime. */
+#define INDIC_COMBINE_CATEGORIES(S,M) \
+  (ASSERT_STATIC_EXPR_ZERO (M == INDIC_MATRA_CATEGORY_NOT_APPLICABLE || (S == INDIC_SYLLABIC_CATEGORY_VIRAMA || S == INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT)) + \
+   ASSERT_STATIC_EXPR_ZERO (S < 16 && M < 16) + \
+   ((M << 4) | S))
+
+
+#include "hb-ot-shape-complex-indic-table.hh"
+
+/* XXX
+ * This is a hack for now.  We should:
+ * 1. Move this data into the main Indic table,
+ * and/or
+ * 2. Probe font lookups to determine consonant positions.
+ */
+static const struct consonant_position_t {
+  hb_codepoint_t u;
+  indic_position_t position;
+} consonant_positions[] = {
+  {0x0930, POS_BELOW},
+  {0x09AC, POS_BELOW},
+  {0x09AF, POS_POST},
+  {0x09B0, POS_BELOW},
+  {0x09F0, POS_BELOW},
+  {0x0A2F, POS_POST},
+  {0x0A30, POS_BELOW},
+  {0x0A35, POS_BELOW},
+  {0x0A39, POS_BELOW},
+  {0x0AB0, POS_BELOW},
+  {0x0B24, POS_BELOW},
+  {0x0B28, POS_BELOW},
+  {0x0B2C, POS_BELOW},
+  {0x0B2D, POS_BELOW},
+  {0x0B2E, POS_BELOW},
+  {0x0B2F, POS_POST},
+  {0x0B30, POS_BELOW},
+  {0x0B32, POS_BELOW},
+  {0x0B33, POS_BELOW},
+  {0x0B5F, POS_POST},
+  {0x0B71, POS_BELOW},
+  {0x0C15, POS_BELOW},
+  {0x0C16, POS_BELOW},
+  {0x0C17, POS_BELOW},
+  {0x0C18, POS_BELOW},
+  {0x0C19, POS_BELOW},
+  {0x0C1A, POS_BELOW},
+  {0x0C1B, POS_BELOW},
+  {0x0C1C, POS_BELOW},
+  {0x0C1D, POS_BELOW},
+  {0x0C1E, POS_BELOW},
+  {0x0C1F, POS_BELOW},
+  {0x0C20, POS_BELOW},
+  {0x0C21, POS_BELOW},
+  {0x0C22, POS_BELOW},
+  {0x0C23, POS_BELOW},
+  {0x0C24, POS_BELOW},
+  {0x0C25, POS_BELOW},
+  {0x0C26, POS_BELOW},
+  {0x0C27, POS_BELOW},
+  {0x0C28, POS_BELOW},
+  {0x0C2A, POS_BELOW},
+  {0x0C2B, POS_BELOW},
+  {0x0C2C, POS_BELOW},
+  {0x0C2D, POS_BELOW},
+  {0x0C2E, POS_BELOW},
+  {0x0C2F, POS_BELOW},
+  {0x0C30, POS_BELOW},
+  {0x0C32, POS_BELOW},
+  {0x0C33, POS_BELOW},
+  {0x0C35, POS_BELOW},
+  {0x0C36, POS_BELOW},
+  {0x0C37, POS_BELOW},
+  {0x0C38, POS_BELOW},
+  {0x0C39, POS_BELOW},
+  {0x0C95, POS_BELOW},
+  {0x0C96, POS_BELOW},
+  {0x0C97, POS_BELOW},
+  {0x0C98, POS_BELOW},
+  {0x0C99, POS_BELOW},
+  {0x0C9A, POS_BELOW},
+  {0x0C9B, POS_BELOW},
+  {0x0C9C, POS_BELOW},
+  {0x0C9D, POS_BELOW},
+  {0x0C9E, POS_BELOW},
+  {0x0C9F, POS_BELOW},
+  {0x0CA0, POS_BELOW},
+  {0x0CA1, POS_BELOW},
+  {0x0CA2, POS_BELOW},
+  {0x0CA3, POS_BELOW},
+  {0x0CA4, POS_BELOW},
+  {0x0CA5, POS_BELOW},
+  {0x0CA6, POS_BELOW},
+  {0x0CA7, POS_BELOW},
+  {0x0CA8, POS_BELOW},
+  {0x0CAA, POS_BELOW},
+  {0x0CAB, POS_BELOW},
+  {0x0CAC, POS_BELOW},
+  {0x0CAD, POS_BELOW},
+  {0x0CAE, POS_BELOW},
+  {0x0CAF, POS_BELOW},
+  {0x0CB0, POS_BELOW},
+  {0x0CB2, POS_BELOW},
+  {0x0CB3, POS_BELOW},
+  {0x0CB5, POS_BELOW},
+  {0x0CB6, POS_BELOW},
+  {0x0CB7, POS_BELOW},
+  {0x0CB8, POS_BELOW},
+  {0x0CB9, POS_BELOW},
+  {0x0CDE, POS_BELOW},
+  {0x0D2F, POS_POST},
+  {0x0D30, POS_POST},
+  {0x0D32, POS_BELOW},
+  {0x0D35, POS_POST},
+};
+
+/* XXX
+ * This is a hack for now.  We should move this data into the main Indic table.
+ */
+static const hb_codepoint_t ra_chars[] = {
+  0x0930, /* Devanagari */
+  0x09B0, /* Bengali */
+  0x09F0, /* Bengali */
+//0x09F1, /* Bengali */
+//0x0A30, /* Gurmukhi */
+  0x0AB0, /* Gujarati */
+  0x0B30, /* Oriya */
+//0x0BB0, /* Tamil */
+//0x0C30, /* Telugu */
+  0x0CB0, /* Kannada */
+//  0x0D30, /* Malayalam */
+};
+
+
+#endif /* HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-table.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-table.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-table.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-indic-table.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,872 @@
+/* == Start of generated table == */
+/*
+ * The following table is generated by running:
+ *
+ *   ./gen-indic-table.py IndicSyllabicCategory.txt IndicMatraCategory.txt Blocks.txt
+ *
+ * on files with these headers:
+ *
+ * # IndicSyllabicCategory-6.1.0.txt
+ * # Date: 2011-08-31, 23:54:00 GMT [KW]
+ * # IndicMatraCategory-6.1.0.txt
+ * # Date: 2011-08-31, 23:50:00 GMT [KW]
+ * # Blocks-6.1.0.txt
+ * # Date: 2011-06-14, 18:26:00 GMT [KW, LI]
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH
+#define HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH
+
+
+#define ISC_A	INDIC_SYLLABIC_CATEGORY_AVAGRAHA		/*  11 chars; Avagraha */
+#define ISC_Bi	INDIC_SYLLABIC_CATEGORY_BINDU			/*  34 chars; Bindu */
+#define ISC_C	INDIC_SYLLABIC_CATEGORY_CONSONANT		/* 123 chars; Consonant */
+#define ISC_CD	INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD		/*   2 chars; Consonant_Dead */
+#define ISC_CF	INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL		/*  17 chars; Consonant_Final */
+#define ISC_CHL	INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER	/*   1 chars; Consonant_Head_Letter */
+#define ISC_CM	INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL	/*  12 chars; Consonant_Medial */
+#define ISC_CP	INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER	/*   4 chars; Consonant_Placeholder */
+#define ISC_CR	INDIC_SYLLABIC_CATEGORY_CONSONANT_REPHA		/*   5 chars; Consonant_Repha */
+#define ISC_CS	INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED	/*  10 chars; Consonant_Subjoined */
+#define ISC_ML	INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER	/*   1 chars; Modifying_Letter */
+#define ISC_N	INDIC_SYLLABIC_CATEGORY_NUKTA			/*  12 chars; Nukta */
+#define ISC_x	INDIC_SYLLABIC_CATEGORY_OTHER			/*   1 chars; Other */
+#define ISC_RS	INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER	/*   1 chars; Register_Shifter */
+#define ISC_TL	INDIC_SYLLABIC_CATEGORY_TONE_LETTER		/*   3 chars; Tone_Letter */
+#define ISC_TM	INDIC_SYLLABIC_CATEGORY_TONE_MARK		/*  16 chars; Tone_Mark */
+#define ISC_V	INDIC_SYLLABIC_CATEGORY_VIRAMA			/*  34 chars; Virama */
+#define ISC_Vs	INDIC_SYLLABIC_CATEGORY_VISARGA			/*  25 chars; Visarga */
+#define ISC_Vo	INDIC_SYLLABIC_CATEGORY_VOWEL			/*   5 chars; Vowel */
+#define ISC_M	INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT		/* 165 chars; Vowel_Dependent */
+#define ISC_VI	INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT	/*  59 chars; Vowel_Independent */
+
+#define IMC_B	INDIC_MATRA_CATEGORY_BOTTOM			/*  65 chars; Bottom */
+#define IMC_BR	INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT		/*   2 chars; Bottom_And_Right */
+#define IMC_I	INDIC_MATRA_CATEGORY_INVISIBLE			/*   6 chars; Invisible */
+#define IMC_L	INDIC_MATRA_CATEGORY_LEFT			/*  30 chars; Left */
+#define IMC_LR	INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT		/*   8 chars; Left_And_Right */
+#define IMC_x	INDIC_MATRA_CATEGORY_NOT_APPLICABLE		/*   1 chars; Not_Applicable */
+#define IMC_O	INDIC_MATRA_CATEGORY_OVERSTRUCK			/*   2 chars; Overstruck */
+#define IMC_R	INDIC_MATRA_CATEGORY_RIGHT			/*  75 chars; Right */
+#define IMC_T	INDIC_MATRA_CATEGORY_TOP			/*  83 chars; Top */
+#define IMC_TB	INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM		/*   6 chars; Top_And_Bottom */
+#define IMC_TBR	INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT	/*   1 chars; Top_And_Bottom_And_Right */
+#define IMC_TL	INDIC_MATRA_CATEGORY_TOP_AND_LEFT		/*   4 chars; Top_And_Left */
+#define IMC_TLR	INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT	/*   2 chars; Top_And_Left_And_Right */
+#define IMC_TR	INDIC_MATRA_CATEGORY_TOP_AND_RIGHT		/*   8 chars; Top_And_Right */
+#define IMC_VOL	INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT		/*   5 chars; Visual_Order_Left */
+
+#define _(S,M) INDIC_COMBINE_CATEGORIES (ISC_##S, IMC_##M)
+
+
+static const INDIC_TABLE_ELEMENT_TYPE indic_table[] = {
+
+
+#define indic_offset_0x0900 0
+
+
+  /* Devanagari  (0900..097F) */
+
+  /* 0900 */ _(Bi,x), _(Bi,x), _(Bi,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0908 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0910 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0918 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0920 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0928 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0930 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0938 */  _(C,x),  _(C,x),  _(M,T),  _(M,R),  _(N,x),  _(A,x),  _(M,R),  _(M,L),
+  /* 0940 */  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T),
+  /* 0948 */  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(V,B),  _(M,L),  _(M,R),
+  /* 0950 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),  _(M,B),  _(M,B),
+  /* 0958 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0960 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0968 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0970 */  _(x,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0978 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+
+  /* Bengali  (0980..09FF) */
+
+  /* 0980 */  _(x,x), _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0988 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),
+  /* 0990 */ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0998 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 09A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 09A8 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 09B0 */  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),
+  /* 09B8 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,x),  _(A,x),  _(M,R),  _(M,L),
+  /* 09C0 */  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),
+  /* 09C8 */  _(M,L),  _(x,x),  _(x,x), _(M,LR), _(M,LR),  _(V,B), _(CD,x),  _(x,x),
+  /* 09D0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),
+  /* 09D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),
+  /* 09E0 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 09E8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 09F0 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 09F8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Gurmukhi  (0A00..0A7F) */
+
+  /* 0A00 */  _(x,x), _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0A08 */ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),
+  /* 0A10 */ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0A18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0A20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0A28 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0A30 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),
+  /* 0A38 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,x),  _(x,x),  _(M,R),  _(M,L),
+  /* 0A40 */  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),
+  /* 0A48 */  _(M,T),  _(x,x),  _(x,x),  _(M,T),  _(M,T),  _(V,B),  _(x,x),  _(x,x),
+  /* 0A50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0A58 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),
+  /* 0A60 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0A68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0A70 */ _(Bi,x),  _(x,x), _(CP,x), _(CP,x),  _(x,x), _(CM,x),  _(x,x),  _(x,x),
+  /* 0A78 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Gujarati  (0A80..0AFF) */
+
+  /* 0A80 */  _(x,x), _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0A88 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x),
+  /* 0A90 */ _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0A98 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0AA0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0AA8 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0AB0 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0AB8 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,x),  _(A,x),  _(M,R),  _(M,L),
+  /* 0AC0 */  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(x,x),  _(M,T),
+  /* 0AC8 */  _(M,T), _(M,TR),  _(x,x),  _(M,R),  _(M,R),  _(V,B),  _(x,x),  _(x,x),
+  /* 0AD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0AD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0AE0 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0AE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0AF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0AF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Oriya  (0B00..0B7F) */
+
+  /* 0B00 */  _(x,x), _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0B08 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),
+  /* 0B10 */ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0B18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0B20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0B28 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0B30 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0B38 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,x),  _(A,x),  _(M,R),  _(M,T),
+  /* 0B40 */  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),
+  /* 0B48 */ _(M,TL),  _(x,x),  _(x,x), _(M,LR),_(M,TLR),  _(V,B),  _(x,x),  _(x,x),
+  /* 0B50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T), _(M,TR),
+  /* 0B58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),
+  /* 0B60 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0B68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0B70 */  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0B78 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tamil  (0B80..0BFF) */
+
+  /* 0B80 */  _(x,x),  _(x,x), _(Bi,x), _(ML,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0B88 */ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),
+  /* 0B90 */ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(x,x),  _(x,x),
+  /* 0B98 */  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),
+  /* 0BA0 */  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0BA8 */  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),
+  /* 0BB0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0BB8 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),
+  /* 0BC0 */  _(M,T),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(M,L),  _(M,L),
+  /* 0BC8 */  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T),  _(x,x),  _(x,x),
+  /* 0BD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),
+  /* 0BD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0BE0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0BE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0BF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0BF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Telugu  (0C00..0C7F) */
+
+  /* 0C00 */  _(x,x), _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0C08 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),
+  /* 0C10 */ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C28 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C30 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C38 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x),  _(M,T),  _(M,T),
+  /* 0C40 */  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T),  _(M,T),
+  /* 0C48 */ _(M,TB),  _(x,x),  _(M,T),  _(M,T),  _(M,T),  _(V,T),  _(x,x),  _(x,x),
+  /* 0C50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),  _(M,B),  _(x,x),
+  /* 0C58 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0C60 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0C68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0C70 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0C78 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Kannada  (0C80..0CFF) */
+
+  /* 0C80 */  _(x,x),  _(x,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0C88 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),
+  /* 0C90 */ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0C98 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0CA0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0CA8 */  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0CB0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0CB8 */  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,x),  _(A,x),  _(M,R),  _(M,T),
+  /* 0CC0 */ _(M,TR),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T), _(M,TR),
+  /* 0CC8 */ _(M,TR),  _(x,x), _(M,TR), _(M,TR),  _(M,T),  _(V,T),  _(x,x),  _(x,x),
+  /* 0CD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),
+  /* 0CD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(x,x),
+  /* 0CE0 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0CE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0CF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0CF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Malayalam  (0D00..0D7F) */
+
+  /* 0D00 */  _(x,x),  _(x,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0D08 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),
+  /* 0D10 */ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0D18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0D20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0D28 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0D30 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0D38 */  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(A,x),  _(M,R),  _(M,R),
+  /* 0D40 */  _(M,R),  _(M,R),  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(M,L),  _(M,L),
+  /* 0D48 */  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T), _(CR,x),  _(x,x),
+  /* 0D50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),
+  /* 0D58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0D60 */ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0D68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0D70 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0D78 */  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x),
+
+  /* Sinhala  (0D80..0DFF) */
+
+  /* 0D80 */  _(x,x),  _(x,x), _(Bi,x), _(Vs,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0D88 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 0D90 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),
+  /* 0D98 */  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0DA0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0DA8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0DB0 */  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0DB8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),
+  /* 0DC0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),
+  /* 0DC8 */  _(x,x),  _(x,x),  _(V,T),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),
+  /* 0DD0 */  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),  _(x,x),  _(M,B),  _(x,x),
+  /* 0DD8 */  _(M,R),  _(M,L), _(M,TL),  _(M,L), _(M,LR), _(M,LR), _(M,LR),  _(M,R),
+  /* 0DE0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0DE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0DF0 */  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0DF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Thai  (0E00..0E7F) */
+
+  /* 0E00 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E08 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E10 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E28 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),
+  /* 0E30 */  _(M,R),  _(M,T),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,T),  _(M,T),
+  /* 0E38 */  _(M,B),  _(M,B),  _(V,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E40 */_(M,VOL),_(M,VOL),_(M,VOL),_(M,VOL),_(M,VOL),  _(M,R),  _(x,x),  _(M,T),
+  /* 0E48 */ _(TM,x), _(TM,x), _(TM,x), _(TM,x),  _(x,x), _(Bi,x),  _(V,T),  _(x,x),
+  /* 0E50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E60 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E70 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0E78 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Lao  (0E80..0EFF) */
+
+  /* 0E80 */  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(C,x),
+  /* 0E88 */  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),
+  /* 0E90 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0E98 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0EA0 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(C,x),
+  /* 0EA8 */  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),
+  /* 0EB0 */  _(M,R),  _(M,T),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,T),  _(M,T),
+  /* 0EB8 */  _(M,B),  _(M,B),  _(x,x),  _(M,T), _(CM,x), _(CM,x),  _(x,x),  _(x,x),
+  /* 0EC0 */_(M,VOL),_(M,VOL),_(M,VOL),_(M,VOL),_(M,VOL),  _(x,x),  _(x,x),  _(x,x),
+  /* 0EC8 */ _(TM,x), _(TM,x), _(TM,x), _(TM,x),  _(x,x), _(Bi,x),  _(x,x),  _(x,x),
+  /* 0ED0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0ED8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),
+  /* 0EE0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0EE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0EF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0EF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tibetan  (0F00..0FFF) */
+
+  /* 0F00 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F08 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F10 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F18 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F20 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F28 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F30 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F38 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F40 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0F48 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0F50 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0F58 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0F60 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 0F68 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0F70 */  _(x,x),  _(M,B),  _(M,T), _(M,TB),  _(M,B),  _(M,B), _(M,TB), _(M,TB),
+  /* 0F78 */ _(M,TB), _(M,TB),  _(M,T),  _(M,T),  _(M,T),  _(M,T), _(Bi,x), _(Vs,x),
+  /* 0F80 */  _(M,T), _(M,TB), _(Bi,x), _(Bi,x),  _(V,B),  _(A,x),  _(x,x),  _(x,x),
+  /* 0F88 */_(CHL,x),_(CHL,x),_(CHL,x),_(CHL,x),_(CHL,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0F90 */ _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0F98 */  _(x,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0FA0 */ _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0FA8 */ _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0FB0 */ _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),
+  /* 0FB8 */ _(CS,x), _(CS,x), _(CS,x), _(CS,x), _(CS,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FC0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FC8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FE0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 0FF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Myanmar  (1000..109F) */
+
+  /* 1000 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1008 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1010 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1018 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1020 */  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 1028 */ _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),
+  /* 1030 */  _(M,B),  _(M,L),  _(M,T),  _(M,T),  _(M,T),  _(M,T), _(Bi,x), _(TM,x),
+  /* 1038 */ _(Vs,x),  _(V,I),  _(V,T), _(CM,x), _(CM,x), _(CM,x), _(CM,x),  _(C,x),
+  /* 1040 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1048 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1050 */  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),
+  /* 1058 */  _(M,B),  _(M,B),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(CM,x), _(CM,x),
+  /* 1060 */ _(CM,x),  _(C,x),  _(M,R), _(TM,x), _(TM,x),  _(C,x),  _(C,x),  _(M,R),
+  /* 1068 */  _(M,R), _(TM,x), _(TM,x), _(TM,x), _(TM,x), _(TM,x),  _(C,x),  _(C,x),
+  /* 1070 */  _(C,x),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(C,x),  _(C,x),  _(C,x),
+  /* 1078 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1080 */  _(C,x),  _(C,x), _(CM,x),  _(M,R),  _(M,L),  _(M,T),  _(M,T), _(TM,x),
+  /* 1088 */ _(TM,x), _(TM,x), _(TM,x), _(TM,x), _(TM,x), _(TM,x),  _(C,x), _(TM,x),
+  /* 1090 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1098 */  _(x,x),  _(x,x), _(TM,x), _(TM,x),  _(M,R),  _(M,T),  _(x,x),  _(x,x),
+
+#define indic_offset_0x1700 1952
+
+
+  /* Tagalog  (1700..171F) */
+
+  /* 1700 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1708 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),
+  /* 1710 */  _(C,x),  _(C,x),  _(M,T),  _(M,B),  _(V,B),  _(x,x),  _(x,x),  _(x,x),
+  /* 1718 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Hanunoo  (1720..173F) */
+
+  /* 1720 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1728 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1730 */  _(C,x),  _(C,x),  _(M,T),  _(M,B),  _(V,B),  _(x,x),  _(x,x),  _(x,x),
+  /* 1738 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Buhid  (1740..175F) */
+
+  /* 1740 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1748 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1750 */  _(C,x),  _(C,x),  _(M,T),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1758 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tagbanwa  (1760..177F) */
+
+  /* 1760 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1768 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),
+  /* 1770 */  _(C,x),  _(x,x),  _(M,T),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1778 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Khmer  (1780..17FF) */
+
+  /* 1780 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1788 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1790 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1798 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 17A0 */  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 17A8 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 17B0 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(M,R),  _(M,T),
+  /* 17B8 */  _(M,T),  _(M,T),  _(M,T),  _(M,B),  _(M,B),  _(M,B), _(M,TL),_(M,TLR),
+  /* 17C0 */ _(M,LR),  _(M,L),  _(M,L),  _(M,L), _(M,LR), _(M,LR), _(Bi,x), _(Vs,x),
+  /* 17C8 */  _(M,R), _(RS,x), _(RS,x),  _(x,x), _(CR,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17D0 */  _(x,x),  _(V,T),  _(V,I),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17E0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17E8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17F0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 17F8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x1900 2208
+
+
+  /* Limbu  (1900..194F) */
+
+  /* 1900 */ _(CP,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1908 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1910 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1918 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1920 */  _(M,T),  _(M,T),  _(M,B),  _(M,R),  _(M,R), _(M,TR), _(M,TR),  _(M,T),
+  /* 1928 */  _(M,T), _(CS,x), _(CS,x), _(CS,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1930 */ _(CF,x), _(CF,x), _(Bi,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),
+  /* 1938 */ _(CF,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1940 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1948 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tai Le  (1950..197F) */
+
+  /* 1950 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1958 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1960 */  _(C,x),  _(C,x),  _(C,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x),
+  /* 1968 */ _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x),  _(x,x),  _(x,x),
+  /* 1970 */ _(TL,x), _(TL,x), _(TL,x), _(TL,x), _(TL,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1978 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* New Tai Lue  (1980..19DF) */
+
+  /* 1980 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1988 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1990 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1998 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 19A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 19A8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19B0 */  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,L),  _(M,L),  _(M,L),
+  /* 19B8 */  _(M,R),  _(M,R),  _(M,L),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),
+  /* 19C0 */  _(M,R), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),
+  /* 19C8 */ _(TM,x), _(TM,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19D0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* FILLER  (19E0..19FF) */
+
+  /* 19E0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19E8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19F0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 19F8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Buginese  (1A00..1A1F) */
+
+  /* 1A00 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A08 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A10 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(M,T),
+  /* 1A18 */  _(M,B),  _(M,L),  _(M,R),  _(M,L),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tai Tham  (1A20..1AAF) */
+
+  /* 1A20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A28 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A30 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A38 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A40 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1A48 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 1A50 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x), _(CM,x), _(CM,x), _(CF,x),
+  /* 1A58 */ _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),  _(x,x),
+  /* 1A60 */  _(V,I),  _(M,R),  _(M,T),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,T),
+  /* 1A68 */  _(M,T),  _(M,B),  _(M,B),  _(M,T),  _(M,B),  _(M,R),  _(M,L),  _(M,L),
+  /* 1A70 */  _(M,L),  _(M,L),  _(M,L),  _(M,T),  _(M,T), _(TM,x), _(TM,x), _(TM,x),
+  /* 1A78 */ _(TM,x), _(TM,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1A80 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1A88 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1A90 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1A98 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1AA0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1AA8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x1b00 2640
+
+
+  /* Balinese  (1B00..1B7F) */
+
+  /* 1B00 */ _(Bi,x), _(Bi,x), _(Bi,x), _(CR,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 1B08 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 1B10 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B28 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B30 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(N,x),  _(M,R),  _(M,T),  _(M,T),
+  /* 1B38 */  _(M,B),  _(M,B),  _(M,B), _(M,BR), _(M,TB),_(M,TBR),  _(M,L),  _(M,L),
+  /* 1B40 */ _(M,LR), _(M,LR),  _(M,T), _(M,TR),  _(V,R),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B48 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B60 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B68 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B70 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1B78 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Sundanese  (1B80..1BBF) */
+
+  /* 1B80 */ _(Bi,x), _(CR,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 1B88 */ _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B90 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1B98 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1BA0 */  _(C,x), _(CS,x), _(CS,x), _(CS,x),  _(M,T),  _(M,B),  _(M,L),  _(M,R),
+  /* 1BA8 */  _(M,T),  _(M,T),  _(V,R),  _(V,x), _(CS,x), _(CS,x),  _(C,x),  _(C,x),
+  /* 1BB0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1BB8 */  _(x,x),  _(x,x),  _(A,x),  _(C,x),  _(C,x),  _(C,x), _(CF,x), _(CF,x),
+
+  /* Batak  (1BC0..1BFF) */
+
+  /* 1BC0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1BC8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1BD0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1BD8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1BE0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x),  _(N,x),  _(M,x),
+  /* 1BE8 */  _(M,x),  _(M,x),  _(M,x),  _(M,x),  _(M,x),  _(M,x),  _(M,x),  _(M,x),
+  /* 1BF0 */ _(CF,x), _(CF,x),  _(V,R),  _(V,R),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1BF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Lepcha  (1C00..1C4F) */
+
+  /* 1C00 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1C08 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1C10 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1C18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 1C20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(CS,x), _(CS,x),  _(M,R),  _(M,L),
+  /* 1C28 */  _(M,L), _(M,TL),  _(M,R),  _(M,R),  _(M,B), _(CF,x), _(CF,x), _(CF,x),
+  /* 1C30 */ _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(Bi,x), _(Bi,x),  _(x,x),  _(N,x),
+  /* 1C38 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1C40 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1C48 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+
+#define indic_offset_0x1cd0 2976
+
+
+  /* Vedic Extensions  (1CD0..1CFF) */
+
+  /* 1CD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1CD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1CE0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1CE8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1CF0 */  _(x,x),  _(x,x), _(Vs,x), _(Vs,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 1CF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0xa800 3024
+
+
+  /* Syloti Nagri  (A800..A82F) */
+
+  /* A800 */ _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(V,T),  _(C,x),
+  /* A808 */  _(C,x),  _(C,x),  _(C,x), _(Bi,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A810 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A818 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A820 */  _(C,x),  _(C,x),  _(C,x),  _(M,R),  _(M,R),  _(M,B),  _(M,T),  _(M,R),
+  /* A828 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* FILLER  (A830..A83F) */
+
+  /* A830 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A838 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Phags-pa  (A840..A87F) */
+
+  /* A840 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A848 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A850 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A858 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(Vo,x), _(Vo,x),
+  /* A860 */ _(Vo,x), _(Vo,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(Vo,x), _(CS,x),
+  /* A868 */ _(CS,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A870 */  _(C,x), _(CS,x),  _(C,x), _(Bi,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A878 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Saurashtra  (A880..A8DF) */
+
+  /* A880 */ _(Bi,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* A888 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* A890 */ _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A898 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A8A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A8A8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A8B0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(CF,x),  _(M,R),  _(M,R),  _(M,R),
+  /* A8B8 */  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(M,R),
+  /* A8C0 */  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(V,B),  _(x,x),  _(x,x),  _(x,x),
+  /* A8C8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A8D0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A8D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* FILLER  (A8E0..A8FF) */
+
+  /* A8E0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A8E8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A8F0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A8F8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Kayah Li  (A900..A92F) */
+
+  /* A900 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A908 */  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A910 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A918 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A920 */  _(C,x),  _(C,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x), _(Vo,x),
+  /* A928 */ _(Vo,x), _(Vo,x), _(Vo,x), _(TM,x), _(TM,x), _(TM,x),  _(x,x),  _(x,x),
+
+  /* Rejang  (A930..A95F) */
+
+  /* A930 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A938 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A940 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(M,B),
+  /* A948 */  _(M,B),  _(M,B),  _(M,T),  _(M,B),  _(M,B),  _(M,B),  _(M,B), _(CF,x),
+  /* A950 */ _(CF,x), _(CF,x), _(CF,x),  _(V,R),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A958 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* FILLER  (A960..A97F) */
+
+  /* A960 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A968 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A970 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A978 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Javanese  (A980..A9DF) */
+
+  /* A980 */ _(Bi,x), _(Bi,x), _(CR,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* A988 */ _(VI,x),  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),
+  /* A990 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A998 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A9A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A9A8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* A9B0 */  _(C,x),  _(C,x),  _(C,x),  _(N,x),  _(M,R),  _(M,R),  _(M,T),  _(M,T),
+  /* A9B8 */  _(M,B),  _(M,B),  _(M,L),  _(M,L),  _(M,T), _(CS,x), _(CM,x), _(CM,x),
+  /* A9C0 */ _(V,BR),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9C8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9D0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* FILLER  (A9E0..A9FF) */
+
+  /* A9E0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9E8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9F0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* A9F8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Cham  (AA00..AA5F) */
+
+  /* AA00 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),
+  /* AA08 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA10 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA18 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA28 */  _(C,x),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(M,B),  _(M,T),  _(M,L),
+  /* AA30 */  _(M,L),  _(M,T),  _(M,B), _(CM,x), _(CM,x), _(CM,x), _(CM,x),  _(x,x),
+  /* AA38 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AA40 */ _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),
+  /* AA48 */ _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),  _(x,x),  _(x,x),
+  /* AA50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AA58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Myanmar Extended-A  (AA60..AA7F) */
+
+  /* AA60 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA68 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA70 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AA78 */  _(x,x),  _(x,x),  _(C,x), _(TM,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Tai Viet  (AA80..AADF) */
+
+  /* AA80 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA88 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA90 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AA98 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AAA0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AAA8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AAB0 */  _(M,T),  _(M,R),  _(M,T),  _(M,T),  _(M,B),_(M,VOL),_(M,VOL),  _(M,T),
+  /* AAB8 */  _(M,T),_(M,VOL),  _(M,R),_(M,VOL),_(M,VOL),  _(M,R),  _(M,T), _(TM,x),
+  /* AAC0 */ _(TL,x), _(TM,x), _(TL,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AAC8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AAD0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* AAD8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Meetei Mayek Extensions  (AAE0..AAFF) */
+
+  /* AAE0 */ _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* AAE8 */  _(C,x),  _(C,x),  _(C,x),  _(M,L),  _(M,B),  _(M,T),  _(M,L),  _(M,R),
+  /* AAF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Vs,x),  _(V,I),  _(x,x),
+  /* AAF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0xabc0 3792
+
+
+  /* Meetei Mayek  (ABC0..ABFF) */
+
+  /* ABC0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* ABC8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x),
+  /* ABD0 */  _(C,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* ABD8 */  _(C,x),  _(C,x),  _(C,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x), _(CF,x),
+  /* ABE0 */ _(CF,x), _(CF,x), _(CF,x),  _(M,R),  _(M,R),  _(M,T),  _(M,R),  _(M,R),
+  /* ABE8 */  _(M,B),  _(M,R),  _(M,R),  _(x,x), _(TM,x),  _(V,B),  _(x,x),  _(x,x),
+  /* ABF0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* ABF8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x10a00 3856
+
+
+  /* Kharoshthi  (10A00..10A5F) */
+
+  /* 10A00 */  _(C,x),  _(M,O),  _(M,B),  _(M,B),  _(x,x),  _(M,T),  _(M,O),  _(x,x),
+  /* 10A08 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,B),  _(x,x), _(Bi,x), _(Vs,x),
+  /* 10A10 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 10A18 */  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 10A20 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 10A28 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 10A30 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 10A38 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(V,I),
+  /* 10A40 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 10A48 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 10A50 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 10A58 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x11000 3952
+
+
+  /* Brahmi  (11000..1107F) */
+
+  /* 11000 */ _(Bi,x), _(Bi,x), _(Vs,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11008 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11010 */ _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11018 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11020 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11028 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11030 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11038 */  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(M,B),  _(M,B),  _(M,B),  _(M,B),
+  /* 11040 */  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(V,T),  _(x,x),
+  /* 11048 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11050 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11058 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11060 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11068 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11070 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11078 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+  /* Kaithi  (11080..110CF) */
+
+  /* 11080 */ _(Bi,x), _(Bi,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11088 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11090 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11098 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 110A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 110A8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 110B0 */  _(M,R),  _(M,L),  _(M,R),  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,R),
+  /* 110B8 */  _(M,R),  _(V,B),  _(N,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 110C0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 110C8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x11100 4160
+
+
+  /* Chakma  (11100..1114F) */
+
+  /* 11100 */ _(Bi,x), _(Bi,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),
+  /* 11108 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11110 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11118 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11120 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(M,T),
+  /* 11128 */  _(M,T),  _(M,T),  _(M,B),  _(M,B),  _(M,L),  _(M,T), _(M,TB), _(M,TB),
+  /* 11130 */  _(M,T),  _(M,B),  _(M,B),  _(V,I),  _(V,T),  _(x,x),  _(x,x),  _(x,x),
+  /* 11138 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11140 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 11148 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x11180 4240
+
+
+  /* Sharada  (11180..111DF) */
+
+  /* 11180 */ _(Bi,x), _(Bi,x), _(Vs,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11188 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11190 */ _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11198 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 111A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 111A8 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 111B0 */  _(C,x),  _(C,x),  _(C,x),  _(M,R),  _(M,L),  _(M,R),  _(M,B),  _(M,B),
+  /* 111B8 */  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T), _(M,TR),
+  /* 111C0 */  _(V,R),  _(A,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 111C8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 111D0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 111D8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_0x11680 4336
+
+
+  /* Takri  (11680..116CF) */
+
+  /* 11680 */ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),
+  /* 11688 */ _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11690 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 11698 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 116A0 */  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),
+  /* 116A8 */  _(C,x),  _(C,x),  _(C,x), _(Bi,x), _(Vs,x),  _(M,T),  _(M,L),  _(M,R),
+  /* 116B0 */  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(V,T),  _(N,x),
+  /* 116B8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 116C0 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+  /* 116C8 */  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),
+
+#define indic_offset_total 4416
+
+}; /* Table occupancy: 60% */
+
+static INDIC_TABLE_ELEMENT_TYPE
+get_indic_categories (hb_codepoint_t u)
+{
+  if (0x0900 <= u && u <= 0x10A0) return indic_table[u - 0x0900 + indic_offset_0x0900];
+  if (0x1700 <= u && u <= 0x1800) return indic_table[u - 0x1700 + indic_offset_0x1700];
+  if (0x1900 <= u && u <= 0x1AB0) return indic_table[u - 0x1900 + indic_offset_0x1900];
+  if (0x1B00 <= u && u <= 0x1C50) return indic_table[u - 0x1B00 + indic_offset_0x1b00];
+  if (0x1CD0 <= u && u <= 0x1D00) return indic_table[u - 0x1CD0 + indic_offset_0x1cd0];
+  if (0xA800 <= u && u <= 0xAB00) return indic_table[u - 0xA800 + indic_offset_0xa800];
+  if (0xABC0 <= u && u <= 0xAC00) return indic_table[u - 0xABC0 + indic_offset_0xabc0];
+  if (0x10A00 <= u && u <= 0x10A60) return indic_table[u - 0x10A00 + indic_offset_0x10a00];
+  if (0x11000 <= u && u <= 0x110D0) return indic_table[u - 0x11000 + indic_offset_0x11000];
+  if (0x11100 <= u && u <= 0x11150) return indic_table[u - 0x11100 + indic_offset_0x11100];
+  if (0x11180 <= u && u <= 0x111E0) return indic_table[u - 0x11180 + indic_offset_0x11180];
+  if (0x11680 <= u && u <= 0x116D0) return indic_table[u - 0x11680 + indic_offset_0x11680];
+  if (unlikely (u == 0x00A0)) return _(CP,x);
+  if (unlikely (u == 0x25CC)) return _(CP,x);
+  return _(x,x);
+}
+
+#undef _
+
+#undef ISC_A
+#undef ISC_Bi
+#undef ISC_C
+#undef ISC_CD
+#undef ISC_CF
+#undef ISC_CHL
+#undef ISC_CM
+#undef ISC_CP
+#undef ISC_CR
+#undef ISC_CS
+#undef ISC_ML
+#undef ISC_N
+#undef ISC_x
+#undef ISC_RS
+#undef ISC_TL
+#undef ISC_TM
+#undef ISC_V
+#undef ISC_Vs
+#undef ISC_Vo
+#undef ISC_M
+#undef ISC_VI
+
+#undef IMC_B
+#undef IMC_BR
+#undef IMC_I
+#undef IMC_L
+#undef IMC_LR
+#undef IMC_x
+#undef IMC_O
+#undef IMC_R
+#undef IMC_T
+#undef IMC_TB
+#undef IMC_TBR
+#undef IMC_TL
+#undef IMC_TLR
+#undef IMC_TR
+#undef IMC_VOL
+
+#endif /* HB_OT_SHAPE_COMPLEX_INDIC_TABLE_HH */
+
+/* == End of generated table == */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-misc.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-misc.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-misc.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-misc.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,183 @@
+/*
+ * Copyright  2010  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-shape-complex-private.hh"
+
+
+/* TODO Add kana, and other small shapers here */
+
+/* When adding trivial shapers, eg. kana, hangul, etc, we can either
+ * add a full shaper enum value for them, or switch on the script in
+ * the default complex shaper.  The former is faster, so I think that's
+ * what we would do, and hence the default complex shaper shall remain
+ * empty.
+ */
+
+void
+_hb_ot_shape_complex_collect_features_default (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props)
+{
+}
+
+hb_ot_shape_normalization_mode_t
+_hb_ot_shape_complex_normalization_preference_default (void)
+{
+  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;
+}
+
+void
+_hb_ot_shape_complex_setup_masks_default (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font)
+{
+}
+
+
+
+/* Hangul shaper */
+
+static const hb_tag_t hangul_features[] =
+{
+  HB_TAG('l','j','m','o'),
+  HB_TAG('v','j','m','o'),
+  HB_TAG('t','j','m','o'),
+};
+
+void
+_hb_ot_shape_complex_collect_features_hangul (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props)
+{
+  for (unsigned int i = 0; i < ARRAY_LENGTH (hangul_features); i++)
+    map->add_bool_feature (hangul_features[i]);
+}
+
+hb_ot_shape_normalization_mode_t
+_hb_ot_shape_complex_normalization_preference_hangul (void)
+{
+  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL;
+}
+
+void
+_hb_ot_shape_complex_setup_masks_hangul (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font)
+{
+}
+
+
+
+/* Thai / Lao shaper */
+
+void
+_hb_ot_shape_complex_collect_features_thai (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props)
+{
+}
+
+hb_ot_shape_normalization_mode_t
+_hb_ot_shape_complex_normalization_preference_thai (void)
+{
+  return HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL;
+}
+
+void
+_hb_ot_shape_complex_setup_masks_thai (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font)
+{
+  /* The following is NOT specified in the MS OT Thai spec, however, it seems
+   * to be what Uniscribe and other engines implement.  According to Eric Muller:
+   *
+   * When you have a sara am, decompose it in nikhahit + sara a, *and* mode the
+   * nihka hit backwards over any *tone* mark (0E48-0E4B).
+   *
+   * <0E14, 0E4B, 0E33> -> <0E14, 0E4D, 0E4B, 0E32>
+   *
+   * This reordering is legit only when the nikhahit comes from a sara am, not
+   * when it's there to start with. The string <0E14, 0E4B, 0E4D> is probably
+   * not what a user wanted, but the rendering is nevertheless nikhahit above
+   * chattawa.
+   *
+   * Same for Lao.
+   */
+
+  /*
+   * Here are the characters of significance:
+   *
+   *			Thai	Lao
+   * SARA AM:		U+0E33	U+0EB3
+   * SARA AA:		U+0E32	U+0EB2
+   * Nikhahit:		U+0E4D	U+0ECD
+   *
+   * Tone marks:
+   * Thai:	<0E48..0E4B> CCC=107
+   * Lao:	<0EC8..0ECB> CCC=122
+   *
+   * Note how the Lao versions are the same as Thai + 0x80.
+   */
+
+  /* We only get one script at a time, so a script-agnostic implementation
+   * is adequate here. */
+#define IS_SARA_AM(x) (((x) & ~0x0080) == 0x0E33)
+#define NIKHAHIT_FROM_SARA_AM(x) ((x) - 0xE33 + 0xE4D)
+#define SARA_AA_FROM_SARA_AM(x) ((x) - 1)
+#define IS_TONE_MARK(x) (((x) & ~0x0083) == 0x0E48)
+
+  buffer->clear_output ();
+  unsigned int count = buffer->len;
+  for (buffer->idx = 0; buffer->idx < count;)
+  {
+    hb_codepoint_t u = buffer->info[buffer->idx].codepoint;
+    if (likely (!IS_SARA_AM (u))) {
+      buffer->next_glyph ();
+      continue;
+    }
+
+    /* Is SARA AM. Decompose and reorder. */
+    hb_codepoint_t decomposed[2] = {hb_codepoint_t (NIKHAHIT_FROM_SARA_AM (u)),
+				    hb_codepoint_t (SARA_AA_FROM_SARA_AM (u))};
+    buffer->replace_glyphs (1, 2, decomposed);
+    if (unlikely (buffer->in_error))
+      return;
+
+    /* Ok, let's see... */
+    unsigned int end = buffer->out_len;
+    unsigned int start = end - 2;
+    while (start > 0 && IS_TONE_MARK (buffer->out_info[start - 1].codepoint))
+      start--;
+
+    /* Move Nikhahit (end-2) to the beginning */
+    hb_glyph_info_t t = buffer->out_info[end - 2];
+    memmove (buffer->out_info + start + 1,
+	     buffer->out_info + start,
+	     sizeof (buffer->out_info[0]) * (end - start - 2));
+    buffer->out_info[start] = t;
+
+    /* Make cluster */
+    for (; start > 0 && buffer->out_info[start - 1].cluster == buffer->out_info[start].cluster; start--)
+      ;
+    for (; buffer->idx < count;)
+      if (buffer->info[buffer->idx].cluster == buffer->out_info[buffer->out_len - 1].cluster)
+        buffer->next_glyph ();
+      else
+        break;
+    end = buffer->out_len;
+
+    buffer->merge_out_clusters (start, end);
+  }
+  buffer->swap_buffers ();
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-complex-private.hh	2012-05-07 14:37:52.038084930 +0530
@@ -0,0 +1,306 @@
+/*
+ * Copyright  2010,2011,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_COMPLEX_PRIVATE_HH
+#define HB_OT_SHAPE_COMPLEX_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-ot-map-private.hh"
+#include "hb-ot-shape-normalize-private.hh"
+
+
+
+/* buffer var allocations, used during the entire shaping process */
+#define general_category() var1.u8[0] /* unicode general_category (hb_unicode_general_category_t) */
+#define combining_class() var1.u8[1] /* unicode combining_class (uint8_t) */
+
+/* buffer var allocations, used by complex shapers */
+#define complex_var_persistent_u8_0()	var2.u8[0]
+#define complex_var_persistent_u8_1()	var2.u8[1]
+#define complex_var_persistent_u16()	var2.u16[0]
+#define complex_var_temporary_u8_0()	var2.u8[2]
+#define complex_var_temporary_u8_1()	var2.u8[3]
+#define complex_var_temporary_u16()	var2.u16[1]
+
+
+#define HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS \
+  HB_COMPLEX_SHAPER_IMPLEMENT (default) /* should be first */ \
+  HB_COMPLEX_SHAPER_IMPLEMENT (arabic) \
+  HB_COMPLEX_SHAPER_IMPLEMENT (hangul) \
+  HB_COMPLEX_SHAPER_IMPLEMENT (indic) \
+  HB_COMPLEX_SHAPER_IMPLEMENT (thai) \
+  /* ^--- Add new shapers here */
+
+enum hb_ot_complex_shaper_t {
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) hb_ot_complex_shaper_##name,
+  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+  /* Just here to avoid enum trailing comma: */
+  hb_ot_complex_shaper_generic = hb_ot_complex_shaper_default
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+};
+
+static inline hb_ot_complex_shaper_t
+hb_ot_shape_complex_categorize (const hb_segment_properties_t *props)
+{
+  switch ((int) props->script)
+  {
+    default:
+      return hb_ot_complex_shaper_default;
+
+
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_ARABIC:
+    case HB_SCRIPT_MONGOLIAN:
+    case HB_SCRIPT_SYRIAC:
+
+    /* Unicode-5.0 additions */
+    case HB_SCRIPT_NKO:
+
+    /* Unicode-6.0 additions */
+    case HB_SCRIPT_MANDAIC:
+
+      return hb_ot_complex_shaper_arabic;
+
+
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_HANGUL:
+
+      return hb_ot_complex_shaper_hangul;
+
+
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_THAI:
+    case HB_SCRIPT_LAO:
+
+      return hb_ot_complex_shaper_thai;
+
+
+
+    /* ^--- Add new shapers here */
+
+
+#if 0
+    /* Note:
+     *
+     * These disabled scripts are listed in ucd/IndicSyllabicCategory.txt, but according
+     * to Martin Hosken and Jonathan Kew do not require complex shaping.
+     *
+     * TODO We should automate figuring out which scripts do not need complex shaping
+     *
+     * TODO We currently keep data for these scripts in our indic table.  Need to fix the
+     * generator to not do that.
+     */
+
+
+    /* Simple? */
+
+    /* Unicode-3.2 additions */
+    case HB_SCRIPT_BUHID:
+    case HB_SCRIPT_HANUNOO:
+
+    /* Unicode-5.1 additions */
+    case HB_SCRIPT_SAURASHTRA:
+
+    /* Unicode-5.2 additions */
+    case HB_SCRIPT_MEETEI_MAYEK:
+
+    /* Unicode-6.0 additions */
+    case HB_SCRIPT_BATAK:
+    case HB_SCRIPT_BRAHMI:
+
+
+    /* Simple */
+
+    /* Unicode-1.1 additions */
+    /* TODO These two need their own shaper I guess? */
+    case HB_SCRIPT_LAO:
+    case HB_SCRIPT_THAI:
+
+    /* Unicode-2.0 additions */
+    case HB_SCRIPT_TIBETAN:
+
+    /* Unicode-3.2 additions */
+    case HB_SCRIPT_TAGALOG:
+    case HB_SCRIPT_TAGBANWA:
+
+    /* Unicode-4.0 additions */
+    case HB_SCRIPT_LIMBU:
+    case HB_SCRIPT_TAI_LE:
+
+    /* Unicode-4.1 additions */
+    case HB_SCRIPT_SYLOTI_NAGRI:
+
+    /* Unicode-5.0 additions */
+    case HB_SCRIPT_PHAGS_PA:
+
+    /* Unicode-5.1 additions */
+    case HB_SCRIPT_KAYAH_LI:
+
+    /* Unicode-5.2 additions */
+    case HB_SCRIPT_TAI_VIET:
+
+
+    /* May need Indic treatment in the future? */
+
+    /* Unicode-3.0 additions */
+    case HB_SCRIPT_MYANMAR:
+
+
+#endif
+
+    /* Unicode-1.1 additions */
+    case HB_SCRIPT_BENGALI:
+    case HB_SCRIPT_DEVANAGARI:
+    case HB_SCRIPT_GUJARATI:
+    case HB_SCRIPT_GURMUKHI:
+    case HB_SCRIPT_KANNADA:
+    case HB_SCRIPT_MALAYALAM:
+    case HB_SCRIPT_ORIYA:
+    case HB_SCRIPT_TAMIL:
+    case HB_SCRIPT_TELUGU:
+
+    /* Unicode-3.0 additions */
+    case HB_SCRIPT_KHMER:
+    case HB_SCRIPT_SINHALA:
+
+    /* Unicode-4.1 additions */
+    case HB_SCRIPT_BUGINESE:
+    case HB_SCRIPT_KHAROSHTHI:
+    case HB_SCRIPT_NEW_TAI_LUE:
+
+    /* Unicode-5.0 additions */
+    case HB_SCRIPT_BALINESE:
+
+    /* Unicode-5.1 additions */
+    case HB_SCRIPT_CHAM:
+    case HB_SCRIPT_LEPCHA:
+    case HB_SCRIPT_REJANG:
+    case HB_SCRIPT_SUNDANESE:
+
+    /* Unicode-5.2 additions */
+    case HB_SCRIPT_JAVANESE:
+    case HB_SCRIPT_KAITHI:
+    case HB_SCRIPT_TAI_THAM:
+
+    /* Unicode-6.1 additions */
+    case HB_SCRIPT_CHAKMA:
+    case HB_SCRIPT_SHARADA:
+    case HB_SCRIPT_TAKRI:
+
+      return hb_ot_complex_shaper_indic;
+  }
+}
+
+
+
+/*
+ * collect_features()
+ *
+ * Called during shape_plan().
+ *
+ * Shapers should use map to add their features and callbacks.
+ */
+
+typedef void hb_ot_shape_complex_collect_features_func_t (hb_ot_map_builder_t *map, const hb_segment_properties_t  *props);
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+  HB_INTERNAL hb_ot_shape_complex_collect_features_func_t _hb_ot_shape_complex_collect_features_##name;
+  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+
+static inline void
+hb_ot_shape_complex_collect_features (hb_ot_complex_shaper_t shaper,
+				      hb_ot_map_builder_t *map,
+				      const hb_segment_properties_t  *props)
+{
+  switch (shaper) {
+    default:
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+    case hb_ot_complex_shaper_##name:	_hb_ot_shape_complex_collect_features_##name (map, props); return;
+    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+  }
+}
+
+
+/*
+ * normalization_preference()
+ *
+ * Called during shape_execute().
+ *
+ * Shapers should return TRUE if it prefers decomposed (NFD) input rather than precomposed (NFC).
+ */
+
+typedef hb_ot_shape_normalization_mode_t hb_ot_shape_complex_normalization_preference_func_t (void);
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+  HB_INTERNAL hb_ot_shape_complex_normalization_preference_func_t _hb_ot_shape_complex_normalization_preference_##name;
+  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+
+static inline hb_ot_shape_normalization_mode_t
+hb_ot_shape_complex_normalization_preference (hb_ot_complex_shaper_t shaper)
+{
+  switch (shaper) {
+    default:
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+    case hb_ot_complex_shaper_##name:	return _hb_ot_shape_complex_normalization_preference_##name ();
+    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+  }
+}
+
+
+/* setup_masks()
+ *
+ * Called during shape_execute().
+ *
+ * Shapers should use map to get feature masks and set on buffer.
+ */
+
+typedef void hb_ot_shape_complex_setup_masks_func_t (hb_ot_map_t *map, hb_buffer_t *buffer, hb_font_t *font);
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+  HB_INTERNAL hb_ot_shape_complex_setup_masks_func_t _hb_ot_shape_complex_setup_masks_##name;
+  HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+
+static inline void
+hb_ot_shape_complex_setup_masks (hb_ot_complex_shaper_t shaper,
+				 hb_ot_map_t *map,
+				 hb_buffer_t *buffer,
+				 hb_font_t *font)
+{
+  switch (shaper) {
+    default:
+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) \
+    case hb_ot_complex_shaper_##name:	_hb_ot_shape_complex_setup_masks_##name (map, buffer, font); return;
+    HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
+#undef HB_COMPLEX_SHAPER_IMPLEMENT
+  }
+}
+
+
+
+#endif /* HB_OT_SHAPE_COMPLEX_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape.h	2012-03-17 16:16:34.000000000 +0530
@@ -0,0 +1,47 @@
+/*
+ * Copyright  2010  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_H
+#define HB_OT_SHAPE_H
+
+#include "hb-common.h"
+#include "hb-shape.h"
+
+
+HB_BEGIN_DECLS
+
+
+hb_bool_t
+hb_ot_shape (hb_font_t          *font,
+	     hb_buffer_t        *buffer,
+	     const hb_feature_t *features,
+	     unsigned int        num_features,
+	     const char * const *shaper_options);
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_SHAPE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize.cc	2012-05-07 19:04:11.514305329 +0530
@@ -0,0 +1,293 @@
+/*
+ * Copyright  2011,2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-ot-shape-normalize-private.hh"
+#include "hb-ot-shape-private.hh"
+
+
+/*
+ * HIGHLEVEL DESIGN:
+ *
+ * This file exports one main function: _hb_ot_shape_normalize().
+ *
+ * This function closely reflects the Unicode Normalization Algorithm,
+ * yet it's different.
+ *
+ * Each shaper specifies whether it prefers decomposed (NFD) or composed (NFC).
+ * The logic however tries to use whatever the font can support.
+ *
+ * In general what happens is that: each grapheme is decomposed in a chain
+ * of 1:2 decompositions, marks reordered, and then recomposed if desired,
+ * so far it's like Unicode Normalization.  However, the decomposition and
+ * recomposition only happens if the font supports the resulting characters.
+ *
+ * The goals are:
+ *
+ *   - Try to render all canonically equivalent strings similarly.  To really
+ *     achieve this we have to always do the full decomposition and then
+ *     selectively recompose from there.  It's kinda too expensive though, so
+ *     we skip some cases.  For example, if composed is desired, we simply
+ *     don't touch 1-character clusters that are supported by the font, even
+ *     though their NFC may be different.
+ *
+ *   - When a font has a precomposed character for a sequence but the 'ccmp'
+ *     feature in the font is not adequate, use the precomposed character
+ *     which typically has better mark positioning.
+ *
+ *   - When a font does not support a combining mark, but supports it precomposed
+ *     with previous base, use that.  This needs the itemizer to have this
+ *     knowledge too.  We need to provide assistance to the itemizer.
+ *
+ *   - When a font does not support a character but supports its decomposition,
+ *     well, use the decomposition.
+ *
+ *   - The Indic shaper requests decomposed output.  This will handle splitting
+ *     matra for the Indic shaper.
+ */
+
+static inline void
+set_unicode_props (hb_glyph_info_t *info, hb_unicode_funcs_t *unicode)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,info->codepoint) ;
+  info->general_category() = hb_unicode_general_category (unicode, info->codepoint);
+  info->combining_class() = _hb_unicode_modified_combining_class (unicode, info->codepoint);
+}
+
+static void
+output_glyph (hb_font_t *font, hb_buffer_t *buffer,
+	      hb_codepoint_t glyph)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info->codepoint) ;
+  buffer->output_glyph (glyph);
+  set_unicode_props (&buffer->out_info[buffer->out_len - 1], buffer->unicode);
+}
+
+static bool
+decompose (hb_font_t *font, hb_buffer_t *buffer,
+	   bool shortest,
+	   hb_codepoint_t ab)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,ab) ;
+  hb_codepoint_t a, b, glyph;
+
+  if (!hb_unicode_decompose (buffer->unicode, ab, &a, &b) ||
+      (b && !hb_font_get_glyph (font, b, 0, &glyph)))
+    return FALSE;
+
+  bool has_a = hb_font_get_glyph (font, a, 0, &glyph);
+  if (shortest && has_a) {
+    /* Output a and b */
+    output_glyph (font, buffer, a);
+    if (b)
+      output_glyph (font, buffer, b);
+    return TRUE;
+  }
+
+  if (decompose (font, buffer, shortest, a)) {
+    if (b)
+      output_glyph (font, buffer, b);
+    return TRUE;
+  }
+
+  if (has_a) {
+    output_glyph (font, buffer, a);
+    if (b)
+      output_glyph (font, buffer, b);
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+static void
+decompose_current_glyph (hb_font_t *font, hb_buffer_t *buffer,
+			 bool shortest)
+{
+//printf ( "(%s)(%d)(%s) (%X) \n", __FILE__, __LINE__, __func__, buffer->info[buffer->idx].codepoint) ;
+  if (decompose (font, buffer, shortest, buffer->info[buffer->idx].codepoint))
+    buffer->skip_glyph ();
+  else
+    buffer->next_glyph ();
+}
+
+static void
+decompose_single_char_cluster (hb_font_t *font, hb_buffer_t *buffer,
+			       bool will_recompose)
+{
+//printf ( "(%s)(%d)(%s) (%X) \n", __FILE__, __LINE__, __func__, buffer->info[buffer->idx].codepoint) ;
+  hb_codepoint_t glyph;
+
+  /* If recomposing and font supports this, we're good to go */
+  if (will_recompose && hb_font_get_glyph (font, buffer->info[buffer->idx].codepoint, 0, &glyph)) {
+    buffer->next_glyph ();
+    return;
+  }
+
+  decompose_current_glyph (font, buffer, will_recompose);
+}
+
+static void
+decompose_multi_char_cluster (hb_font_t *font, hb_buffer_t *buffer,
+			      unsigned int end)
+{
+  /* TODO Currently if there's a variation-selector we give-up, it's just too hard. */
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__, buffer->info[0].codepoint) ;
+  for (unsigned int i = buffer->idx; i < end; i++)
+    if (unlikely (_hb_unicode_is_variation_selector (buffer->info[i].codepoint))) {
+      while (buffer->idx < end)
+	buffer->next_glyph ();
+      return;
+    }
+
+  while (buffer->idx < end)
+    decompose_current_glyph (font, buffer, FALSE);
+}
+
+static int
+compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
+{
+  unsigned int a = pa->combining_class();
+  unsigned int b = pb->combining_class();
+
+  return a < b ? -1 : a == b ? 0 : +1;
+}
+
+void
+_hb_ot_shape_normalize (hb_font_t *font, hb_buffer_t *buffer,
+			hb_ot_shape_normalization_mode_t mode)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__, buffer->info[0].codepoint) ;
+  bool recompose = mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;
+  bool has_multichar_clusters = FALSE;
+  unsigned int count;
+
+  /* We do a fairly straightforward yet custom normalization process in three
+   * separate rounds: decompose, reorder, recompose (if desired).  Currently
+   * this makes two buffer swaps.  We can make it faster by moving the last
+   * two rounds into the inner loop for the first round, but it's more readable
+   * this way. */
+
+
+  /* First round, decompose */
+
+  buffer->clear_output ();
+  count = buffer->len;
+  for (buffer->idx = 0; buffer->idx < count;)
+  {
+    unsigned int end;
+    for (end = buffer->idx + 1; end < count; end++)
+      if (buffer->info[buffer->idx].cluster != buffer->info[end].cluster)
+        break;
+
+    if (buffer->idx + 1 == end)
+      decompose_single_char_cluster (font, buffer, recompose);
+    else {
+      decompose_multi_char_cluster (font, buffer, end);
+      has_multichar_clusters = TRUE;
+    }
+  }
+  buffer->swap_buffers ();
+
+
+  if (mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL && !has_multichar_clusters)
+    return; /* Done! */
+
+
+  /* Second round, reorder (inplace) */
+
+  count = buffer->len;
+  for (unsigned int i = 0; i < count; i++)
+  {
+    if (buffer->info[i].combining_class() == 0)
+      continue;
+
+    unsigned int end;
+    for (end = i + 1; end < count; end++)
+      if (buffer->info[end].combining_class() == 0)
+        break;
+
+    /* We are going to do a bubble-sort.  Only do this if the
+     * sequence is short.  Doing it on long sequences can result
+     * in an O(n^2) DoS. */
+    if (end - i > 10) {
+      i = end;
+      continue;
+    }
+
+    hb_bubble_sort (buffer->info + i, end - i, compare_combining_class);
+
+    i = end;
+  }
+
+
+  if (!recompose)
+    return;
+
+  /* Third round, recompose */
+
+  /* As noted in the comment earlier, we don't try to combine
+   * ccc=0 chars with their previous Starter. */
+
+  buffer->clear_output ();
+  count = buffer->len;
+  unsigned int starter = 0;
+  buffer->next_glyph ();
+  while (buffer->idx < count)
+  {
+    hb_codepoint_t composed, glyph;
+    if (/* If mode is NOT COMPOSED_FULL (ie. it's COMPOSED_DIACRITICS), we don't try to
+	 * compose a CCC=0 character with it's preceding starter. */
+	(mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL ||
+	 buffer->info[buffer->idx].combining_class() != 0) &&
+	/* If there's anything between the starter and this char, they should have CCC
+	 * smaller than this character's. */
+	(starter == buffer->out_len - 1 ||
+	 buffer->out_info[buffer->out_len - 1].combining_class() < buffer->info[buffer->idx].combining_class()) &&
+	/* And compose. */
+	hb_unicode_compose (buffer->unicode,
+			    buffer->out_info[starter].codepoint,
+			    buffer->info[buffer->idx].codepoint,
+			    &composed) &&
+	/* And the font has glyph for the composite. */
+	hb_font_get_glyph (font, composed, 0, &glyph))
+    {
+      /* Composes. Modify starter and carry on. */
+      buffer->out_info[starter].codepoint = composed;
+      set_unicode_props (&buffer->out_info[starter], buffer->unicode);
+
+      buffer->skip_glyph ();
+      continue;
+    }
+
+    /* Blocked, or doesn't compose. */
+    buffer->next_glyph ();
+
+    if (buffer->out_info[buffer->out_len - 1].combining_class() == 0)
+      starter = buffer->out_len - 1;
+  }
+  buffer->swap_buffers ();
+
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-normalize-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,46 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_NORMALIZE_PRIVATE_HH
+#define HB_OT_SHAPE_NORMALIZE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-font.h"
+#include "hb-buffer.h"
+
+
+enum hb_ot_shape_normalization_mode_t {
+  HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED,
+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS, /* never composes base-to-base */
+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_FULL /* including base-to-base composition */
+};
+
+HB_INTERNAL void _hb_ot_shape_normalize (hb_font_t *font,
+					 hb_buffer_t *buffer,
+					 hb_ot_shape_normalization_mode_t mode);
+
+#endif /* HB_OT_SHAPE_NORMALIZE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-shape-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-shape-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,56 @@
+/*
+ * Copyright  2010  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_SHAPE_PRIVATE_HH
+#define HB_OT_SHAPE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-ot-map-private.hh"
+#include "hb-ot-shape-complex-private.hh"
+
+
+struct hb_ot_shape_plan_t
+{
+  hb_ot_map_t map;
+  hb_ot_complex_shaper_t shaper;
+
+  hb_ot_shape_plan_t (void) : map () {}
+  ~hb_ot_shape_plan_t (void) { map.finish (); }
+
+  private:
+  NO_COPY (hb_ot_shape_plan_t);
+};
+
+
+
+HB_INTERNAL hb_bool_t
+_hb_ot_shape (hb_font_t          *font,
+	      hb_buffer_t        *buffer,
+	      const hb_feature_t *features,
+	      unsigned int        num_features);
+
+#endif /* HB_OT_SHAPE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.c	2012-05-05 23:46:51.529763796 +0530
@@ -0,0 +1,698 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+#include "hb-ot.h"
+
+#include <string.h>
+
+HB_BEGIN_DECLS
+
+
+/*
+ * Complete list at:
+ * http://www.microsoft.com/typography/otspec/scripttags.htm
+ */
+static const hb_tag_t ot_scripts[][3] = {
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_COMMON */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_INHERITED */
+  {HB_TAG('a','r','a','b')},	/* HB_SCRIPT_ARABIC */
+  {HB_TAG('a','r','m','n')},	/* HB_SCRIPT_ARMENIAN */
+  {HB_TAG('b','n','g','2'), HB_TAG('b','e','n','g')},	/* HB_SCRIPT_BENGALI */
+  {HB_TAG('b','o','p','o')},	/* HB_SCRIPT_BOPOMOFO */
+  {HB_TAG('c','h','e','r')},	/* HB_SCRIPT_CHEROKEE */
+  {HB_TAG('c','o','p','t')},	/* HB_SCRIPT_COPTIC */
+  {HB_TAG('c','y','r','l')},	/* HB_SCRIPT_CYRILLIC */
+  {HB_TAG('d','s','r','t')},	/* HB_SCRIPT_DESERET */
+  {HB_TAG('d','e','v','2'), HB_TAG('d','e','v','a')},	/* HB_SCRIPT_DEVANAGARI */
+  {HB_TAG('e','t','h','i')},	/* HB_SCRIPT_ETHIOPIC */
+  {HB_TAG('g','e','o','r')},	/* HB_SCRIPT_GEORGIAN */
+  {HB_TAG('g','o','t','h')},	/* HB_SCRIPT_GOTHIC */
+  {HB_TAG('g','r','e','k')},	/* HB_SCRIPT_GREEK */
+  {HB_TAG('g','j','r','2'), HB_TAG('g','u','j','r')},	/* HB_SCRIPT_GUJARATI */
+  {HB_TAG('g','u','r','2'), HB_TAG('g','u','r','u')},	/* HB_SCRIPT_GURMUKHI */
+  {HB_TAG('h','a','n','i')},	/* HB_SCRIPT_HAN */
+  {HB_TAG('h','a','n','g')},	/* HB_SCRIPT_HANGUL */
+  {HB_TAG('h','e','b','r')},	/* HB_SCRIPT_HEBREW */
+  {HB_TAG('k','a','n','a')},	/* HB_SCRIPT_HIRAGANA */
+  {HB_TAG('k','n','d','2'), HB_TAG('k','n','d','a')},	/* HB_SCRIPT_KANNADA */
+  {HB_TAG('k','a','n','a')},	/* HB_SCRIPT_KATAKANA */
+  {HB_TAG('k','h','m','r')},	/* HB_SCRIPT_KHMER */
+  {HB_TAG('l','a','o',' ')},	/* HB_SCRIPT_LAO */
+  {HB_TAG('l','a','t','n')},	/* HB_SCRIPT_LATIN */
+  {HB_TAG('m','l','m','2'), HB_TAG('m','l','y','m')},	/* HB_SCRIPT_MALAYALAM */
+  {HB_TAG('m','o','n','g')},	/* HB_SCRIPT_MONGOLIAN */
+  {HB_TAG('m','y','m','r')},	/* HB_SCRIPT_MYANMAR */
+  {HB_TAG('o','g','a','m')},	/* HB_SCRIPT_OGHAM */
+  {HB_TAG('i','t','a','l')},	/* HB_SCRIPT_OLD_ITALIC */
+  {HB_TAG('o','r','y','2'), HB_TAG('o','r','y','a')},	/* HB_SCRIPT_ORIYA */
+  {HB_TAG('r','u','n','r')},	/* HB_SCRIPT_RUNIC */
+  {HB_TAG('s','i','n','h')},	/* HB_SCRIPT_SINHALA */
+  {HB_TAG('s','y','r','c')},	/* HB_SCRIPT_SYRIAC */
+  {HB_TAG('t','m','l','2'), HB_TAG('t','a','m','l')},	/* HB_SCRIPT_TAMIL */
+  {HB_TAG('t','e','l','2'), HB_TAG('t','e','l','u')},	/* HB_SCRIPT_TELUGU */
+  {HB_TAG('t','h','a','a')},	/* HB_SCRIPT_THAANA */
+  {HB_TAG('t','h','a','i')},	/* HB_SCRIPT_THAI */
+  {HB_TAG('t','i','b','t')},	/* HB_SCRIPT_TIBETAN */
+  {HB_TAG('c','a','n','s')},	/* HB_SCRIPT_CANADIAN_ABORIGINAL */
+  {HB_TAG('y','i',' ',' ')},	/* HB_SCRIPT_YI */
+  {HB_TAG('t','g','l','g')},	/* HB_SCRIPT_TAGALOG */
+  {HB_TAG('h','a','n','o')},	/* HB_SCRIPT_HANUNOO */
+  {HB_TAG('b','u','h','d')},	/* HB_SCRIPT_BUHID */
+  {HB_TAG('t','a','g','b')},	/* HB_SCRIPT_TAGBANWA */
+
+  /* Unicode-4.0 additions */
+  {HB_TAG('b','r','a','i')},	/* HB_SCRIPT_BRAILLE */
+  {HB_TAG('c','p','r','t')},	/* HB_SCRIPT_CYPRIOT */
+  {HB_TAG('l','i','m','b')},	/* HB_SCRIPT_LIMBU */
+  {HB_TAG('o','s','m','a')},	/* HB_SCRIPT_OSMANYA */
+  {HB_TAG('s','h','a','w')},	/* HB_SCRIPT_SHAVIAN */
+  {HB_TAG('l','i','n','b')},	/* HB_SCRIPT_LINEAR_B */
+  {HB_TAG('t','a','l','e')},	/* HB_SCRIPT_TAI_LE */
+  {HB_TAG('u','g','a','r')},	/* HB_SCRIPT_UGARITIC */
+
+  /* Unicode-4.1 additions */
+  {HB_TAG('t','a','l','u')},	/* HB_SCRIPT_NEW_TAI_LUE */
+  {HB_TAG('b','u','g','i')},	/* HB_SCRIPT_BUGINESE */
+  {HB_TAG('g','l','a','g')},	/* HB_SCRIPT_GLAGOLITIC */
+  {HB_TAG('t','f','n','g')},	/* HB_SCRIPT_TIFINAGH */
+  {HB_TAG('s','y','l','o')},	/* HB_SCRIPT_SYLOTI_NAGRI */
+  {HB_TAG('x','p','e','o')},	/* HB_SCRIPT_OLD_PERSIAN */
+  {HB_TAG('k','h','a','r')},	/* HB_SCRIPT_KHAROSHTHI */
+
+  /* Unicode-5.0 additions */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_UNKNOWN */
+  {HB_TAG('b','a','l','i')},	/* HB_SCRIPT_BALINESE */
+  {HB_TAG('x','s','u','x')},	/* HB_SCRIPT_CUNEIFORM */
+  {HB_TAG('p','h','n','x')},	/* HB_SCRIPT_PHOENICIAN */
+  {HB_TAG('p','h','a','g')},	/* HB_SCRIPT_PHAGS_PA */
+  {HB_TAG('n','k','o',' ')},	/* HB_SCRIPT_NKO */
+
+  /* Unicode-5.1 additions */
+  {HB_TAG('k','a','l','i')},	/* HB_SCRIPT_KAYAH_LI */
+  {HB_TAG('l','e','p','c')},	/* HB_SCRIPT_LEPCHA */
+  {HB_TAG('r','j','n','g')},	/* HB_SCRIPT_REJANG */
+  {HB_TAG('s','u','n','d')},	/* HB_SCRIPT_SUNDANESE */
+  {HB_TAG('s','a','u','r')},	/* HB_SCRIPT_SAURASHTRA */
+  {HB_TAG('c','h','a','m')},	/* HB_SCRIPT_CHAM */
+  {HB_TAG('o','l','c','k')},	/* HB_SCRIPT_OL_CHIKI */
+  {HB_TAG('v','a','i',' ')},	/* HB_SCRIPT_VAI */
+  {HB_TAG('c','a','r','i')},	/* HB_SCRIPT_CARIAN */
+  {HB_TAG('l','y','c','i')},	/* HB_SCRIPT_LYCIAN */
+  {HB_TAG('l','y','d','i')},	/* HB_SCRIPT_LYDIAN */
+
+  /* Unicode-5.2 additions */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_AVESTAN */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_BAMUM */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_EGYPTIAN_HIEROGLYPHS */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_IMPERIAL_ARAMAIC */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_INSCRIPTIONAL_PAHLAVI */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_INSCRIPTIONAL_PARTHIAN */
+  {HB_TAG('j','a','v','a')},	/* HB_SCRIPT_JAVANESE */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_KAITHI */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_LISU */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_MEITEI_MAYEK */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_OLD_SOUTH_ARABIAN */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_OLD_TURKIC */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_SAMARITAN */
+  {HB_TAG('D','F','L','T')},	/* HB_SCRIPT_TAI_THAM */
+  {HB_TAG('D','F','L','T')} 	/* HB_SCRIPT_TAI_VIET */
+};
+
+const hb_tag_t *
+hb_ot_tags_from_script (hb_script_t script)
+{
+  static const hb_tag_t def_tag[] = {HB_OT_TAG_DEFAULT_SCRIPT, HB_TAG_NONE};
+
+  if (unlikely ((unsigned int) script >= ARRAY_LENGTH (ot_scripts)))
+    return def_tag;
+
+  return ot_scripts[script];
+}
+
+hb_script_t
+hb_ot_tag_to_script (hb_tag_t tag)
+{
+  int i;
+
+  for (i = 0; i < ARRAY_LENGTH (ot_scripts); i++) {
+    const hb_tag_t *p;
+    for (p = ot_scripts[i]; *p; p++)
+      if (tag == *p)
+        return i;
+  }
+
+  return HB_SCRIPT_UNKNOWN;
+}
+
+typedef struct {
+  char language[6];
+  hb_tag_t tag;
+} LangTag;
+
+/*
+ * Complete list at:
+ * http://www.microsoft.com/typography/otspec/languagetags.htm
+ *
+ * Generated by intersecting the OpenType language tag list from
+ * Draft OpenType 1.5 spec, with with the ISO 639-3 codes from
+ * 2008/08/04, matching on name, and finally adjusted manually.
+ *
+ * Many items still missing.  Those are commented out at the end.
+ * Keep sorted for bsearch.
+ */
+static const LangTag ot_languages[] = {
+  {"aa",	HB_TAG('A','F','R',' ')},	/* Afar */
+  {"ab",	HB_TAG('A','B','K',' ')},	/* Abkhazian */
+  {"abq",	HB_TAG('A','B','A',' ')},	/* Abaza */
+  {"ady",	HB_TAG('A','D','Y',' ')},	/* Adyghe */
+  {"af",	HB_TAG('A','F','K',' ')},	/* Afrikaans */
+  {"aiw",	HB_TAG('A','R','I',' ')},	/* Aari */
+  {"am",	HB_TAG('A','M','H',' ')},	/* Amharic */
+  {"ar",	HB_TAG('A','R','A',' ')},	/* Arabic */
+  {"arn",	HB_TAG('M','A','P',' ')},	/* Mapudungun */
+  {"as",	HB_TAG('A','S','M',' ')},	/* Assamese */
+  {"av",	HB_TAG('A','V','R',' ')},	/* Avaric */
+  {"awa",	HB_TAG('A','W','A',' ')},	/* Awadhi */
+  {"ay",	HB_TAG('A','Y','M',' ')},	/* Aymara */
+  {"az",	HB_TAG('A','Z','E',' ')},	/* Azerbaijani */
+  {"ba",	HB_TAG('B','S','H',' ')},	/* Bashkir */
+  {"bal",	HB_TAG('B','L','I',' ')},	/* Baluchi */
+  {"bcq",	HB_TAG('B','C','H',' ')},	/* Bench */
+  {"bem",	HB_TAG('B','E','M',' ')},	/* Bemba (Zambia) */
+  {"bfq",	HB_TAG('B','A','D',' ')},	/* Badaga */
+  {"bft",	HB_TAG('B','L','T',' ')},	/* Balti */
+  {"bg",	HB_TAG('B','G','R',' ')},	/* Bulgarian */
+  {"bhb",	HB_TAG('B','H','I',' ')},	/* Bhili */
+  {"bho",	HB_TAG('B','H','O',' ')},	/* Bhojpuri */
+  {"bik",	HB_TAG('B','I','K',' ')},	/* Bikol */
+  {"bin",	HB_TAG('E','D','O',' ')},	/* Bini */
+  {"bm",	HB_TAG('B','M','B',' ')},	/* Bambara */
+  {"bn",	HB_TAG('B','E','N',' ')},	/* Bengali */
+  {"bo",	HB_TAG('T','I','B',' ')},	/* Tibetan */
+  {"br",	HB_TAG('B','R','E',' ')},	/* Breton */
+  {"brh",	HB_TAG('B','R','H',' ')},	/* Brahui */
+  {"bs",	HB_TAG('B','O','S',' ')},	/* Bosnian */
+  {"btb",	HB_TAG('B','T','I',' ')},	/* Beti (Cameroon) */
+  {"ca",	HB_TAG('C','A','T',' ')},	/* Catalan */
+  {"ce",	HB_TAG('C','H','E',' ')},	/* Chechen */
+  {"ceb",	HB_TAG('C','E','B',' ')},	/* Cebuano */
+  {"chp",	HB_TAG('C','H','P',' ')},	/* Chipewyan */
+  {"chr",	HB_TAG('C','H','R',' ')},	/* Cherokee */
+  {"cop",	HB_TAG('C','O','P',' ')},	/* Coptic */
+  {"cr",	HB_TAG('C','R','E',' ')},	/* Cree */
+  {"crh",	HB_TAG('C','R','T',' ')},	/* Crimean Tatar */
+  {"crm",	HB_TAG('M','C','R',' ')},	/* Moose Cree */
+  {"crx",	HB_TAG('C','R','R',' ')},	/* Carrier */
+  {"cs",	HB_TAG('C','S','Y',' ')},	/* Czech */
+  {"cu",	HB_TAG('C','S','L',' ')},	/* Church Slavic */
+  {"cv",	HB_TAG('C','H','U',' ')},	/* Chuvash */
+  {"cwd",	HB_TAG('D','C','R',' ')},	/* Woods Cree */
+  {"cy",	HB_TAG('W','E','L',' ')},	/* Welsh */
+  {"da",	HB_TAG('D','A','N',' ')},	/* Danish */
+  {"dap",	HB_TAG('N','I','S',' ')},	/* Nisi (India) */
+  {"dar",	HB_TAG('D','A','R',' ')},	/* Dargwa */
+  {"de",	HB_TAG('D','E','U',' ')},	/* German */
+  {"din",	HB_TAG('D','N','K',' ')},	/* Dinka */
+  {"dng",	HB_TAG('D','U','N',' ')},	/* Dungan */
+  {"doi",	HB_TAG('D','G','R',' ')},	/* Dogri */
+  {"dsb",	HB_TAG('L','S','B',' ')},	/* Lower Sorbian */
+  {"dv",	HB_TAG('D','I','V',' ')},	/* Dhivehi */
+  {"dz",	HB_TAG('D','Z','N',' ')},	/* Dzongkha */
+  {"ee",	HB_TAG('E','W','E',' ')},	/* Ewe */
+  {"efi",	HB_TAG('E','F','I',' ')},	/* Efik */
+  {"el",	HB_TAG('E','L','L',' ')},	/* Modern Greek (1453-) */
+  {"en",	HB_TAG('E','N','G',' ')},	/* English */
+  {"eo",	HB_TAG('N','T','O',' ')},	/* Esperanto */
+  {"eot",	HB_TAG('B','T','I',' ')},	/* Beti (Cte d'Ivoire) */
+  {"es",	HB_TAG('E','S','P',' ')},	/* Spanish */
+  {"et",	HB_TAG('E','T','I',' ')},	/* Estonian */
+  {"eu",	HB_TAG('E','U','Q',' ')},	/* Basque */
+  {"eve",	HB_TAG('E','V','N',' ')},	/* Even */
+  {"evn",	HB_TAG('E','V','K',' ')},	/* Evenki */
+  {"fa",	HB_TAG('F','A','R',' ')},	/* Persian */
+  {"ff",	HB_TAG('F','U','L',' ')},	/* Fulah */
+  {"fi",	HB_TAG('F','I','N',' ')},	/* Finnish */
+  {"fil",	HB_TAG('P','I','L',' ')},	/* Filipino */
+  {"fj",	HB_TAG('F','J','I',' ')},	/* Fijian */
+  {"fo",	HB_TAG('F','O','S',' ')},	/* Faroese */
+  {"fon",	HB_TAG('F','O','N',' ')},	/* Fon */
+  {"fr",	HB_TAG('F','R','A',' ')},	/* French */
+  {"fur",	HB_TAG('F','R','L',' ')},	/* Friulian */
+  {"fy",	HB_TAG('F','R','I',' ')},	/* Western Frisian */
+  {"ga",	HB_TAG('I','R','I',' ')},	/* Irish */
+  {"gaa",	HB_TAG('G','A','D',' ')},	/* Ga */
+  {"gag",	HB_TAG('G','A','G',' ')},	/* Gagauz */
+  {"gbm",	HB_TAG('G','A','W',' ')},	/* Garhwali */
+  {"gd",	HB_TAG('G','A','E',' ')},	/* Scottish Gaelic */
+  {"gl",	HB_TAG('G','A','L',' ')},	/* Galician */
+  {"gld",	HB_TAG('N','A','N',' ')},	/* Nanai */
+  {"gn",	HB_TAG('G','U','A',' ')},	/* Guarani */
+  {"gon",	HB_TAG('G','O','N',' ')},	/* Gondi */
+  {"grt",	HB_TAG('G','R','O',' ')},	/* Garo */
+  {"gu",	HB_TAG('G','U','J',' ')},	/* Gujarati */
+  {"guk",	HB_TAG('G','M','Z',' ')},	/* Gumuz */
+  {"gv",	HB_TAG('M','N','X',' ')},	/* Manx Gaelic */
+  {"ha",	HB_TAG('H','A','U',' ')},	/* Hausa */
+  {"har",	HB_TAG('H','R','I',' ')},	/* Harari */
+  {"he",	HB_TAG('I','W','R',' ')},	/* Hebrew */
+  {"hi",	HB_TAG('H','I','N',' ')},	/* Hindi */
+  {"hil",	HB_TAG('H','I','L',' ')},	/* Hiligaynon */
+  {"hoc",	HB_TAG('H','O',' ',' ')},	/* Ho */
+  {"hr",	HB_TAG('H','R','V',' ')},	/* Croatian */
+  {"hsb",	HB_TAG('U','S','B',' ')},	/* Upper Sorbian */
+  {"ht",	HB_TAG('H','A','I',' ')},	/* Haitian */
+  {"hu",	HB_TAG('H','U','N',' ')},	/* Hungarian */
+  {"hy",	HB_TAG('H','Y','E',' ')},	/* Armenian */
+  {"id",	HB_TAG('I','N','D',' ')},	/* Indonesian */
+  {"ig",	HB_TAG('I','B','O',' ')},	/* Igbo */
+  {"igb",	HB_TAG('E','B','I',' ')},	/* Ebira */
+  {"inh",	HB_TAG('I','N','G',' ')},	/* Ingush */
+  {"is",	HB_TAG('I','S','L',' ')},	/* Icelandic */
+  {"it",	HB_TAG('I','T','A',' ')},	/* Italian */
+  {"iu",	HB_TAG('I','N','U',' ')},	/* Inuktitut */
+  {"ja",	HB_TAG('J','A','N',' ')},	/* Japanese */
+  {"jv",	HB_TAG('J','A','V',' ')},	/* Javanese */
+  {"ka",	HB_TAG('K','A','T',' ')},	/* Georgian */
+  {"kam",	HB_TAG('K','M','B',' ')},	/* Kamba (Kenya) */
+  {"kbd",	HB_TAG('K','A','B',' ')},	/* Kabardian */
+  {"kdr",	HB_TAG('K','R','M',' ')},	/* Karaim */
+  {"kdt",	HB_TAG('K','U','Y',' ')},	/* Kuy */
+  {"kfr",	HB_TAG('K','A','C',' ')},	/* Kachchi */
+  {"kfy",	HB_TAG('K','M','N',' ')},	/* Kumaoni */
+  {"kha",	HB_TAG('K','S','I',' ')},	/* Khasi */
+  {"khw",	HB_TAG('K','H','W',' ')},	/* Khowar */
+  {"ki",	HB_TAG('K','I','K',' ')},	/* Kikuyu */
+  {"kk",	HB_TAG('K','A','Z',' ')},	/* Kazakh */
+  {"kl",	HB_TAG('G','R','N',' ')},	/* Kalaallisut */
+  {"kln",	HB_TAG('K','A','L',' ')},	/* Kalenjin */
+  {"km",	HB_TAG('K','H','M',' ')},	/* Central Khmer */
+  {"kmw",	HB_TAG('K','M','O',' ')},	/* Komo (Democratic Republic of Congo) */
+  {"kn",	HB_TAG('K','A','N',' ')},	/* Kannada */
+  {"ko",	HB_TAG('K','O','R',' ')},	/* Korean */
+  {"koi",	HB_TAG('K','O','P',' ')},	/* Komi-Permyak */
+  {"kok",	HB_TAG('K','O','K',' ')},	/* Konkani */
+  {"kpe",	HB_TAG('K','P','L',' ')},	/* Kpelle */
+  {"kpv",	HB_TAG('K','O','Z',' ')},	/* Komi-Zyrian */
+  {"kpy",	HB_TAG('K','Y','K',' ')},	/* Koryak */
+  {"kqy",	HB_TAG('K','R','T',' ')},	/* Koorete */
+  {"kr",	HB_TAG('K','N','R',' ')},	/* Kanuri */
+  {"kri",	HB_TAG('K','R','I',' ')},	/* Krio */
+  {"krl",	HB_TAG('K','R','L',' ')},	/* Karelian */
+  {"kru",	HB_TAG('K','U','U',' ')},	/* Kurukh */
+  {"ks",	HB_TAG('K','S','H',' ')},	/* Kashmiri */
+  {"ku",	HB_TAG('K','U','R',' ')},	/* Kurdish */
+  {"kum",	HB_TAG('K','U','M',' ')},	/* Kumyk */
+  {"kvd",	HB_TAG('K','U','I',' ')},	/* Kui (Indonesia) */
+  {"kxu",	HB_TAG('K','U','I',' ')},	/* Kui (India) */
+  {"ky",	HB_TAG('K','I','R',' ')},	/* Kirghiz */
+  {"la",	HB_TAG('L','A','T',' ')},	/* Latin */
+  {"lad",	HB_TAG('J','U','D',' ')},	/* Ladino */
+  {"lb",	HB_TAG('L','T','Z',' ')},	/* Luxembourgish */
+  {"lbe",	HB_TAG('L','A','K',' ')},	/* Lak */
+  {"lbj",	HB_TAG('L','D','K',' ')},	/* Ladakhi */
+  {"lif",	HB_TAG('L','M','B',' ')},	/* Limbu */
+  {"lld",	HB_TAG('L','A','D',' ')},	/* Ladin */
+  {"ln",	HB_TAG('L','I','N',' ')},	/* Lingala */
+  {"lo",	HB_TAG('L','A','O',' ')},	/* Lao */
+  {"lt",	HB_TAG('L','T','H',' ')},	/* Lithuanian */
+  {"luo",	HB_TAG('L','U','O',' ')},	/* Luo (Kenya and Tanzania) */
+  {"luw",	HB_TAG('L','U','O',' ')},	/* Luo (Cameroon) */
+  {"lv",	HB_TAG('L','V','I',' ')},	/* Latvian */
+  {"lzz",	HB_TAG('L','A','Z',' ')},	/* Laz */
+  {"mai",	HB_TAG('M','T','H',' ')},	/* Maithili */
+  {"mdc",	HB_TAG('M','L','E',' ')},	/* Male (Papua New Guinea) */
+  {"mdf",	HB_TAG('M','O','K',' ')},	/* Moksha */
+  {"mdy",	HB_TAG('M','L','E',' ')},	/* Male (Ethiopia) */
+  {"men",	HB_TAG('M','D','E',' ')},	/* Mende (Sierra Leone) */
+  {"mg",	HB_TAG('M','L','G',' ')},	/* Malagasy */
+  {"mi",	HB_TAG('M','R','I',' ')},	/* Maori */
+  {"mk",	HB_TAG('M','K','D',' ')},	/* Macedonian */
+  {"ml",	HB_TAG('M','L','R',' ')},	/* Malayalam */
+  {"mn",	HB_TAG('M','N','G',' ')},	/* Mongolian */
+  {"mnc",	HB_TAG('M','C','H',' ')},	/* Manchu */
+  {"mni",	HB_TAG('M','N','I',' ')},	/* Manipuri */
+  {"mnk",	HB_TAG('M','N','D',' ')},	/* Mandinka */
+  {"mns",	HB_TAG('M','A','N',' ')},	/* Mansi */
+  {"mnw",	HB_TAG('M','O','N',' ')},	/* Mon */
+  {"mo",	HB_TAG('M','O','L',' ')},	/* Moldavian */
+  {"moh",	HB_TAG('M','O','H',' ')},	/* Mohawk */
+  {"mpe",	HB_TAG('M','A','J',' ')},	/* Majang */
+  {"mr",	HB_TAG('M','A','R',' ')},	/* Marathi */
+  {"ms",	HB_TAG('M','L','Y',' ')},	/* Malay */
+  {"mt",	HB_TAG('M','T','S',' ')},	/* Maltese */
+  {"mwr",	HB_TAG('M','A','W',' ')},	/* Marwari */
+  {"my",	HB_TAG('B','R','M',' ')},	/* Burmese */
+  {"mym",	HB_TAG('M','E','N',' ')},	/* Me'en */
+  {"myv",	HB_TAG('E','R','Z',' ')},	/* Erzya */
+  {"nb",	HB_TAG('N','O','R',' ')},	/* Norwegian Bokml */
+  {"nco",	HB_TAG('S','I','B',' ')},	/* Sibe */
+  {"ne",	HB_TAG('N','E','P',' ')},	/* Nepali */
+  {"new",	HB_TAG('N','E','W',' ')},	/* Newari */
+  {"ng",	HB_TAG('N','D','G',' ')},	/* Ndonga */
+  {"ngl",	HB_TAG('L','M','W',' ')},	/* Lomwe */
+  {"niu",	HB_TAG('N','I','U',' ')},	/* Niuean */
+  {"niv",	HB_TAG('G','I','L',' ')},	/* Gilyak */
+  {"nl",	HB_TAG('N','L','D',' ')},	/* Dutch */
+  {"nn",	HB_TAG('N','Y','N',' ')},	/* Norwegian Nynorsk */
+  {"no",	HB_TAG('N','O','R',' ')},	/* Norwegian (deprecated) */
+  {"nog",	HB_TAG('N','O','G',' ')},	/* Nogai */
+  {"nqo",	HB_TAG('N','K','O',' ')},	/* N'Ko */
+  {"nsk",	HB_TAG('N','A','S',' ')},	/* Naskapi */
+  {"ny",	HB_TAG('C','H','I',' ')},	/* Nyanja */
+  {"oc",	HB_TAG('O','C','I',' ')},	/* Occitan (post 1500) */
+  {"oj",	HB_TAG('O','J','B',' ')},	/* Ojibwa */
+  {"om",	HB_TAG('O','R','O',' ')},	/* Oromo */
+  {"or",	HB_TAG('O','R','I',' ')},	/* Oriya */
+  {"os",	HB_TAG('O','S','S',' ')},	/* Ossetian */
+  {"pa",	HB_TAG('P','A','N',' ')},	/* Panjabi */
+  {"pi",	HB_TAG('P','A','L',' ')},	/* Pali */
+  {"pl",	HB_TAG('P','L','K',' ')},	/* Polish */
+  {"plp",	HB_TAG('P','A','P',' ')},	/* Palpa */
+  {"prs",	HB_TAG('D','R','I',' ')},	/* Dari */
+  {"ps",	HB_TAG('P','A','S',' ')},	/* Pushto */
+  {"pt",	HB_TAG('P','T','G',' ')},	/* Portuguese */
+  {"raj",	HB_TAG('R','A','J',' ')},	/* Rajasthani */
+  {"ria",	HB_TAG('R','I','A',' ')},	/* Riang (India) */
+  {"ril",	HB_TAG('R','I','A',' ')},	/* Riang (Myanmar) */
+  {"ro",	HB_TAG('R','O','M',' ')},	/* Romanian */
+  {"rom",	HB_TAG('R','O','Y',' ')},	/* Romany */
+  {"ru",	HB_TAG('R','U','S',' ')},	/* Russian */
+  {"rue",	HB_TAG('R','S','Y',' ')},	/* Rusyn */
+  {"sa",	HB_TAG('S','A','N',' ')},	/* Sanskrit */
+  {"sah",	HB_TAG('Y','A','K',' ')},	/* Yakut */
+  {"sat",	HB_TAG('S','A','T',' ')},	/* Santali */
+  {"sck",	HB_TAG('S','A','D',' ')},	/* Sadri */
+  {"sd",	HB_TAG('S','N','D',' ')},	/* Sindhi */
+  {"se",	HB_TAG('N','S','M',' ')},	/* Northern Sami */
+  {"seh",	HB_TAG('S','N','A',' ')},	/* Sena */
+  {"sel",	HB_TAG('S','E','L',' ')},	/* Selkup */
+  {"sg",	HB_TAG('S','G','O',' ')},	/* Sango */
+  {"shn",	HB_TAG('S','H','N',' ')},	/* Shan */
+  {"si",	HB_TAG('S','N','H',' ')},	/* Sinhala */
+  {"sid",	HB_TAG('S','I','D',' ')},	/* Sidamo */
+  {"sjd",	HB_TAG('K','S','M',' ')},	/* Kildin Sami */
+  {"sk",	HB_TAG('S','K','Y',' ')},	/* Slovak */
+  {"skr",	HB_TAG('S','R','K',' ')},	/* Seraiki */
+  {"sl",	HB_TAG('S','L','V',' ')},	/* Slovenian */
+  {"sm",	HB_TAG('S','M','O',' ')},	/* Samoan */
+  {"sma",	HB_TAG('S','S','M',' ')},	/* Southern Sami */
+  {"smj",	HB_TAG('L','S','M',' ')},	/* Lule Sami */
+  {"smn",	HB_TAG('I','S','M',' ')},	/* Inari Sami */
+  {"sms",	HB_TAG('S','K','S',' ')},	/* Skolt Sami */
+  {"snk",	HB_TAG('S','N','K',' ')},	/* Soninke */
+  {"so",	HB_TAG('S','M','L',' ')},	/* Somali */
+  {"sq",	HB_TAG('S','Q','I',' ')},	/* Albanian */
+  {"sr",	HB_TAG('S','R','B',' ')},	/* Serbian */
+  {"srr",	HB_TAG('S','R','R',' ')},	/* Serer */
+  {"suq",	HB_TAG('S','U','R',' ')},	/* Suri */
+  {"sv",	HB_TAG('S','V','E',' ')},	/* Swedish */
+  {"sva",	HB_TAG('S','V','A',' ')},	/* Svan */
+  {"sw",	HB_TAG('S','W','K',' ')},	/* Swahili */
+  {"swb",	HB_TAG('C','M','R',' ')},	/* Comorian */
+  {"syr",	HB_TAG('S','Y','R',' ')},	/* Syriac */
+  {"ta",	HB_TAG('T','A','M',' ')},	/* Tamil */
+  {"tcy",	HB_TAG('T','U','L',' ')},	/* Tulu */
+  {"te",	HB_TAG('T','E','L',' ')},	/* Telugu */
+  {"tg",	HB_TAG('T','A','J',' ')},	/* Tajik */
+  {"th",	HB_TAG('T','H','A',' ')},	/* Thai */
+  {"ti",	HB_TAG('T','G','Y',' ')},	/* Tigrinya */
+  {"tig",	HB_TAG('T','G','R',' ')},	/* Tigre */
+  {"tk",	HB_TAG('T','K','M',' ')},	/* Turkmen */
+  {"tn",	HB_TAG('T','N','A',' ')},	/* Tswana */
+  {"tnz",	HB_TAG('T','N','G',' ')},	/* Tonga (Thailand) */
+  {"to",	HB_TAG('T','N','G',' ')},	/* Tonga (Tonga Islands) */
+  {"tog",	HB_TAG('T','N','G',' ')},	/* Tonga (Nyasa) */
+  {"toi",	HB_TAG('T','N','G',' ')},	/* Tonga (Zambia) */
+  {"tr",	HB_TAG('T','R','K',' ')},	/* Turkish */
+  {"ts",	HB_TAG('T','S','G',' ')},	/* Tsonga */
+  {"tt",	HB_TAG('T','A','T',' ')},	/* Tatar */
+  {"tw",	HB_TAG('T','W','I',' ')},	/* Twi */
+  {"ty",	HB_TAG('T','H','T',' ')},	/* Tahitian */
+  {"udm",	HB_TAG('U','D','M',' ')},	/* Udmurt */
+  {"ug",	HB_TAG('U','Y','G',' ')},	/* Uighur */
+  {"uk",	HB_TAG('U','K','R',' ')},	/* Ukrainian */
+  {"unr",	HB_TAG('M','U','N',' ')},	/* Mundari */
+  {"ur",	HB_TAG('U','R','D',' ')},	/* Urdu */
+  {"uz",	HB_TAG('U','Z','B',' ')},	/* Uzbek */
+  {"ve",	HB_TAG('V','E','N',' ')},	/* Venda */
+  {"vi",	HB_TAG('V','I','T',' ')},	/* Vietnamese */
+  {"wbm",	HB_TAG('W','A',' ',' ')},	/* Wa */
+  {"wbr",	HB_TAG('W','A','G',' ')},	/* Wagdi */
+  {"wo",	HB_TAG('W','L','F',' ')},	/* Wolof */
+  {"xal",	HB_TAG('K','L','M',' ')},	/* Kalmyk */
+  {"xh",	HB_TAG('X','H','S',' ')},	/* Xhosa */
+  {"xom",	HB_TAG('K','M','O',' ')},	/* Komo (Sudan) */
+  {"xsl",	HB_TAG('S','S','L',' ')},	/* South Slavey */
+  {"yi",	HB_TAG('J','I','I',' ')},	/* Yiddish */
+  {"yo",	HB_TAG('Y','B','A',' ')},	/* Yoruba */
+  {"yso",	HB_TAG('N','I','S',' ')},	/* Nisi (China) */
+  {"zh-cn",	HB_TAG('Z','H','S',' ')},	/* Chinese (China) */
+  {"zh-hk",	HB_TAG('Z','H','H',' ')},	/* Chinese (Hong Kong) */
+  {"zh-mo",	HB_TAG('Z','H','T',' ')},	/* Chinese (Macao) */
+  {"zh-sg",	HB_TAG('Z','H','S',' ')},	/* Chinese (Singapore) */
+  {"zh-tw",	HB_TAG('Z','H','T',' ')},	/* Chinese (Taiwan) */
+  {"zne",	HB_TAG('Z','N','D',' ')},	/* Zande */
+  {"zu",	HB_TAG('Z','U','L',' ')} 	/* Zulu */
+
+  /* I couldn't find the language id for these */
+
+/*{"??",	HB_TAG('A','G','W',' ')},*/	/* Agaw */
+/*{"??",	HB_TAG('A','L','S',' ')},*/	/* Alsatian */
+/*{"??",	HB_TAG('A','L','T',' ')},*/	/* Altai */
+/*{"??",	HB_TAG('A','R','K',' ')},*/	/* Arakanese */
+/*{"??",	HB_TAG('A','T','H',' ')},*/	/* Athapaskan */
+/*{"??",	HB_TAG('B','A','G',' ')},*/	/* Baghelkhandi */
+/*{"??",	HB_TAG('B','A','L',' ')},*/	/* Balkar */
+/*{"??",	HB_TAG('B','A','U',' ')},*/	/* Baule */
+/*{"??",	HB_TAG('B','B','R',' ')},*/	/* Berber */
+/*{"??",	HB_TAG('B','C','R',' ')},*/	/* Bible Cree */
+/*{"??",	HB_TAG('B','E','L',' ')},*/	/* Belarussian */
+/*{"??",	HB_TAG('B','I','L',' ')},*/	/* Bilen */
+/*{"??",	HB_TAG('B','K','F',' ')},*/	/* Blackfoot */
+/*{"??",	HB_TAG('B','L','N',' ')},*/	/* Balante */
+/*{"??",	HB_TAG('B','M','L',' ')},*/	/* Bamileke */
+/*{"??",	HB_TAG('B','R','I',' ')},*/	/* Braj Bhasha */
+/*{"??",	HB_TAG('C','H','G',' ')},*/	/* Chaha Gurage */
+/*{"??",	HB_TAG('C','H','H',' ')},*/	/* Chattisgarhi */
+/*{"??",	HB_TAG('C','H','K',' ')},*/	/* Chukchi */
+/*{"??",	HB_TAG('D','J','R',' ')},*/	/* Djerma */
+/*{"??",	HB_TAG('D','N','G',' ')},*/	/* Dangme */
+/*{"??",	HB_TAG('E','C','R',' ')},*/	/* Eastern Cree */
+/*{"??",	HB_TAG('F','A','N',' ')},*/	/* French Antillean */
+/*{"??",	HB_TAG('F','L','E',' ')},*/	/* Flemish */
+/*{"??",	HB_TAG('F','N','E',' ')},*/	/* Forest Nenets */
+/*{"??",	HB_TAG('F','T','A',' ')},*/	/* Futa */
+/*{"??",	HB_TAG('G','A','R',' ')},*/	/* Garshuni */
+/*{"??",	HB_TAG('G','E','Z',' ')},*/	/* Ge'ez */
+/*{"??",	HB_TAG('H','A','L',' ')},*/	/* Halam */
+/*{"??",	HB_TAG('H','A','R',' ')},*/	/* Harauti */
+/*{"??",	HB_TAG('H','A','W',' ')},*/	/* Hawaiin */
+/*{"??",	HB_TAG('H','B','N',' ')},*/	/* Hammer-Banna */
+/*{"??",	HB_TAG('H','M','A',' ')},*/	/* High Mari */
+/*{"??",	HB_TAG('H','N','D',' ')},*/	/* Hindko */
+/*{"??",	HB_TAG('I','J','O',' ')},*/	/* Ijo */
+/*{"??",	HB_TAG('I','L','O',' ')},*/	/* Ilokano */
+/*{"??",	HB_TAG('I','R','T',' ')},*/	/* Irish Traditional */
+/*{"??",	HB_TAG('J','U','L',' ')},*/	/* Jula */
+/*{"??",	HB_TAG('K','A','R',' ')},*/	/* Karachay */
+/*{"??",	HB_TAG('K','E','B',' ')},*/	/* Kebena */
+/*{"??",	HB_TAG('K','G','E',' ')},*/	/* Khutsuri Georgian */
+/*{"??",	HB_TAG('K','H','A',' ')},*/	/* Khakass */
+/*{"??",	HB_TAG('K','H','K',' ')},*/	/* Khanty-Kazim */
+/*{"??",	HB_TAG('K','H','S',' ')},*/	/* Khanty-Shurishkar */
+/*{"??",	HB_TAG('K','H','V',' ')},*/	/* Khanty-Vakhi */
+/*{"??",	HB_TAG('K','I','S',' ')},*/	/* Kisii */
+/*{"??",	HB_TAG('K','K','N',' ')},*/	/* Kokni */
+/*{"??",	HB_TAG('K','M','S',' ')},*/	/* Komso */
+/*{"??",	HB_TAG('K','O','D',' ')},*/	/* Kodagu */
+/*{"??",	HB_TAG('K','O','H',' ')},*/	/* Korean Old Hangul */
+/*{"??",	HB_TAG('K','O','N',' ')},*/	/* Kikongo */
+/*{"??",	HB_TAG('K','R','K',' ')},*/	/* Karakalpak */
+/*{"??",	HB_TAG('K','R','N',' ')},*/	/* Karen */
+/*{"??",	HB_TAG('K','U','L',' ')},*/	/* Kulvi */
+/*{"??",	HB_TAG('L','A','H',' ')},*/	/* Lahuli */
+/*{"??",	HB_TAG('L','A','M',' ')},*/	/* Lambani */
+/*{"??",	HB_TAG('L','C','R',' ')},*/	/* L-Cree */
+/*{"??",	HB_TAG('L','E','Z',' ')},*/	/* Lezgi */
+/*{"??",	HB_TAG('L','M','A',' ')},*/	/* Low Mari */
+/*{"??",	HB_TAG('L','U','B',' ')},*/	/* Luba */
+/*{"??",	HB_TAG('L','U','G',' ')},*/	/* Luganda */
+/*{"??",	HB_TAG('L','U','H',' ')},*/	/* Luhya */
+/*{"??",	HB_TAG('M','A','K',' ')},*/	/* Makua */
+/*{"??",	HB_TAG('M','A','L',' ')},*/	/* Malayalam Traditional */
+/*{"??",	HB_TAG('M','B','N',' ')},*/	/* Mbundu */
+/*{"??",	HB_TAG('M','I','Z',' ')},*/	/* Mizo */
+/*{"??",	HB_TAG('M','L','N',' ')},*/	/* Malinke */
+/*{"??",	HB_TAG('M','N','K',' ')},*/	/* Maninka */
+/*{"??",	HB_TAG('M','O','R',' ')},*/	/* Moroccan */
+/*{"??",	HB_TAG('N','A','G',' ')},*/	/* Naga-Assamese */
+/*{"??",	HB_TAG('N','C','R',' ')},*/	/* N-Cree */
+/*{"??",	HB_TAG('N','D','B',' ')},*/	/* Ndebele */
+/*{"??",	HB_TAG('N','G','R',' ')},*/	/* Nagari */
+/*{"??",	HB_TAG('N','H','C',' ')},*/	/* Norway House Cree */
+/*{"??",	HB_TAG('N','K','L',' ')},*/	/* Nkole */
+/*{"??",	HB_TAG('N','T','A',' ')},*/	/* Northern Tai */
+/*{"??",	HB_TAG('O','C','R',' ')},*/	/* Oji-Cree */
+/*{"??",	HB_TAG('P','A','A',' ')},*/	/* Palestinian Aramaic */
+/*{"??",	HB_TAG('P','G','R',' ')},*/	/* Polytonic Greek */
+/*{"??",	HB_TAG('P','L','G',' ')},*/	/* Palaung */
+/*{"??",	HB_TAG('Q','I','N',' ')},*/	/* Chin */
+/*{"??",	HB_TAG('R','B','U',' ')},*/	/* Russian Buriat */
+/*{"??",	HB_TAG('R','C','R',' ')},*/	/* R-Cree */
+/*{"??",	HB_TAG('R','M','S',' ')},*/	/* Rhaeto-Romanic */
+/*{"??",	HB_TAG('R','U','A',' ')},*/	/* Ruanda */
+/*{"??",	HB_TAG('S','A','Y',' ')},*/	/* Sayisi */
+/*{"??",	HB_TAG('S','E','K',' ')},*/	/* Sekota */
+/*{"??",	HB_TAG('S','I','G',' ')},*/	/* Silte Gurage */
+/*{"??",	HB_TAG('S','L','A',' ')},*/	/* Slavey */
+/*{"??",	HB_TAG('S','O','G',' ')},*/	/* Sodo Gurage */
+/*{"??",	HB_TAG('S','O','T',' ')},*/	/* Sotho */
+/*{"??",	HB_TAG('S','W','A',' ')},*/	/* Swadaya Aramaic */
+/*{"??",	HB_TAG('S','W','Z',' ')},*/	/* Swazi */
+/*{"??",	HB_TAG('S','X','T',' ')},*/	/* Sutu */
+/*{"??",	HB_TAG('T','A','B',' ')},*/	/* Tabasaran */
+/*{"??",	HB_TAG('T','C','R',' ')},*/	/* TH-Cree */
+/*{"??",	HB_TAG('T','G','N',' ')},*/	/* Tongan */
+/*{"??",	HB_TAG('T','M','N',' ')},*/	/* Temne */
+/*{"??",	HB_TAG('T','N','E',' ')},*/	/* Tundra Nenets */
+/*{"??",	HB_TAG('T','O','D',' ')},*/	/* Todo */
+/*{"??",	HB_TAG('T','U','A',' ')},*/	/* Turoyo Aramaic */
+/*{"??",	HB_TAG('T','U','V',' ')},*/	/* Tuvin */
+/*{"??",	HB_TAG('W','C','R',' ')},*/	/* West-Cree */
+/*{"??",	HB_TAG('X','B','D',' ')},*/	/* Tai Lue */
+/*{"??",	HB_TAG('Y','C','R',' ')},*/	/* Y-Cree */
+/*{"??",	HB_TAG('Y','I','C',' ')},*/	/* Yi Classic */
+/*{"??",	HB_TAG('Y','I','M',' ')},*/	/* Yi Modern */
+/*{"??",	HB_TAG('Z','H','P',' ')},*/	/* Chinese Phonetic */
+};
+
+static int
+lang_compare_first_component (const char *a,
+			      const char *b)
+{
+  unsigned int da, db;
+  const char *p;
+
+  p = strstr (a, "-");
+  da = p ? (unsigned int) (p - a) : strlen (a);
+
+  p = strstr (b, "-");
+  db = p ? (unsigned int) (p - b) : strlen (b);
+
+  return strncmp (a, b, MAX (da, db));
+}
+
+static hb_bool_t
+lang_matches (const char *lang_str, const char *spec)
+{
+  unsigned int len = strlen (spec);
+
+  return lang_str && strncmp (lang_str, spec, len) == 0 &&
+	 (lang_str[len] == '\0' || lang_str[len] == '-');
+}
+
+hb_tag_t
+hb_ot_tag_from_language (hb_language_t language)
+{
+  const char *lang_str;
+  LangTag *lang_tag;
+
+  if (language == NULL)
+    return HB_OT_TAG_DEFAULT_LANGUAGE;
+
+  lang_str = hb_language_to_string (language);
+
+  if (0 == strcmp (lang_str, "x-hbot")) {
+    char tag[4];
+    int i;
+    lang_str += 6;
+#define IS_LETTER(c) (((c) >= 'a' && (c) <= 'z') || ((c) >= 'A' && (c) <= 'Z'))
+#define TO_UPPER(c) (((c) >= 'a' && (c) <= 'z') ? (c) + 'A' - 'a' : (c))
+    for (i = 0; i < 4 && IS_LETTER (lang_str[i]); i++)
+      tag[i] = TO_UPPER (lang_str[i]);
+    for (; i < 4; i++)
+      tag[i] = ' ';
+    return HB_TAG_STR (tag);
+  }
+
+  /* find a language matching in the first component */
+  lang_tag = bsearch (lang_str, ot_languages,
+		      ARRAY_LENGTH (ot_languages), sizeof (LangTag),
+		      (hb_compare_func_t) lang_compare_first_component);
+
+  /* we now need to find the best language matching */
+  if (lang_tag)
+  {
+    hb_bool_t found = FALSE;
+
+    /* go to the final one matching in the first component */
+    while (lang_tag + 1 < ot_languages + ARRAY_LENGTH (ot_languages) &&
+	   lang_compare_first_component (lang_str, (lang_tag + 1)->language) == 0)
+      lang_tag++;
+
+    /* go back, find which one matches completely */
+    while (lang_tag >= ot_languages &&
+	   lang_compare_first_component (lang_str, lang_tag->language) == 0)
+    {
+      if (lang_matches (lang_str, lang_tag->language)) {
+	found = TRUE;
+	break;
+      }
+
+      lang_tag--;
+    }
+
+    if (!found)
+      lang_tag = NULL;
+  }
+
+  if (lang_tag)
+    return lang_tag->tag;
+
+  return HB_OT_TAG_DEFAULT_LANGUAGE;
+}
+
+hb_language_t
+hb_ot_tag_to_language (hb_tag_t tag)
+{
+  unsigned int i;
+  unsigned char buf[11] = "x-hbot";
+
+  for (i = 0; i < ARRAY_LENGTH (ot_languages); i++)
+    if (ot_languages[i].tag == tag)
+      return hb_language_from_string (ot_languages[i].language);
+
+  buf[6] = tag >> 24;
+  buf[7] = (tag >> 16) & 0xFF;
+  buf[8] = (tag >> 8) & 0xFF;
+  buf[9] = tag & 0xFF;
+  buf[10] = '\0';
+  return hb_language_from_string ((char *) buf);
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,710 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+#include "hb-ot.h"
+
+#include <string.h>
+
+
+
+/* hb_script_t */
+
+static hb_tag_t
+hb_ot_old_tag_from_script (hb_script_t script)
+{
+  switch ((hb_tag_t) script) {
+    case HB_SCRIPT_INVALID:		return HB_OT_TAG_DEFAULT_SCRIPT;
+
+    /* KATAKANA and HIRAGANA both map to 'kana' */
+    case HB_SCRIPT_HIRAGANA:		return HB_TAG('k','a','n','a');
+
+    /* Spaces at the end are preserved, unlike ISO 15924 */
+    case HB_SCRIPT_LAO:			return HB_TAG('l','a','o',' ');
+    case HB_SCRIPT_YI:			return HB_TAG('y','i',' ',' ');
+    /* Unicode-5.0 additions */
+    case HB_SCRIPT_NKO:			return HB_TAG('n','k','o',' ');
+    /* Unicode-5.1 additions */
+    case HB_SCRIPT_VAI:			return HB_TAG('v','a','i',' ');
+    /* Unicode-5.2 additions */
+    /* Unicode-6.0 additions */
+  }
+
+  /* Else, just change first char to lowercase and return */
+  return ((hb_tag_t) script) | 0x20000000;
+}
+
+static hb_script_t
+hb_ot_old_tag_to_script (hb_tag_t tag)
+{
+  if (unlikely (tag == HB_OT_TAG_DEFAULT_SCRIPT))
+    return HB_SCRIPT_INVALID;
+
+  /* This side of the conversion is fully algorithmic. */
+
+  /* Any spaces at the end of the tag are replaced by repeating the last
+   * letter.  Eg 'nko ' -> 'Nkoo' */
+  if (unlikely ((tag & 0x0000FF00) == 0x00002000))
+    tag |= (tag >> 8) & 0x0000FF00; /* Copy second letter to third */
+  if (unlikely ((tag & 0x000000FF) == 0x00000020))
+    tag |= (tag >> 8) & 0x000000FF; /* Copy third letter to fourth */
+
+  /* Change first char to uppercase and return */
+  return (hb_script_t) (tag & ~0x20000000);
+}
+
+static hb_tag_t
+hb_ot_new_tag_from_script (hb_script_t script)
+{
+  switch ((hb_tag_t) script) {
+    case HB_SCRIPT_BENGALI:		return HB_TAG('b','n','g','2');
+    case HB_SCRIPT_DEVANAGARI:		return HB_TAG('d','e','v','2');
+    case HB_SCRIPT_GUJARATI:		return HB_TAG('g','j','r','2');
+    case HB_SCRIPT_GURMUKHI:		return HB_TAG('g','u','r','2');
+    case HB_SCRIPT_KANNADA:		return HB_TAG('k','n','d','2');
+    case HB_SCRIPT_MALAYALAM:		return HB_TAG('m','l','m','2');
+    case HB_SCRIPT_ORIYA:		return HB_TAG('o','r','y','2');
+    case HB_SCRIPT_TAMIL:		return HB_TAG('t','m','l','2');
+    case HB_SCRIPT_TELUGU:		return HB_TAG('t','e','l','2');
+  }
+
+  return HB_OT_TAG_DEFAULT_SCRIPT;
+}
+
+static hb_script_t
+hb_ot_new_tag_to_script (hb_tag_t tag)
+{
+  switch (tag) {
+    case HB_TAG('b','n','g','2'):	return HB_SCRIPT_BENGALI;
+    case HB_TAG('d','e','v','2'):	return HB_SCRIPT_DEVANAGARI;
+    case HB_TAG('g','j','r','2'):	return HB_SCRIPT_GUJARATI;
+    case HB_TAG('g','u','r','2'):	return HB_SCRIPT_GURMUKHI;
+    case HB_TAG('k','n','d','2'):	return HB_SCRIPT_KANNADA;
+    case HB_TAG('m','l','m','2'):	return HB_SCRIPT_MALAYALAM;
+    case HB_TAG('o','r','y','2'):	return HB_SCRIPT_ORIYA;
+    case HB_TAG('t','m','l','2'):	return HB_SCRIPT_TAMIL;
+    case HB_TAG('t','e','l','2'):	return HB_SCRIPT_TELUGU;
+  }
+
+  return HB_SCRIPT_UNKNOWN;
+}
+
+/*
+ * Complete list at:
+ * https://www.microsoft.com/typography/otspec/scripttags.htm
+ * https://www.microsoft.com/typography/otspec160/scripttagsProposed.htm
+ *
+ * Most of the script tags are the same as the ISO 15924 tag but lowercased.
+ * So we just do that, and handle the exceptional cases in a switch.
+ */
+
+void
+hb_ot_tags_from_script (hb_script_t  script,
+			hb_tag_t    *script_tag_1,
+			hb_tag_t    *script_tag_2)
+{
+  hb_tag_t new_tag;
+
+  *script_tag_2 = HB_OT_TAG_DEFAULT_SCRIPT;
+  *script_tag_1 = hb_ot_old_tag_from_script (script);
+
+  new_tag = hb_ot_new_tag_from_script (script);
+  if (unlikely (new_tag != HB_OT_TAG_DEFAULT_SCRIPT)) {
+    *script_tag_2 = *script_tag_1;
+    *script_tag_1 = new_tag;
+  }
+}
+
+hb_script_t
+hb_ot_tag_to_script (hb_tag_t tag)
+{
+  if (unlikely ((tag & 0x000000FF) == '2'))
+    return hb_ot_new_tag_to_script (tag);
+
+  return hb_ot_old_tag_to_script (tag);
+}
+
+
+/* hb_language_t */
+
+typedef struct {
+  char language[6];
+  hb_tag_t tag;
+} LangTag;
+
+/*
+ * Complete list at:
+ * http://www.microsoft.com/typography/otspec/languagetags.htm
+ *
+ * Generated by intersecting the OpenType language tag list from
+ * Draft OpenType 1.5 spec, with with the ISO 639-3 codes from
+ * 2008/08/04, matching on name, and finally adjusted manually.
+ *
+ * Many items still missing.  Those are commented out at the end.
+ * Keep sorted for bsearch.
+ */
+
+static const LangTag ot_languages[] = {
+  {"aa",	HB_TAG('A','F','R',' ')},	/* Afar */
+  {"ab",	HB_TAG('A','B','K',' ')},	/* Abkhazian */
+  {"abq",	HB_TAG('A','B','A',' ')},	/* Abaza */
+  {"ady",	HB_TAG('A','D','Y',' ')},	/* Adyghe */
+  {"af",	HB_TAG('A','F','K',' ')},	/* Afrikaans */
+  {"aiw",	HB_TAG('A','R','I',' ')},	/* Aari */
+  {"am",	HB_TAG('A','M','H',' ')},	/* Amharic */
+  {"ar",	HB_TAG('A','R','A',' ')},	/* Arabic */
+  {"arn",	HB_TAG('M','A','P',' ')},	/* Mapudungun */
+  {"as",	HB_TAG('A','S','M',' ')},	/* Assamese */
+  {"av",	HB_TAG('A','V','R',' ')},	/* Avaric */
+  {"awa",	HB_TAG('A','W','A',' ')},	/* Awadhi */
+  {"ay",	HB_TAG('A','Y','M',' ')},	/* Aymara */
+  {"az",	HB_TAG('A','Z','E',' ')},	/* Azerbaijani */
+  {"ba",	HB_TAG('B','S','H',' ')},	/* Bashkir */
+  {"bal",	HB_TAG('B','L','I',' ')},	/* Baluchi */
+  {"bcq",	HB_TAG('B','C','H',' ')},	/* Bench */
+  {"bem",	HB_TAG('B','E','M',' ')},	/* Bemba (Zambia) */
+  {"bfq",	HB_TAG('B','A','D',' ')},	/* Badaga */
+  {"bft",	HB_TAG('B','L','T',' ')},	/* Balti */
+  {"bg",	HB_TAG('B','G','R',' ')},	/* Bulgarian */
+  {"bhb",	HB_TAG('B','H','I',' ')},	/* Bhili */
+  {"bho",	HB_TAG('B','H','O',' ')},	/* Bhojpuri */
+  {"bik",	HB_TAG('B','I','K',' ')},	/* Bikol */
+  {"bin",	HB_TAG('E','D','O',' ')},	/* Bini */
+  {"bm",	HB_TAG('B','M','B',' ')},	/* Bambara */
+  {"bn",	HB_TAG('B','E','N',' ')},	/* Bengali */
+  {"bo",	HB_TAG('T','I','B',' ')},	/* Tibetan */
+  {"br",	HB_TAG('B','R','E',' ')},	/* Breton */
+  {"brh",	HB_TAG('B','R','H',' ')},	/* Brahui */
+  {"bs",	HB_TAG('B','O','S',' ')},	/* Bosnian */
+  {"btb",	HB_TAG('B','T','I',' ')},	/* Beti (Cameroon) */
+  {"ca",	HB_TAG('C','A','T',' ')},	/* Catalan */
+  {"ce",	HB_TAG('C','H','E',' ')},	/* Chechen */
+  {"ceb",	HB_TAG('C','E','B',' ')},	/* Cebuano */
+  {"chp",	HB_TAG('C','H','P',' ')},	/* Chipewyan */
+  {"chr",	HB_TAG('C','H','R',' ')},	/* Cherokee */
+  {"cop",	HB_TAG('C','O','P',' ')},	/* Coptic */
+  {"cr",	HB_TAG('C','R','E',' ')},	/* Cree */
+  {"crh",	HB_TAG('C','R','T',' ')},	/* Crimean Tatar */
+  {"crm",	HB_TAG('M','C','R',' ')},	/* Moose Cree */
+  {"crx",	HB_TAG('C','R','R',' ')},	/* Carrier */
+  {"cs",	HB_TAG('C','S','Y',' ')},	/* Czech */
+  {"cu",	HB_TAG('C','S','L',' ')},	/* Church Slavic */
+  {"cv",	HB_TAG('C','H','U',' ')},	/* Chuvash */
+  {"cwd",	HB_TAG('D','C','R',' ')},	/* Woods Cree */
+  {"cy",	HB_TAG('W','E','L',' ')},	/* Welsh */
+  {"da",	HB_TAG('D','A','N',' ')},	/* Danish */
+  {"dap",	HB_TAG('N','I','S',' ')},	/* Nisi (India) */
+  {"dar",	HB_TAG('D','A','R',' ')},	/* Dargwa */
+  {"de",	HB_TAG('D','E','U',' ')},	/* German */
+  {"din",	HB_TAG('D','N','K',' ')},	/* Dinka */
+  {"dng",	HB_TAG('D','U','N',' ')},	/* Dungan */
+  {"doi",	HB_TAG('D','G','R',' ')},	/* Dogri */
+  {"dsb",	HB_TAG('L','S','B',' ')},	/* Lower Sorbian */
+  {"dv",	HB_TAG('D','I','V',' ')},	/* Dhivehi */
+  {"dz",	HB_TAG('D','Z','N',' ')},	/* Dzongkha */
+  {"ee",	HB_TAG('E','W','E',' ')},	/* Ewe */
+  {"efi",	HB_TAG('E','F','I',' ')},	/* Efik */
+  {"el",	HB_TAG('E','L','L',' ')},	/* Modern Greek (1453-) */
+  {"en",	HB_TAG('E','N','G',' ')},	/* English */
+  {"eo",	HB_TAG('N','T','O',' ')},	/* Esperanto */
+  {"eot",	HB_TAG('B','T','I',' ')},	/* Beti (Cte d'Ivoire) */
+  {"es",	HB_TAG('E','S','P',' ')},	/* Spanish */
+  {"et",	HB_TAG('E','T','I',' ')},	/* Estonian */
+  {"eu",	HB_TAG('E','U','Q',' ')},	/* Basque */
+  {"eve",	HB_TAG('E','V','N',' ')},	/* Even */
+  {"evn",	HB_TAG('E','V','K',' ')},	/* Evenki */
+  {"fa",	HB_TAG('F','A','R',' ')},	/* Persian */
+  {"ff",	HB_TAG('F','U','L',' ')},	/* Fulah */
+  {"fi",	HB_TAG('F','I','N',' ')},	/* Finnish */
+  {"fil",	HB_TAG('P','I','L',' ')},	/* Filipino */
+  {"fj",	HB_TAG('F','J','I',' ')},	/* Fijian */
+  {"fo",	HB_TAG('F','O','S',' ')},	/* Faroese */
+  {"fon",	HB_TAG('F','O','N',' ')},	/* Fon */
+  {"fr",	HB_TAG('F','R','A',' ')},	/* French */
+  {"fur",	HB_TAG('F','R','L',' ')},	/* Friulian */
+  {"fy",	HB_TAG('F','R','I',' ')},	/* Western Frisian */
+  {"ga",	HB_TAG('I','R','I',' ')},	/* Irish */
+  {"gaa",	HB_TAG('G','A','D',' ')},	/* Ga */
+  {"gag",	HB_TAG('G','A','G',' ')},	/* Gagauz */
+  {"gbm",	HB_TAG('G','A','W',' ')},	/* Garhwali */
+  {"gd",	HB_TAG('G','A','E',' ')},	/* Scottish Gaelic */
+  {"gl",	HB_TAG('G','A','L',' ')},	/* Galician */
+  {"gld",	HB_TAG('N','A','N',' ')},	/* Nanai */
+  {"gn",	HB_TAG('G','U','A',' ')},	/* Guarani */
+  {"gon",	HB_TAG('G','O','N',' ')},	/* Gondi */
+  {"grt",	HB_TAG('G','R','O',' ')},	/* Garo */
+  {"gu",	HB_TAG('G','U','J',' ')},	/* Gujarati */
+  {"guk",	HB_TAG('G','M','Z',' ')},	/* Gumuz */
+  {"gv",	HB_TAG('M','N','X',' ')},	/* Manx Gaelic */
+  {"ha",	HB_TAG('H','A','U',' ')},	/* Hausa */
+  {"har",	HB_TAG('H','R','I',' ')},	/* Harari */
+  {"he",	HB_TAG('I','W','R',' ')},	/* Hebrew */
+  {"hi",	HB_TAG('H','I','N',' ')},	/* Hindi */
+  {"hil",	HB_TAG('H','I','L',' ')},	/* Hiligaynon */
+  {"hoc",	HB_TAG('H','O',' ',' ')},	/* Ho */
+  {"hr",	HB_TAG('H','R','V',' ')},	/* Croatian */
+  {"hsb",	HB_TAG('U','S','B',' ')},	/* Upper Sorbian */
+  {"ht",	HB_TAG('H','A','I',' ')},	/* Haitian */
+  {"hu",	HB_TAG('H','U','N',' ')},	/* Hungarian */
+  {"hy",	HB_TAG('H','Y','E',' ')},	/* Armenian */
+  {"id",	HB_TAG('I','N','D',' ')},	/* Indonesian */
+  {"ig",	HB_TAG('I','B','O',' ')},	/* Igbo */
+  {"igb",	HB_TAG('E','B','I',' ')},	/* Ebira */
+  {"inh",	HB_TAG('I','N','G',' ')},	/* Ingush */
+  {"is",	HB_TAG('I','S','L',' ')},	/* Icelandic */
+  {"it",	HB_TAG('I','T','A',' ')},	/* Italian */
+  {"iu",	HB_TAG('I','N','U',' ')},	/* Inuktitut */
+  {"ja",	HB_TAG('J','A','N',' ')},	/* Japanese */
+  {"jv",	HB_TAG('J','A','V',' ')},	/* Javanese */
+  {"ka",	HB_TAG('K','A','T',' ')},	/* Georgian */
+  {"kam",	HB_TAG('K','M','B',' ')},	/* Kamba (Kenya) */
+  {"kbd",	HB_TAG('K','A','B',' ')},	/* Kabardian */
+  {"kdr",	HB_TAG('K','R','M',' ')},	/* Karaim */
+  {"kdt",	HB_TAG('K','U','Y',' ')},	/* Kuy */
+  {"kfr",	HB_TAG('K','A','C',' ')},	/* Kachchi */
+  {"kfy",	HB_TAG('K','M','N',' ')},	/* Kumaoni */
+  {"kha",	HB_TAG('K','S','I',' ')},	/* Khasi */
+  {"khw",	HB_TAG('K','H','W',' ')},	/* Khowar */
+  {"ki",	HB_TAG('K','I','K',' ')},	/* Kikuyu */
+  {"kk",	HB_TAG('K','A','Z',' ')},	/* Kazakh */
+  {"kl",	HB_TAG('G','R','N',' ')},	/* Kalaallisut */
+  {"kln",	HB_TAG('K','A','L',' ')},	/* Kalenjin */
+  {"km",	HB_TAG('K','H','M',' ')},	/* Central Khmer */
+  {"kmw",	HB_TAG('K','M','O',' ')},	/* Komo (Democratic Republic of Congo) */
+  {"kn",	HB_TAG('K','A','N',' ')},	/* Kannada */
+  {"ko",	HB_TAG('K','O','R',' ')},	/* Korean */
+  {"koi",	HB_TAG('K','O','P',' ')},	/* Komi-Permyak */
+  {"kok",	HB_TAG('K','O','K',' ')},	/* Konkani */
+  {"kpe",	HB_TAG('K','P','L',' ')},	/* Kpelle */
+  {"kpv",	HB_TAG('K','O','Z',' ')},	/* Komi-Zyrian */
+  {"kpy",	HB_TAG('K','Y','K',' ')},	/* Koryak */
+  {"kqy",	HB_TAG('K','R','T',' ')},	/* Koorete */
+  {"kr",	HB_TAG('K','N','R',' ')},	/* Kanuri */
+  {"kri",	HB_TAG('K','R','I',' ')},	/* Krio */
+  {"krl",	HB_TAG('K','R','L',' ')},	/* Karelian */
+  {"kru",	HB_TAG('K','U','U',' ')},	/* Kurukh */
+  {"ks",	HB_TAG('K','S','H',' ')},	/* Kashmiri */
+  {"ku",	HB_TAG('K','U','R',' ')},	/* Kurdish */
+  {"kum",	HB_TAG('K','U','M',' ')},	/* Kumyk */
+  {"kvd",	HB_TAG('K','U','I',' ')},	/* Kui (Indonesia) */
+  {"kxu",	HB_TAG('K','U','I',' ')},	/* Kui (India) */
+  {"ky",	HB_TAG('K','I','R',' ')},	/* Kirghiz */
+  {"la",	HB_TAG('L','A','T',' ')},	/* Latin */
+  {"lad",	HB_TAG('J','U','D',' ')},	/* Ladino */
+  {"lb",	HB_TAG('L','T','Z',' ')},	/* Luxembourgish */
+  {"lbe",	HB_TAG('L','A','K',' ')},	/* Lak */
+  {"lbj",	HB_TAG('L','D','K',' ')},	/* Ladakhi */
+  {"lif",	HB_TAG('L','M','B',' ')},	/* Limbu */
+  {"lld",	HB_TAG('L','A','D',' ')},	/* Ladin */
+  {"ln",	HB_TAG('L','I','N',' ')},	/* Lingala */
+  {"lo",	HB_TAG('L','A','O',' ')},	/* Lao */
+  {"lt",	HB_TAG('L','T','H',' ')},	/* Lithuanian */
+  {"luo",	HB_TAG('L','U','O',' ')},	/* Luo (Kenya and Tanzania) */
+  {"luw",	HB_TAG('L','U','O',' ')},	/* Luo (Cameroon) */
+  {"lv",	HB_TAG('L','V','I',' ')},	/* Latvian */
+  {"lzz",	HB_TAG('L','A','Z',' ')},	/* Laz */
+  {"mai",	HB_TAG('M','T','H',' ')},	/* Maithili */
+  {"mdc",	HB_TAG('M','L','E',' ')},	/* Male (Papua New Guinea) */
+  {"mdf",	HB_TAG('M','O','K',' ')},	/* Moksha */
+  {"mdy",	HB_TAG('M','L','E',' ')},	/* Male (Ethiopia) */
+  {"men",	HB_TAG('M','D','E',' ')},	/* Mende (Sierra Leone) */
+  {"mg",	HB_TAG('M','L','G',' ')},	/* Malagasy */
+  {"mi",	HB_TAG('M','R','I',' ')},	/* Maori */
+  {"mk",	HB_TAG('M','K','D',' ')},	/* Macedonian */
+  {"ml",	HB_TAG('M','L','R',' ')},	/* Malayalam */
+  {"mn",	HB_TAG('M','N','G',' ')},	/* Mongolian */
+  {"mnc",	HB_TAG('M','C','H',' ')},	/* Manchu */
+  {"mni",	HB_TAG('M','N','I',' ')},	/* Manipuri */
+  {"mnk",	HB_TAG('M','N','D',' ')},	/* Mandinka */
+  {"mns",	HB_TAG('M','A','N',' ')},	/* Mansi */
+  {"mnw",	HB_TAG('M','O','N',' ')},	/* Mon */
+  {"mo",	HB_TAG('M','O','L',' ')},	/* Moldavian */
+  {"moh",	HB_TAG('M','O','H',' ')},	/* Mohawk */
+  {"mpe",	HB_TAG('M','A','J',' ')},	/* Majang */
+  {"mr",	HB_TAG('M','A','R',' ')},	/* Marathi */
+  {"ms",	HB_TAG('M','L','Y',' ')},	/* Malay */
+  {"mt",	HB_TAG('M','T','S',' ')},	/* Maltese */
+  {"mwr",	HB_TAG('M','A','W',' ')},	/* Marwari */
+  {"my",	HB_TAG('B','R','M',' ')},	/* Burmese */
+  {"mym",	HB_TAG('M','E','N',' ')},	/* Me'en */
+  {"myv",	HB_TAG('E','R','Z',' ')},	/* Erzya */
+  {"nb",	HB_TAG('N','O','R',' ')},	/* Norwegian Bokml */
+  {"nco",	HB_TAG('S','I','B',' ')},	/* Sibe */
+  {"ne",	HB_TAG('N','E','P',' ')},	/* Nepali */
+  {"new",	HB_TAG('N','E','W',' ')},	/* Newari */
+  {"ng",	HB_TAG('N','D','G',' ')},	/* Ndonga */
+  {"ngl",	HB_TAG('L','M','W',' ')},	/* Lomwe */
+  {"niu",	HB_TAG('N','I','U',' ')},	/* Niuean */
+  {"niv",	HB_TAG('G','I','L',' ')},	/* Gilyak */
+  {"nl",	HB_TAG('N','L','D',' ')},	/* Dutch */
+  {"nn",	HB_TAG('N','Y','N',' ')},	/* Norwegian Nynorsk */
+  {"no",	HB_TAG('N','O','R',' ')},	/* Norwegian (deprecated) */
+  {"nog",	HB_TAG('N','O','G',' ')},	/* Nogai */
+  {"nqo",	HB_TAG('N','K','O',' ')},	/* N'Ko */
+  {"nsk",	HB_TAG('N','A','S',' ')},	/* Naskapi */
+  {"ny",	HB_TAG('C','H','I',' ')},	/* Nyanja */
+  {"oc",	HB_TAG('O','C','I',' ')},	/* Occitan (post 1500) */
+  {"oj",	HB_TAG('O','J','B',' ')},	/* Ojibwa */
+  {"om",	HB_TAG('O','R','O',' ')},	/* Oromo */
+  {"or",	HB_TAG('O','R','I',' ')},	/* Oriya */
+  {"os",	HB_TAG('O','S','S',' ')},	/* Ossetian */
+  {"pa",	HB_TAG('P','A','N',' ')},	/* Panjabi */
+  {"pi",	HB_TAG('P','A','L',' ')},	/* Pali */
+  {"pl",	HB_TAG('P','L','K',' ')},	/* Polish */
+  {"plp",	HB_TAG('P','A','P',' ')},	/* Palpa */
+  {"prs",	HB_TAG('D','R','I',' ')},	/* Dari */
+  {"ps",	HB_TAG('P','A','S',' ')},	/* Pushto */
+  {"pt",	HB_TAG('P','T','G',' ')},	/* Portuguese */
+  {"raj",	HB_TAG('R','A','J',' ')},	/* Rajasthani */
+  {"ria",	HB_TAG('R','I','A',' ')},	/* Riang (India) */
+  {"ril",	HB_TAG('R','I','A',' ')},	/* Riang (Myanmar) */
+  {"ro",	HB_TAG('R','O','M',' ')},	/* Romanian */
+  {"rom",	HB_TAG('R','O','Y',' ')},	/* Romany */
+  {"ru",	HB_TAG('R','U','S',' ')},	/* Russian */
+  {"rue",	HB_TAG('R','S','Y',' ')},	/* Rusyn */
+  {"sa",	HB_TAG('S','A','N',' ')},	/* Sanskrit */
+  {"sah",	HB_TAG('Y','A','K',' ')},	/* Yakut */
+  {"sat",	HB_TAG('S','A','T',' ')},	/* Santali */
+  {"sck",	HB_TAG('S','A','D',' ')},	/* Sadri */
+  {"sd",	HB_TAG('S','N','D',' ')},	/* Sindhi */
+  {"se",	HB_TAG('N','S','M',' ')},	/* Northern Sami */
+  {"seh",	HB_TAG('S','N','A',' ')},	/* Sena */
+  {"sel",	HB_TAG('S','E','L',' ')},	/* Selkup */
+  {"sg",	HB_TAG('S','G','O',' ')},	/* Sango */
+  {"shn",	HB_TAG('S','H','N',' ')},	/* Shan */
+  {"si",	HB_TAG('S','N','H',' ')},	/* Sinhala */
+  {"sid",	HB_TAG('S','I','D',' ')},	/* Sidamo */
+  {"sjd",	HB_TAG('K','S','M',' ')},	/* Kildin Sami */
+  {"sk",	HB_TAG('S','K','Y',' ')},	/* Slovak */
+  {"skr",	HB_TAG('S','R','K',' ')},	/* Seraiki */
+  {"sl",	HB_TAG('S','L','V',' ')},	/* Slovenian */
+  {"sm",	HB_TAG('S','M','O',' ')},	/* Samoan */
+  {"sma",	HB_TAG('S','S','M',' ')},	/* Southern Sami */
+  {"smj",	HB_TAG('L','S','M',' ')},	/* Lule Sami */
+  {"smn",	HB_TAG('I','S','M',' ')},	/* Inari Sami */
+  {"sms",	HB_TAG('S','K','S',' ')},	/* Skolt Sami */
+  {"snk",	HB_TAG('S','N','K',' ')},	/* Soninke */
+  {"so",	HB_TAG('S','M','L',' ')},	/* Somali */
+  {"sq",	HB_TAG('S','Q','I',' ')},	/* Albanian */
+  {"sr",	HB_TAG('S','R','B',' ')},	/* Serbian */
+  {"srr",	HB_TAG('S','R','R',' ')},	/* Serer */
+  {"suq",	HB_TAG('S','U','R',' ')},	/* Suri */
+  {"sv",	HB_TAG('S','V','E',' ')},	/* Swedish */
+  {"sva",	HB_TAG('S','V','A',' ')},	/* Svan */
+  {"sw",	HB_TAG('S','W','K',' ')},	/* Swahili */
+  {"swb",	HB_TAG('C','M','R',' ')},	/* Comorian */
+  {"syr",	HB_TAG('S','Y','R',' ')},	/* Syriac */
+  {"ta",	HB_TAG('T','A','M',' ')},	/* Tamil */
+  {"tcy",	HB_TAG('T','U','L',' ')},	/* Tulu */
+  {"te",	HB_TAG('T','E','L',' ')},	/* Telugu */
+  {"tg",	HB_TAG('T','A','J',' ')},	/* Tajik */
+  {"th",	HB_TAG('T','H','A',' ')},	/* Thai */
+  {"ti",	HB_TAG('T','G','Y',' ')},	/* Tigrinya */
+  {"tig",	HB_TAG('T','G','R',' ')},	/* Tigre */
+  {"tk",	HB_TAG('T','K','M',' ')},	/* Turkmen */
+  {"tn",	HB_TAG('T','N','A',' ')},	/* Tswana */
+  {"tnz",	HB_TAG('T','N','G',' ')},	/* Tonga (Thailand) */
+  {"to",	HB_TAG('T','N','G',' ')},	/* Tonga (Tonga Islands) */
+  {"tog",	HB_TAG('T','N','G',' ')},	/* Tonga (Nyasa) */
+  {"toi",	HB_TAG('T','N','G',' ')},	/* Tonga (Zambia) */
+  {"tr",	HB_TAG('T','R','K',' ')},	/* Turkish */
+  {"ts",	HB_TAG('T','S','G',' ')},	/* Tsonga */
+  {"tt",	HB_TAG('T','A','T',' ')},	/* Tatar */
+  {"tw",	HB_TAG('T','W','I',' ')},	/* Twi */
+  {"ty",	HB_TAG('T','H','T',' ')},	/* Tahitian */
+  {"udm",	HB_TAG('U','D','M',' ')},	/* Udmurt */
+  {"ug",	HB_TAG('U','Y','G',' ')},	/* Uighur */
+  {"uk",	HB_TAG('U','K','R',' ')},	/* Ukrainian */
+  {"unr",	HB_TAG('M','U','N',' ')},	/* Mundari */
+  {"ur",	HB_TAG('U','R','D',' ')},	/* Urdu */
+  {"uz",	HB_TAG('U','Z','B',' ')},	/* Uzbek */
+  {"ve",	HB_TAG('V','E','N',' ')},	/* Venda */
+  {"vi",	HB_TAG('V','I','T',' ')},	/* Vietnamese */
+  {"wbm",	HB_TAG('W','A',' ',' ')},	/* Wa */
+  {"wbr",	HB_TAG('W','A','G',' ')},	/* Wagdi */
+  {"wo",	HB_TAG('W','L','F',' ')},	/* Wolof */
+  {"xal",	HB_TAG('K','L','M',' ')},	/* Kalmyk */
+  {"xh",	HB_TAG('X','H','S',' ')},	/* Xhosa */
+  {"xom",	HB_TAG('K','M','O',' ')},	/* Komo (Sudan) */
+  {"xsl",	HB_TAG('S','S','L',' ')},	/* South Slavey */
+  {"yi",	HB_TAG('J','I','I',' ')},	/* Yiddish */
+  {"yo",	HB_TAG('Y','B','A',' ')},	/* Yoruba */
+  {"yso",	HB_TAG('N','I','S',' ')},	/* Nisi (China) */
+  {"zne",	HB_TAG('Z','N','D',' ')},	/* Zande */
+  {"zu",	HB_TAG('Z','U','L',' ')} 	/* Zulu */
+
+  /* I couldn't find the language id for these */
+
+/*{"??",	HB_TAG('A','G','W',' ')},*/	/* Agaw */
+/*{"??",	HB_TAG('A','L','S',' ')},*/	/* Alsatian */
+/*{"??",	HB_TAG('A','L','T',' ')},*/	/* Altai */
+/*{"??",	HB_TAG('A','R','K',' ')},*/	/* Arakanese */
+/*{"??",	HB_TAG('A','T','H',' ')},*/	/* Athapaskan */
+/*{"??",	HB_TAG('B','A','G',' ')},*/	/* Baghelkhandi */
+/*{"??",	HB_TAG('B','A','L',' ')},*/	/* Balkar */
+/*{"??",	HB_TAG('B','A','U',' ')},*/	/* Baule */
+/*{"??",	HB_TAG('B','B','R',' ')},*/	/* Berber */
+/*{"??",	HB_TAG('B','C','R',' ')},*/	/* Bible Cree */
+/*{"??",	HB_TAG('B','E','L',' ')},*/	/* Belarussian */
+/*{"??",	HB_TAG('B','I','L',' ')},*/	/* Bilen */
+/*{"??",	HB_TAG('B','K','F',' ')},*/	/* Blackfoot */
+/*{"??",	HB_TAG('B','L','N',' ')},*/	/* Balante */
+/*{"??",	HB_TAG('B','M','L',' ')},*/	/* Bamileke */
+/*{"??",	HB_TAG('B','R','I',' ')},*/	/* Braj Bhasha */
+/*{"??",	HB_TAG('C','H','G',' ')},*/	/* Chaha Gurage */
+/*{"??",	HB_TAG('C','H','H',' ')},*/	/* Chattisgarhi */
+/*{"??",	HB_TAG('C','H','K',' ')},*/	/* Chukchi */
+/*{"??",	HB_TAG('D','J','R',' ')},*/	/* Djerma */
+/*{"??",	HB_TAG('D','N','G',' ')},*/	/* Dangme */
+/*{"??",	HB_TAG('E','C','R',' ')},*/	/* Eastern Cree */
+/*{"??",	HB_TAG('F','A','N',' ')},*/	/* French Antillean */
+/*{"??",	HB_TAG('F','L','E',' ')},*/	/* Flemish */
+/*{"??",	HB_TAG('F','N','E',' ')},*/	/* Forest Nenets */
+/*{"??",	HB_TAG('F','T','A',' ')},*/	/* Futa */
+/*{"??",	HB_TAG('G','A','R',' ')},*/	/* Garshuni */
+/*{"??",	HB_TAG('G','E','Z',' ')},*/	/* Ge'ez */
+/*{"??",	HB_TAG('H','A','L',' ')},*/	/* Halam */
+/*{"??",	HB_TAG('H','A','R',' ')},*/	/* Harauti */
+/*{"??",	HB_TAG('H','A','W',' ')},*/	/* Hawaiin */
+/*{"??",	HB_TAG('H','B','N',' ')},*/	/* Hammer-Banna */
+/*{"??",	HB_TAG('H','M','A',' ')},*/	/* High Mari */
+/*{"??",	HB_TAG('H','N','D',' ')},*/	/* Hindko */
+/*{"??",	HB_TAG('I','J','O',' ')},*/	/* Ijo */
+/*{"??",	HB_TAG('I','L','O',' ')},*/	/* Ilokano */
+/*{"??",	HB_TAG('I','R','T',' ')},*/	/* Irish Traditional */
+/*{"??",	HB_TAG('J','U','L',' ')},*/	/* Jula */
+/*{"??",	HB_TAG('K','A','R',' ')},*/	/* Karachay */
+/*{"??",	HB_TAG('K','E','B',' ')},*/	/* Kebena */
+/*{"??",	HB_TAG('K','G','E',' ')},*/	/* Khutsuri Georgian */
+/*{"??",	HB_TAG('K','H','A',' ')},*/	/* Khakass */
+/*{"??",	HB_TAG('K','H','K',' ')},*/	/* Khanty-Kazim */
+/*{"??",	HB_TAG('K','H','S',' ')},*/	/* Khanty-Shurishkar */
+/*{"??",	HB_TAG('K','H','V',' ')},*/	/* Khanty-Vakhi */
+/*{"??",	HB_TAG('K','I','S',' ')},*/	/* Kisii */
+/*{"??",	HB_TAG('K','K','N',' ')},*/	/* Kokni */
+/*{"??",	HB_TAG('K','M','S',' ')},*/	/* Komso */
+/*{"??",	HB_TAG('K','O','D',' ')},*/	/* Kodagu */
+/*{"??",	HB_TAG('K','O','H',' ')},*/	/* Korean Old Hangul */
+/*{"??",	HB_TAG('K','O','N',' ')},*/	/* Kikongo */
+/*{"??",	HB_TAG('K','R','K',' ')},*/	/* Karakalpak */
+/*{"??",	HB_TAG('K','R','N',' ')},*/	/* Karen */
+/*{"??",	HB_TAG('K','U','L',' ')},*/	/* Kulvi */
+/*{"??",	HB_TAG('L','A','H',' ')},*/	/* Lahuli */
+/*{"??",	HB_TAG('L','A','M',' ')},*/	/* Lambani */
+/*{"??",	HB_TAG('L','C','R',' ')},*/	/* L-Cree */
+/*{"??",	HB_TAG('L','E','Z',' ')},*/	/* Lezgi */
+/*{"??",	HB_TAG('L','M','A',' ')},*/	/* Low Mari */
+/*{"??",	HB_TAG('L','U','B',' ')},*/	/* Luba */
+/*{"??",	HB_TAG('L','U','G',' ')},*/	/* Luganda */
+/*{"??",	HB_TAG('L','U','H',' ')},*/	/* Luhya */
+/*{"??",	HB_TAG('M','A','K',' ')},*/	/* Makua */
+/*{"??",	HB_TAG('M','A','L',' ')},*/	/* Malayalam Traditional */
+/*{"??",	HB_TAG('M','B','N',' ')},*/	/* Mbundu */
+/*{"??",	HB_TAG('M','I','Z',' ')},*/	/* Mizo */
+/*{"??",	HB_TAG('M','L','N',' ')},*/	/* Malinke */
+/*{"??",	HB_TAG('M','N','K',' ')},*/	/* Maninka */
+/*{"??",	HB_TAG('M','O','R',' ')},*/	/* Moroccan */
+/*{"??",	HB_TAG('N','A','G',' ')},*/	/* Naga-Assamese */
+/*{"??",	HB_TAG('N','C','R',' ')},*/	/* N-Cree */
+/*{"??",	HB_TAG('N','D','B',' ')},*/	/* Ndebele */
+/*{"??",	HB_TAG('N','G','R',' ')},*/	/* Nagari */
+/*{"??",	HB_TAG('N','H','C',' ')},*/	/* Norway House Cree */
+/*{"??",	HB_TAG('N','K','L',' ')},*/	/* Nkole */
+/*{"??",	HB_TAG('N','T','A',' ')},*/	/* Northern Tai */
+/*{"??",	HB_TAG('O','C','R',' ')},*/	/* Oji-Cree */
+/*{"??",	HB_TAG('P','A','A',' ')},*/	/* Palestinian Aramaic */
+/*{"??",	HB_TAG('P','G','R',' ')},*/	/* Polytonic Greek */
+/*{"??",	HB_TAG('P','L','G',' ')},*/	/* Palaung */
+/*{"??",	HB_TAG('Q','I','N',' ')},*/	/* Chin */
+/*{"??",	HB_TAG('R','B','U',' ')},*/	/* Russian Buriat */
+/*{"??",	HB_TAG('R','C','R',' ')},*/	/* R-Cree */
+/*{"??",	HB_TAG('R','M','S',' ')},*/	/* Rhaeto-Romanic */
+/*{"??",	HB_TAG('R','U','A',' ')},*/	/* Ruanda */
+/*{"??",	HB_TAG('S','A','Y',' ')},*/	/* Sayisi */
+/*{"??",	HB_TAG('S','E','K',' ')},*/	/* Sekota */
+/*{"??",	HB_TAG('S','I','G',' ')},*/	/* Silte Gurage */
+/*{"??",	HB_TAG('S','L','A',' ')},*/	/* Slavey */
+/*{"??",	HB_TAG('S','O','G',' ')},*/	/* Sodo Gurage */
+/*{"??",	HB_TAG('S','O','T',' ')},*/	/* Sotho */
+/*{"??",	HB_TAG('S','W','A',' ')},*/	/* Swadaya Aramaic */
+/*{"??",	HB_TAG('S','W','Z',' ')},*/	/* Swazi */
+/*{"??",	HB_TAG('S','X','T',' ')},*/	/* Sutu */
+/*{"??",	HB_TAG('T','A','B',' ')},*/	/* Tabasaran */
+/*{"??",	HB_TAG('T','C','R',' ')},*/	/* TH-Cree */
+/*{"??",	HB_TAG('T','G','N',' ')},*/	/* Tongan */
+/*{"??",	HB_TAG('T','M','N',' ')},*/	/* Temne */
+/*{"??",	HB_TAG('T','N','E',' ')},*/	/* Tundra Nenets */
+/*{"??",	HB_TAG('T','O','D',' ')},*/	/* Todo */
+/*{"??",	HB_TAG('T','U','A',' ')},*/	/* Turoyo Aramaic */
+/*{"??",	HB_TAG('T','U','V',' ')},*/	/* Tuvin */
+/*{"??",	HB_TAG('W','C','R',' ')},*/	/* West-Cree */
+/*{"??",	HB_TAG('X','B','D',' ')},*/	/* Tai Lue */
+/*{"??",	HB_TAG('Y','C','R',' ')},*/	/* Y-Cree */
+/*{"??",	HB_TAG('Y','I','C',' ')},*/	/* Yi Classic */
+/*{"??",	HB_TAG('Y','I','M',' ')},*/	/* Yi Modern */
+/*{"??",	HB_TAG('Z','H','P',' ')},*/	/* Chinese Phonetic */
+};
+
+static const LangTag ot_languages_zh[] = {
+  {"zh-cn",	HB_TAG('Z','H','S',' ')},	/* Chinese (China) */
+  {"zh-hk",	HB_TAG('Z','H','H',' ')},	/* Chinese (Hong Kong) */
+  {"zh-mo",	HB_TAG('Z','H','T',' ')},	/* Chinese (Macao) */
+  {"zh-sg",	HB_TAG('Z','H','S',' ')},	/* Chinese (Singapore) */
+  {"zh-tw",	HB_TAG('Z','H','T',' ')} 	/* Chinese (Taiwan) */
+};
+
+static int
+lang_compare_first_component (const char *a,
+			      const char *b)
+{
+  unsigned int da, db;
+  const char *p;
+
+  p = strchr (a, '-');
+  da = p ? (unsigned int) (p - a) : strlen (a);
+
+  p = strchr (b, '-');
+  db = p ? (unsigned int) (p - b) : strlen (b);
+
+  return strncmp (a, b, MAX (da, db));
+}
+
+static hb_bool_t
+lang_matches (const char *lang_str, const char *spec)
+{
+  unsigned int len = strlen (spec);
+
+  return strncmp (lang_str, spec, len) == 0 &&
+	 (lang_str[len] == '\0' || lang_str[len] == '-');
+}
+
+hb_tag_t
+hb_ot_tag_from_language (hb_language_t language)
+{
+  const char *lang_str, *s;
+  const LangTag *lang_tag;
+
+  if (language == HB_LANGUAGE_INVALID)
+    return HB_OT_TAG_DEFAULT_LANGUAGE;
+
+  lang_str = hb_language_to_string (language);
+
+  s = strstr (lang_str, "x-hbot");
+  if (s) {
+    char tag[4];
+    int i;
+    s += 6;
+    for (i = 0; i < 4 && ISALPHA (s[i]); i++)
+      tag[i] = TOUPPER (s[i]);
+    if (i) {
+      for (; i < 4; i++)
+	tag[i] = ' ';
+      return HB_TAG_CHAR4 (tag);
+    }
+  }
+
+  /* Find a language matching in the first component */
+  lang_tag = (LangTag *) bsearch (lang_str, ot_languages,
+				  ARRAY_LENGTH (ot_languages), sizeof (LangTag),
+				  (hb_compare_func_t) lang_compare_first_component);
+  if (lang_tag)
+    return lang_tag->tag;
+
+  /* Otherwise, check the Chinese ones */
+  if (0 == lang_compare_first_component (lang_str, "zh"))
+  {
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_LENGTH (ot_languages_zh); i++)
+    {
+      lang_tag = &ot_languages_zh[i];
+      if (lang_matches (lang_tag->language, lang_str))
+	return lang_tag->tag;
+    }
+
+    /* Otherwise just return 'ZHS ' */
+    return HB_TAG('Z','H','S',' ');
+  }
+
+  s = strchr (lang_str, '-');
+  if (!s)
+    s = lang_str + strlen (lang_str);
+  if (s - lang_str == 3) {
+    /* Assume it's ISO-639-3 and upper-case and use it. */
+    return hb_tag_from_string (lang_str, s - lang_str) & ~0x20202000;
+  }
+
+  return HB_OT_TAG_DEFAULT_LANGUAGE;
+}
+
+hb_language_t
+hb_ot_tag_to_language (hb_tag_t tag)
+{
+  unsigned int i;
+
+  if (tag == HB_OT_TAG_DEFAULT_LANGUAGE)
+    return NULL;
+
+  for (i = 0; i < ARRAY_LENGTH (ot_languages); i++)
+    if (ot_languages[i].tag == tag)
+      return hb_language_from_string (ot_languages[i].language, -1);
+
+  /* If tag starts with ZH, it's Chinese */
+  if ((tag & 0xFFFF0000)  == 0x5A480000) {
+    switch (tag) {
+      case HB_TAG('Z','H','H',' '): return hb_language_from_string ("zh-hk", -1); /* Hong Kong */
+      default: {
+        /* Encode the tag... */
+	unsigned char buf[14] = "zh-x-hbot";
+	buf[9] = tag >> 24;
+	buf[10] = (tag >> 16) & 0xFF;
+	buf[11] = (tag >> 8) & 0xFF;
+	buf[12] = tag & 0xFF;
+	if (buf[12] == 0x20)
+	  buf[12] = '\0';
+	buf[13] = '\0';
+	return hb_language_from_string ((char *) buf, -1);
+      }
+    }
+  }
+
+  /* Else return a custom language in the form of "x-hbotABCD" */
+  {
+    unsigned char buf[11] = "x-hbot";
+    buf[6] = tag >> 24;
+    buf[7] = (tag >> 16) & 0xFF;
+    buf[8] = (tag >> 8) & 0xFF;
+    buf[9] = tag & 0xFF;
+    if (buf[9] == 0x20)
+      buf[9] = '\0';
+    buf[10] = '\0';
+    return hb_language_from_string ((char *) buf, -1);
+  }
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-ot-tag.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-ot-tag.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,59 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_OT_H_IN
+#error "Include <hb-ot.h> instead."
+#endif
+
+#ifndef HB_OT_TAG_H
+#define HB_OT_TAG_H
+
+#include "hb.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_OT_TAG_DEFAULT_SCRIPT	HB_TAG ('D', 'F', 'L', 'T')
+#define HB_OT_TAG_DEFAULT_LANGUAGE	HB_TAG ('d', 'f', 'l', 't')
+
+void
+hb_ot_tags_from_script (hb_script_t  script,
+			hb_tag_t    *script_tag_1,
+			hb_tag_t    *script_tag_2);
+
+hb_script_t
+hb_ot_tag_to_script (hb_tag_t tag);
+
+hb_tag_t
+hb_ot_tag_from_language (hb_language_t language);
+
+hb_language_t
+hb_ot_tag_to_language (hb_tag_t tag);
+
+
+HB_END_DECLS
+
+#endif /* HB_OT_TAG_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-private.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-private.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-private.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-private.h	2012-05-05 23:46:51.524763796 +0530
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2007,2008,2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_PRIVATE_H
+#define HB_PRIVATE_H
+
+#if HAVE_CONFIG_H
+//#include "config.h"
+#endif
+
+#include "hb-common.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+/* We only use these two for debug output.  However, the debug code is
+ * always seen by the compiler (and optimized out in non-debug builds.
+ * If including these becomes a problem, we can start thinking about
+ * someway around that. */
+#include <stdio.h>
+#include <errno.h>
+
+HB_BEGIN_DECLS
+
+
+/* Essentials */
+
+#ifndef NULL
+# define NULL ((void *) 0)
+#endif
+
+#undef FALSE
+#define FALSE 0
+
+#undef TRUE
+#define TRUE 1
+
+
+/* Basics */
+
+#undef MIN
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+#undef MAX
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((signed int) (sizeof (__array) / sizeof (__array[0])))
+
+#define HB_STMT_START do
+#define HB_STMT_END   while (0)
+
+#define _ASSERT_STATIC1(_line, _cond) typedef int _static_assert_on_line_##_line##_failed[(_cond)?1:-1]
+#define _ASSERT_STATIC0(_line, _cond) _ASSERT_STATIC1 (_line, (_cond))
+#define ASSERT_STATIC(_cond) _ASSERT_STATIC0 (__LINE__, (_cond))
+
+
+/* Misc */
+
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _HB_BOOLEAN_EXPR(expr) ((expr) ? 1 : 0)
+#define likely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 1))
+#define unlikely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 0))
+#else
+#define likely(expr) (expr)
+#define unlikely(expr) (expr)
+#endif
+
+#ifndef __GNUC__
+#undef __attribute__
+#define __attribute__(x)
+#endif
+
+#if __GNUC__ >= 3
+#define HB_PURE_FUNC	__attribute__((pure))
+#define HB_CONST_FUNC	__attribute__((const))
+#else
+#define HB_PURE_FUNC
+#define HB_CONST_FUNC
+#endif
+#if __GNUC__ >= 4
+#define HB_UNUSED	__attribute__((unused))
+#else
+#define HB_UNUSED
+#endif
+
+#ifndef HB_INTERNAL
+# define HB_INTERNAL __attribute__((__visibility__("hidden")))
+#endif
+
+
+#if (defined(__WIN32__) && !defined(__WINE__)) || defined(_MSC_VER)
+#define snprintf _snprintf
+#endif
+
+#ifdef _MSC_VER
+#undef inline
+#define inline __inline
+#endif
+
+#ifdef __STRICT_ANSI__
+#undef inline
+#define inline __inline__
+#endif
+
+
+#if __GNUC__ >= 3
+#define HB_FUNC __PRETTY_FUNCTION__
+#elif defined(_MSC_VER)
+#define HB_FUNC __FUNCSIG__
+#else
+#define HB_FUNC __func__
+#endif
+
+
+/* Return the number of 1 bits in mask. */
+static inline HB_CONST_FUNC unsigned int
+_hb_popcount32 (uint32_t mask)
+{
+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+  return __builtin_popcount (mask);
+#else
+  /* "HACKMEM 169" */
+  register uint32_t y;
+  y = (mask >> 1) &033333333333;
+  y = mask - y - ((y >>1) & 033333333333);
+  return (((y + (y >> 3)) & 030707070707) % 077);
+#endif
+}
+
+/* Returns the number of bits needed to store number */
+static inline HB_CONST_FUNC unsigned int
+_hb_bit_storage (unsigned int number)
+{
+#if defined(__GNUC__) && (__GNUC__ >= 4) && defined(__OPTIMIZE__)
+  return likely (number) ? (sizeof (unsigned int) * 8 - __builtin_clz (number)) : 0;
+#else
+  register unsigned int n_bits = 0;
+  while (number) {
+    n_bits++;
+    number >>= 1;
+  }
+  return n_bits;
+#endif
+}
+
+/* Returns the number of zero bits in the least significant side of number */
+static inline HB_CONST_FUNC unsigned int
+_hb_ctz (unsigned int number)
+{
+#if defined(__GNUC__) && (__GNUC__ >= 4) && defined(__OPTIMIZE__)
+  return likely (number) ? __builtin_ctz (number) : 0;
+#else
+  register unsigned int n_bits = 0;
+  if (unlikely (!number)) return 0;
+  while (!(number & 1)) {
+    n_bits++;
+    number >>= 1;
+  }
+  return n_bits;
+#endif
+}
+
+/* Type of bsearch() / qsort() compare function */
+typedef int (*hb_compare_func_t) (const void *, const void *);
+
+
+/* We need external help for these */
+
+#ifdef HAVE_GLIB
+
+#include <glib.h>
+
+typedef int hb_atomic_int_t;
+#define hb_atomic_int_fetch_and_add(AI, V)	g_atomic_int_exchange_and_add (&(AI), V)
+#define hb_atomic_int_get(AI)			g_atomic_int_get (&(AI))
+#define hb_atomic_int_set(AI, V)		g_atomic_int_set (&(AI), V)
+
+typedef GStaticMutex hb_mutex_t;
+#define HB_MUTEX_INIT			G_STATIC_MUTEX_INIT
+#define hb_mutex_init(M)		g_static_mutex_init (&M)
+#define hb_mutex_lock(M)		g_static_mutex_lock (&M)
+#define hb_mutex_trylock(M)		g_static_mutex_trylock (&M)
+#define hb_mutex_unlock(M)		g_static_mutex_unlock (&M)
+
+#else
+
+#ifdef _MSC_VER
+#pragma message(_HB__LOC__"Could not find any system to define platform macros, library will NOT be thread-safe")
+#else
+#warning "Could not find any system to define platform macros, library will NOT be thread-safe"
+#endif
+
+typedef int hb_atomic_int_t;
+#define hb_atomic_int_fetch_and_add(AI, V)	((AI) += (V), (AI) - (V))
+#define hb_atomic_int_get(AI)			(AI)
+#define hb_atomic_int_set(AI, V)		HB_STMT_START { (AI) = (V); } HB_STMT_END
+
+typedef int hb_mutex_t;
+#define HB_MUTEX_INIT				0
+#define hb_mutex_init(M)			HB_STMT_START { (M) = 0; } HB_STMT_END
+#define hb_mutex_lock(M)			HB_STMT_START { (M) = 1; } HB_STMT_END
+#define hb_mutex_trylock(M)			((M) = 1, 1)
+#define hb_mutex_unlock(M)			HB_STMT_START { (M) = 0; } HB_STMT_END
+
+#endif
+
+
+/* Big-endian handling */
+
+#define hb_be_uint16(v)		((uint16_t) ((((const uint8_t *)&(v))[0] << 8) + (((const uint8_t *)&(v))[1])))
+
+#define hb_be_uint16_put(v,V)	HB_STMT_START { v[0] = (V>>8); v[1] = (V); } HB_STMT_END
+#define hb_be_uint16_get(v)	(uint16_t) ((v[0] << 8) + v[1])
+#define hb_be_uint16_cmp(a,b)	(a[0] == b[0] && a[1] == b[1])
+
+#define hb_be_uint32_put(v,V)	HB_STMT_START { v[0] = (V>>24); v[1] = (V>>16); v[2] = (V>>8); v[3] = (V); } HB_STMT_END
+#define hb_be_uint32_get(v)	(uint32_t) ((v[0] << 24) + (v[1] << 16) + (v[2] << 8) + v[3])
+#define hb_be_uint32_cmp(a,b)	(a[0] == b[0] && a[1] == b[1] && a[2] == b[2] && a[3] == b[3])
+
+
+/* Debug */
+
+#ifndef HB_DEBUG
+#define HB_DEBUG 0
+#endif
+
+static inline hb_bool_t /* always returns TRUE */
+_hb_trace (const char *what,
+	   const char *function,
+	   const void *obj,
+	   unsigned int depth,
+	   unsigned int max_depth)
+{
+  if (depth < max_depth)
+    fprintf (stderr, "%s(%p) %-*d-> %s\n", what, obj, depth, depth, function);
+  return TRUE;
+}
+
+
+#include "hb-object-private.h"
+
+
+HB_END_DECLS
+
+#endif /* HB_PRIVATE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-private.hh	2012-05-05 20:28:05.000000000 +0530
@@ -0,0 +1,645 @@
+/*
+ * Copyright  2007,2008,2009  Red Hat, Inc.
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_PRIVATE_HH
+#define HB_PRIVATE_HH
+
+#ifdef HAVE_CONFIG_H
+#include "scconfig.h"
+#endif
+
+#include "hb.h"
+#define HB_H_IN
+#ifdef HAVE_OT
+#include "hb-ot.h"
+#define HB_OT_H_IN
+#endif
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <assert.h>
+
+/* We only use these two for debug output.  However, the debug code is
+ * always seen by the compiler (and optimized out in non-debug builds.
+ * If including these becomes a problem, we can start thinking about
+ * someway around that. */
+#include <stdio.h>
+#include <errno.h>
+#include <stdarg.h>
+
+
+
+/* Essentials */
+
+#ifndef NULL
+# define NULL ((void *) 0)
+#endif
+
+#undef FALSE
+#define FALSE 0
+
+#undef TRUE
+#define TRUE 1
+
+
+/* Basics */
+
+
+#undef MIN
+template <typename Type> static inline Type MIN (const Type &a, const Type &b) { return a < b ? a : b; }
+
+#undef MAX
+template <typename Type> static inline Type MAX (const Type &a, const Type &b) { return a > b ? a : b; }
+
+
+#undef  ARRAY_LENGTH
+#define ARRAY_LENGTH(__array) ((signed int) (sizeof (__array) / sizeof (__array[0])))
+
+#define HB_STMT_START do
+#define HB_STMT_END   while (0)
+
+#define _ASSERT_STATIC1(_line, _cond) typedef int _static_assert_on_line_##_line##_failed[(_cond)?1:-1]
+#define _ASSERT_STATIC0(_line, _cond) _ASSERT_STATIC1 (_line, (_cond))
+#define ASSERT_STATIC(_cond) _ASSERT_STATIC0 (__LINE__, (_cond))
+
+#define ASSERT_STATIC_EXPR(_cond) ((void) sizeof (char[(_cond) ? 1 : -1]))
+#define ASSERT_STATIC_EXPR_ZERO(_cond) (0 * sizeof (char[(_cond) ? 1 : -1]))
+
+
+/* Lets assert int types.  Saves trouble down the road. */
+
+ASSERT_STATIC (sizeof (int8_t) == 1);
+ASSERT_STATIC (sizeof (uint8_t) == 1);
+ASSERT_STATIC (sizeof (int16_t) == 2);
+ASSERT_STATIC (sizeof (uint16_t) == 2);
+ASSERT_STATIC (sizeof (int32_t) == 4);
+ASSERT_STATIC (sizeof (uint32_t) == 4);
+ASSERT_STATIC (sizeof (int64_t) == 8);
+ASSERT_STATIC (sizeof (uint64_t) == 8);
+
+ASSERT_STATIC (sizeof (hb_codepoint_t) == 4);
+ASSERT_STATIC (sizeof (hb_position_t) == 4);
+ASSERT_STATIC (sizeof (hb_mask_t) == 4);
+ASSERT_STATIC (sizeof (hb_var_int_t) == 4);
+
+/* Misc */
+
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+#define _HB_BOOLEAN_EXPR(expr) ((expr) ? 1 : 0)
+#define likely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 1))
+#define unlikely(expr) (__builtin_expect (_HB_BOOLEAN_EXPR(expr), 0))
+#else
+#define likely(expr) (expr)
+#define unlikely(expr) (expr)
+#endif
+
+#ifndef __GNUC__
+#undef __attribute__
+#define __attribute__(x)
+#endif
+
+#if __GNUC__ >= 3
+#define HB_PURE_FUNC	__attribute__((pure))
+#define HB_CONST_FUNC	__attribute__((const))
+#define HB_PRINTF_FUNC(format_idx, arg_idx) __attribute__((__format__ (__printf__, format_idx, arg_idx)))
+#else
+#define HB_PURE_FUNC
+#define HB_CONST_FUNC
+#define HB_PRINTF_FUNC(format_idx, arg_idx)
+#endif
+#if __GNUC__ >= 4
+#define HB_UNUSED	__attribute__((unused))
+#else
+#define HB_UNUSED
+#endif
+
+#ifndef HB_INTERNAL
+# ifndef __MINGW32__
+#  define HB_INTERNAL __attribute__((__visibility__("hidden")))
+# else
+#  define HB_INTERNAL
+# endif
+#endif
+
+
+#if (defined(__WIN32__) && !defined(__WINE__)) || defined(_MSC_VER)
+#define snprintf _snprintf
+#endif
+
+#ifdef _MSC_VER
+#undef inline
+#define inline __inline
+#endif
+
+#ifdef __STRICT_ANSI__
+#undef inline
+#define inline __inline__
+#endif
+
+
+#if __GNUC__ >= 3
+#define HB_FUNC __PRETTY_FUNCTION__
+#elif defined(_MSC_VER)
+#define HB_FUNC __FUNCSIG__
+#else
+#define HB_FUNC __func__
+#endif
+
+
+/* Return the number of 1 bits in mask. */
+static inline HB_CONST_FUNC unsigned int
+_hb_popcount32 (uint32_t mask)
+{
+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
+  return __builtin_popcount (mask);
+#else
+  /* "HACKMEM 169" */
+  register uint32_t y;
+  y = (mask >> 1) &033333333333;
+  y = mask - y - ((y >>1) & 033333333333);
+  return (((y + (y >> 3)) & 030707070707) % 077);
+#endif
+}
+
+/* Returns the number of bits needed to store number */
+static inline HB_CONST_FUNC unsigned int
+_hb_bit_storage (unsigned int number)
+{
+#if defined(__GNUC__) && (__GNUC__ >= 4) && defined(__OPTIMIZE__)
+  return likely (number) ? (sizeof (unsigned int) * 8 - __builtin_clz (number)) : 0;
+#else
+  register unsigned int n_bits = 0;
+  while (number) {
+    n_bits++;
+    number >>= 1;
+  }
+  return n_bits;
+#endif
+}
+
+/* Returns the number of zero bits in the least significant side of number */
+static inline HB_CONST_FUNC unsigned int
+_hb_ctz (unsigned int number)
+{
+#if defined(__GNUC__) && (__GNUC__ >= 4) && defined(__OPTIMIZE__)
+  return likely (number) ? __builtin_ctz (number) : 0;
+#else
+  register unsigned int n_bits = 0;
+  if (unlikely (!number)) return 0;
+  while (!(number & 1)) {
+    n_bits++;
+    number >>= 1;
+  }
+  return n_bits;
+#endif
+}
+
+static inline bool
+_hb_unsigned_int_mul_overflows (unsigned int count, unsigned int size)
+{
+  return (size > 0) && (count >= ((unsigned int) -1) / size);
+}
+
+
+/* Type of bsearch() / qsort() compare function */
+typedef int (*hb_compare_func_t) (const void *, const void *);
+
+
+
+
+/* arrays and maps */
+
+
+template <typename Type, unsigned int StaticSize>
+struct hb_prealloced_array_t {
+
+  unsigned int len;
+  unsigned int allocated;
+  Type *array;
+  Type static_array[StaticSize];
+
+  hb_prealloced_array_t (void) { memset (this, 0, sizeof (*this)); }
+
+  inline Type& operator [] (unsigned int i) { return array[i]; }
+  inline const Type& operator [] (unsigned int i) const { return array[i]; }
+
+  inline Type *push (void)
+  {
+    if (!array) {
+      array = static_array;
+      allocated = ARRAY_LENGTH (static_array);
+    }
+    if (likely (len < allocated))
+      return &array[len++];
+
+    /* Need to reallocate */
+    unsigned int new_allocated = allocated + (allocated >> 1) + 8;
+    Type *new_array = NULL;
+
+    if (array == static_array) {
+      new_array = (Type *) calloc (new_allocated, sizeof (Type));
+      if (new_array)
+        memcpy (new_array, array, len * sizeof (Type));
+    } else {
+      bool overflows = (new_allocated < allocated) || _hb_unsigned_int_mul_overflows (new_allocated, sizeof (Type));
+      if (likely (!overflows)) {
+	new_array = (Type *) realloc (array, new_allocated * sizeof (Type));
+      }
+    }
+
+    if (unlikely (!new_array))
+      return NULL;
+
+    array = new_array;
+    allocated = new_allocated;
+    return &array[len++];
+  }
+
+  inline void pop (void)
+  {
+    len--;
+    /* TODO: shrink array if needed */
+  }
+
+  inline void shrink (unsigned int l)
+  {
+     if (l < len)
+       len = l;
+    /* TODO: shrink array if needed */
+  }
+
+  template <typename T>
+  inline Type *find (T v) {
+    for (unsigned int i = 0; i < len; i++)
+      if (array[i] == v)
+	return &array[i];
+    return NULL;
+  }
+  template <typename T>
+  inline const Type *find (T v) const {
+    for (unsigned int i = 0; i < len; i++)
+      if (array[i] == v)
+	return &array[i];
+    return NULL;
+  }
+
+  inline void sort (void)
+  {
+    qsort (array, len, sizeof (Type), (hb_compare_func_t) Type::cmp);
+  }
+
+  inline void sort (unsigned int start, unsigned int end)
+  {
+    qsort (array + start, end - start, sizeof (Type), (hb_compare_func_t) Type::cmp);
+  }
+
+  template <typename T>
+  inline Type *bsearch (T *key)
+  {
+    return (Type *) ::bsearch (key, array, len, sizeof (Type), (hb_compare_func_t) Type::cmp);
+  }
+  template <typename T>
+  inline const Type *bsearch (T *key) const
+  {
+    return (const Type *) ::bsearch (key, array, len, sizeof (Type), (hb_compare_func_t) Type::cmp);
+  }
+
+  inline void finish (void)
+  {
+    if (array != static_array)
+      free (array);
+    array = NULL;
+    allocated = len = 0;
+  }
+};
+
+template <typename Type>
+struct hb_array_t : hb_prealloced_array_t<Type, 2> {};
+
+
+template <typename item_t, typename lock_t>
+struct hb_lockable_set_t
+{
+  hb_array_t <item_t> items;
+
+  template <typename T>
+  inline item_t *replace_or_insert (T v, lock_t &l, bool replace)
+  {
+    l.lock ();
+    item_t *item = items.find (v);
+    if (item) {
+      if (replace) {
+	item_t old = *item;
+	*item = v;
+	l.unlock ();
+	old.finish ();
+      }
+      else {
+        item = NULL;
+	l.unlock ();
+      }
+    } else {
+      item = items.push ();
+      if (likely (item))
+	*item = v;
+      l.unlock ();
+    }
+    return item;
+  }
+
+  template <typename T>
+  inline void remove (T v, lock_t &l)
+  {
+    l.lock ();
+    item_t *item = items.find (v);
+    if (item) {
+      item_t old = *item;
+      *item = items[items.len - 1];
+      items.pop ();
+      l.unlock ();
+      old.finish ();
+    } else {
+      l.unlock ();
+    }
+  }
+
+  template <typename T>
+  inline bool find (T v, item_t *i, lock_t &l)
+  {
+    l.lock ();
+    item_t *item = items.find (v);
+    if (item)
+      *i = *item;
+    l.unlock ();
+    return !!item;
+  }
+
+  template <typename T>
+  inline item_t *find_or_insert (T v, lock_t &l)
+  {
+    l.lock ();
+    item_t *item = items.find (v);
+    if (!item) {
+      item = items.push ();
+      if (likely (item))
+        *item = v;
+    }
+    l.unlock ();
+    return item;
+  }
+
+  inline void finish (lock_t &l)
+  {
+    l.lock ();
+    while (items.len) {
+      item_t old = items[items.len - 1];
+	items.pop ();
+	l.unlock ();
+	old.finish ();
+	l.lock ();
+    }
+    items.finish ();
+    l.unlock ();
+  }
+
+};
+
+
+
+
+/* Big-endian handling */
+
+static inline uint16_t hb_be_uint16 (const uint16_t v)
+{
+  const uint8_t *V = (const uint8_t *) &v;
+  return (uint16_t) (V[0] << 8) + V[1];
+}
+
+/* Note, of the following macros, uint16_get is the one called many many times.
+ * If there is any optimizations to be done, it's in that macro.  However, I
+ * already confirmed that on my T400 ThinkPad at least, using bswap_16(), which
+ * results in a single ror instruction, does NOT speed this up.  In fact, it
+ * resulted in a minor slowdown.  At any rate, note that v may not be correctly
+ * aligned, so I think the current implementation is optimal.
+ */
+
+#define hb_be_uint16_put(v,V)	HB_STMT_START { v[0] = (V>>8); v[1] = (V); } HB_STMT_END
+#define hb_be_uint16_get(v)	(uint16_t) ((v[0] << 8) + v[1])
+#define hb_be_uint16_eq(a,b)	(a[0] == b[0] && a[1] == b[1])
+
+#define hb_be_uint32_put(v,V)	HB_STMT_START { v[0] = (V>>24); v[1] = (V>>16); v[2] = (V>>8); v[3] = (V); } HB_STMT_END
+#define hb_be_uint32_get(v)	(uint32_t) ((v[0] << 24) + (v[1] << 16) + (v[2] << 8) + v[3])
+#define hb_be_uint32_eq(a,b)	(a[0] == b[0] && a[1] == b[1] && a[2] == b[2] && a[3] == b[3])
+
+
+/* ASCII tag/character handling */
+
+static inline unsigned char ISALPHA (unsigned char c)
+{ return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'); }
+static inline unsigned char ISALNUM (unsigned char c)
+{ return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'); }
+static inline unsigned char TOUPPER (unsigned char c)
+{ return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c; }
+static inline unsigned char TOLOWER (unsigned char c)
+{ return (c >= 'A' && c <= 'Z') ? c - 'A' + 'a' : c; }
+
+#define HB_TAG_CHAR4(s)   (HB_TAG(((const char *) s)[0], \
+				  ((const char *) s)[1], \
+				  ((const char *) s)[2], \
+				  ((const char *) s)[3]))
+
+
+/* C++ helpers */
+
+/* Makes class uncopyable.  Use in private: section. */
+#define NO_COPY(T) \
+  T (const T &o); \
+  T &operator = (const T &o)
+
+
+/* Debug */
+
+
+#ifndef HB_DEBUG
+#define HB_DEBUG 0
+#endif
+
+static inline bool
+_hb_debug (unsigned int level,
+	   unsigned int max_level)
+{
+  return level < max_level;
+}
+
+#define DEBUG_LEVEL(WHAT, LEVEL) (_hb_debug ((LEVEL), HB_DEBUG_##WHAT))
+#define DEBUG(WHAT) (DEBUG_LEVEL (WHAT, 0))
+
+template <int max_level> inline bool /* always returns TRUE */
+_hb_debug_msg (const char *what,
+	       const void *obj,
+	       const char *func,
+	       bool indented,
+	       int level,
+	       const char *message,
+	       ...) HB_PRINTF_FUNC(6, 7);
+template <int max_level> inline bool /* always returns TRUE */
+_hb_debug_msg (const char *what,
+	       const void *obj,
+	       const char *func,
+	       bool indented,
+	       int level,
+	       const char *message,
+	       ...)
+{
+  va_list ap;
+  va_start (ap, message);
+
+  (void) (_hb_debug (level, max_level) &&
+	  fprintf (stderr, "%s", what) &&
+	  (obj && fprintf (stderr, "(%p)", obj), TRUE) &&
+	  fprintf (stderr, ": ") &&
+	  (func && fprintf (stderr, "%s: ", func), TRUE) &&
+	  (indented && fprintf (stderr, "%-*d-> ", level + 1, level), TRUE) &&
+	  vfprintf (stderr, message, ap) &&
+	  fprintf (stderr, "\n"));
+
+  va_end (ap);
+
+  return TRUE;
+}
+template <> inline bool /* always returns TRUE */
+_hb_debug_msg<0> (const char *what,
+		  const void *obj,
+		  const char *func,
+		  bool indented,
+		  int level,
+		  const char *message,
+		  ...) HB_PRINTF_FUNC(6, 7);
+template <> inline bool /* always returns TRUE */
+_hb_debug_msg<0> (const char *what,
+		  const void *obj,
+		  const char *func,
+		  bool indented,
+		  int level,
+		  const char *message,
+		  ...)
+{
+  return TRUE;
+}
+
+#define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, ...) _hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), NULL, FALSE, (LEVEL), __VA_ARGS__)
+#define DEBUG_MSG(WHAT, OBJ, ...) DEBUG_MSG_LEVEL (WHAT, OBJ, 0, __VA_ARGS__)
+#define DEBUG_MSG_FUNC(WHAT, OBJ, ...) _hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), HB_FUNC, FALSE, 0, __VA_ARGS__)
+
+
+/*
+ * Trace
+ */
+
+template <int max_level>
+struct hb_auto_trace_t {
+  explicit inline hb_auto_trace_t (unsigned int *plevel_,
+				   const char *what,
+				   const void *obj,
+				   const char *func,
+				   const char *message) : plevel(plevel_)
+  {
+    if (max_level) ++*plevel;
+    /* TODO support variadic args here */
+    _hb_debug_msg<max_level> (what, obj, func, TRUE, *plevel, "%s", message);
+  }
+  ~hb_auto_trace_t (void) { if (max_level) --*plevel; }
+
+  private:
+  unsigned int *plevel;
+};
+template <> /* Optimize when tracing is disabled */
+struct hb_auto_trace_t<0> {
+  explicit inline hb_auto_trace_t (unsigned int *plevel_,
+				   const char *what,
+				   const void *obj,
+				   const char *func,
+				   const char *message) {}
+};
+
+
+/* Misc */
+
+
+/* Pre-mature optimization:
+ * Checks for lo <= u <= hi but with an optimization if lo and hi
+ * are only different in a contiguous set of lower-most bits.
+ */
+template <typename T> inline bool
+hb_in_range (T u, T lo, T hi)
+{
+  if ( ((lo^hi) & lo) == 0 &&
+       ((lo^hi) & hi) == (lo^hi) &&
+       ((lo^hi) & ((lo^hi) + 1)) == 0 )
+    return (u & ~(lo^hi)) == lo;
+  else
+    return lo <= u && u <= hi;
+}
+
+
+/* Useful for set-operations on small enums.
+ * For example, for testing "x  {x1, x2, x3}" use:
+ * (FLAG(x) & (FLAG(x1) | FLAG(x2) | FLAG(x3)))
+ */
+#define FLAG(x) (1<<(x))
+
+
+template <typename T> inline void
+hb_bubble_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))
+{
+  if (unlikely (!len))
+    return;
+
+  unsigned int k = len - 1;
+  do {
+    unsigned int new_k = 0;
+
+    for (unsigned int j = 0; j < k; j++)
+      if (compar (&array[j], &array[j+1]) > 0) {
+        T t;
+	t = array[j];
+	array[j] = array[j + 1];
+	array[j + 1] = t;
+
+	new_k = j;
+      }
+    k = new_k;
+  } while (k);
+}
+
+
+
+
+#endif /* HB_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,175 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-set-private.hh"
+
+
+
+/* Public API */
+
+static hb_set_t _hb_set_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  {0} /* elts */
+};
+
+
+hb_set_t *
+hb_set_create ()
+{
+  hb_set_t *set;
+
+  if (!(set = hb_object_create<hb_set_t> ()))
+    return &_hb_set_nil;
+
+  set->clear ();
+
+  return set;
+}
+
+hb_set_t *
+hb_set_get_empty (void)
+{
+  return &_hb_set_nil;
+}
+
+hb_set_t *
+hb_set_reference (hb_set_t *set)
+{
+  return hb_object_reference (set);
+}
+
+void
+hb_set_destroy (hb_set_t *set)
+{
+  if (!hb_object_destroy (set)) return;
+
+  free (set);
+}
+
+hb_bool_t
+hb_set_set_user_data (hb_set_t        *set,
+			 hb_user_data_key_t *key,
+			 void *              data,
+			 hb_destroy_func_t   destroy,
+			 hb_bool_t           replace)
+{
+  return hb_object_set_user_data (set, key, data, destroy, replace);
+}
+
+void *
+hb_set_get_user_data (hb_set_t        *set,
+			 hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (set, key);
+}
+
+
+hb_bool_t
+hb_set_allocation_successful (hb_set_t  *set)
+{
+  return TRUE;
+}
+
+void
+hb_set_clear (hb_set_t *set)
+{
+  set->clear ();
+}
+
+hb_bool_t
+hb_set_empty (hb_set_t *set)
+{
+  return set->empty ();
+}
+
+hb_bool_t
+hb_set_has (hb_set_t       *set,
+	    hb_codepoint_t  codepoint)
+{
+  return set->has (codepoint);
+}
+
+void
+hb_set_add (hb_set_t       *set,
+	    hb_codepoint_t  codepoint)
+{
+  set->add (codepoint);
+}
+
+void
+hb_set_del (hb_set_t       *set,
+	    hb_codepoint_t  codepoint)
+{
+  set->del (codepoint);
+}
+
+hb_bool_t
+hb_set_equal (hb_set_t *set,
+	      hb_set_t *other)
+{
+  return set->equal (other);
+}
+
+void
+hb_set_set (hb_set_t *set,
+	    hb_set_t *other)
+{
+  set->set (other);
+}
+
+void
+hb_set_union (hb_set_t *set,
+	      hb_set_t *other)
+{
+  set->union_ (other);
+}
+
+void
+hb_set_intersect (hb_set_t *set,
+		  hb_set_t *other)
+{
+  set->intersect (other);
+}
+
+void
+hb_set_subtract (hb_set_t *set,
+		 hb_set_t *other)
+{
+  set->subtract (other);
+}
+
+hb_codepoint_t
+hb_set_min (hb_set_t *set)
+{
+  return set->min ();
+}
+
+hb_codepoint_t
+hb_set_max (hb_set_t *set)
+{
+  return set->max ();
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,119 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_SET_H
+#define HB_SET_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+typedef struct _hb_set_t hb_set_t;
+
+
+hb_set_t *
+hb_set_create (void);
+
+hb_set_t *
+hb_set_get_empty (void);
+
+hb_set_t *
+hb_set_reference (hb_set_t *set);
+
+void
+hb_set_destroy (hb_set_t *set);
+
+hb_bool_t
+hb_set_set_user_data (hb_set_t           *set,
+		      hb_user_data_key_t *key,
+		      void *              data,
+		      hb_destroy_func_t   destroy,
+		      hb_bool_t           replace);
+
+void *
+hb_set_get_user_data (hb_set_t           *set,
+		      hb_user_data_key_t *key);
+
+
+/* Returns FALSE if allocation has failed before */
+hb_bool_t
+hb_set_allocation_successful (hb_set_t  *set);
+
+void
+hb_set_clear (hb_set_t *set);
+
+hb_bool_t
+hb_set_empty (hb_set_t *set);
+
+hb_bool_t
+hb_set_has (hb_set_t       *set,
+	    hb_codepoint_t  codepoint);
+
+void
+hb_set_add (hb_set_t       *set,
+	    hb_codepoint_t  codepoint);
+
+void
+hb_set_del (hb_set_t       *set,
+	    hb_codepoint_t  codepoint);
+
+hb_bool_t
+hb_set_equal (hb_set_t *set,
+	      hb_set_t *other);
+
+void
+hb_set_set (hb_set_t *set,
+	    hb_set_t *other);
+
+void
+hb_set_union (hb_set_t *set,
+	      hb_set_t *other);
+
+void
+hb_set_intersect (hb_set_t *set,
+		  hb_set_t *other);
+
+void
+hb_set_subtract (hb_set_t *set,
+		 hb_set_t *other);
+
+hb_codepoint_t
+hb_set_min (hb_set_t *set);
+
+hb_codepoint_t
+hb_set_max (hb_set_t *set);
+
+/* TODO: Add faster iteration API? */
+
+
+HB_END_DECLS
+
+#endif /* HB_SET_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-set-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-set-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,139 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_SET_PRIVATE_HH
+#define HB_SET_PRIVATE_HH
+
+#include "hb-private.hh"
+#include "hb-set.h"
+#include "hb-object-private.hh"
+
+
+
+struct _hb_set_t
+{
+  inline void clear (void) {
+    memset (elts, 0, sizeof elts);
+  }
+  inline bool empty (void) const {
+    for (unsigned int i = 0; i < ARRAY_LENGTH (elts); i++)
+      if (elts[i])
+        return false;
+    return true;
+  }
+  inline void add (hb_codepoint_t g)
+  {
+    if (unlikely (g > MAX_G)) return;
+    elt (g) |= mask (g);
+  }
+  inline void del (hb_codepoint_t g)
+  {
+    if (unlikely (g > MAX_G)) return;
+    elt (g) &= ~mask (g);
+  }
+  inline bool has (hb_codepoint_t g) const
+  {
+    if (unlikely (g > MAX_G)) return false;
+    return !!(elt (g) & mask (g));
+  }
+  inline bool intersects (hb_codepoint_t first,
+			  hb_codepoint_t last) const
+  {
+    if (unlikely (first > MAX_G)) return false;
+    if (unlikely (last  > MAX_G)) last = MAX_G;
+    unsigned int end = last + 1;
+    for (hb_codepoint_t i = first; i < end; i++)
+      if (has (i))
+        return true;
+    return false;
+  }
+  inline bool equal (const hb_set_t *other) const
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      if (elts[i] != other->elts[i])
+        return false;
+    return true;
+  }
+  inline void set (const hb_set_t *other)
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      elts[i] = other->elts[i];
+  }
+  inline void union_ (const hb_set_t *other)
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      elts[i] |= other->elts[i];
+  }
+  inline void intersect (const hb_set_t *other)
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      elts[i] &= other->elts[i];
+  }
+  inline void subtract (const hb_set_t *other)
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      elts[i] &= ~other->elts[i];
+  }
+  inline hb_codepoint_t min (void) const
+  {
+    for (unsigned int i = 0; i < ELTS; i++)
+      if (elts[i])
+	for (unsigned int j = 0; i < BITS; j++)
+	  if (elts[i] & (1 << j))
+	    return i * BITS + j;
+    return 0;
+  }
+  inline hb_codepoint_t max (void) const
+  {
+    for (unsigned int i = ELTS; i; i--)
+      if (elts[i - 1])
+	for (unsigned int j = BITS; j; j--)
+	  if (elts[i - 1] & (1 << (j - 1)))
+	    return (i - 1) * BITS + (j - 1);
+    return 0;
+  }
+
+  typedef uint32_t elt_t;
+  static const unsigned int MAX_G = 65536 - 1;
+  static const unsigned int SHIFT = 5;
+  static const unsigned int BITS = (1 << SHIFT);
+  static const unsigned int MASK = BITS - 1;
+  static const unsigned int ELTS = (MAX_G + 1 + (BITS - 1)) / BITS;
+
+  elt_t &elt (hb_codepoint_t g) { return elts[g >> SHIFT]; }
+  elt_t elt (hb_codepoint_t g) const { return elts[g >> SHIFT]; }
+  elt_t mask (hb_codepoint_t g) const { return elt_t (1) << (g & MASK); }
+
+  hb_object_header_t header;
+  elt_t elts[ELTS]; /* 8kb */
+
+  ASSERT_STATIC (sizeof (elt_t) * 8 == BITS);
+  ASSERT_STATIC (sizeof (elts) * 8 > MAX_G);
+};
+
+
+
+#endif /* HB_SET_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-shape.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-shape.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-shape.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-shape.cc	2012-08-09 00:09:46.084761213 +0530
@@ -0,0 +1,152 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-shape.h"
+
+#include "hb-buffer-private.hh"
+
+#ifdef HAVE_GRAPHITE
+#include "hb-graphite2-private.hh"
+#endif
+#ifdef HAVE_UNISCRIBE
+# include "hb-uniscribe-private.hh"
+#endif
+#ifdef HAVE_OT
+# include "hb-ot-shape-private.hh"
+#endif
+#include "hb-fallback-shape-private.hh"
+
+typedef hb_bool_t (*hb_shape_func_t) (hb_font_t          *font,
+				      hb_buffer_t        *buffer,
+				      const hb_feature_t *features,
+				      unsigned int        num_features);
+
+#define HB_SHAPER_IMPLEMENT(name) {#name, _hb_##name##_shape}
+static struct hb_shaper_pair_t {
+  char name[16];
+  hb_shape_func_t func;
+} shapers[] = {
+  /* v--- Add new shapers in the right place here */
+#ifdef HAVE_GRAPHITE
+  HB_SHAPER_IMPLEMENT (graphite2),
+#endif
+#ifdef HAVE_UNISCRIBE
+  HB_SHAPER_IMPLEMENT (uniscribe),
+#endif
+#ifdef HAVE_OT
+  HB_SHAPER_IMPLEMENT (ot),
+#endif
+  HB_SHAPER_IMPLEMENT (fallback) /* should be last */
+};
+#undef HB_SHAPER_IMPLEMENT
+
+static struct static_shaper_list_t
+{
+  static_shaper_list_t (void)
+  {
+    char *env = getenv ("HB_SHAPER_LIST");
+    if (env && *env)
+    {
+       /* Reorder shaper list to prefer requested shaper list. */
+      unsigned int i = 0;
+      char *end, *p = env;
+      for (;;) {
+        end = strchr (p, ',');
+        if (!end)
+          end = p + strlen (p);
+
+	for (unsigned int j = i; j < ARRAY_LENGTH (shapers); j++)
+	  if (end - p == (int) strlen (shapers[j].name) &&
+	      0 == strncmp (shapers[j].name, p, end - p))
+	  {
+	    /* Reorder this shaper to position i */
+	   struct hb_shaper_pair_t t = shapers[j];
+	   memmove (&shapers[i + 1], &shapers[i], sizeof (shapers[i]) * (j - i));
+	   shapers[i] = t;
+	   i++;
+	  }
+
+        if (!*end)
+          break;
+        else
+          p = end + 1;
+      }
+    }
+
+    ASSERT_STATIC ((ARRAY_LENGTH (shapers) + 1) * sizeof (*shaper_list) <= sizeof (shaper_list));
+    unsigned int i;
+    for (i = 0; i < ARRAY_LENGTH (shapers); i++)
+      shaper_list[i] = shapers[i].name;
+    shaper_list[i] = NULL;
+  }
+
+  const char *shaper_list[ARRAY_LENGTH (shapers) + 1];
+} static_shaper_list;
+
+const char **
+hb_shape_list_shapers (void)
+{
+  return static_shaper_list.shaper_list;
+}
+
+hb_bool_t
+hb_shape_full (hb_font_t          *font,
+	       hb_buffer_t        *buffer,
+	       const hb_feature_t *features,
+	       unsigned int        num_features,
+	       const char * const *shaper_list)
+{
+//printf ( "(%s)(%d)(%s) (%X)  \n", __FILE__, __LINE__, __func__,buffer->info[0].codepoint) ;
+  hb_font_make_immutable (font); /* So we can safely cache stuff on it */
+
+  if (likely (!shaper_list)) {
+    for (unsigned int i = 0; i < ARRAY_LENGTH (shapers); i++)
+      if (likely (shapers[i].func (font, buffer, features, num_features)))
+        return TRUE;
+  } else {
+    while (*shaper_list) {
+      for (unsigned int i = 0; i < ARRAY_LENGTH (shapers); i++)
+	if (0 == strcmp (*shaper_list, shapers[i].name)) {
+	  if (likely (shapers[i].func (font, buffer, features, num_features)))
+	    return TRUE;
+	  break;
+	}
+      shaper_list++;
+    }
+  }
+  return FALSE;
+}
+
+void
+hb_shape (hb_font_t           *font,
+	  hb_buffer_t         *buffer,
+	  const hb_feature_t  *features,
+	  unsigned int         num_features)
+{
+  hb_shape_full (font, buffer, features, num_features, NULL);
+}
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-shape.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-shape.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-shape.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-shape.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,68 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_SHAPE_H
+#define HB_SHAPE_H
+
+#include "hb-common.h"
+#include "hb-buffer.h"
+#include "hb-font.h"
+
+HB_BEGIN_DECLS
+
+
+typedef struct _hb_feature_t {
+  hb_tag_t      tag;
+  uint32_t      value;
+  unsigned int  start;
+  unsigned int  end;
+} hb_feature_t;
+
+
+void
+hb_shape (hb_font_t           *font,
+	  hb_buffer_t         *buffer,
+	  const hb_feature_t  *features,
+	  unsigned int         num_features);
+
+hb_bool_t
+hb_shape_full (hb_font_t          *font,
+	       hb_buffer_t        *buffer,
+	       const hb_feature_t *features,
+	       unsigned int        num_features,
+	       const char * const *shaper_list);
+
+const char **
+hb_shape_list_shapers (void);
+
+
+HB_END_DECLS
+
+#endif /* HB_SHAPE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-tt-font.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-tt-font.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-tt-font.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-tt-font.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,242 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-open-type-private.hh"
+
+#include "hb-ot-hhea-table.hh"
+#include "hb-ot-hmtx-table.hh"
+
+#include "hb-font-private.hh"
+#include "hb-blob.h"
+
+#include <string.h>
+
+
+
+#if 0
+struct hb_tt_font_t
+{
+  const struct hhea *hhea;
+  hb_blob_t *hhea_blob;
+};
+
+
+static hb_tt_font_t *
+_hb_tt_font_create (hb_font_t *font)
+{
+  /* TODO Remove this object altogether */
+  hb_tt_font_t *tt = (hb_tt_font_t *) calloc (1, sizeof (hb_tt_font_t));
+
+  tt->hhea_blob = Sanitizer<hhea>::sanitize (hb_face_reference_table (font->face, HB_OT_TAG_hhea));
+  tt->hhea = Sanitizer<hhea>::lock_instance (tt->hhea_blob);
+
+  return tt;
+}
+
+static void
+_hb_tt_font_destroy (hb_tt_font_t *tt)
+{
+  hb_blob_destroy (tt->hhea_blob);
+
+  free (tt);
+}
+
+static inline const hhea&
+_get_hhea (hb_face_t *face)
+{
+//  return likely (face->tt && face->tt->hhea) ? *face->tt->hhea : Null(hhea);
+}
+
+
+/*
+ * hb_tt_font_funcs_t
+ */
+
+static hb_bool_t
+hb_font_get_glyph_nil (hb_font_t *font HB_UNUSED,
+		       void *font_data HB_UNUSED,
+		       hb_codepoint_t unicode,
+		       hb_codepoint_t variation_selector,
+		       hb_codepoint_t *glyph,
+		       void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return hb_font_get_glyph (font->parent, unicode, variation_selector, glyph);
+
+  *glyph = 0;
+  return FALSE;
+}
+
+static hb_position_t
+hb_font_get_glyph_h_advance_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_x_distance (hb_font_get_glyph_h_advance (font->parent, glyph));
+
+  return font->x_scale;
+}
+
+static hb_position_t
+hb_font_get_glyph_v_advance_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_y_distance (hb_font_get_glyph_v_advance (font->parent, glyph));
+
+  return font->y_scale;
+}
+
+static hb_bool_t
+hb_font_get_glyph_h_origin_nil (hb_font_t *font HB_UNUSED,
+				void *font_data HB_UNUSED,
+				hb_codepoint_t glyph,
+				hb_position_t *x,
+				hb_position_t *y,
+				void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_h_origin (font->parent,
+						glyph,
+						x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+static hb_bool_t
+hb_font_get_glyph_v_origin_nil (hb_font_t *font HB_UNUSED,
+				void *font_data HB_UNUSED,
+				hb_codepoint_t glyph,
+				hb_position_t *x,
+				hb_position_t *y,
+				void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_v_origin (font->parent,
+						glyph,
+						x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+static hb_position_t
+hb_font_get_glyph_h_kerning_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t left_glyph,
+				 hb_codepoint_t right_glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_x_distance (hb_font_get_glyph_h_kerning (font->parent, left_glyph, right_glyph));
+
+  return 0;
+}
+
+static hb_position_t
+hb_font_get_glyph_v_kerning_nil (hb_font_t *font HB_UNUSED,
+				 void *font_data HB_UNUSED,
+				 hb_codepoint_t top_glyph,
+				 hb_codepoint_t bottom_glyph,
+				 void *user_data HB_UNUSED)
+{
+  if (font->parent)
+    return font->parent_scale_y_distance (hb_font_get_glyph_v_kerning (font->parent, top_glyph, bottom_glyph));
+
+  return 0;
+}
+
+static hb_bool_t
+hb_font_get_glyph_extents_nil (hb_font_t *font HB_UNUSED,
+			       void *font_data HB_UNUSED,
+			       hb_codepoint_t glyph,
+			       hb_glyph_extents_t *extents,
+			       void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_extents (font->parent,
+					       glyph,
+					       extents);
+    if (ret) {
+      font->parent_scale_position (&extents->x_bearing, &extents->y_bearing);
+      font->parent_scale_distance (&extents->width, &extents->height);
+    }
+    return ret;
+  }
+
+  memset (extents, 0, sizeof (*extents));
+  return FALSE;
+}
+
+static hb_bool_t
+hb_font_get_glyph_contour_point_nil (hb_font_t *font HB_UNUSED,
+				     void *font_data HB_UNUSED,
+				     hb_codepoint_t glyph,
+				     unsigned int point_index,
+				     hb_position_t *x,
+				     hb_position_t *y,
+				     void *user_data HB_UNUSED)
+{
+  if (font->parent) {
+    hb_bool_t ret = hb_font_get_glyph_contour_point (font->parent,
+						     glyph, point_index,
+						     x, y);
+    if (ret)
+      font->parent_scale_position (x, y);
+    return ret;
+  }
+
+  *x = *y = 0;
+  return FALSE;
+}
+
+
+static hb_font_funcs_t _hb_font_funcs_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  TRUE, /* immutable */
+
+  {
+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,
+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_FONT_FUNC_IMPLEMENT
+  }
+};
+#endif
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.c Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.c
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.c	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.c	2012-05-05 23:46:51.528763796 +0530
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.h"
+
+#include "hb-unicode-private.h"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * hb_unicode_funcs_t
+ */
+
+static hb_codepoint_t hb_unicode_get_mirroring_nil (hb_codepoint_t unicode) { return unicode; }
+static hb_category_t hb_unicode_get_general_category_nil (hb_codepoint_t unicode HB_UNUSED) { return HB_CATEGORY_OTHER_LETTER; }
+static hb_script_t hb_unicode_get_script_nil (hb_codepoint_t unicode HB_UNUSED) { return HB_SCRIPT_UNKNOWN; }
+static unsigned int hb_unicode_get_combining_class_nil (hb_codepoint_t unicode HB_UNUSED) { return 0; }
+static unsigned int hb_unicode_get_eastasian_width_nil (hb_codepoint_t unicode HB_UNUSED) { return 1; }
+
+hb_unicode_funcs_t _hb_unicode_funcs_nil = {
+  HB_REFERENCE_COUNT_INVALID, /* ref_count */
+  TRUE, /* immutable */
+  {
+    hb_unicode_get_general_category_nil,
+    hb_unicode_get_combining_class_nil,
+    hb_unicode_get_mirroring_nil,
+    hb_unicode_get_script_nil,
+    hb_unicode_get_eastasian_width_nil
+  }
+};
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_create (void)
+{
+  hb_unicode_funcs_t *ufuncs;
+
+  if (!HB_OBJECT_DO_CREATE (hb_unicode_funcs_t, ufuncs))
+    return &_hb_unicode_funcs_nil;
+
+  ufuncs->v = _hb_unicode_funcs_nil.v;
+
+  return ufuncs;
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)
+{
+  HB_OBJECT_DO_REFERENCE (ufuncs);
+}
+
+unsigned int
+hb_unicode_funcs_get_reference_count (hb_unicode_funcs_t *ufuncs)
+{
+  HB_OBJECT_DO_GET_REFERENCE_COUNT (ufuncs);
+}
+
+void
+hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs)
+{
+  HB_OBJECT_DO_DESTROY (ufuncs);
+
+  free (ufuncs);
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_copy (hb_unicode_funcs_t *other_ufuncs)
+{
+  hb_unicode_funcs_t *ufuncs;
+
+  if (!HB_OBJECT_DO_CREATE (hb_unicode_funcs_t, ufuncs))
+    return &_hb_unicode_funcs_nil;
+
+  ufuncs->v = other_ufuncs->v;
+
+  return ufuncs;
+}
+
+void
+hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)
+{
+  if (HB_OBJECT_IS_INERT (ufuncs))
+    return;
+
+  ufuncs->immutable = TRUE;
+}
+
+hb_bool_t
+hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->immutable;
+}
+
+
+void
+hb_unicode_funcs_set_mirroring_func (hb_unicode_funcs_t *ufuncs,
+				     hb_unicode_get_mirroring_func_t mirroring_func)
+{
+  if (ufuncs->immutable)
+    return;
+
+  ufuncs->v.get_mirroring = mirroring_func ? mirroring_func : hb_unicode_get_mirroring_nil;
+}
+
+void
+hb_unicode_funcs_set_general_category_func (hb_unicode_funcs_t *ufuncs,
+					    hb_unicode_get_general_category_func_t general_category_func)
+{
+  if (ufuncs->immutable)
+    return;
+
+  ufuncs->v.get_general_category = general_category_func ? general_category_func : hb_unicode_get_general_category_nil;
+}
+
+void
+hb_unicode_funcs_set_script_func (hb_unicode_funcs_t *ufuncs,
+				  hb_unicode_get_script_func_t script_func)
+{
+  if (ufuncs->immutable)
+    return;
+
+  ufuncs->v.get_script = script_func ? script_func : hb_unicode_get_script_nil;
+}
+
+void
+hb_unicode_funcs_set_combining_class_func (hb_unicode_funcs_t *ufuncs,
+					   hb_unicode_get_combining_class_func_t combining_class_func)
+{
+  if (ufuncs->immutable)
+    return;
+
+  ufuncs->v.get_combining_class = combining_class_func ? combining_class_func : hb_unicode_get_combining_class_nil;
+}
+
+void
+hb_unicode_funcs_set_eastasian_width_func (hb_unicode_funcs_t *ufuncs,
+					   hb_unicode_get_eastasian_width_func_t eastasian_width_func)
+{
+  if (ufuncs->immutable)
+    return;
+
+  ufuncs->v.get_eastasian_width = eastasian_width_func ? eastasian_width_func : hb_unicode_get_eastasian_width_nil;
+}
+
+
+hb_unicode_get_mirroring_func_t
+hb_unicode_funcs_get_mirroring_func (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->v.get_mirroring;
+}
+
+hb_unicode_get_general_category_func_t
+hb_unicode_funcs_get_general_category_func (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->v.get_general_category;
+}
+
+hb_unicode_get_script_func_t
+hb_unicode_funcs_get_script_func (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->v.get_script;
+}
+
+hb_unicode_get_combining_class_func_t
+hb_unicode_funcs_get_combining_class_func (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->v.get_combining_class;
+}
+
+hb_unicode_get_eastasian_width_func_t
+hb_unicode_funcs_get_eastasian_width_func (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->v.get_eastasian_width;
+}
+
+
+
+hb_codepoint_t
+hb_unicode_get_mirroring (hb_unicode_funcs_t *ufuncs,
+			  hb_codepoint_t unicode)
+{
+  return ufuncs->v.get_mirroring (unicode);
+}
+
+hb_category_t
+hb_unicode_get_general_category (hb_unicode_funcs_t *ufuncs,
+				 hb_codepoint_t unicode)
+{
+  return ufuncs->v.get_general_category (unicode);
+}
+
+hb_script_t
+hb_unicode_get_script (hb_unicode_funcs_t *ufuncs,
+		       hb_codepoint_t unicode)
+{
+  return ufuncs->v.get_script (unicode);
+}
+
+unsigned int
+hb_unicode_get_combining_class (hb_unicode_funcs_t *ufuncs,
+				hb_codepoint_t unicode)
+{
+  return ufuncs->v.get_combining_class (unicode);
+}
+
+unsigned int
+hb_unicode_get_eastasian_width (hb_unicode_funcs_t *ufuncs,
+				hb_codepoint_t unicode)
+{
+  return ufuncs->v.get_eastasian_width (unicode);
+}
+
+
+
+#define LTR HB_DIRECTION_LTR
+#define RTL HB_DIRECTION_RTL
+const hb_direction_t horiz_dir[] =
+{
+  LTR,	/* Zyyy */
+  LTR,	/* Qaai */
+  RTL,	/* Arab */
+  LTR,	/* Armn */
+  LTR,	/* Beng */
+  LTR,	/* Bopo */
+  LTR,	/* Cher */
+  LTR,	/* Qaac */
+  LTR,	/* Cyrl (Cyrs) */
+  LTR,	/* Dsrt */
+  LTR,	/* Deva */
+  LTR,	/* Ethi */
+  LTR,	/* Geor (Geon, Geoa) */
+  LTR,	/* Goth */
+  LTR,	/* Grek */
+  LTR,	/* Gujr */
+  LTR,	/* Guru */
+  LTR,	/* Hani */
+  LTR,	/* Hang */
+  RTL,	/* Hebr */
+  LTR,	/* Hira */
+  LTR,	/* Knda */
+  LTR,	/* Kana */
+  LTR,	/* Khmr */
+  LTR,	/* Laoo */
+  LTR,	/* Latn (Latf, Latg) */
+  LTR,	/* Mlym */
+  LTR,	/* Mong */
+  LTR,	/* Mymr */
+  LTR,	/* Ogam */
+  LTR,	/* Ital */
+  LTR,	/* Orya */
+  LTR,	/* Runr */
+  LTR,	/* Sinh */
+  RTL,	/* Syrc (Syrj, Syrn, Syre) */
+  LTR,	/* Taml */
+  LTR,	/* Telu */
+  RTL,	/* Thaa */
+  LTR,	/* Thai */
+  LTR,	/* Tibt */
+  LTR,	/* Cans */
+  LTR,	/* Yiii */
+  LTR,	/* Tglg */
+  LTR,	/* Hano */
+  LTR,	/* Buhd */
+  LTR,	/* Tagb */
+
+  /* Unicode-4.0 additions */
+  LTR,	/* Brai */
+  RTL,	/* Cprt */
+  LTR,	/* Limb */
+  LTR,	/* Osma */
+  LTR,	/* Shaw */
+  LTR,	/* Linb */
+  LTR,	/* Tale */
+  LTR,	/* Ugar */
+
+  /* Unicode-4.1 additions */
+  LTR,	/* Talu */
+  LTR,	/* Bugi */
+  LTR,	/* Glag */
+  LTR,	/* Tfng */
+  LTR,	/* Sylo */
+  LTR,	/* Xpeo */
+  LTR,	/* Khar */
+
+  /* Unicode-5.0 additions */
+  LTR,	/* Zzzz */
+  LTR,	/* Bali */
+  LTR,	/* Xsux */
+  RTL,	/* Phnx */
+  LTR,	/* Phag */
+  RTL,	/* Nkoo */
+
+  /* Unicode-5.1 additions */
+  LTR,	/* Kali */
+  LTR,	/* Lepc */
+  LTR,	/* Rjng */
+  LTR,	/* Sund */
+  LTR,	/* Saur */
+  LTR,	/* Cham */
+  LTR,	/* Olck */
+  LTR,	/* Vaii */
+  LTR,	/* Cari */
+  LTR,	/* Lyci */
+  LTR,	/* Lydi */
+
+  /* Unicode-5.2 additions */
+  RTL,	/* Avst */
+  LTR,	/* Bamu */
+  LTR,	/* Egyp */
+  RTL,	/* Armi */
+  RTL,	/* Phli */
+  RTL,	/* Prti */
+  LTR,	/* Java */
+  LTR,	/* Kthi */
+  LTR,	/* Lisu */
+  LTR,	/* Mtei */
+  RTL,	/* Sarb */
+  RTL,	/* Orkh */
+  RTL,	/* Samr */
+  LTR,	/* Lana */
+  LTR 	/* Tavt */
+};
+#undef LTR
+#undef RTL
+
+hb_direction_t
+_hb_script_get_horizontal_direction (hb_script_t script)
+{
+  if (unlikely ((unsigned int) script >= ARRAY_LENGTH (horiz_dir)))
+    return HB_DIRECTION_LTR;
+
+  return horiz_dir[script];
+}
+
+
+HB_END_DECLS
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.cc	2012-05-07 19:04:19.427305541 +0530
@@ -0,0 +1,346 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011 Codethink Limited
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Codethink Author(s): Ryan Lortie
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-private.hh"
+
+#include "hb-unicode-private.hh"
+
+
+
+/*
+ * hb_unicode_funcs_t
+ */
+
+static unsigned int
+hb_unicode_combining_class_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+				hb_codepoint_t      unicode   HB_UNUSED,
+				void               *user_data HB_UNUSED)
+{
+  return 0;
+}
+
+static unsigned int
+hb_unicode_eastasian_width_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+				hb_codepoint_t      unicode   HB_UNUSED,
+				void               *user_data HB_UNUSED)
+{
+  return 1;
+}
+
+static hb_unicode_general_category_t
+hb_unicode_general_category_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+				 hb_codepoint_t      unicode   HB_UNUSED,
+				 void               *user_data HB_UNUSED)
+{
+  return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER;
+}
+
+static hb_codepoint_t
+hb_unicode_mirroring_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+			  hb_codepoint_t      unicode   HB_UNUSED,
+			  void               *user_data HB_UNUSED)
+{
+  return unicode;
+}
+
+static hb_script_t
+hb_unicode_script_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+		       hb_codepoint_t      unicode   HB_UNUSED,
+		       void               *user_data HB_UNUSED)
+{
+//printf ( "(%s)(%d)(%s) -(%X)  \n", __FILE__, __LINE__, __func__,  unicode ) ;
+  return HB_SCRIPT_UNKNOWN;
+}
+
+static hb_bool_t
+hb_unicode_compose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+			hb_codepoint_t      a         HB_UNUSED,
+			hb_codepoint_t      b         HB_UNUSED,
+			hb_codepoint_t     *ab        HB_UNUSED,
+			void               *user_data HB_UNUSED)
+{
+  /* TODO handle Hangul jamo here? */
+  return FALSE;
+}
+
+static hb_bool_t
+hb_unicode_decompose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
+			  hb_codepoint_t      ab        HB_UNUSED,
+			  hb_codepoint_t     *a         HB_UNUSED,
+			  hb_codepoint_t     *b         HB_UNUSED,
+			  void               *user_data HB_UNUSED)
+{
+//printf ( "(%s)(%d)(%s) -(%X)  \n", __FILE__, __LINE__, __func__,  ab ) ;
+  /* TODO handle Hangul jamo here? */
+  switch ( ab ) {
+     case 0xd4a : 
+         *a = 0xd46 ;
+         *b = 0xd3e ;
+         return TRUE;
+       break ;
+     case 0xd4b : 
+         *a = 0xd47 ;
+         *b = 0xd3e ;
+         return TRUE;
+       break ;
+     case 0xd4c : 
+         *a = 0xd57 ;
+         return TRUE;
+       break ;
+  }
+  return FALSE;
+}
+
+
+hb_unicode_funcs_t _hb_unicode_funcs_nil = {
+  HB_OBJECT_HEADER_STATIC,
+
+  NULL, /* parent */
+  TRUE, /* immutable */
+  {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  }
+};
+
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_default (void)
+{
+  return &_hb_unicode_funcs_default;
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_create (hb_unicode_funcs_t *parent)
+{
+  hb_unicode_funcs_t *ufuncs;
+
+  if (!(ufuncs = hb_object_create<hb_unicode_funcs_t> ()))
+    return &_hb_unicode_funcs_nil;
+
+  if (!parent)
+    parent = &_hb_unicode_funcs_nil;
+
+  hb_unicode_funcs_make_immutable (parent);
+  ufuncs->parent = hb_unicode_funcs_reference (parent);
+
+  ufuncs->func = parent->func;
+
+  /* We can safely copy user_data from parent since we hold a reference
+   * onto it and it's immutable.  We should not copy the destroy notifiers
+   * though. */
+  ufuncs->user_data = parent->user_data;
+
+  return ufuncs;
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_empty (void)
+{
+  return &_hb_unicode_funcs_nil;
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)
+{
+  return hb_object_reference (ufuncs);
+}
+
+void
+hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs)
+{
+  if (!hb_object_destroy (ufuncs)) return;
+
+#define HB_UNICODE_FUNC_IMPLEMENT(name) \
+  if (ufuncs->destroy.name) ufuncs->destroy.name (ufuncs->user_data.name);
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+
+  hb_unicode_funcs_destroy (ufuncs->parent);
+
+  free (ufuncs);
+}
+
+hb_bool_t
+hb_unicode_funcs_set_user_data (hb_unicode_funcs_t *ufuncs,
+			        hb_user_data_key_t *key,
+			        void *              data,
+			        hb_destroy_func_t   destroy,
+				hb_bool_t           replace)
+{
+  return hb_object_set_user_data (ufuncs, key, data, destroy, replace);
+}
+
+void *
+hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,
+			        hb_user_data_key_t *key)
+{
+  return hb_object_get_user_data (ufuncs, key);
+}
+
+
+void
+hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)
+{
+  if (hb_object_is_inert (ufuncs))
+    return;
+
+  ufuncs->immutable = TRUE;
+}
+
+hb_bool_t
+hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->immutable;
+}
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs)
+{
+  return ufuncs->parent ? ufuncs->parent : &_hb_unicode_funcs_nil;
+}
+
+
+#define HB_UNICODE_FUNC_IMPLEMENT(name)						\
+										\
+void										\
+hb_unicode_funcs_set_##name##_func (hb_unicode_funcs_t		   *ufuncs,	\
+				    hb_unicode_##name##_func_t	    func,	\
+				    void			   *user_data,	\
+				    hb_destroy_func_t		    destroy)	\
+{										\
+  if (ufuncs->immutable)							\
+    return;									\
+										\
+  if (ufuncs->destroy.name)							\
+    ufuncs->destroy.name (ufuncs->user_data.name);				\
+										\
+  if (func) {									\
+    ufuncs->func.name = func;							\
+    ufuncs->user_data.name = user_data;						\
+    ufuncs->destroy.name = destroy;						\
+  } else {									\
+    ufuncs->func.name = ufuncs->parent->func.name;				\
+    ufuncs->user_data.name = ufuncs->parent->user_data.name;			\
+    ufuncs->destroy.name = NULL;						\
+  }										\
+}
+
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+
+
+#define HB_UNICODE_FUNC_IMPLEMENT(return_type, name)				\
+										\
+return_type									\
+hb_unicode_##name (hb_unicode_funcs_t *ufuncs,					\
+		   hb_codepoint_t      unicode)					\
+{										\
+  return ufuncs->func.name (ufuncs, unicode, ufuncs->user_data.name);		\
+}
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE
+#undef HB_UNICODE_FUNC_IMPLEMENT
+
+hb_bool_t
+hb_unicode_compose (hb_unicode_funcs_t *ufuncs,
+		    hb_codepoint_t      a,
+		    hb_codepoint_t      b,
+		    hb_codepoint_t     *ab)
+{
+  *ab = 0;
+  return ufuncs->func.compose (ufuncs, a, b, ab, ufuncs->user_data.compose);
+}
+
+hb_bool_t
+hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
+		      hb_codepoint_t      ab,
+		      hb_codepoint_t     *a,
+		      hb_codepoint_t     *b)
+{
+  *a = ab; *b = 0;
+  return ufuncs->func.decompose (ufuncs, ab, a, b, ufuncs->user_data.decompose);
+}
+
+
+
+unsigned int
+_hb_unicode_modified_combining_class (hb_unicode_funcs_t *ufuncs,
+				      hb_codepoint_t      unicode)
+{
+  int c = hb_unicode_combining_class (ufuncs, unicode);
+
+  if (unlikely (hb_in_range<int> (c, 27, 33)))
+  {
+    /* Modify the combining-class to suit Arabic better.  See:
+     * http://unicode.org/faq/normalization.html#8
+     * http://unicode.org/faq/normalization.html#9
+     */
+    c = c == 33 ? 27 : c + 1;
+  }
+  else if (unlikely (hb_in_range<int> (c, 10, 25)))
+  {
+    /* The equivalent fix for Hebrew is more complex.
+     *
+     * We permute the "fixed-position" classes 10-25 into the order
+     * described in the SBL Hebrew manual:
+     *
+     * http://www.sbl-site.org/Fonts/SBLHebrewUserManual1.5x.pdf
+     *
+     * (as recommended by:
+     *  http://forum.fontlab.com/archive-old-microsoft-volt-group/vista-and-diacritic-ordering-t6751.0.html)
+     *
+     * More details here:
+     * https://bugzilla.mozilla.org/show_bug.cgi?id=662055
+     */
+    static const int permuted_hebrew_classes[25 - 10 + 1] = {
+      /* 10 sheva */        22,
+      /* 11 hataf segol */  15,
+      /* 12 hataf patah */  16,
+      /* 13 hataf qamats */ 17,
+      /* 14 hiriq */        23,
+      /* 15 tsere */        18,
+      /* 16 segol */        19,
+      /* 17 patah */        20,
+      /* 18 qamats */       21,
+      /* 19 holam */        14,
+      /* 20 qubuts */       24,
+      /* 21 dagesh */       12,
+      /* 22 meteg */        25,
+      /* 23 rafe */         13,
+      /* 24 shin dot */     10,
+      /* 25 sin dot */      11,
+    };
+    c = permuted_hebrew_classes[c - 10];
+  }
+
+  return c;
+}
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,198 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Codethink Limited
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Codethink Author(s): Ryan Lortie
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_UNICODE_H
+#define HB_UNICODE_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * hb_unicode_funcs_t
+ */
+
+typedef struct _hb_unicode_funcs_t hb_unicode_funcs_t;
+
+
+/*
+ * just give me the best implementation you've got there.
+ */
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_default (void);
+
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_create (hb_unicode_funcs_t *parent);
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_empty (void);
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs);
+
+void
+hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs);
+
+hb_bool_t
+hb_unicode_funcs_set_user_data (hb_unicode_funcs_t *ufuncs,
+			        hb_user_data_key_t *key,
+			        void *              data,
+			        hb_destroy_func_t   destroy,
+				hb_bool_t           replace);
+
+
+void *
+hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,
+			        hb_user_data_key_t *key);
+
+
+void
+hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs);
+
+hb_bool_t
+hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs);
+
+hb_unicode_funcs_t *
+hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs);
+
+
+/*
+ * funcs
+ */
+
+/* typedefs */
+
+typedef unsigned int			(*hb_unicode_combining_class_func_t)	(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      unicode,
+										 void               *user_data);
+typedef unsigned int			(*hb_unicode_eastasian_width_func_t)	(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      unicode,
+										 void               *user_data);
+typedef hb_unicode_general_category_t	(*hb_unicode_general_category_func_t)	(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      unicode,
+										 void               *user_data);
+typedef hb_codepoint_t			(*hb_unicode_mirroring_func_t)		(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      unicode,
+										 void               *user_data);
+typedef hb_script_t			(*hb_unicode_script_func_t)		(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      unicode,
+										 void               *user_data);
+
+typedef hb_bool_t			(*hb_unicode_compose_func_t)		(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      a,
+										 hb_codepoint_t      b,
+										 hb_codepoint_t     *ab,
+										 void               *user_data);
+typedef hb_bool_t			(*hb_unicode_decompose_func_t)		(hb_unicode_funcs_t *ufuncs,
+										 hb_codepoint_t      ab,
+										 hb_codepoint_t     *a,
+										 hb_codepoint_t     *b,
+										 void               *user_data);
+
+/* setters */
+
+void
+hb_unicode_funcs_set_combining_class_func (hb_unicode_funcs_t *ufuncs,
+					   hb_unicode_combining_class_func_t combining_class_func,
+					   void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_eastasian_width_func (hb_unicode_funcs_t *ufuncs,
+					   hb_unicode_eastasian_width_func_t eastasian_width_func,
+					   void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_general_category_func (hb_unicode_funcs_t *ufuncs,
+					    hb_unicode_general_category_func_t general_category_func,
+					    void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_mirroring_func (hb_unicode_funcs_t *ufuncs,
+				     hb_unicode_mirroring_func_t mirroring_func,
+				     void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_script_func (hb_unicode_funcs_t *ufuncs,
+				  hb_unicode_script_func_t script_func,
+				  void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_compose_func (hb_unicode_funcs_t *ufuncs,
+				   hb_unicode_compose_func_t compose_func,
+				   void *user_data, hb_destroy_func_t destroy);
+
+void
+hb_unicode_funcs_set_decompose_func (hb_unicode_funcs_t *ufuncs,
+				     hb_unicode_decompose_func_t decompose_func,
+				     void *user_data, hb_destroy_func_t destroy);
+
+
+/* accessors */
+
+unsigned int
+hb_unicode_combining_class (hb_unicode_funcs_t *ufuncs,
+			    hb_codepoint_t unicode);
+
+unsigned int
+hb_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs,
+			    hb_codepoint_t unicode);
+
+hb_unicode_general_category_t
+hb_unicode_general_category (hb_unicode_funcs_t *ufuncs,
+			     hb_codepoint_t unicode);
+
+hb_codepoint_t
+hb_unicode_mirroring (hb_unicode_funcs_t *ufuncs,
+		      hb_codepoint_t unicode);
+
+hb_script_t
+hb_unicode_script (hb_unicode_funcs_t *ufuncs,
+		   hb_codepoint_t unicode);
+
+hb_bool_t
+hb_unicode_compose (hb_unicode_funcs_t *ufuncs,
+		    hb_codepoint_t      a,
+		    hb_codepoint_t      b,
+		    hb_codepoint_t     *ab);
+hb_bool_t
+hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
+		      hb_codepoint_t      ab,
+		      hb_codepoint_t     *a,
+		      hb_codepoint_t     *b);
+
+HB_END_DECLS
+
+#endif /* HB_UNICODE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode-private.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode-private.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode-private.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode-private.h	2012-05-05 23:46:51.531763797 +0530
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2009  Red Hat, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_UNICODE_PRIVATE_H
+#define HB_UNICODE_PRIVATE_H
+
+#include "hb-private.h"
+
+#include "hb-unicode.h"
+
+HB_BEGIN_DECLS
+
+
+/*
+ * hb_unicode_funcs_t
+ */
+
+struct _hb_unicode_funcs_t {
+  hb_reference_count_t ref_count;
+
+  hb_bool_t immutable;
+
+  struct {
+    hb_unicode_get_general_category_func_t	get_general_category;
+    hb_unicode_get_combining_class_func_t	get_combining_class;
+    hb_unicode_get_mirroring_func_t		get_mirroring;
+    hb_unicode_get_script_func_t		get_script;
+    hb_unicode_get_eastasian_width_func_t	get_eastasian_width;
+  } v;
+};
+
+extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_nil;
+
+
+HB_INTERNAL hb_direction_t
+_hb_script_get_horizontal_direction (hb_script_t script);
+
+
+HB_END_DECLS
+
+#endif /* HB_UNICODE_PRIVATE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-unicode-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-unicode-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,118 @@
+/*
+ * Copyright  2009  Red Hat, Inc.
+ * Copyright  2011  Codethink Limited
+ * Copyright  2010,2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Red Hat Author(s): Behdad Esfahbod
+ * Codethink Author(s): Ryan Lortie
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_UNICODE_PRIVATE_HH
+#define HB_UNICODE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-unicode.h"
+#include "hb-object-private.hh"
+
+
+
+/*
+ * hb_unicode_funcs_t
+ */
+
+#define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS \
+  HB_UNICODE_FUNC_IMPLEMENT (combining_class) \
+  HB_UNICODE_FUNC_IMPLEMENT (eastasian_width) \
+  HB_UNICODE_FUNC_IMPLEMENT (general_category) \
+  HB_UNICODE_FUNC_IMPLEMENT (mirroring) \
+  HB_UNICODE_FUNC_IMPLEMENT (script) \
+  HB_UNICODE_FUNC_IMPLEMENT (compose) \
+  HB_UNICODE_FUNC_IMPLEMENT (decompose) \
+  /* ^--- Add new callbacks here */
+
+/* Simple callbacks are those taking a hb_codepoint_t and returning a hb_codepoint_t */
+#define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE \
+  HB_UNICODE_FUNC_IMPLEMENT (unsigned int, combining_class) \
+  HB_UNICODE_FUNC_IMPLEMENT (unsigned int, eastasian_width) \
+  HB_UNICODE_FUNC_IMPLEMENT (hb_unicode_general_category_t, general_category) \
+  HB_UNICODE_FUNC_IMPLEMENT (hb_codepoint_t, mirroring) \
+  HB_UNICODE_FUNC_IMPLEMENT (hb_script_t, script) \
+  /* ^--- Add new simple callbacks here */
+
+struct _hb_unicode_funcs_t {
+  hb_object_header_t header;
+
+  hb_unicode_funcs_t *parent;
+
+  bool immutable;
+
+  /* Don't access these directly.  Call hb_unicode_*() instead. */
+
+  struct {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_func_t name;
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  } func;
+
+  struct {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) void *name;
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  } user_data;
+
+  struct {
+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_destroy_func_t name;
+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
+#undef HB_UNICODE_FUNC_IMPLEMENT
+  } destroy;
+};
+
+
+#ifdef HAVE_GLIB
+extern HB_INTERNAL hb_unicode_funcs_t _hb_glib_unicode_funcs;
+#define _hb_unicode_funcs_default _hb_glib_unicode_funcs
+#elif defined(HAVE_ICU)
+extern HB_INTERNAL hb_unicode_funcs_t _hb_icu_unicode_funcs;
+#define _hb_unicode_funcs_default _hb_icu_unicode_funcs
+#else
+extern HB_INTERNAL hb_unicode_funcs_t _hb_unicode_funcs_nil;
+#define _hb_unicode_funcs_default _hb_unicode_funcs_nil
+#endif
+
+
+HB_INTERNAL unsigned int
+_hb_unicode_modified_combining_class (hb_unicode_funcs_t *ufuncs,
+				      hb_codepoint_t      unicode);
+
+static inline hb_bool_t
+_hb_unicode_is_variation_selector (hb_codepoint_t unicode)
+{
+  return unlikely ((unicode >=  0x180B && unicode <=  0x180D) || /* MONGOLIAN FREE VARIATION SELECTOR ONE..THREE */
+		   (unicode >=  0xFE00 && unicode <=  0xFE0F) || /* VARIATION SELECTOR-1..16 */
+		   (unicode >= 0xE0100 && unicode <= 0xE01EF));  /* VARIATION SELECTOR-17..256 */
+}
+
+
+#endif /* HB_UNICODE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,462 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#define _WIN32_WINNT 0x0500
+
+#include "hb-private.hh"
+
+#include <windows.h>
+#include <usp10.h>
+
+typedef ULONG WIN_ULONG;
+
+#include "hb-uniscribe.h"
+
+#include "hb-ot-name-table.hh"
+#include "hb-ot-tag.h"
+
+#include "hb-font-private.hh"
+#include "hb-buffer-private.hh"
+
+
+
+#ifndef HB_DEBUG_UNISCRIBE
+#define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)
+#endif
+
+
+/*
+DWORD GetFontData(
+  __in   HDC hdc,
+  __in   DWORD dwTable,
+  __in   DWORD dwOffset,
+  __out  LPVOID lpvBuffer,
+  __in   DWORD cbData
+);
+*/
+
+static bool
+populate_log_font (LOGFONTW  *lf,
+		   HDC        hdc,
+		   hb_font_t *font)
+{
+  memset (lf, 0, sizeof (*lf));
+  int dpi = GetDeviceCaps (hdc, LOGPIXELSY);
+  lf->lfHeight = -font->y_scale;
+
+  hb_blob_t *blob = Sanitizer<name>::sanitize (hb_face_reference_table (font->face, HB_TAG ('n','a','m','e')));
+  const name *name_table = Sanitizer<name>::lock_instance (blob);
+  unsigned int len = name_table->get_name (3, 1, 0x409, 4,
+					   lf->lfFaceName,
+					   sizeof (lf->lfFaceName[0]) * LF_FACESIZE)
+					  / sizeof (lf->lfFaceName[0]);
+  hb_blob_destroy (blob);
+
+  if (unlikely (!len)) {
+    DEBUG_MSG (UNISCRIBE, NULL, "Didn't find English name table entry");
+    return FALSE;
+  }
+  if (unlikely (len >= LF_FACESIZE)) {
+    DEBUG_MSG (UNISCRIBE, NULL, "Font name too long");
+    return FALSE;
+  }
+
+  for (unsigned int i = 0; i < len; i++)
+    lf->lfFaceName[i] = hb_be_uint16 (lf->lfFaceName[i]);
+  lf->lfFaceName[len] = 0;
+
+  return TRUE;
+}
+
+
+static hb_user_data_key_t hb_uniscribe_data_key;
+
+
+static struct hb_uniscribe_face_data_t {
+  HANDLE fh;
+} _hb_uniscribe_face_data_nil = {0};
+
+static void
+_hb_uniscribe_face_data_destroy (hb_uniscribe_face_data_t *data)
+{
+  if (data->fh)
+    RemoveFontMemResourceEx (data->fh);
+  free (data);
+}
+
+static hb_uniscribe_face_data_t *
+_hb_uniscribe_face_get_data (hb_face_t *face)
+{
+  hb_uniscribe_face_data_t *data = (hb_uniscribe_face_data_t *) hb_face_get_user_data (face, &hb_uniscribe_data_key);
+  if (likely (data)) return data;
+
+  data = (hb_uniscribe_face_data_t *) calloc (1, sizeof (hb_uniscribe_face_data_t));
+  if (unlikely (!data))
+    return &_hb_uniscribe_face_data_nil;
+
+
+  hb_blob_t *blob = hb_face_reference_blob (face);
+  unsigned int blob_length;
+  const char *blob_data = hb_blob_get_data (blob, &blob_length);
+  if (unlikely (!blob_length))
+    DEBUG_MSG (UNISCRIBE, face, "Face has empty blob");
+
+  DWORD num_fonts_installed;
+  data->fh = AddFontMemResourceEx ((void *) blob_data, blob_length, 0, &num_fonts_installed);
+  hb_blob_destroy (blob);
+  if (unlikely (!data->fh))
+    DEBUG_MSG (UNISCRIBE, face, "Face AddFontMemResourceEx() failed");
+
+
+  if (unlikely (!hb_face_set_user_data (face, &hb_uniscribe_data_key, data,
+					(hb_destroy_func_t) _hb_uniscribe_face_data_destroy,
+					FALSE)))
+  {
+    _hb_uniscribe_face_data_destroy (data);
+    data = (hb_uniscribe_face_data_t *) hb_face_get_user_data (face, &hb_uniscribe_data_key);
+    if (data)
+      return data;
+    else
+      return &_hb_uniscribe_face_data_nil;
+  }
+
+  return data;
+}
+
+
+static struct hb_uniscribe_font_data_t {
+  HDC hdc;
+  LOGFONTW log_font;
+  HFONT hfont;
+  SCRIPT_CACHE script_cache;
+} _hb_uniscribe_font_data_nil = {NULL, NULL, NULL};
+
+static void
+_hb_uniscribe_font_data_destroy (hb_uniscribe_font_data_t *data)
+{
+  if (data->hdc)
+    ReleaseDC (NULL, data->hdc);
+  if (data->hfont)
+    DeleteObject (data->hfont);
+  if (data->script_cache)
+    ScriptFreeCache (&data->script_cache);
+  free (data);
+}
+
+static hb_uniscribe_font_data_t *
+_hb_uniscribe_font_get_data (hb_font_t *font)
+{
+  hb_uniscribe_font_data_t *data = (hb_uniscribe_font_data_t *) hb_font_get_user_data (font, &hb_uniscribe_data_key);
+  if (likely (data)) return data;
+
+  data = (hb_uniscribe_font_data_t *) calloc (1, sizeof (hb_uniscribe_font_data_t));
+  if (unlikely (!data))
+    return &_hb_uniscribe_font_data_nil;
+
+  data->hdc = GetDC (NULL);
+
+  if (unlikely (!populate_log_font (&data->log_font, data->hdc, font)))
+    DEBUG_MSG (UNISCRIBE, font, "Font populate_log_font() failed");
+  else {
+    data->hfont = CreateFontIndirectW (&data->log_font);
+    if (unlikely (!data->hfont))
+      DEBUG_MSG (UNISCRIBE, font, "Font CreateFontIndirectW() failed");
+    if (!SelectObject (data->hdc, data->hfont))
+      DEBUG_MSG (UNISCRIBE, font, "Font SelectObject() failed");
+  }
+
+  if (unlikely (!hb_font_set_user_data (font, &hb_uniscribe_data_key, data,
+					(hb_destroy_func_t) _hb_uniscribe_font_data_destroy,
+					FALSE)))
+  {
+    _hb_uniscribe_font_data_destroy (data);
+    data = (hb_uniscribe_font_data_t *) hb_font_get_user_data (font, &hb_uniscribe_data_key);
+    if (data)
+      return data;
+    else
+      return &_hb_uniscribe_font_data_nil;
+  }
+
+  return data;
+}
+
+LOGFONTW *
+hb_uniscribe_font_get_logfontw (hb_font_t *font)
+{
+  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
+  if (unlikely (!font_data))
+    return NULL;
+  return &font_data->log_font;
+}
+
+HFONT
+hb_uniscribe_font_get_hfont (hb_font_t *font)
+{
+  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
+  if (unlikely (!font_data))
+    return 0;
+  return font_data->hfont;
+}
+
+
+hb_bool_t
+_hb_uniscribe_shape (hb_font_t          *font,
+		     hb_buffer_t        *buffer,
+		     const hb_feature_t *features,
+		     unsigned int        num_features)
+{
+  buffer->guess_properties ();
+
+#define FAIL(...) \
+  HB_STMT_START { \
+    DEBUG_MSG (UNISCRIBE, NULL, __VA_ARGS__); \
+    return FALSE; \
+  } HB_STMT_END;
+
+  hb_uniscribe_face_data_t *face_data = _hb_uniscribe_face_get_data (font->face);
+  if (unlikely (!face_data->fh))
+    FAIL ("Couldn't get face data");
+
+  hb_uniscribe_font_data_t *font_data = _hb_uniscribe_font_get_data (font);
+  if (unlikely (!font_data->hfont))
+    FAIL ("Couldn't get font font");
+
+  if (unlikely (!buffer->len))
+    return TRUE;
+
+  HRESULT hr;
+
+retry:
+
+  unsigned int scratch_size;
+  char *scratch = (char *) buffer->get_scratch_buffer (&scratch_size);
+
+  /* Allocate char buffers; they all fit */
+
+#define ALLOCATE_ARRAY(Type, name, len) \
+  Type *name = (Type *) scratch; \
+  scratch += len * sizeof (name[0]); \
+  scratch_size -= len * sizeof (name[0]);
+
+#define utf16_index() var1.u32
+
+  WCHAR *pchars = (WCHAR *) scratch;
+  unsigned int chars_len = 0;
+  for (unsigned int i = 0; i < buffer->len; i++) {
+    hb_codepoint_t c = buffer->info[i].codepoint;
+    buffer->info[i].utf16_index() = chars_len;
+    if (likely (c < 0x10000))
+      pchars[chars_len++] = c;
+    else if (unlikely (c >= 0x110000))
+      pchars[chars_len++] = 0xFFFD;
+    else {
+      pchars[chars_len++] = 0xD800 + ((c - 0x10000) >> 10);
+      pchars[chars_len++] = 0xDC00 + ((c - 0x10000) & ((1 << 10) - 1));
+    }
+  }
+
+  ALLOCATE_ARRAY (WCHAR, wchars, chars_len);
+  ALLOCATE_ARRAY (WORD, log_clusters, chars_len);
+  ALLOCATE_ARRAY (SCRIPT_CHARPROP, char_props, chars_len);
+
+  /* On Windows, we don't care about alignment...*/
+  unsigned int glyphs_size = scratch_size / (sizeof (WORD) +
+					     sizeof (SCRIPT_GLYPHPROP) +
+					     sizeof (int) +
+					     sizeof (GOFFSET) +
+					     sizeof (uint32_t));
+
+  ALLOCATE_ARRAY (WORD, glyphs, glyphs_size);
+  ALLOCATE_ARRAY (SCRIPT_GLYPHPROP, glyph_props, glyphs_size);
+  ALLOCATE_ARRAY (int, advances, glyphs_size);
+  ALLOCATE_ARRAY (GOFFSET, offsets, glyphs_size);
+  ALLOCATE_ARRAY (uint32_t, vis_clusters, glyphs_size);
+
+
+#define MAX_ITEMS 10
+
+  SCRIPT_ITEM items[MAX_ITEMS + 1];
+  SCRIPT_CONTROL bidi_control = {0};
+  SCRIPT_STATE bidi_state = {0};
+  WIN_ULONG script_tags[MAX_ITEMS];
+  int item_count;
+
+  /* MinGW32 doesn't define fMergeNeutralItems, so we bruteforce */
+  //bidi_control.fMergeNeutralItems = TRUE;
+  *(uint32_t*)&bidi_control |= 1<<24;
+
+  bidi_state.uBidiLevel = HB_DIRECTION_IS_FORWARD (buffer->props.direction) ? 0 : 1;
+//  bidi_state.fOverrideDirection = 1;
+
+  hr = ScriptItemizeOpenType (wchars,
+			      chars_len,
+			      MAX_ITEMS,
+			      &bidi_control,
+			      &bidi_state,
+			      items,
+			      script_tags,
+			      &item_count);
+  if (unlikely (FAILED (hr)))
+    FAIL ("ScriptItemizeOpenType() failed: 0x%08xL", hr);
+
+#undef MAX_ITEMS
+
+  int *range_char_counts = NULL;
+  TEXTRANGE_PROPERTIES **range_properties = NULL;
+  int range_count = 0;
+  if (num_features) {
+    /* TODO setup ranges */
+  }
+
+  OPENTYPE_TAG language_tag = hb_ot_tag_from_language (buffer->props.language);
+
+  unsigned int glyphs_offset = 0;
+  unsigned int glyphs_len;
+  for (unsigned int i = 0; i < item_count; i++)
+  {
+      unsigned int chars_offset = items[i].iCharPos;
+      unsigned int item_chars_len = items[i + 1].iCharPos - chars_offset;
+      OPENTYPE_TAG script_tag = script_tags[i]; /* XXX buffer->props.script */
+
+      hr = ScriptShapeOpenType (font_data->hdc,
+				&font_data->script_cache,
+				&items[i].a,
+				script_tag,
+				language_tag,
+				range_char_counts,
+				range_properties,
+				range_count,
+				wchars + chars_offset,
+				item_chars_len,
+				glyphs_size - glyphs_offset,
+				/* out */
+				log_clusters + chars_offset,
+				char_props + chars_offset,
+				glyphs + glyphs_offset,
+				glyph_props + glyphs_offset,
+				(int *) &glyphs_len);
+
+      if (unlikely (items[i].a.fNoGlyphIndex))
+	FAIL ("ScriptShapeOpenType() set fNoGlyphIndex");
+      if (unlikely (hr == E_OUTOFMEMORY))
+      {
+        buffer->ensure (buffer->allocated * 2);
+	if (buffer->in_error)
+	  FAIL ("Buffer resize failed");
+	goto retry;
+      }
+      if (unlikely (hr == USP_E_SCRIPT_NOT_IN_FONT))
+	FAIL ("ScriptShapeOpenType() failed: Font doesn't support script");
+      if (unlikely (FAILED (hr)))
+	FAIL ("ScriptShapeOpenType() failed: 0x%08xL", hr);
+
+      hr = ScriptPlaceOpenType (font_data->hdc,
+				&font_data->script_cache,
+				&items[i].a,
+				script_tag,
+				language_tag,
+				range_char_counts,
+				range_properties,
+				range_count,
+				wchars + chars_offset,
+				log_clusters + chars_offset,
+				char_props + chars_offset,
+				item_chars_len,
+				glyphs + glyphs_offset,
+				glyph_props + glyphs_offset,
+				glyphs_len,
+				/* out */
+				advances + glyphs_offset,
+				offsets + glyphs_offset,
+				NULL);
+      if (unlikely (FAILED (hr)))
+	FAIL ("ScriptPlaceOpenType() failed: 0x%08xL", hr);
+
+      glyphs_offset += glyphs_len;
+  }
+  glyphs_len = glyphs_offset;
+
+  /* Ok, we've got everything we need, now compose output buffer,
+   * very, *very*, carefully! */
+
+  /* Calculate visual-clusters.  That's what we ship. */
+  for (unsigned int i = 0; i < glyphs_len; i++)
+    vis_clusters[i] = -1;
+  for (unsigned int i = 0; i < buffer->len; i++) {
+    uint32_t *p = &vis_clusters[log_clusters[buffer->info[i].utf16_index()]];
+    *p = MIN (*p, buffer->info[i].cluster);
+  }
+  if (HB_DIRECTION_IS_FORWARD (buffer->props.direction)) {
+    for (unsigned int i = 1; i < glyphs_len; i++)
+      if (!glyph_props[i].sva.fClusterStart)
+	vis_clusters[i] = vis_clusters[i - 1];
+  } else {
+    for (int i = glyphs_len - 2; i >= 0; i--)
+      if (!glyph_props[i].sva.fClusterStart)
+	vis_clusters[i] = vis_clusters[i + 1];
+  }
+
+#undef utf16_index
+
+  buffer->ensure (glyphs_len);
+  if (buffer->in_error)
+    FAIL ("Buffer in error");
+
+#undef FAIL
+
+  /* Set glyph infos */
+  buffer->len = 0;
+  for (unsigned int i = 0; i < glyphs_len; i++)
+  {
+    hb_glyph_info_t *info = &buffer->info[buffer->len++];
+
+    info->codepoint = glyphs[i];
+    info->cluster = vis_clusters[i];
+
+    /* The rest is crap.  Let's store position info there for now. */
+    info->mask = advances[i];
+    info->var1.u32 = offsets[i].du;
+    info->var2.u32 = offsets[i].dv;
+  }
+
+  /* Set glyph positions */
+  buffer->clear_positions ();
+  for (unsigned int i = 0; i < glyphs_len; i++)
+  {
+    hb_glyph_info_t *info = &buffer->info[i];
+    hb_glyph_position_t *pos = &buffer->pos[i];
+
+    /* TODO vertical */
+    pos->x_advance = info->mask;
+    pos->x_offset = info->var1.u32;
+    pos->y_offset = info->var2.u32;
+  }
+
+  /* Wow, done! */
+  return TRUE;
+}
+
+
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,47 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_UNISCRIBE_H
+#define HB_UNISCRIBE_H
+
+#include "hb.h"
+
+#define _WIN32_WINNT 0x0500
+#include <windows.h>
+
+HB_BEGIN_DECLS
+
+
+LOGFONTW *
+hb_uniscribe_font_get_logfontw (hb_font_t *font);
+
+HFONT
+hb_uniscribe_font_get_hfont (hb_font_t *font);
+
+
+HB_END_DECLS
+
+#endif /* HB_UNISCRIBE_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe-private.hh Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe-private.hh
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-uniscribe-private.hh	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-uniscribe-private.hh	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,42 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_UNISCRIBE_PRIVATE_HH
+#define HB_UNISCRIBE_PRIVATE_HH
+
+#include "hb-private.hh"
+
+#include "hb-uniscribe.h"
+
+
+HB_INTERNAL hb_bool_t
+_hb_uniscribe_shape (hb_font_t          *font,
+		     hb_buffer_t        *buffer,
+		     const hb_feature_t *features,
+		     unsigned int        num_features);
+
+
+#endif /* HB_UNISCRIBE_PRIVATE_HH */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-version.h Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-version.h
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-version.h	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-version.h	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,66 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_VERSION_H
+#define HB_VERSION_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_VERSION_MAJOR 0
+#define HB_VERSION_MINOR 7
+#define HB_VERSION_MICRO 0
+
+#define HB_VERSION_STRING "0.7.0"
+
+#define HB_VERSION_CHECK(major,minor,micro) \
+	((major)*10000+(minor)*100+(micro) >= \
+	 HB_VERSION_MAJOR*10000+HB_VERSION_MINOR*100+HB_VERSION_MICRO)
+
+
+void
+hb_version (unsigned int *major,
+	    unsigned int *minor,
+	    unsigned int *micro);
+
+const char *
+hb_version_string (void);
+
+hb_bool_t
+hb_version_check (unsigned int major,
+		  unsigned int minor,
+		  unsigned int micro);
+
+
+HB_END_DECLS
+
+#endif /* HB_VERSION_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-version.h.in Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-version.h.in
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-version.h.in	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-version.h.in	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,66 @@
+/*
+ * Copyright  2011  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#ifndef HB_H_IN
+#error "Include <hb.h> instead."
+#endif
+
+#ifndef HB_VERSION_H
+#define HB_VERSION_H
+
+#include "hb-common.h"
+
+HB_BEGIN_DECLS
+
+
+#define HB_VERSION_MAJOR @HB_VERSION_MAJOR@
+#define HB_VERSION_MINOR @HB_VERSION_MINOR@
+#define HB_VERSION_MICRO @HB_VERSION_MICRO@
+
+#define HB_VERSION_STRING "@HB_VERSION@"
+
+#define HB_VERSION_CHECK(major,minor,micro) \
+	((major)*10000+(minor)*100+(micro) >= \
+	 HB_VERSION_MAJOR*10000+HB_VERSION_MINOR*100+HB_VERSION_MICRO)
+
+
+void
+hb_version (unsigned int *major,
+	    unsigned int *minor,
+	    unsigned int *micro);
+
+const char *
+hb_version_string (void);
+
+hb_bool_t
+hb_version_check (unsigned int major,
+		  unsigned int minor,
+		  unsigned int micro);
+
+
+HB_END_DECLS
+
+#endif /* HB_VERSION_H */
diff -Naur Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-warning.cc Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-warning.cc
--- Scribus_1.5_120815/scribus/third_party/harfbuzz/src/hb-warning.cc	1970-01-01 05:30:00.000000000 +0530
+++ Scribus_1.5_indic/scribus/third_party/harfbuzz/src/hb-warning.cc	2012-05-05 20:27:14.000000000 +0530
@@ -0,0 +1,53 @@
+/*
+ * Copyright  2012  Google, Inc.
+ *
+ *  This is part of HarfBuzz, a text shaping library.
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ *
+ * Google Author(s): Behdad Esfahbod
+ */
+
+#include "hb-mutex-private.hh"
+#include "hb-object-private.hh"
+
+
+#if !defined(HB_NO_MT) && defined(HB_ATOMIC_INT_NIL)
+#ifdef _MSC_VER
+#pragma message("Could not find any system to define atomic_int macros, library will NOT be thread-safe")
+#else
+#warning "Could not find any system to define atomic_int macros, library will NOT be thread-safe"
+#endif
+#endif
+
+#if !defined(HB_NO_MT) && defined(HB_MUTEX_IMPL_NIL)
+#ifdef _MSC_VER
+#pragma message("Could not find any system to define mutex macros, library will NOT be thread-safe")
+#else
+#warning "Could not find any system to define mutex macros, library will NOT be thread-safe"
+#endif
+#endif
+
+#if !defined(HB_NO_MT) && (defined(HB_ATOMIC_INT_NIL) || defined(HB_MUTEX_IMPL_NIL))
+#ifdef _MSC_VER
+#pragma message("To suppress these warnings, define HB_NO_MT")
+#else
+#warning "To suppress these warnings, define HB_NO_MT"
+#endif
+#endif
